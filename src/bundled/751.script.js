"use strict";(self.webpackChunkbeartooth=self.webpackChunkbeartooth||[]).push([[751],{6563:(e,t,r)=>{r.d(t,{a:()=>a});var n=r(3804);const s=["precision mediump float;","void main(void){","float test = 0.1;","%forloop%","gl_FragColor = vec4(0.0);","}"].join("\n");function i(e){let t="";for(let r=0;r<e;++r)r>0&&(t+="\nelse "),r<e-1&&(t+=`if(test == ${r}.0){}`);return t}let o=null;function a(){if(o)return o;const e=(0,n.W)();return o=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),o=function(e,t){if(0===e)throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");const r=t.createShader(t.FRAGMENT_SHADER);for(;;){const n=s.replace(/%forloop%/gi,i(e));if(t.shaderSource(r,n),t.compileShader(r),t.getShaderParameter(r,t.COMPILE_STATUS))break;e=e/2|0}return e}(o,e),o}},341:(e,t,r)=>{r.d(t,{w:()=>a});var n=r(3513),s=r(4492),i=r(6563);const o={};function a(e,t){let r=0;for(let n=0;n<t;n++)r=31*r+e[n].uid>>>0;return o[r]||function(e,t,r){const a={};let d=0;u||(u=(0,i.a)());for(let r=0;r<u;r++){const n=r<t?e[r]:s.g.EMPTY.source;a[d++]=n.source,a[d++]=n.style}const c=new n.T(a);return o[r]=c,c}(e,t,r)}let u=0},1617:(e,t,r)=>{r.d(t,{J:()=>u});var n=r(949),s=r(1132),i=r(6011);const o=new Float32Array(1),a=new Uint32Array(1);class u extends i.V{constructor(){const e=new n.h({data:o,label:"attribute-batch-buffer",usage:s.S.VERTEX|s.S.COPY_DST,shrinkToFit:!1});super({attributes:{aPosition:{buffer:e,format:"float32x2",stride:24,offset:0,location:1},aUV:{buffer:e,format:"float32x2",stride:24,offset:8,location:3},aColor:{buffer:e,format:"unorm8x4",stride:24,offset:16,location:0},aTextureIdAndRound:{buffer:e,format:"uint16x2",stride:24,offset:20,location:2}},indexBuffer:new n.h({data:a,label:"index-batch-buffer",usage:s.S.INDEX|s.S.COPY_DST,shrinkToFit:!1})})}}},5130:(e,t,r)=>{r.d(t,{i:()=>g});var n=r(133);class s{constructor(e){"number"==typeof e?this.rawBinaryData=new ArrayBuffer(e):e instanceof Uint8Array?this.rawBinaryData=e.buffer:this.rawBinaryData=e,this.uint32View=new Uint32Array(this.rawBinaryData),this.float32View=new Float32Array(this.rawBinaryData),this.size=this.rawBinaryData.byteLength}get int8View(){return this._int8View||(this._int8View=new Int8Array(this.rawBinaryData)),this._int8View}get uint8View(){return this._uint8View||(this._uint8View=new Uint8Array(this.rawBinaryData)),this._uint8View}get int16View(){return this._int16View||(this._int16View=new Int16Array(this.rawBinaryData)),this._int16View}get int32View(){return this._int32View||(this._int32View=new Int32Array(this.rawBinaryData)),this._int32View}get float64View(){return this._float64Array||(this._float64Array=new Float64Array(this.rawBinaryData)),this._float64Array}get bigUint64View(){return this._bigUint64Array||(this._bigUint64Array=new BigUint64Array(this.rawBinaryData)),this._bigUint64Array}view(e){return this[`${e}View`]}destroy(){this.rawBinaryData=null,this._int8View=null,this._uint8View=null,this._int16View=null,this.uint16View=null,this._int32View=null,this.uint32View=null,this.float32View=null}static sizeOf(e){switch(e){case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;default:throw new Error(`${e} isn't a valid view type`)}}}var i=r(6736),o=r(8639),a=r(6563);class u{constructor(){this.ids=Object.create(null),this.textures=[],this.count=0}clear(){for(let e=0;e<this.count;e++){const t=this.textures[e];this.textures[e]=null,this.ids[t.uid]=null}this.count=0}}class d{constructor(){this.renderPipeId="batch",this.action="startBatch",this.start=0,this.size=0,this.textures=new u,this.blendMode="normal",this.canBundle=!0}destroy(){this.textures=null,this.gpuBindGroup=null,this.bindGroup=null,this.batcher=null}}const c=[];let l=0;function h(){return l>0?c[--l]:new d}function p(e){c[l++]=e}let f=0;const m=class e{constructor(t={}){this.uid=(0,n.L)("batcher"),this.dirty=!0,this.batchIndex=0,this.batches=[],this._vertexSize=6,this._elements=[],t={...e.defaultOptions,...t};const{vertexSize:r,indexSize:i}=t;this.attributeBuffer=new s(r*this._vertexSize*4),this.indexBuffer=new Uint16Array(i),this._maxTextures=(0,a.a)()}begin(){this.elementSize=0,this.elementStart=0,this.indexSize=0,this.attributeSize=0;for(let e=0;e<this.batchIndex;e++)p(this.batches[e]);this.batchIndex=0,this._batchIndexStart=0,this._batchIndexSize=0,this.dirty=!0}add(e){this._elements[this.elementSize++]=e,e.indexStart=this.indexSize,e.location=this.attributeSize,e.batcher=this,this.indexSize+=e.indexSize,this.attributeSize+=e.vertexSize*this._vertexSize}checkAndUpdateTexture(e,t){const r=e.batch.textures.ids[t._source.uid];return!(!r&&0!==r||(e.textureId=r,e.texture=t,0))}updateElement(e){this.dirty=!0,e.packAttributes(this.attributeBuffer.float32View,this.attributeBuffer.uint32View,e.location,e.textureId)}break(e){const t=this._elements;if(!t[this.elementStart])return;let r=h(),n=r.textures;n.clear();const s=t[this.elementStart];let i=(0,o.i)(s.blendMode,s.texture._source);4*this.attributeSize>this.attributeBuffer.size&&this._resizeAttributeBuffer(4*this.attributeSize),this.indexSize>this.indexBuffer.length&&this._resizeIndexBuffer(this.indexSize);const a=this.attributeBuffer.float32View,u=this.attributeBuffer.uint32View,d=this.indexBuffer;let c=this._batchIndexSize,l=this._batchIndexStart,p="startBatch";const m=this._maxTextures;for(let s=this.elementStart;s<this.elementSize;++s){const g=t[s];t[s]=null;const x=g.texture._source,_=(0,o.i)(g.blendMode,x),b=i!==_;x._batchTick!==f||b?(x._batchTick=f,(n.count>=m||b)&&(this._finishBatch(r,l,c-l,n,i,e,p),p="renderBatch",l=c,i=_,r=h(),n=r.textures,n.clear(),++f),g.textureId=x._textureBindLocation=n.count,n.ids[x.uid]=n.count,n.textures[n.count++]=x,g.batch=r,c+=g.indexSize,g.packAttributes(a,u,g.location,g.textureId),g.packIndex(d,g.indexStart,g.location/this._vertexSize)):(g.textureId=x._textureBindLocation,c+=g.indexSize,g.packAttributes(a,u,g.location,g.textureId),g.packIndex(d,g.indexStart,g.location/this._vertexSize),g.batch=r)}n.count>0&&(this._finishBatch(r,l,c-l,n,i,e,p),l=c,++f),this.elementStart=this.elementSize,this._batchIndexStart=l,this._batchIndexSize=c}_finishBatch(e,t,r,n,s,i,o){e.gpuBindGroup=null,e.bindGroup=null,e.action=o,e.batcher=this,e.textures=n,e.blendMode=s,e.start=t,e.size=r,++f,this.batches[this.batchIndex++]=e,i.add(e)}finish(e){this.break(e)}ensureAttributeBuffer(e){4*e<=this.attributeBuffer.size||this._resizeAttributeBuffer(4*e)}ensureIndexBuffer(e){e<=this.indexBuffer.length||this._resizeIndexBuffer(e)}_resizeAttributeBuffer(e){const t=Math.max(e,2*this.attributeBuffer.size),r=new s(t);(0,i.W)(this.attributeBuffer.rawBinaryData,r.rawBinaryData),this.attributeBuffer=r}_resizeIndexBuffer(e){const t=this.indexBuffer;let r=Math.max(e,1.5*t.length);r+=r%2;const n=r>65535?new Uint32Array(r):new Uint16Array(r);if(n.BYTES_PER_ELEMENT!==t.BYTES_PER_ELEMENT)for(let e=0;e<t.length;e++)n[e]=t[e];else(0,i.W)(t.buffer,n.buffer);this.indexBuffer=n}destroy(){for(let e=0;e<this.batches.length;e++)p(this.batches[e]);this.batches=null;for(let e=0;e<this._elements.length;e++)this._elements[e].batch=null;this._elements=null,this.indexBuffer=null,this.attributeBuffer.destroy(),this.attributeBuffer=null}};m.defaultOptions={vertexSize:4,indexSize:6};let g=m},5611:(e,t,r)=>{r.d(t,{I:()=>M,v:()=>w});var n=r(9113),s=r(3012),i=r(268);function o(e,t,r){if(e)for(const n in e){const s=t[n.toLocaleLowerCase()];if(s){let t=e[n];"header"===n&&(t=t.replace(/@in\s+[^;]+;\s*/g,"").replace(/@out\s+[^;]+;\s*/g,"")),r&&s.push(`//----${r}----//`),s.push(t)}else(0,i.R)(`${n} placement hook does not exist in shader`)}}const a=/\{\{(.*?)\}\}/g;function u(e){const t={};return(e.match(a)?.map((e=>e.replace(/[{()}]/g,"")))??[]).forEach((e=>{t[e]=[]})),t}function d(e,t){let r;const n=/@in\s+([^;]+);/g;for(;null!==(r=n.exec(e));)t.push(r[1])}function c(e,t,r=!1){const n=[];d(t,n),e.forEach((e=>{e.header&&d(e.header,n)}));const s=n;r&&s.sort();const i=s.map(((e,t)=>`       @location(${t}) ${e},`)).join("\n");let o=t.replace(/@in\s+[^;]+;\s*/g,"");return o=o.replace("{{in}}",`\n${i}\n`),o}function l(e,t){let r;const n=/@out\s+([^;]+);/g;for(;null!==(r=n.exec(e));)t.push(r[1])}function h(e,t){let r=e;for(const e in t){const n=t[e];r=n.join("\n").length?r.replace(`{{${e}}}`,`//-----${e} START-----//\n${n.join("\n")}\n//----${e} FINISH----//`):r.replace(`{{${e}}}`,"")}return r}const p=Object.create(null),f=new Map;let m=0;function g({template:e,bits:t}){const r=x(e,t);return p[r]||(p[r]=_(e.vertex,e.fragment,t)),p[r]}function x(e,t){return t.map((e=>(f.has(e)||f.set(e,m++),f.get(e)))).sort(((e,t)=>e-t)).join("-")+e.vertex+e.fragment}function _(e,t,r){const n=u(e),s=u(t);return r.forEach((e=>{o(e.vertex,n,e.name),o(e.fragment,s,e.name)})),{vertex:h(e,n),fragment:h(t,s)}}const b="\n    @in aPosition: vec2<f32>;\n    @in aUV: vec2<f32>;\n\n    @out @builtin(position) vPosition: vec4<f32>;\n    @out vUV : vec2<f32>;\n    @out vColor : vec4<f32>;\n\n    {{header}}\n\n    struct VSOutput {\n        {{struct}}\n    };\n\n    @vertex\n    fn main( {{in}} ) -> VSOutput {\n\n        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;\n        var modelMatrix = mat3x3<f32>(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        var position = aPosition;\n        var uv = aUV;\n\n        {{start}}\n        \n        vColor = vec4<f32>(1., 1., 1., 1.);\n\n        {{main}}\n\n        vUV = uv;\n\n        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);\n       \n        vColor *= globalUniforms.uWorldColorAlpha;\n\n        {{end}}\n\n        {{return}}\n    };\n",v="\n    @in vUV : vec2<f32>;\n    @in vColor : vec4<f32>;\n   \n    {{header}}\n\n    @fragment\n    fn main(\n        {{in}}\n      ) -> @location(0) vec4<f32> {\n        \n        {{start}}\n\n        var outColor:vec4<f32>;\n      \n        {{main}}\n        \n        return outColor * vColor;\n      };\n",y="\n    in vec2 aPosition;\n    in vec2 aUV;\n\n    out vec4 vColor;\n    out vec2 vUV;\n\n    {{header}}\n\n    void main(void){\n\n        mat3 worldTransformMatrix = uWorldTransformMatrix;\n        mat3 modelMatrix = mat3(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        vec2 position = aPosition;\n        vec2 uv = aUV;\n        \n        {{start}}\n        \n        vColor = vec4(1.);\n        \n        {{main}}\n        \n        vUV = uv;\n        \n        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n\n        vColor *= uWorldColorAlpha;\n\n        {{end}}\n    }\n",T="\n   \n    in vec4 vColor;\n    in vec2 vUV;\n\n    out vec4 finalColor;\n\n    {{header}}\n\n    void main(void) {\n        \n        {{start}}\n\n        vec4 outColor;\n      \n        {{main}}\n        \n        finalColor = outColor * vColor;\n    }\n",S={name:"global-uniforms-bit",vertex:{header:"\n        struct GlobalUniforms {\n            uProjectionMatrix:mat3x3<f32>,\n            uWorldTransformMatrix:mat3x3<f32>,\n            uWorldColorAlpha: vec4<f32>,\n            uResolution: vec2<f32>,\n        }\n\n        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n        "}},P={name:"global-uniforms-bit",vertex:{header:"\n          uniform mat3 uProjectionMatrix;\n          uniform mat3 uWorldTransformMatrix;\n          uniform vec4 uWorldColorAlpha;\n          uniform vec2 uResolution;\n        "}};function w({bits:e,name:t}){const r=function({template:e,bits:t}){const r=x(e,t);if(p[r])return p[r];const{vertex:n,fragment:s}=function(e,t){const r=t.map((e=>e.vertex)).filter((e=>!!e)),n=t.map((e=>e.fragment)).filter((e=>!!e));let s=c(r,e.vertex,!0);return s=function(e,t){const r=[];l(t,r),e.forEach((e=>{e.header&&l(e.header,r)}));let n=0;const s=r.sort().map((e=>e.indexOf("builtin")>-1?e:`@location(${n++}) ${e}`)).join(",\n"),i=r.sort().map((e=>{return`       var ${t=e,t.replace(/@.*?\s+/g,"")};`;var t})).join("\n"),o=`return VSOutput(\n                ${r.sort().map((e=>` ${function(e){const t=/\b(\w+)\s*:/g.exec(e);return t?t[1]:""}(e)}`)).join(",\n")});`;let a=t.replace(/@out\s+[^;]+;\s*/g,"");return a=a.replace("{{struct}}",`\n${s}\n`),a=a.replace("{{start}}",`\n${i}\n`),a=a.replace("{{return}}",`\n${o}\n`),a}(r,s),{vertex:s,fragment:c(n,e.fragment,!0)}}(e,t);return p[r]=_(n,s,t),p[r]}({template:{fragment:v,vertex:b},bits:[S,...e]});return s.B.from({name:t,vertex:{source:r.vertex,entryPoint:"main"},fragment:{source:r.fragment,entryPoint:"main"}})}function M({bits:e,name:t}){return new n.M({name:t,...g({template:{vertex:y,fragment:T},bits:[P,...e]})})}},4459:(e,t,r)=>{r.d(t,{F:()=>n,a:()=>s});const n={name:"color-bit",vertex:{header:"\n            @in aColor: vec4<f32>;\n        ",main:"\n            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);\n        "}},s={name:"color-bit",vertex:{header:"\n            in vec4 aColor;\n        ",main:"\n            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);\n        "}}},4e3:(e,t,r)=>{r.d(t,{P:()=>d,_:()=>o});const n={};function s(e){const t=[];if(1===e)t.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;"),t.push("@group(1) @binding(1) var textureSampler1: sampler;");else{let r=0;for(let n=0;n<e;n++)t.push(`@group(1) @binding(${r++}) var textureSource${n+1}: texture_2d<f32>;`),t.push(`@group(1) @binding(${r++}) var textureSampler${n+1}: sampler;`)}return t.join("\n")}function i(e){const t=[];if(1===e)t.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);");else{t.push("switch vTextureId {");for(let r=0;r<e;r++)r===e-1?t.push("  default:{"):t.push(`  case ${r}:{`),t.push(`      outColor = textureSampleGrad(textureSource${r+1}, textureSampler${r+1}, vUV, uvDx, uvDy);`),t.push("      break;}");t.push("}")}return t.join("\n")}function o(e){return n[e]||(n[e]={name:"texture-batch-bit",vertex:{header:"\n                @in aTextureIdAndRound: vec2<u32>;\n                @out @interpolate(flat) vTextureId : u32;\n            ",main:"\n                vTextureId = aTextureIdAndRound.y;\n            ",end:"\n                if(aTextureIdAndRound.x == 1)\n                {\n                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n                }\n            "},fragment:{header:`\n                @in @interpolate(flat) vTextureId: u32;\n\n                ${s(e)}\n            `,main:`\n                var uvDx = dpdx(vUV);\n                var uvDy = dpdy(vUV);\n\n                ${i(e)}\n            `}}),n[e]}const a={};function u(e){const t=[];for(let r=0;r<e;r++)r>0&&t.push("else"),r<e-1&&t.push(`if(vTextureId < ${r}.5)`),t.push("{"),t.push(`\toutColor = texture(uTextures[${r}], vUV);`),t.push("}");return t.join("\n")}function d(e){return a[e]||(a[e]={name:"texture-batch-bit",vertex:{header:"\n                in vec2 aTextureIdAndRound;\n                out float vTextureId;\n\n            ",main:"\n                vTextureId = aTextureIdAndRound.y;\n            ",end:"\n                if(aTextureIdAndRound.x == 1.)\n                {\n                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n                }\n            "},fragment:{header:`\n                in float vTextureId;\n\n                uniform sampler2D uTextures[${e}];\n\n            `,main:`\n\n                ${u(e)}\n            `}}),a[e]}},2067:(e,t,r)=>{r.d(t,{Ls:()=>n,_Q:()=>s,mA:()=>i});const n={name:"local-uniform-bit",vertex:{header:"\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        ",main:"\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        ",end:"\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        "}},s={...n,vertex:{...n.vertex,header:n.vertex.header.replace("group(1)","group(2)")}},i={name:"local-uniform-bit",vertex:{header:"\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        ",main:"\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        ",end:"\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        "}}},6665:(e,t,r)=>{r.d(t,{b:()=>n,m:()=>s});const n={name:"round-pixels-bit",vertex:{header:"\n            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> \n            {\n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        "}},s={name:"round-pixels-bit",vertex:{header:"   \n            vec2 roundPixels(vec2 position, vec2 targetSize)\n            {       \n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        "}}},3391:(e,t,r)=>{r.d(t,{R:()=>n,m:()=>s});const n={name:"texture-bit",vertex:{header:"\n\n        struct TextureUniforms {\n            uTextureMatrix:mat3x3<f32>,\n        }\n\n        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;\n        ",main:"\n            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;\n        "},fragment:{header:"\n            @group(2) @binding(0) var uTexture: texture_2d<f32>;\n            @group(2) @binding(1) var uSampler: sampler;\n\n         \n        ",main:"\n            outColor = textureSample(uTexture, uSampler, vUV);\n        "}},s={name:"texture-bit",vertex:{header:"\n            uniform mat3 uTextureMatrix;\n        ",main:"\n            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;\n        "},fragment:{header:"\n        uniform sampler2D uTexture;\n\n         \n        ",main:"\n            outColor = texture(uTexture, vUV);\n        "}}},9113:(e,t,r)=>{r.d(t,{M:()=>h});var n=r(7952),s=r(3804);let i;function o(){if(!i){i="mediump";const e=(0,s.W)();if(e&&e.getShaderPrecisionFormat){const t=e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.HIGH_FLOAT);i=t.precision?"highp":"mediump"}}return i}const a={},u={},d={stripVersion:function(e,t){return t?e.replace("#version 300 es",""):e},ensurePrecision:function(e,t,r){const n=r?t.maxSupportedFragmentPrecision:t.maxSupportedVertexPrecision;if("precision"!==e.substring(0,9)){let s=r?t.requestedFragmentPrecision:t.requestedVertexPrecision;return"highp"===s&&"highp"!==n&&(s="mediump"),`precision ${s} float;\n${e}`}return"highp"!==n&&"precision highp"===e.substring(0,15)?e.replace("precision highp","precision mediump"):e},addProgramDefines:function(e,t,r){return t?e:r?`\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in varying\n        #define finalColor gl_FragColor\n        #define texture texture2D\n        #endif\n        ${e=e.replace("out vec4 finalColor;","")}\n        `:`\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in attribute\n        #define out varying\n        #endif\n        ${e}\n        `},setProgramName:function(e,{name:t="pixi-program"},r=!0){t=t.replace(/\s+/g,"-");const n=r?a:u;return n[t+=r?"-fragment":"-vertex"]?(n[t]++,t+=`-${n[t]}`):n[t]=1,-1!==e.indexOf("#define SHADER_NAME")?e:`#define SHADER_NAME ${t}\n${e}`},insertVersion:function(e,t){return t?`#version 300 es\n${e}`:e}},c=Object.create(null),l=class e{constructor(t){const r=-1!==(t={...e.defaultOptions,...t}).fragment.indexOf("#version 300 es"),s={stripVersion:r,ensurePrecision:{requestedFragmentPrecision:t.preferredFragmentPrecision,requestedVertexPrecision:t.preferredVertexPrecision,maxSupportedVertexPrecision:"highp",maxSupportedFragmentPrecision:o()},setProgramName:{name:t.name},addProgramDefines:r,insertVersion:r};let i=t.fragment,a=t.vertex;Object.keys(d).forEach((e=>{const t=s[e];i=d[e](i,t,!0),a=d[e](a,t,!1)})),this.fragment=i,this.vertex=a,this._key=(0,n.X)(`${this.vertex}:${this.fragment}`,"gl-program")}destroy(){this.fragment=null,this.vertex=null,this._attributeData=null,this._uniformData=null,this._uniformBlockData=null,this.transformFeedbackVaryings=null}static from(t){const r=`${t.vertex}:${t.fragment}`;return c[r]||(c[r]=new e(t)),c[r]}};l.defaultOptions={preferredVertexPrecision:"highp",preferredFragmentPrecision:"mediump"};let h=l},7084:(e,t,r)=>{r.d(t,{q:()=>i});var n=r(268),s=r(8306);function i(e,t){for(const r in e.attributes){const s=e.attributes[r],i=t[r];i?(s.location??(s.location=i.location),s.format??(s.format=i.format),s.offset??(s.offset=i.offset),s.instance??(s.instance=i.instance)):(0,n.R)(`Attribute ${r} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`)}!function(e){const{buffers:t,attributes:r}=e,n={},i={};for(const e in t){const r=t[e];n[r.uid]=0,i[r.uid]=0}for(const e in r){const t=r[e];n[t.buffer.uid]+=(0,s.m)(t.format).stride}for(const e in r){const t=r[e];t.stride??(t.stride=n[t.buffer.uid]),t.start??(t.start=i[t.buffer.uid]),i[t.buffer.uid]+=(0,s.m)(t.format).stride}}(e)}},3804:(e,t,r)=>{r.d(t,{W:()=>i});var n=r(1761);let s;function i(){if(!s||s?.isContextLost()){const e=n.e.get().createCanvas();s=e.getContext("webgl",{})}return s}},4751:(e,t,r)=>{r.d(t,{WebGPURenderer:()=>we});var n=r(8507),s=r(9313),i=r(6563),o=r(341),a=r(5611),u=r(4459),d=r(4e3),c=r(2067),l=r(6665),h=r(8475),p=r(5811);class f{init(){const e=new p.k({uTransformMatrix:{value:new s.u,type:"mat3x3<f32>"},uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uRound:{value:0,type:"f32"}}),t=(0,a.v)({name:"graphics",bits:[u.F,(0,d._)((0,i.a)()),c._Q,l.b]});this.shader=new h.M({gpuProgram:t,resources:{localUniforms:e}})}execute(e,t){const r=t.context,n=r.customShader||this.shader,s=e.renderer,i=s.graphicsContext,{geometry:a,instructions:u}=i.getContextRenderData(r),d=s.encoder;d.setPipelineFromGeometryProgramAndState(a,n.gpuProgram,e.state),d.setGeometry(a);const c=s.globalUniforms.bindGroup;d.setBindGroup(0,c,n.gpuProgram);const l=s.renderPipes.uniformBatch.getUniformBindGroup(n.resources.localUniforms,!0);d.setBindGroup(2,l,n.gpuProgram);const h=u.instructions;for(let e=0;e<u.instructionSize;e++){const t=h[e];if(n.groups[1]=t.bindGroup,!t.gpuBindGroup){const e=t.textures;t.bindGroup=(0,o.w)(e.textures,e.count),t.gpuBindGroup=s.bindGroup.getBindGroup(t.bindGroup,n.gpuProgram,1)}d.setBindGroup(1,t.bindGroup,n.gpuProgram),d.renderPassEncoder.drawIndexed(t.size,1,t.start)}}destroy(){this.shader.destroy(!0),this.shader=null}}f.extension={type:[n.Ag.WebGPUPipesAdaptor],name:"graphics"};var m=r(3391),g=r(4492),x=r(268);class _{init(){const e=(0,a.v)({name:"mesh",bits:[c.Ls,m.R,l.b]});this._shader=new h.M({gpuProgram:e,resources:{uTexture:g.g.EMPTY._source,uSampler:g.g.EMPTY._source.style,textureUniforms:{uTextureMatrix:{type:"mat3x3<f32>",value:new s.u}}}})}execute(e,t){const r=e.renderer;let n=t._shader;if(n){if(!n.gpuProgram)return void(0,x.R)("Mesh shader has no gpuProgram",t.shader)}else n=this._shader,n.resources.uTexture=t.texture.source,n.resources.uSampler=t.texture.source.style,n.resources.textureUniforms.uniforms.uTextureMatrix=t.texture.textureMatrix.mapCoord;const s=n.gpuProgram;if(s.autoAssignGlobalUniforms&&(n.groups[0]=r.globalUniforms.bindGroup),s.autoAssignLocalUniforms){const t=e.localUniforms;n.groups[1]=r.renderPipes.uniformBatch.getUniformBindGroup(t,!0)}r.encoder.draw({geometry:t._geometry,shader:n,state:t.state})}destroy(){this._shader.destroy(!0),this._shader=null}}_.extension={type:[n.Ag.WebGPUPipesAdaptor],name:"mesh"};var b=r(7547);const v=b.U.for2d();class y{init(){const e=(0,a.v)({name:"batch",bits:[u.F,(0,d._)((0,i.a)()),l.b]});this._shader=new h.M({gpuProgram:e,groups:{}})}start(e,t){const r=e.renderer,n=r.encoder,s=this._shader.gpuProgram;this._geometry=t,n.setGeometry(t),v.blendMode="normal",r.pipeline.getPipeline(t,s,v);const i=r.globalUniforms.bindGroup;n.resetBindGroup(1),n.setBindGroup(0,i,s)}execute(e,t){const r=this._shader.gpuProgram,n=e.renderer,s=n.encoder;if(!t.bindGroup){const e=t.textures;t.bindGroup=(0,o.w)(e.textures,e.count)}v.blendMode=t.blendMode;const i=n.bindGroup.getBindGroup(t.bindGroup,r,1),a=n.pipeline.getPipeline(this._geometry,r,v);t.bindGroup._touch(n.textureGC.count),s.setPipeline(a),s.renderPassEncoder.setBindGroup(1,i),s.renderPassEncoder.drawIndexed(t.size,1,t.start)}destroy(){this._shader.destroy(!0),this._shader=null}}y.extension={type:[n.Ag.WebGPUPipesAdaptor],name:"batch"};var T=r(800),S=r(5717),P=r(5099);class w{constructor(e){this._hash=Object.create(null),this._renderer=e}contextChange(e){this._gpu=e}getBindGroup(e,t,r){return e._updateKey(),this._hash[e._key]||this._createBindGroup(e,t,r)}_createBindGroup(e,t,r){const n=this._gpu.device,s=t.layout[r],i=[],o=this._renderer;for(const t in s){const r=e.resources[t]??e.resources[s[t]];let n;if("uniformGroup"===r._resourceType){const e=r;o.ubo.updateUniformGroup(e);const t=e.buffer;n={buffer:o.buffer.getGPUBuffer(t),offset:0,size:t.descriptor.size}}else if("buffer"===r._resourceType){const e=r;n={buffer:o.buffer.getGPUBuffer(e),offset:0,size:e.descriptor.size}}else if("bufferResource"===r._resourceType){const e=r;n={buffer:o.buffer.getGPUBuffer(e.buffer),offset:e.offset,size:e.size}}else if("textureSampler"===r._resourceType){const e=r;n=o.texture.getGpuSampler(e)}else if("textureSource"===r._resourceType){const e=r;n=o.texture.getGpuSource(e).createView({})}i.push({binding:s[t],resource:n})}const a=o.shader.getProgramData(t).bindGroups[r],u=n.createBindGroup({layout:a,entries:i});return this._hash[e._key]=u,u}destroy(){for(const e of Object.keys(this._hash))this._hash[e]=null;this._hash=null,this._renderer=null}}w.extension={type:[n.Ag.WebGPUSystem],name:"bindGroup"};var M=r(6736);class C{constructor(){this._gpuBuffers=Object.create(null),this._managedBuffers=[]}contextChange(e){this._gpu=e}getGPUBuffer(e){return this._gpuBuffers[e.uid]||this.createGPUBuffer(e)}updateBuffer(e){const t=this._gpuBuffers[e.uid]||this.createGPUBuffer(e),r=e.data;return e._updateID&&r&&(e._updateID=0,this._gpu.device.queue.writeBuffer(t,0,r.buffer,0,(e._updateSize||r.byteLength)+3&-4)),t}destroyAll(){for(const e in this._gpuBuffers)this._gpuBuffers[e].destroy();this._gpuBuffers={}}createGPUBuffer(e){this._gpuBuffers[e.uid]||(e.on("update",this.updateBuffer,this),e.on("change",this.onBufferChange,this),e.on("destroy",this.onBufferDestroy,this),this._managedBuffers.push(e));const t=this._gpu.device.createBuffer(e.descriptor);return e._updateID=0,e.data&&((0,M.W)(e.data.buffer,t.getMappedRange()),t.unmap()),this._gpuBuffers[e.uid]=t,t}onBufferChange(e){this._gpuBuffers[e.uid].destroy(),e._updateID=0,this._gpuBuffers[e.uid]=this.createGPUBuffer(e)}onBufferDestroy(e){this._managedBuffers.splice(this._managedBuffers.indexOf(e),1),this._destroyBuffer(e)}destroy(){this._managedBuffers.forEach((e=>this._destroyBuffer(e))),this._managedBuffers=null,this._gpuBuffers=null}_destroyBuffer(e){this._gpuBuffers[e.uid].destroy(),e.off("update",this.updateBuffer,this),e.off("change",this.onBufferChange,this),e.off("destroy",this.onBufferDestroy,this),this._gpuBuffers[e.uid]=null}}C.extension={type:[n.Ag.WebGPUSystem],name:"buffer"};class G{constructor(e){this._colorMaskCache=15,this._renderer=e}setMask(e){this._colorMaskCache!==e&&(this._colorMaskCache=e,this._renderer.pipeline.setColorMask(e))}destroy(){this._renderer=null,this._colorMaskCache=null}}G.extension={type:[n.Ag.WebGPUSystem],name:"colorMask"};class B{constructor(e){this._renderer=e}async init(e){return this._initPromise||(this._initPromise=this._createDeviceAndAdaptor(e).then((e=>{this.gpu=e,this._renderer.runners.contextChange.emit(this.gpu)}))),this._initPromise}contextChange(e){this._renderer.gpu=e}async _createDeviceAndAdaptor(e){const t=await navigator.gpu.requestAdapter({powerPreference:e.powerPreference,forceFallbackAdapter:e.forceFallbackAdapter}),r=["texture-compression-bc","texture-compression-astc","texture-compression-etc2"].filter((e=>t.features.has(e))),n=await t.requestDevice({requiredFeatures:r});return{adapter:t,device:n}}destroy(){this.gpu=null,this._renderer=null}}B.extension={type:[n.Ag.WebGPUSystem],name:"device"},B.defaultOptions={powerPreference:void 0,forceFallbackAdapter:!1};class k{constructor(e){this._boundBindGroup=Object.create(null),this._boundVertexBuffer=Object.create(null),this._renderer=e}renderStart(){this.commandFinished=new Promise((e=>{this._resolveCommandFinished=e})),this.commandEncoder=this._renderer.gpu.device.createCommandEncoder()}beginRenderPass(e){this.endRenderPass(),this._clearCache(),this.renderPassEncoder=this.commandEncoder.beginRenderPass(e.descriptor)}endRenderPass(){this.renderPassEncoder&&this.renderPassEncoder.end(),this.renderPassEncoder=null}setViewport(e){this.renderPassEncoder.setViewport(e.x,e.y,e.width,e.height,0,1)}setPipelineFromGeometryProgramAndState(e,t,r,n){const s=this._renderer.pipeline.getPipeline(e,t,r,n);this.setPipeline(s)}setPipeline(e){this._boundPipeline!==e&&(this._boundPipeline=e,this.renderPassEncoder.setPipeline(e))}_setVertexBuffer(e,t){this._boundVertexBuffer[e]!==t&&(this._boundVertexBuffer[e]=t,this.renderPassEncoder.setVertexBuffer(e,this._renderer.buffer.updateBuffer(t)))}_setIndexBuffer(e){if(this._boundIndexBuffer===e)return;this._boundIndexBuffer=e;const t=2===e.data.BYTES_PER_ELEMENT?"uint16":"uint32";this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(e),t)}resetBindGroup(e){this._boundBindGroup[e]=null}setBindGroup(e,t,r){if(this._boundBindGroup[e]===t)return;this._boundBindGroup[e]=t,t._touch(this._renderer.textureGC.count);const n=this._renderer.bindGroup.getBindGroup(t,r,e);this.renderPassEncoder.setBindGroup(e,n)}setGeometry(e){for(const t in e.attributes){const r=e.attributes[t];this._setVertexBuffer(r.location,r.buffer)}e.indexBuffer&&this._setIndexBuffer(e.indexBuffer)}_setShaderBindGroups(e,t){for(const r in e.groups){const n=e.groups[r];t||this._syncBindGroup(n),this.setBindGroup(r,n,e.gpuProgram)}}_syncBindGroup(e){for(const t in e.resources){const r=e.resources[t];r.isUniformGroup&&this._renderer.ubo.updateUniformGroup(r)}}draw(e){const{geometry:t,shader:r,state:n,topology:s,size:i,start:o,instanceCount:a,skipSync:u}=e;this.setPipelineFromGeometryProgramAndState(t,r.gpuProgram,n,s),this.setGeometry(t),this._setShaderBindGroups(r,u),t.indexBuffer?this.renderPassEncoder.drawIndexed(i||t.indexBuffer.data.length,a||t.instanceCount,o||0):this.renderPassEncoder.draw(i||t.getSize(),a||t.instanceCount,o||0)}finishRenderPass(){this.renderPassEncoder&&(this.renderPassEncoder.end(),this.renderPassEncoder=null)}postrender(){this.finishRenderPass(),this._gpu.device.queue.submit([this.commandEncoder.finish()]),this._resolveCommandFinished(),this.commandEncoder=null}restoreRenderPass(){const e=this._renderer.renderTarget.adaptor.getDescriptor(this._renderer.renderTarget.renderTarget,!1,[0,0,0,1]);this.renderPassEncoder=this.commandEncoder.beginRenderPass(e);const t=this._boundPipeline,r={...this._boundVertexBuffer},n=this._boundIndexBuffer,s={...this._boundBindGroup};this._clearCache();const i=this._renderer.renderTarget.viewport;this.renderPassEncoder.setViewport(i.x,i.y,i.width,i.height,0,1),this.setPipeline(t);for(const e in r)this._setVertexBuffer(e,r[e]);for(const e in s)this.setBindGroup(e,s[e],null);this._setIndexBuffer(n)}_clearCache(){for(let e=0;e<16;e++)this._boundBindGroup[e]=null,this._boundVertexBuffer[e]=null;this._boundIndexBuffer=null,this._boundPipeline=null}destroy(){this._renderer=null,this._gpu=null,this._boundBindGroup=null,this._boundVertexBuffer=null,this._boundIndexBuffer=null,this._boundPipeline=null}contextChange(e){this._gpu=e}}k.extension={type:[n.Ag.WebGPUSystem],name:"encoder",priority:1};var A=r(1957);class U{constructor(e){this._renderTargetStencilState=Object.create(null),this._renderer=e,e.renderTarget.onRenderTargetChange.add(this)}onRenderTargetChange(e){let t=this._renderTargetStencilState[e.uid];t||(t=this._renderTargetStencilState[e.uid]={stencilMode:A.K.DISABLED,stencilReference:0}),this._activeRenderTarget=e,this.setStencilMode(t.stencilMode,t.stencilReference)}setStencilMode(e,t){const r=this._renderTargetStencilState[this._activeRenderTarget.uid];r.stencilMode=e,r.stencilReference=t;const n=this._renderer;n.pipeline.setStencilMode(e),n.encoder.renderPassEncoder.setStencilReference(t)}destroy(){this._renderer.renderTarget.onRenderTargetChange.remove(this),this._renderer=null,this._activeRenderTarget=null,this._renderTargetStencilState=null}}U.extension={type:[n.Ag.WebGPUSystem],name:"stencil"};var R=r(7047);const E={i32:{align:4,size:4},u32:{align:4,size:4},f32:{align:4,size:4},f16:{align:2,size:2},"vec2<i32>":{align:8,size:8},"vec2<u32>":{align:8,size:8},"vec2<f32>":{align:8,size:8},"vec2<f16>":{align:4,size:4},"vec3<i32>":{align:16,size:12},"vec3<u32>":{align:16,size:12},"vec3<f32>":{align:16,size:12},"vec3<f16>":{align:8,size:6},"vec4<i32>":{align:16,size:16},"vec4<u32>":{align:16,size:16},"vec4<f32>":{align:16,size:16},"vec4<f16>":{align:8,size:8},"mat2x2<f32>":{align:8,size:16},"mat2x2<f16>":{align:4,size:8},"mat3x2<f32>":{align:8,size:24},"mat3x2<f16>":{align:4,size:12},"mat4x2<f32>":{align:8,size:32},"mat4x2<f16>":{align:4,size:16},"mat2x3<f32>":{align:16,size:32},"mat2x3<f16>":{align:8,size:16},"mat3x3<f32>":{align:16,size:48},"mat3x3<f16>":{align:8,size:24},"mat4x3<f32>":{align:16,size:64},"mat4x3<f16>":{align:8,size:32},"mat2x4<f32>":{align:16,size:32},"mat2x4<f16>":{align:8,size:16},"mat3x4<f32>":{align:16,size:48},"mat3x4<f16>":{align:8,size:24},"mat4x4<f32>":{align:16,size:64},"mat4x4<f16>":{align:8,size:32}};function z(e){const t=e.map((e=>({data:e,offset:0,size:0})));let r=0;for(let e=0;e<t.length;e++){const n=t[e];let s=E[n.data.type].size;const i=E[n.data.type].align;if(!E[n.data.type])throw new Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${n.data.type}`);n.data.size>1&&(s=Math.max(s,i)*n.data.size),r=Math.ceil(r/i)*i,n.size=s,n.offset=r,r+=s}return r=16*Math.ceil(r/16),{uboElements:t,size:r}}var I=r(6423),O=r(1266);function F(e,t){const{size:r,align:n}=E[e.data.type],s=(n-r)/4;return`\n         v = uv.${e.data.name};\n         ${0!==t?`offset += ${t};`:""}\n\n         arrayOffset = offset;\n\n         t = 0;\n\n         for(var i=0; i < ${e.data.size*(r/4)}; i++)\n         {\n             for(var j = 0; j < ${r/4}; j++)\n             {\n                 data[arrayOffset++] = v[t++];\n             }\n             ${0!==s?`arrayOffset += ${s};`:""}\n         }\n     `}function D(e){return(0,I.E)(e,"uboWgsl",F,O._)}class V extends R.W{constructor(){super({createUboElements:z,generateUboSync:D})}}V.extension={type:[n.Ag.WebGPUSystem],name:"ubo"};var L=r(949),W=r(581),H=r(1132);class ${constructor({minUniformOffsetAlignment:e}){this._minUniformOffsetAlignment=256,this.byteIndex=0,this._minUniformOffsetAlignment=e,this.data=new Float32Array(65535)}clear(){this.byteIndex=0}addEmptyGroup(e){if(e>this._minUniformOffsetAlignment/4)throw new Error("UniformBufferBatch: array is too large: "+4*e);const t=this.byteIndex;let r=t+4*e;if(r=Math.ceil(r/this._minUniformOffsetAlignment)*this._minUniformOffsetAlignment,r>4*this.data.length)throw new Error("UniformBufferBatch: ubo batch got too big");return this.byteIndex=r,t}addGroup(e){const t=this.addEmptyGroup(e.length);for(let r=0;r<e.length;r++)this.data[t/4+r]=e[r];return t}destroy(){this._buffer.destroy(),this._buffer=null,this.data=null}}var j=r(3513);const N=128;class K{constructor(e){this._bindGroupHash=Object.create(null),this._buffers=[],this._bindGroups=[],this._bufferResources=[],this._renderer=e,this._batchBuffer=new $({minUniformOffsetAlignment:N});for(let e=0;e<2;e++){let t=H.S.UNIFORM|H.S.COPY_DST;0===e&&(t|=H.S.COPY_SRC),this._buffers.push(new L.h({data:this._batchBuffer.data,usage:t}))}}renderEnd(){this._uploadBindGroups(),this._resetBindGroups()}_resetBindGroups(){for(const e in this._bindGroupHash)this._bindGroupHash[e]=null;this._batchBuffer.clear()}getUniformBindGroup(e,t){if(!t&&this._bindGroupHash[e.uid])return this._bindGroupHash[e.uid];this._renderer.ubo.ensureUniformGroup(e);const r=e.buffer.data,n=this._batchBuffer.addEmptyGroup(r.length);return this._renderer.ubo.syncUniformGroup(e,this._batchBuffer.data,n/4),this._bindGroupHash[e.uid]=this._getBindGroup(n/N),this._bindGroupHash[e.uid]}getUboResource(e){this._renderer.ubo.updateUniformGroup(e);const t=e.buffer.data,r=this._batchBuffer.addGroup(t);return this._getBufferResource(r/N)}getArrayBindGroup(e){const t=this._batchBuffer.addGroup(e);return this._getBindGroup(t/N)}getArrayBufferResource(e){const t=this._batchBuffer.addGroup(e)/N;return this._getBufferResource(t)}_getBufferResource(e){if(!this._bufferResources[e]){const t=this._buffers[e%2];this._bufferResources[e]=new W.d({buffer:t,offset:256*(e/2|0),size:N})}return this._bufferResources[e]}_getBindGroup(e){if(!this._bindGroups[e]){const t=new j.T({0:this._getBufferResource(e)});this._bindGroups[e]=t}return this._bindGroups[e]}_uploadBindGroups(){const e=this._renderer.buffer,t=this._buffers[0];t.update(this._batchBuffer.byteIndex),e.updateBuffer(t);const r=this._renderer.gpu.device.createCommandEncoder();for(let n=1;n<this._buffers.length;n++){const s=this._buffers[n];r.copyBufferToBuffer(e.getGPUBuffer(t),N,e.getGPUBuffer(s),0,this._batchBuffer.byteIndex)}this._renderer.gpu.device.queue.submit([r.finish()])}destroy(){for(let e=0;e<this._bindGroups.length;e++)this._bindGroups[e].destroy();this._bindGroups=null,this._bindGroupHash=null;for(let e=0;e<this._buffers.length;e++)this._buffers[e].destroy();this._buffers=null;for(let e=0;e<this._bufferResources.length;e++)this._bufferResources[e].destroy();this._bufferResources=null,this._batchBuffer.destroy(),this._bindGroupHash=null,this._renderer=null}}K.extension={type:[n.Ag.WebGPUPipes],name:"uniformBatch"};var Y=r(7084),X=r(7952),q=r(1172);const Q={"point-list":0,"line-list":1,"line-strip":2,"triangle-list":3,"triangle-strip":4};class Z{constructor(e){this._moduleCache=Object.create(null),this._bufferLayoutsCache=Object.create(null),this._pipeCache=Object.create(null),this._pipeStateCaches=Object.create(null),this._colorMask=15,this._multisampleCount=1,this._renderer=e}contextChange(e){this._gpu=e,this.setStencilMode(A.K.DISABLED),this._updatePipeHash()}setMultisampleCount(e){this._multisampleCount!==e&&(this._multisampleCount=e,this._updatePipeHash())}setRenderTarget(e){this._multisampleCount=e.msaaSamples,this._depthStencilAttachment=e.descriptor.depthStencilAttachment?1:0,this._updatePipeHash()}setColorMask(e){this._colorMask!==e&&(this._colorMask=e,this._updatePipeHash())}setStencilMode(e){this._stencilMode!==e&&(this._stencilMode=e,this._stencilState=q.g[e],this._updatePipeHash())}setPipeline(e,t,r,n){const s=this.getPipeline(e,t,r);n.setPipeline(s)}getPipeline(e,t,r,n){e._layoutKey||((0,Y.q)(e,t.attributeData),this._generateBufferKey(e)),n=n||e.topology;const s=function(e,t,r,n,s){return e<<24|t<<16|r<<10|n<<5|s}(e._layoutKey,t._layoutKey,r.data,r._blendModeId,Q[n]);return this._pipeCache[s]||(this._pipeCache[s]=this._createPipeline(e,t,r,n)),this._pipeCache[s]}_createPipeline(e,t,r,n){const s=this._gpu.device,i=this._createVertexBufferLayouts(e),o=this._renderer.state.getColorTargets(r);o[0].writeMask=this._stencilMode===A.K.RENDERING_MASK_ADD?0:this._colorMask;const a=this._renderer.shader.getProgramData(t).pipeline,u={vertex:{module:this._getModule(t.vertex.source),entryPoint:t.vertex.entryPoint,buffers:i},fragment:{module:this._getModule(t.fragment.source),entryPoint:t.fragment.entryPoint,targets:o},primitive:{topology:n,cullMode:r.cullMode},layout:a,multisample:{count:this._multisampleCount},label:"PIXI Pipeline"};return this._depthStencilAttachment&&(u.depthStencil={...this._stencilState,format:"depth24plus-stencil8",depthWriteEnabled:r.depthTest,depthCompare:r.depthTest?"less":"always"}),s.createRenderPipeline(u)}_getModule(e){return this._moduleCache[e]||this._createModule(e)}_createModule(e){const t=this._gpu.device;return this._moduleCache[e]=t.createShaderModule({code:e}),this._moduleCache[e]}_generateBufferKey(e){const t=[];let r=0;const n=Object.keys(e.attributes).sort();for(let s=0;s<n.length;s++){const i=e.attributes[n[s]];t[r++]=i.location,t[r++]=i.offset,t[r++]=i.format,t[r++]=i.stride}const s=t.join("");return e._layoutKey=(0,X.X)(s,"geometry"),e._layoutKey}_createVertexBufferLayouts(e){if(this._bufferLayoutsCache[e._layoutKey])return this._bufferLayoutsCache[e._layoutKey];const t=[];return e.buffers.forEach((r=>{const n={arrayStride:0,stepMode:"vertex",attributes:[]},s=n.attributes;for(const t in e.attributes){const i=e.attributes[t];1!==(i.divisor??1)&&(0,x.R)(`Attribute ${t} has an invalid divisor value of '${i.divisor}'. WebGPU only supports a divisor value of 1`),i.buffer===r&&(n.arrayStride=i.stride,n.stepMode=i.instance?"instance":"vertex",s.push({shaderLocation:i.location,offset:i.offset,format:i.format}))}s.length&&t.push(n)})),this._bufferLayoutsCache[e._layoutKey]=t,t}_updatePipeHash(){const e=(t=this._stencilMode,r=this._multisampleCount,this._colorMask<<6|t<<3|this._depthStencilAttachment<<1|r);var t,r;this._pipeStateCaches[e]||(this._pipeStateCaches[e]=Object.create(null)),this._pipeCache=this._pipeStateCaches[e]}destroy(){this._renderer=null,this._bufferLayoutsCache=null}}Z.extension={type:[n.Ag.WebGPUSystem],name:"pipeline"};var J=r(7238),ee=r(1257),te=r(4884),re=r(6932);class ne{constructor(){this.contexts=[],this.msaaTextures=[],this.msaaSamples=1}}class se{init(e,t){this._renderer=e,this._renderTargetSystem=t}copyToTexture(e,t,r,n,s){const i=this._renderer,o=this._getGpuColorTexture(e),a=i.texture.getGpuSource(t.source);return i.encoder.commandEncoder.copyTextureToTexture({texture:o,origin:r},{texture:a,origin:s},n),t}startRenderPass(e,t=!0,r,n){const s=this._renderTargetSystem.getGpuRenderTarget(e),i=this.getDescriptor(e,t,r);s.descriptor=i,this._renderer.pipeline.setRenderTarget(s),this._renderer.encoder.beginRenderPass(s),this._renderer.encoder.setViewport(n)}finishRenderPass(){this._renderer.encoder.endRenderPass()}_getGpuColorTexture(e){const t=this._renderTargetSystem.getGpuRenderTarget(e);return t.contexts[0]?t.contexts[0].getCurrentTexture():this._renderer.texture.getGpuSource(e.colorTextures[0].source)}getDescriptor(e,t,r){"boolean"==typeof t&&(t=t?ee.u.ALL:ee.u.NONE);const n=this._renderTargetSystem,s=n.getGpuRenderTarget(e),i=e.colorTextures.map(((e,i)=>{const o=s.contexts[i];let a,u;a=o?o.getCurrentTexture().createView():this._renderer.texture.getGpuSource(e).createView({mipLevelCount:1}),s.msaaTextures[i]&&(u=a,a=this._renderer.texture.getTextureView(s.msaaTextures[i]));const d=t&ee.u.COLOR?"clear":"load";return r??(r=n.defaultClearColor),{view:a,resolveTarget:u,clearValue:r,storeOp:"store",loadOp:d}}));let o;if(!e.stencil&&!e.depth||e.depthStencilTexture||(e.ensureDepthStencilTexture(),e.depthStencilTexture.source.sampleCount=s.msaa?4:1),e.depthStencilTexture){const r=t&ee.u.STENCIL?"clear":"load",n=t&ee.u.DEPTH?"clear":"load";o={view:this._renderer.texture.getGpuSource(e.depthStencilTexture.source).createView(),stencilStoreOp:"store",stencilLoadOp:r,depthClearValue:1,depthLoadOp:n,depthStoreOp:"store"}}return{colorAttachments:i,depthStencilAttachment:o}}clear(e,t=!0,r,n){if(!t)return;const{gpu:s,encoder:i}=this._renderer,o=s.device;if(null===i.commandEncoder){const s=o.createCommandEncoder(),i=this.getDescriptor(e,t,r),a=s.beginRenderPass(i);a.setViewport(n.x,n.y,n.width,n.height,0,1),a.end();const u=s.finish();o.queue.submit([u])}else this.startRenderPass(e,t,r,n)}initGpuRenderTarget(e){e.isRoot=!0;const t=new ne;return e.colorTextures.forEach(((e,r)=>{if(te.q.test(e.resource)){const n=e.resource.getContext("webgpu"),s=e.transparent?"premultiplied":"opaque";try{n.configure({device:this._renderer.gpu.device,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC,format:"bgra8unorm",alphaMode:s})}catch(e){console.error(e)}t.contexts[r]=n}if(t.msaa=e.source.antialias,e.source.antialias){const e=new re.v({width:0,height:0,sampleCount:4});t.msaaTextures[r]=e}})),t.msaa&&(t.msaaSamples=4,e.depthStencilTexture&&(e.depthStencilTexture.source.sampleCount=4)),t}destroyGpuRenderTarget(e){e.contexts.forEach((e=>{e.unconfigure()})),e.msaaTextures.forEach((e=>{e.destroy()})),e.msaaTextures.length=0,e.contexts.length=0}ensureDepthStencilTexture(e){const t=this._renderTargetSystem.getGpuRenderTarget(e);e.depthStencilTexture&&t.msaa&&(e.depthStencilTexture.source.sampleCount=4)}resizeGpuRenderTarget(e){const t=this._renderTargetSystem.getGpuRenderTarget(e);t.width=e.width,t.height=e.height,t.msaa&&e.colorTextures.forEach(((e,r)=>{const n=t.msaaTextures[r];n?.resize(e.source.width,e.source.height,e.source._resolution)}))}}class ie extends J.l{constructor(e){super(e),this.adaptor=new se,this.adaptor.init(e,this)}}ie.extension={type:[n.Ag.WebGPUSystem],name:"renderTarget"};class oe{constructor(){this._gpuProgramData=Object.create(null)}contextChange(e){this._gpu=e}getProgramData(e){return this._gpuProgramData[e._layoutKey]||this._createGPUProgramData(e)}_createGPUProgramData(e){const t=this._gpu.device,r=e.gpuLayout.map((e=>t.createBindGroupLayout({entries:e}))),n={bindGroupLayouts:r};return this._gpuProgramData[e._layoutKey]={bindGroups:r,pipeline:t.createPipelineLayout(n)},this._gpuProgramData[e._layoutKey]}destroy(){this._gpu=null,this._gpuProgramData=null}}oe.extension={type:[n.Ag.WebGPUSystem],name:"shader"};const ae={normal:{alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"}},add:{alpha:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"one",dstFactor:"one",operation:"add"}},multiply:{alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"dst",dstFactor:"one-minus-src-alpha",operation:"add"}},screen:{alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"one",dstFactor:"one-minus-src",operation:"add"}},overlay:{alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"one",dstFactor:"one-minus-src",operation:"add"}},none:{alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"zero",dstFactor:"zero",operation:"add"}},"normal-npm":{alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"}},"add-npm":{alpha:{srcFactor:"one",dstFactor:"one",operation:"add"},color:{srcFactor:"src-alpha",dstFactor:"one",operation:"add"}},"screen-npm":{alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"src-alpha",dstFactor:"one-minus-src",operation:"add"}},erase:{alpha:{srcFactor:"zero",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"zero",dstFactor:"one-minus-src",operation:"add"}}};class ue{constructor(){this.defaultState=new b.U,this.defaultState.blend=!0}contextChange(e){this.gpu=e}getColorTargets(e){return[{format:"bgra8unorm",writeMask:0,blend:ae[e.blendMode]||ae.normal}]}destroy(){this.gpu=null}}ue.extension={type:[n.Ag.WebGPUSystem],name:"state"};var de=r(1761),ce=r(7608);const le={type:"image",upload(e,t,r){const n=e.resource,s=(0|e.pixelWidth)*(0|e.pixelHeight),i=n.byteLength/s;r.device.queue.writeTexture({texture:t},n,{offset:0,rowsPerImage:e.pixelHeight,bytesPerRow:e.pixelHeight*i},{width:e.pixelWidth,height:e.pixelHeight,depthOrArrayLayers:1})}},he={"bc1-rgba-unorm":{blockBytes:8,blockWidth:4,blockHeight:4},"bc2-rgba-unorm":{blockBytes:16,blockWidth:4,blockHeight:4},"bc3-rgba-unorm":{blockBytes:16,blockWidth:4,blockHeight:4},"bc7-rgba-unorm":{blockBytes:16,blockWidth:4,blockHeight:4},"etc1-rgb-unorm":{blockBytes:8,blockWidth:4,blockHeight:4},"etc2-rgba8unorm":{blockBytes:16,blockWidth:4,blockHeight:4},"astc-4x4-unorm":{blockBytes:16,blockWidth:4,blockHeight:4}},pe={blockBytes:4,blockWidth:1,blockHeight:1},fe={type:"compressed",upload(e,t,r){let n=e.pixelWidth,s=e.pixelHeight;const i=he[e.format]||pe;for(let o=0;o<e.resource.length;o++){const a=e.resource[o],u=Math.ceil(n/i.blockWidth)*i.blockBytes;r.device.queue.writeTexture({texture:t,mipLevel:o},a,{offset:0,bytesPerRow:u},{width:Math.ceil(n/i.blockWidth)*i.blockWidth,height:Math.ceil(s/i.blockHeight)*i.blockHeight,depthOrArrayLayers:1}),n=Math.max(n>>1,1),s=Math.max(s>>1,1)}}},me={type:"image",upload(e,t,r){const n=e.resource;if(!n)return;const s=Math.min(t.width,e.resourceWidth||e.pixelWidth),i=Math.min(t.height,e.resourceHeight||e.pixelHeight),o="premultiply-alpha-on-upload"===e.alphaMode;r.device.queue.copyExternalImageToTexture({source:n},{texture:t,premultipliedAlpha:o},{width:s,height:i})}},ge={type:"video",upload(e,t,r){me.upload(e,t,r)}};class xe{constructor(e){this.device=e,this.sampler=e.createSampler({minFilter:"linear"}),this.pipelines={}}_getMipmapPipeline(e){let t=this.pipelines[e];return t||(this.mipmapShaderModule||(this.mipmapShaderModule=this.device.createShaderModule({code:"\n                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(\n                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));\n\n                        struct VertexOutput {\n                        @builtin(position) position : vec4<f32>,\n                        @location(0) texCoord : vec2<f32>,\n                        };\n\n                        @vertex\n                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {\n                        var output : VertexOutput;\n                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);\n                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);\n                        return output;\n                        }\n\n                        @group(0) @binding(0) var imgSampler : sampler;\n                        @group(0) @binding(1) var img : texture_2d<f32>;\n\n                        @fragment\n                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {\n                        return textureSample(img, imgSampler, texCoord);\n                        }\n                    "})),t=this.device.createRenderPipeline({layout:"auto",vertex:{module:this.mipmapShaderModule,entryPoint:"vertexMain"},fragment:{module:this.mipmapShaderModule,entryPoint:"fragmentMain",targets:[{format:e}]}}),this.pipelines[e]=t),t}generateMipmap(e){const t=this._getMipmapPipeline(e.format);if("3d"===e.dimension||"1d"===e.dimension)throw new Error("Generating mipmaps for non-2d textures is currently unsupported!");let r=e;const n=e.depthOrArrayLayers||1,s=e.usage&GPUTextureUsage.RENDER_ATTACHMENT;if(!s){const t={size:{width:Math.ceil(e.width/2),height:Math.ceil(e.height/2),depthOrArrayLayers:n},format:e.format,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.RENDER_ATTACHMENT,mipLevelCount:e.mipLevelCount-1};r=this.device.createTexture(t)}const i=this.device.createCommandEncoder({}),o=t.getBindGroupLayout(0);for(let a=0;a<n;++a){let n=e.createView({baseMipLevel:0,mipLevelCount:1,dimension:"2d",baseArrayLayer:a,arrayLayerCount:1}),u=s?1:0;for(let s=1;s<e.mipLevelCount;++s){const e=r.createView({baseMipLevel:u++,mipLevelCount:1,dimension:"2d",baseArrayLayer:a,arrayLayerCount:1}),s=i.beginRenderPass({colorAttachments:[{view:e,storeOp:"store",loadOp:"clear",clearValue:{r:0,g:0,b:0,a:0}}]}),d=this.device.createBindGroup({layout:o,entries:[{binding:0,resource:this.sampler},{binding:1,resource:n}]});s.setPipeline(t),s.setBindGroup(0,d),s.draw(3,1,0,0),s.end(),n=e}}if(!s){const t={width:Math.ceil(e.width/2),height:Math.ceil(e.height/2),depthOrArrayLayers:n};for(let n=1;n<e.mipLevelCount;++n)i.copyTextureToTexture({texture:r,mipLevel:n-1},{texture:e,mipLevel:n},t),t.width=Math.ceil(t.width/2),t.height=Math.ceil(t.height/2)}return this.device.queue.submit([i.finish()]),s||r.destroy(),e}}class _e{constructor(e){this.managedTextures=[],this._gpuSources=Object.create(null),this._gpuSamplers=Object.create(null),this._bindGroupHash=Object.create(null),this._textureViewHash=Object.create(null),this._uploads={image:me,buffer:le,video:ge,compressed:fe},this._renderer=e}contextChange(e){this._gpu=e}initSource(e){if(e.autoGenerateMipmaps){const t=Math.max(e.pixelWidth,e.pixelHeight);e.mipLevelCount=Math.floor(Math.log2(t))+1}let t=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST;"compressed"!==e.uploadMethodId&&(t|=GPUTextureUsage.RENDER_ATTACHMENT,t|=GPUTextureUsage.COPY_SRC);const r=he[e.format]||{blockBytes:4,blockWidth:1,blockHeight:1},n=Math.ceil(e.pixelWidth/r.blockWidth)*r.blockWidth,s=Math.ceil(e.pixelHeight/r.blockHeight)*r.blockHeight,i={label:e.label,size:{width:n,height:s},format:e.format,sampleCount:e.sampleCount,mipLevelCount:e.mipLevelCount,dimension:e.dimension,usage:t},o=this._gpu.device.createTexture(i);return this._gpuSources[e.uid]=o,this.managedTextures.includes(e)||(e.on("update",this.onSourceUpdate,this),e.on("resize",this.onSourceResize,this),e.on("destroy",this.onSourceDestroy,this),e.on("unload",this.onSourceUnload,this),e.on("updateMipmaps",this.onUpdateMipmaps,this),this.managedTextures.push(e)),this.onSourceUpdate(e),o}onSourceUpdate(e){const t=this.getGpuSource(e);t&&(this._uploads[e.uploadMethodId]&&this._uploads[e.uploadMethodId].upload(e,t,this._gpu),e.autoGenerateMipmaps&&e.mipLevelCount>1&&this.onUpdateMipmaps(e))}onSourceUnload(e){const t=this._gpuSources[e.uid];t&&(this._gpuSources[e.uid]=null,t.destroy())}onUpdateMipmaps(e){this._mipmapGenerator||(this._mipmapGenerator=new xe(this._gpu.device));const t=this.getGpuSource(e);this._mipmapGenerator.generateMipmap(t)}onSourceDestroy(e){e.off("update",this.onSourceUpdate,this),e.off("unload",this.onSourceUnload,this),e.off("destroy",this.onSourceDestroy,this),e.off("resize",this.onSourceResize,this),e.off("updateMipmaps",this.onUpdateMipmaps,this),this.managedTextures.splice(this.managedTextures.indexOf(e),1),this.onSourceUnload(e)}onSourceResize(e){const t=this._gpuSources[e.uid];t?t.width===e.pixelWidth&&t.height===e.pixelHeight||(this._textureViewHash[e.uid]=null,this._bindGroupHash[e.uid]=null,this.onSourceUnload(e),this.initSource(e)):this.initSource(e)}_initSampler(e){return this._gpuSamplers[e._resourceId]=this._gpu.device.createSampler(e),this._gpuSamplers[e._resourceId]}getGpuSampler(e){return this._gpuSamplers[e._resourceId]||this._initSampler(e)}getGpuSource(e){return this._gpuSources[e.uid]||this.initSource(e)}getTextureBindGroup(e){return this._bindGroupHash[e.uid]??this._createTextureBindGroup(e)}_createTextureBindGroup(e){const t=e.source,r=t.uid;return this._bindGroupHash[r]=new j.T({0:t,1:t.style}),this._bindGroupHash[r]}getTextureView(e){const t=e.source;return this._textureViewHash[t.uid]??this._createTextureView(t)}_createTextureView(e){return this._textureViewHash[e.uid]=this.getGpuSource(e).createView(),this._textureViewHash[e.uid]}generateCanvas(e){const t=this._renderer,r=t.gpu.device.createCommandEncoder(),n=de.e.get().createCanvas();n.width=e.source.pixelWidth,n.height=e.source.pixelHeight;const s=n.getContext("webgpu");return s.configure({device:t.gpu.device,usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC,format:navigator.gpu.getPreferredCanvasFormat(),alphaMode:"premultiplied"}),r.copyTextureToTexture({texture:t.texture.getGpuSource(e.source),origin:{x:0,y:0}},{texture:s.getCurrentTexture()},{width:n.width,height:n.height}),t.gpu.device.queue.submit([r.finish()]),n}getPixels(e){const t=this.generateCanvas(e),r=ce.N.getOptimalCanvasAndContext(t.width,t.height),n=r.context;n.drawImage(t,0,0);const{width:s,height:i}=t,o=n.getImageData(0,0,s,i),a=new Uint8ClampedArray(o.data.buffer);return ce.N.returnCanvasAndContext(r),{pixels:a,width:s,height:i}}destroy(){this.managedTextures.slice().forEach((e=>this.onSourceDestroy(e))),this.managedTextures=null;for(const e of Object.keys(this._bindGroupHash)){const t=Number(e),r=this._bindGroupHash[t];r?.destroy(),this._bindGroupHash[t]=null}this._gpu=null,this._mipmapGenerator=null,this._gpuSources=null,this._bindGroupHash=null,this._textureViewHash=null,this._gpuSamplers=null}}_e.extension={type:[n.Ag.WebGPUSystem],name:"texture"};const be=[...S.i,V,k,B,C,_e,ie,oe,ue,Z,G,U,w],ve=[...S.f,K],ye=[y,_,f],Te=[],Se=[],Pe=[];n.XO.handleByNamedList(n.Ag.WebGPUSystem,Te),n.XO.handleByNamedList(n.Ag.WebGPUPipes,Se),n.XO.handleByNamedList(n.Ag.WebGPUPipesAdaptor,Pe),n.XO.add(...be,...ve,...ye);class we extends T.k{constructor(){super({name:"webgpu",type:P.W.WEBGPU,systems:Te,renderPipes:Se,renderPipeAdaptors:Pe})}}},3513:(e,t,r)=>{r.d(t,{T:()=>n});class n{constructor(e){this.resources=Object.create(null),this._dirty=!0;let t=0;for(const r in e){const n=e[r];this.setResource(n,t++)}this._updateKey()}_updateKey(){if(!this._dirty)return;this._dirty=!1;const e=[];let t=0;for(const r in this.resources)e[t++]=this.resources[r]._resourceId;this._key=e.join("|")}setResource(e,t){const r=this.resources[t];e!==r&&(r&&e.off?.("change",this.onResourceChange,this),e.on?.("change",this.onResourceChange,this),this.resources[t]=e,this._dirty=!0)}getResource(e){return this.resources[e]}_touch(e){const t=this.resources;for(const r in t)t[r]._touched=e}destroy(){const e=this.resources;for(const t in e){const r=e[t];r.off?.("change",this.onResourceChange,this)}this.resources=null}onResourceChange(e){if(this._dirty=!0,e.destroyed){const t=this.resources;for(const r in t)t[r]===e&&(t[r]=null)}else this._updateKey()}}},3012:(e,t,r)=>{r.d(t,{B:()=>d});var n=r(7952),s=r(8306);const i={f32:"float32","vec2<f32>":"float32x2","vec3<f32>":"float32x3","vec4<f32>":"float32x4",vec2f:"float32x2",vec3f:"float32x3",vec4f:"float32x4",i32:"sint32","vec2<i32>":"sint32x2","vec3<i32>":"sint32x3","vec4<i32>":"sint32x4",u32:"uint32","vec2<u32>":"uint32x2","vec3<u32>":"uint32x3","vec4<u32>":"uint32x4",bool:"uint32","vec2<bool>":"uint32x2","vec3<bool>":"uint32x3","vec4<bool>":"uint32x4"};function o(e){const t=/@group\((\d+)\)/,r=/@binding\((\d+)\)/,n=/var(<[^>]+>)? (\w+)/,s=/:\s*(\w+)/,i=/(\w+)\s*:\s*([\w\<\>]+)/g,o=/struct\s+(\w+)/,a=e.match(/(^|[^/])@(group|binding)\(\d+\)[^;]+;/g)?.map((e=>({group:parseInt(e.match(t)[1],10),binding:parseInt(e.match(r)[1],10),name:e.match(n)[2],isUniform:"<uniform>"===e.match(n)[1],type:e.match(s)[1]})));if(!a)return{groups:[],structs:[]};const u=e.match(/struct\s+(\w+)\s*{([^}]+)}/g)?.map((e=>{const t=e.match(o)[1],r=e.match(i).reduce(((e,t)=>{const[r,n]=t.split(":");return e[r.trim()]=n.trim(),e}),{});return r?{name:t,members:r}:null})).filter((({name:e})=>a.some((t=>t.type===e))))??[];return{groups:a,structs:u}}var a=(e=>(e[e.VERTEX=1]="VERTEX",e[e.FRAGMENT=2]="FRAGMENT",e[e.COMPUTE=4]="COMPUTE",e))(a||{});const u=Object.create(null);class d{constructor(e){this._layoutKey=0;const{fragment:t,vertex:r,layout:n,gpuLayout:s,name:i}=e;if(this.name=i,this.fragment=t,this.vertex=r,t.source===r.source){const e=o(t.source);this.structsAndGroups=e}else{const e=o(r.source),n=o(t.source);this.structsAndGroups=function(e,t){const r=new Set,n=new Set;return{structs:[...e.structs,...t.structs].filter((e=>!r.has(e.name)&&(r.add(e.name),!0))),groups:[...e.groups,...t.groups].filter((e=>{const t=`${e.name}-${e.binding}`;return!n.has(t)&&(n.add(t),!0)}))}}(e,n)}this.layout=n??function({groups:e}){const t=[];for(let r=0;r<e.length;r++){const n=e[r];t[n.group]||(t[n.group]={}),t[n.group][n.name]=n.binding}return t}(this.structsAndGroups),this.gpuLayout=s??function({groups:e}){const t=[];for(let r=0;r<e.length;r++){const n=e[r];t[n.group]||(t[n.group]=[]),n.isUniform?t[n.group].push({binding:n.binding,visibility:a.VERTEX|a.FRAGMENT,buffer:{type:"uniform"}}):"sampler"===n.type?t[n.group].push({binding:n.binding,visibility:a.FRAGMENT,sampler:{type:"filtering"}}):"texture_2d"===n.type&&t[n.group].push({binding:n.binding,visibility:a.FRAGMENT,texture:{sampleType:"float",viewDimension:"2d",multisampled:!1}})}return t}(this.structsAndGroups),this.autoAssignGlobalUniforms=!(void 0===this.layout[0]?.globalUniforms),this.autoAssignLocalUniforms=!(void 0===this.layout[1]?.localUniforms),this._generateProgramKey()}_generateProgramKey(){const{vertex:e,fragment:t}=this,r=e.source+t.source+e.entryPoint+t.entryPoint;this._layoutKey=(0,n.X)(r,"program")}get attributeData(){return this._attributeData??(this._attributeData=function({source:e,entryPoint:t}){const r={},n=e.indexOf(`fn ${t}`);if(-1!==n){const t=e.indexOf("->",n);if(-1!==t){const o=e.substring(n,t),a=/@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g;let u;for(;null!==(u=a.exec(o));){const e=i[u[3]]??"float32";r[u[2]]={location:parseInt(u[1],10),format:e,stride:(0,s.m)(e).stride,offset:0,instance:!1,start:0}}}}return r}(this.vertex)),this._attributeData}destroy(){this.gpuLayout=null,this.layout=null,this.structsAndGroups=null,this.fragment=null,this.vertex=null}static from(e){const t=`${e.vertex.source}:${e.fragment.source}:${e.fragment.entryPoint}:${e.vertex.entryPoint}`;return u[t]||(u[t]=new d(e)),u[t]}}},1172:(e,t,r)=>{r.d(t,{g:()=>s});var n=r(1957);const s=[];s[n.K.NONE]=void 0,s[n.K.DISABLED]={stencilWriteMask:0,stencilReadMask:0},s[n.K.RENDERING_MASK_ADD]={stencilFront:{compare:"equal",passOp:"increment-clamp"},stencilBack:{compare:"equal",passOp:"increment-clamp"}},s[n.K.RENDERING_MASK_REMOVE]={stencilFront:{compare:"equal",passOp:"decrement-clamp"},stencilBack:{compare:"equal",passOp:"decrement-clamp"}},s[n.K.MASK_ACTIVE]={stencilWriteMask:0,stencilFront:{compare:"equal",passOp:"keep"},stencilBack:{compare:"equal",passOp:"keep"}}},949:(e,t,r)=>{r.d(t,{h:()=>o});var n=r(4486),s=r(133),i=r(1132);class o extends n.A{constructor(e){let{data:t,size:r}=e;const{usage:n,label:i,shrinkToFit:o}=e;super(),this.uid=(0,s.L)("buffer"),this._resourceType="buffer",this._resourceId=(0,s.L)("resource"),this._touched=0,this._updateID=1,this.shrinkToFit=!0,this.destroyed=!1,t instanceof Array&&(t=new Float32Array(t)),this._data=t,r=r??t?.byteLength;const a=!!t;this.descriptor={size:r,usage:n,mappedAtCreation:a,label:i},this.shrinkToFit=o??!0}get data(){return this._data}set data(e){this.setDataWithSize(e,e.length,!0)}get static(){return!!(this.descriptor.usage&i.S.STATIC)}set static(e){e?this.descriptor.usage|=i.S.STATIC:this.descriptor.usage&=~i.S.STATIC}setDataWithSize(e,t,r){if(this._updateID++,this._updateSize=t*e.BYTES_PER_ELEMENT,this._data===e)return void(r&&this.emit("update",this));const n=this._data;this._data=e,n.length===e.length||!this.shrinkToFit&&e.byteLength<n.byteLength?r&&this.emit("update",this):(this.descriptor.size=e.byteLength,this._resourceId=(0,s.L)("resource"),this.emit("change",this))}update(e){this._updateSize=e??this._updateSize,this._updateID++,this.emit("update",this)}destroy(){this.destroyed=!0,this.emit("destroy",this),this.emit("change",this),this._data=null,this.descriptor=null,this.removeAllListeners()}}},581:(e,t,r)=>{r.d(t,{d:()=>i});var n=r(4486),s=r(133);class i extends n.A{constructor({buffer:e,offset:t,size:r}){super(),this.uid=(0,s.L)("buffer"),this._resourceType="bufferResource",this._touched=0,this._resourceId=(0,s.L)("resource"),this._bufferResource=!0,this.destroyed=!1,this.buffer=e,this.offset=0|t,this.size=r,this.buffer.on("change",this.onBufferChange,this)}onBufferChange(){this._resourceId=(0,s.L)("resource"),this.emit("change",this)}destroy(e=!1){this.destroyed=!0,e&&this.buffer.destroy(),this.emit("change",this),this.buffer=null}}},1132:(e,t,r)=>{r.d(t,{S:()=>n});var n=(e=>(e[e.MAP_READ=1]="MAP_READ",e[e.MAP_WRITE=2]="MAP_WRITE",e[e.COPY_SRC=4]="COPY_SRC",e[e.COPY_DST=8]="COPY_DST",e[e.INDEX=16]="INDEX",e[e.VERTEX=32]="VERTEX",e[e.UNIFORM=64]="UNIFORM",e[e.STORAGE=128]="STORAGE",e[e.INDIRECT=256]="INDIRECT",e[e.QUERY_RESOLVE=512]="QUERY_RESOLVE",e[e.STATIC=1024]="STATIC",e))(n||{})},6736:(e,t,r)=>{function n(e,t){const r=e.byteLength/8|0,n=new Float64Array(e,0,r);new Float64Array(t,0,r).set(n);const s=e.byteLength-8*r;if(s>0){const n=new Uint8Array(e,8*r,s);new Uint8Array(t,8*r,s).set(n)}}r.d(t,{W:()=>n})},6011:(e,t,r)=>{r.d(t,{V:()=>c});var n=r(4486),s=r(9636),i=r(133),o=r(949),a=r(1132);function u(e,t){if(!(e instanceof o.h)){let r=t?a.S.INDEX:a.S.VERTEX;e instanceof Array&&(t?(e=new Uint32Array(e),r=a.S.INDEX|a.S.COPY_DST):(e=new Float32Array(e),r=a.S.VERTEX|a.S.COPY_DST)),e=new o.h({data:e,label:t?"index-mesh-buffer":"vertex-mesh-buffer",usage:r})}return e}function d(e){return(e instanceof o.h||Array.isArray(e)||e.BYTES_PER_ELEMENT)&&(e={buffer:e}),e.buffer=u(e.buffer,!1),e}class c extends n.A{constructor(e){const{attributes:t,indexBuffer:r,topology:n}=e;super(),this.uid=(0,i.L)("geometry"),this._layoutKey=0,this.instanceCount=1,this._bounds=new s.c,this._boundsDirty=!0,this.attributes=t,this.buffers=[],this.instanceCount=e.instanceCount||1;for(const e in t){const r=t[e]=d(t[e]);-1===this.buffers.indexOf(r.buffer)&&(this.buffers.push(r.buffer),r.buffer.on("update",this.onBufferUpdate,this),r.buffer.on("change",this.onBufferUpdate,this))}r&&(this.indexBuffer=u(r,!0),this.buffers.push(this.indexBuffer)),this.topology=n||"triangle-list"}onBufferUpdate(){this._boundsDirty=!0,this.emit("update",this)}getAttribute(e){return this.attributes[e]}getIndex(){return this.indexBuffer}getBuffer(e){return this.getAttribute(e).buffer}getSize(){for(const e in this.attributes){const t=this.attributes[e];return t.buffer.data.length/(t.stride/4||t.size)}return 0}get bounds(){return this._boundsDirty?(this._boundsDirty=!1,function(e,t,r){const n=e.getAttribute("aPosition");if(!n)return r.minX=0,r.minY=0,r.maxX=0,r.maxY=0,r;const s=n.buffer.data;let i=1/0,o=1/0,a=-1/0,u=-1/0;const d=s.BYTES_PER_ELEMENT,c=(n.offset||0)/d,l=(n.stride||8)/d;for(let e=c;e<s.length;e+=l){const t=s[e],r=s[e+1];t>a&&(a=t),r>u&&(u=r),t<i&&(i=t),r<o&&(o=r)}return r.minX=i,r.minY=o,r.maxX=a,r.maxY=u,r}(this,0,this._bounds)):this._bounds}destroy(e=!1){this.emit("destroy",this),this.removeAllListeners(),e&&this.buffers.forEach((e=>e.destroy())),this.attributes=null,this.buffers=null,this.indexBuffer=null,this._bounds=null}}},8306:(e,t,r)=>{r.d(t,{m:()=>s});const n={uint8x2:{size:2,stride:2,normalised:!1},uint8x4:{size:4,stride:4,normalised:!1},sint8x2:{size:2,stride:2,normalised:!1},sint8x4:{size:4,stride:4,normalised:!1},unorm8x2:{size:2,stride:2,normalised:!0},unorm8x4:{size:4,stride:4,normalised:!0},snorm8x2:{size:2,stride:2,normalised:!0},snorm8x4:{size:4,stride:4,normalised:!0},uint16x2:{size:2,stride:4,normalised:!1},uint16x4:{size:4,stride:8,normalised:!1},sint16x2:{size:2,stride:4,normalised:!1},sint16x4:{size:4,stride:8,normalised:!1},unorm16x2:{size:2,stride:4,normalised:!0},unorm16x4:{size:4,stride:8,normalised:!0},snorm16x2:{size:2,stride:4,normalised:!0},snorm16x4:{size:4,stride:8,normalised:!0},float16x2:{size:2,stride:4,normalised:!1},float16x4:{size:4,stride:8,normalised:!1},float32:{size:1,stride:4,normalised:!1},float32x2:{size:2,stride:8,normalised:!1},float32x3:{size:3,stride:12,normalised:!1},float32x4:{size:4,stride:16,normalised:!1},uint32:{size:1,stride:4,normalised:!1},uint32x2:{size:2,stride:8,normalised:!1},uint32x3:{size:3,stride:12,normalised:!1},uint32x4:{size:4,stride:16,normalised:!1},sint32:{size:1,stride:4,normalised:!1},sint32x2:{size:2,stride:8,normalised:!1},sint32x3:{size:3,stride:12,normalised:!1},sint32x4:{size:4,stride:16,normalised:!1}};function s(e){return n[e]??n.float32}},279:(e,t,r)=>{r.d(t,{O:()=>a});var n=r(133),s=r(6932),i=r(4492);const o=class e{constructor(t={}){if(this.uid=(0,n.L)("renderTarget"),this.colorTextures=[],this.dirtyId=0,this.isRoot=!1,this._size=new Float32Array(2),this._managedColorTextures=!1,t={...e.defaultOptions,...t},this.stencil=t.stencil,this.depth=t.depth,this.isRoot=t.isRoot,"number"==typeof t.colorTextures){this._managedColorTextures=!0;for(let e=0;e<t.colorTextures;e++)this.colorTextures.push(new s.v({width:t.width,height:t.height,resolution:t.resolution,antialias:t.antialias}))}else{this.colorTextures=[...t.colorTextures.map((e=>e.source))];const e=this.colorTexture.source;this.resize(e.width,e.height,e._resolution)}this.colorTexture.source.on("resize",this.onSourceResize,this),(t.depthStencilTexture||this.stencil)&&(t.depthStencilTexture instanceof i.g||t.depthStencilTexture instanceof s.v?this.depthStencilTexture=t.depthStencilTexture.source:this.ensureDepthStencilTexture())}get size(){const e=this._size;return e[0]=this.pixelWidth,e[1]=this.pixelHeight,e}get width(){return this.colorTexture.source.width}get height(){return this.colorTexture.source.height}get pixelWidth(){return this.colorTexture.source.pixelWidth}get pixelHeight(){return this.colorTexture.source.pixelHeight}get resolution(){return this.colorTexture.source._resolution}get colorTexture(){return this.colorTextures[0]}onSourceResize(e){this.resize(e.width,e.height,e._resolution,!0)}ensureDepthStencilTexture(){this.depthStencilTexture||(this.depthStencilTexture=new s.v({width:this.width,height:this.height,resolution:this.resolution,format:"depth24plus-stencil8",autoGenerateMipmaps:!1,antialias:!1,mipLevelCount:1}))}resize(e,t,r=this.resolution,n=!1){this.dirtyId++,this.colorTextures.forEach(((s,i)=>{n&&0===i||s.source.resize(e,t,r)})),this.depthStencilTexture&&this.depthStencilTexture.source.resize(e,t,r)}destroy(){this.colorTexture.source.off("resize",this.onSourceResize,this),this._managedColorTextures&&this.colorTextures.forEach((e=>{e.destroy()})),this.depthStencilTexture&&(this.depthStencilTexture.destroy(),delete this.depthStencilTexture)}};o.defaultOptions={width:0,height:0,resolution:1,colorTextures:1,stencil:!1,depth:!1,antialias:!1,isRoot:!1};let a=o},7238:(e,t,r)=>{r.d(t,{l:()=>h});var n=r(9313),s=r(9252),i=r(1257),o=r(7729),a=r(4884),u=r(6932),d=r(4492),c=r(8725),l=r(279);class h{constructor(e){this.rootViewPort=new s.M,this.viewport=new s.M,this.onRenderTargetChange=new o.C("onRenderTargetChange"),this.projectionMatrix=new n.u,this.defaultClearColor=[0,0,0,0],this._renderSurfaceToRenderTargetHash=new Map,this._gpuRenderTargetHash=Object.create(null),this._renderTargetStack=[],this._renderer=e}finishRenderPass(){this.adaptor.finishRenderPass(this.renderTarget)}renderStart({target:e,clear:t,clearColor:r,frame:n}){this._renderTargetStack.length=0,this.push(e,t,r,n),this.rootViewPort.copyFrom(this.viewport),this.rootRenderTarget=this.renderTarget,this.renderingToScreen=function(e){const t=e.colorTexture.source.resource;return globalThis.HTMLCanvasElement&&t instanceof HTMLCanvasElement&&document.body.contains(t)}(this.rootRenderTarget)}bind(e,t=!0,r,n){const s=this.getRenderTarget(e),i=this.renderTarget!==s;this.renderTarget=s,this.renderSurface=e;const o=this.getGpuRenderTarget(s);s.pixelWidth===o.width&&s.pixelHeight===o.height||(this.adaptor.resizeGpuRenderTarget(s),o.width=s.pixelWidth,o.height=s.pixelHeight);const a=s.colorTexture,u=this.viewport,c=a.pixelWidth,l=a.pixelHeight;if(!n&&e instanceof d.g&&(n=e.frame),n){const e=a._resolution;u.x=n.x*e+.5|0,u.y=n.y*e+.5|0,u.width=n.width*e+.5|0,u.height=n.height*e+.5|0}else u.x=0,u.y=0,u.width=c,u.height=l;return function(e,t,r,n,s,i){const o=i?1:-1;e.identity(),e.a=1/n*2,e.d=o*(1/s*2),e.tx=-1-0*e.a,e.ty=-o-0*e.d}(this.projectionMatrix,0,0,u.width/a.resolution,u.height/a.resolution,!s.isRoot),this.adaptor.startRenderPass(s,t,r,u),i&&this.onRenderTargetChange.emit(s),s}clear(e,t=i.u.ALL,r){t&&(e&&(e=this.getRenderTarget(e)),this.adaptor.clear(e||this.renderTarget,t,r,this.viewport))}contextChange(){this._gpuRenderTargetHash=Object.create(null)}push(e,t=i.u.ALL,r,n){const s=this.bind(e,t,r,n);return this._renderTargetStack.push({renderTarget:s,frame:n}),s}pop(){this._renderTargetStack.pop();const e=this._renderTargetStack[this._renderTargetStack.length-1];this.bind(e.renderTarget,!1,null,e.frame)}getRenderTarget(e){return e.isTexture&&(e=e.source),this._renderSurfaceToRenderTargetHash.get(e)??this._initRenderTarget(e)}copyToTexture(e,t,r,n,s){r.x<0&&(n.width+=r.x,s.x-=r.x,r.x=0),r.y<0&&(n.height+=r.y,s.y-=r.y,r.y=0);const{pixelWidth:i,pixelHeight:o}=e;return n.width=Math.min(n.width,i-r.x),n.height=Math.min(n.height,o-r.y),this.adaptor.copyToTexture(e,t,r,n,s)}ensureDepthStencil(){this.renderTarget.stencil||(this.renderTarget.stencil=!0,this.adaptor.startRenderPass(this.renderTarget,!1,null,this.viewport))}destroy(){this._renderer=null,this._renderSurfaceToRenderTargetHash.forEach(((e,t)=>{e!==t&&e.destroy()})),this._renderSurfaceToRenderTargetHash.clear(),this._gpuRenderTargetHash=Object.create(null)}_initRenderTarget(e){let t=null;return a.q.test(e)&&(e=(0,c.c)(e).source),e instanceof l.O?t=e:e instanceof u.v&&(t=new l.O({colorTextures:[e]}),a.q.test(e.source.resource)&&(t.isRoot=!0),e.once("destroy",(()=>{t.destroy();const e=this._gpuRenderTargetHash[t.uid];e&&(this._gpuRenderTargetHash[t.uid]=null,this.adaptor.destroyGpuRenderTarget(e))}))),this._renderSurfaceToRenderTargetHash.set(e,t),t}getGpuRenderTarget(e){return this._gpuRenderTargetHash[e.uid]||(this._gpuRenderTargetHash[e.uid]=this.adaptor.initGpuRenderTarget(e))}}},8475:(e,t,r)=>{r.d(t,{M:()=>d});var n=r(4486),s=r(9113),i=r(3513),o=r(3012),a=r(5099),u=r(5811);class d extends n.A{constructor(e){super(),this._uniformBindMap=Object.create(null),this._ownedBindGroups=[];let{gpuProgram:t,glProgram:r,groups:n,resources:s,compatibleRenderers:o,groupMap:d}=e;this.gpuProgram=t,this.glProgram=r,void 0===o&&(o=0,t&&(o|=a.W.WEBGPU),r&&(o|=a.W.WEBGL)),this.compatibleRenderers=o;const c={};if(s||n||(s={}),s&&n)throw new Error("[Shader] Cannot have both resources and groups");if(!t&&n&&!d)throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");if(!t&&n&&d)for(const e in d)for(const t in d[e]){const r=d[e][t];c[r]={group:e,binding:t,name:r}}else if(t&&n&&!d){const e=t.structsAndGroups.groups;d={},e.forEach((e=>{d[e.group]=d[e.group]||{},d[e.group][e.binding]=e.name,c[e.name]=e}))}else if(s){n={},d={},t&&t.structsAndGroups.groups.forEach((e=>{d[e.group]=d[e.group]||{},d[e.group][e.binding]=e.name,c[e.name]=e}));let e=0;for(const t in s)c[t]||(n[99]||(n[99]=new i.T,this._ownedBindGroups.push(n[99])),c[t]={group:99,binding:e,name:t},d[99]=d[99]||{},d[99][e]=t,e++);for(const e in s){const t=e;let r=s[e];r.source||r._resourceType||(r=new u.k(r));const o=c[t];o&&(n[o.group]||(n[o.group]=new i.T,this._ownedBindGroups.push(n[o.group])),n[o.group].setResource(r,o.binding))}}this.groups=n,this._uniformBindMap=d,this.resources=this._buildResourceAccessor(n,c)}addResource(e,t,r){var n,s;(n=this._uniformBindMap)[t]||(n[t]={}),(s=this._uniformBindMap[t])[r]||(s[r]=e),this.groups[t]||(this.groups[t]=new i.T,this._ownedBindGroups.push(this.groups[t]))}_buildResourceAccessor(e,t){const r={};for(const n in t){const s=t[n];Object.defineProperty(r,s.name,{get:()=>e[s.group].getResource(s.binding),set(t){e[s.group].setResource(t,s.binding)}})}return r}destroy(e=!1){this.emit("destroy",this),e&&(this.gpuProgram?.destroy(),this.glProgram?.destroy()),this.gpuProgram=null,this.glProgram=null,this.removeAllListeners(),this._uniformBindMap=null,this._ownedBindGroups.forEach((e=>{e.destroy()})),this._ownedBindGroups=null,this.resources=null,this.groups=null}static from(e){const{gpu:t,gl:r,...n}=e;let i,a;return t&&(i=o.B.from(t)),r&&(a=s.M.from(r)),new d({gpuProgram:i,glProgram:a,...n})}}},7047:(e,t,r)=>{r.d(t,{W:()=>o});var n=r(4577),s=r(949),i=r(1132);class o{constructor(e){this._syncFunctionHash=Object.create(null),this._adaptor=e,this._systemCheck()}_systemCheck(){if(!(0,n.f)())throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.")}ensureUniformGroup(e){const t=this.getUniformGroupData(e);e.buffer||(e.buffer=new s.h({data:new Float32Array(t.layout.size/4),usage:i.S.UNIFORM|i.S.COPY_DST}))}getUniformGroupData(e){return this._syncFunctionHash[e._signature]||this._initUniformGroup(e)}_initUniformGroup(e){const t=e._signature;let r=this._syncFunctionHash[t];if(!r){const n=Object.keys(e.uniformStructures).map((t=>e.uniformStructures[t])),s=this._adaptor.createUboElements(n),i=this._generateUboSync(s.uboElements);r=this._syncFunctionHash[t]={layout:s,syncFunction:i}}return this._syncFunctionHash[t]}_generateUboSync(e){return this._adaptor.generateUboSync(e)}syncUniformGroup(e,t,r){const n=this.getUniformGroupData(e);return e.buffer||(e.buffer=new s.h({data:new Float32Array(n.layout.size/4),usage:i.S.UNIFORM|i.S.COPY_DST})),t||(t=e.buffer.data),r||(r=0),n.syncFunction(e.uniforms,t,r),!0}updateUniformGroup(e){if(e.isStatic&&!e._dirtyId)return!1;e._dirtyId=0;const t=this.syncUniformGroup(e);return e.buffer.update(),t}destroy(){this._syncFunctionHash=null}}},5811:(e,t,r)=>{r.d(t,{k:()=>d});var n=r(133),s=r(7952);const i=["f32","i32","vec2<f32>","vec3<f32>","vec4<f32>","mat2x2<f32>","mat3x3<f32>","mat4x4<f32>","mat3x2<f32>","mat4x2<f32>","mat2x3<f32>","mat4x3<f32>","mat2x4<f32>","mat3x4<f32>"],o=i.reduce(((e,t)=>(e[t]=!0,e)),{});function a(e,t){switch(e){case"f32":return 0;case"vec2<f32>":return new Float32Array(2*t);case"vec3<f32>":return new Float32Array(3*t);case"vec4<f32>":return new Float32Array(4*t);case"mat2x2<f32>":return new Float32Array([1,0,0,1]);case"mat3x3<f32>":return new Float32Array([1,0,0,0,1,0,0,0,1]);case"mat4x4<f32>":return new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}return null}const u=class e{constructor(t,r){this._touched=0,this.uid=(0,n.L)("uniform"),this._resourceType="uniformGroup",this._resourceId=(0,n.L)("resource"),this.isUniformGroup=!0,this._dirtyId=0,this.destroyed=!1,r={...e.defaultOptions,...r},this.uniformStructures=t;const u={};for(const e in t){const r=t[e];if(r.name=e,r.size=r.size??1,!o[r.type])throw new Error(`Uniform type ${r.type} is not supported. Supported uniform types are: ${i.join(", ")}`);r.value??(r.value=a(r.type,r.size)),u[e]=r.value}this.uniforms=u,this._dirtyId=1,this.ubo=r.ubo,this.isStatic=r.isStatic,this._signature=(0,s.X)(Object.keys(u).map((e=>`${e}-${t[e].type}`)).join("-"),"uniform-group")}update(){this._dirtyId++}};u.defaultOptions={ubo:!1,isStatic:!1};let d=u},6423:(e,t,r)=>{r.d(t,{E:()=>s});var n=r(8166);function s(e,t,r,s){const i=["\n        var v = null;\n        var v2 = null;\n        var t = 0;\n        var index = 0;\n        var name = null;\n        var arrayOffset = null;\n    "];let o=0;for(let a=0;a<e.length;a++){const u=e[a],d=u.data.name;let c=!1,l=0;for(let e=0;e<n.$.length;e++)if(n.$[e].test(u.data)){l=u.offset/4,i.push(`name = "${d}";`,`offset += ${l-o};`,n.$[e][t]||n.$[e].ubo),c=!0;break}if(!c)if(u.data.size>1)l=u.offset/4,i.push(r(u,l-o));else{const e=s[u.data.type];l=u.offset/4,i.push(`\n                    v = uv.${d};\n                    offset += ${l-o};\n                    ${e};\n                `)}o=l}const a=i.join("\n");return new Function("uv","data","offset",a)}},1266:(e,t,r)=>{function n(e,t){return`\n        for (let i = 0; i < ${e*t}; i++) {\n            data[offset + (((i / ${e})|0) * 4) + (i % ${e})] = v[i];\n        }\n    `}r.d(t,{_:()=>i,g:()=>s});const s={f32:"\n        data[offset] = v;",i32:"\n        data[offset] = v;","vec2<f32>":"\n        data[offset] = v[0];\n        data[offset + 1] = v[1];","vec3<f32>":"\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];","vec4<f32>":"\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];","mat2x2<f32>":"\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 4] = v[2];\n        data[offset + 5] = v[3];","mat3x3<f32>":"\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];","mat4x4<f32>":"\n        for (let i = 0; i < 16; i++) {\n            data[offset + i] = v[i];\n        }","mat3x2<f32>":n(3,2),"mat4x2<f32>":n(4,2),"mat2x3<f32>":n(2,3),"mat4x3<f32>":n(4,3),"mat2x4<f32>":n(2,4),"mat3x4<f32>":n(3,4)},i={...s,"mat2x2<f32>":"\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];\n    "}},8166:(e,t,r)=>{r.d(t,{$:()=>n});const n=[{type:"mat3x3<f32>",test:e=>void 0!==e.value.a,ubo:"\n            var matrix = uv[name].toArray(true);\n            data[offset] = matrix[0];\n            data[offset + 1] = matrix[1];\n            data[offset + 2] = matrix[2];\n            data[offset + 4] = matrix[3];\n            data[offset + 5] = matrix[4];\n            data[offset + 6] = matrix[5];\n            data[offset + 8] = matrix[6];\n            data[offset + 9] = matrix[7];\n            data[offset + 10] = matrix[8];\n        ",uniform:"\n            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));\n        "},{type:"vec4<f32>",test:e=>"vec4<f32>"===e.type&&1===e.size&&void 0!==e.value.width,ubo:"\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n            data[offset + 2] = v.width;\n            data[offset + 3] = v.height;\n        ",uniform:"\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                cv[2] = v.width;\n                cv[3] = v.height;\n                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);\n            }\n        "},{type:"vec2<f32>",test:e=>"vec2<f32>"===e.type&&1===e.size&&void 0!==e.value.x,ubo:"\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n        ",uniform:"\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                gl.uniform2f(ud[name].location, v.x, v.y);\n            }\n        "},{type:"vec4<f32>",test:e=>"vec4<f32>"===e.type&&1===e.size&&void 0!==e.value.red,ubo:"\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n            data[offset + 3] = v.alpha;\n        ",uniform:"\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                cv[3] = v.alpha;\n                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);\n            }\n        "},{type:"vec3<f32>",test:e=>"vec3<f32>"===e.type&&1===e.size&&void 0!==e.value.red,ubo:"\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n        ",uniform:"\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);\n            }\n        "}]},7547:(e,t,r)=>{r.d(t,{U:()=>i});const n={normal:0,add:1,multiply:2,screen:3,overlay:4,erase:5,"normal-npm":6,"add-npm":7,"screen-npm":8},s=class e{constructor(){this.data=0,this.blendMode="normal",this.polygonOffset=0,this.blend=!0,this.depthMask=!0}get blend(){return!!(1&this.data)}set blend(e){!!(1&this.data)!==e&&(this.data^=1)}get offsets(){return!!(2&this.data)}set offsets(e){!!(2&this.data)!==e&&(this.data^=2)}set cullMode(e){"none"!==e?(this.culling=!0,this.clockwiseFrontFace="front"===e):this.culling=!1}get cullMode(){return this.culling?this.clockwiseFrontFace?"front":"back":"none"}get culling(){return!!(4&this.data)}set culling(e){!!(4&this.data)!==e&&(this.data^=4)}get depthTest(){return!!(8&this.data)}set depthTest(e){!!(8&this.data)!==e&&(this.data^=8)}get depthMask(){return!!(32&this.data)}set depthMask(e){!!(32&this.data)!==e&&(this.data^=32)}get clockwiseFrontFace(){return!!(16&this.data)}set clockwiseFrontFace(e){!!(16&this.data)!==e&&(this.data^=16)}get blendMode(){return this._blendMode}set blendMode(e){this.blend="none"!==e,this._blendMode=e,this._blendModeId=n[e]||0}get polygonOffset(){return this._polygonOffset}set polygonOffset(e){this.offsets=!!e,this._polygonOffset=e}toString(){return`[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`}static for2d(){const t=new e;return t.depthTest=!1,t.blend=!0,t}};s.default2d=s.for2d();let i=s},1957:(e,t,r)=>{r.d(t,{K:()=>s,Q:()=>n});const n={normal:"normal-npm",add:"add-npm",screen:"screen-npm"};var s=(e=>(e[e.DISABLED=0]="DISABLED",e[e.RENDERING_MASK_ADD=1]="RENDERING_MASK_ADD",e[e.MASK_ACTIVE=2]="MASK_ACTIVE",e[e.RENDERING_MASK_REMOVE=3]="RENDERING_MASK_REMOVE",e[e.NONE=4]="NONE",e))(s||{})},8639:(e,t,r)=>{r.d(t,{i:()=>s});var n=r(1957);function s(e,t){return"no-premultiply-alpha"===t.alphaMode&&n.Q[e]||e}},5717:(e,t,r)=>{r.d(t,{f:()=>Ee,i:()=>Re});var n=r(8507);class s{constructor(e){this._renderer=e}addRenderable(e,t){this._renderer.renderPipes.batch.break(t),t.add(e)}execute(e){e.isRenderable&&e.render(this._renderer)}destroy(){this._renderer=null}}function i(e,t){const r=e.instructionSet,n=r.instructions;for(let e=0;e<r.instructionSize;e++){const r=n[e];t[r.renderPipeId].execute(r)}}s.extension={type:[n.Ag.WebGLPipes,n.Ag.WebGPUPipes,n.Ag.CanvasPipes],name:"customRender"};class o{constructor(e){this._renderer=e}addRenderGroup(e,t){this._renderer.renderPipes.batch.break(t),t.add(e)}execute(e){e.isRenderable&&(this._renderer.globalUniforms.push({worldTransformMatrix:e.worldTransform,worldColor:e.worldColorAlpha}),i(e,this._renderer.renderPipes),this._renderer.globalUniforms.pop())}destroy(){this._renderer=null}}o.extension={type:[n.Ag.WebGLPipes,n.Ag.WebGPUPipes,n.Ag.CanvasPipes],name:"renderGroup"};var a=r(9313);function u(e,t){const r=e.root,n=e.instructionSet;n.reset(),t.batch.buildStart(n),t.blendMode.buildStart(),t.colorMask.buildStart(),r.sortableChildren&&r.sortChildren(),c(r,n,t,!0),t.batch.buildEnd(n),t.blendMode.buildEnd(n)}function d(e,t,r){e.globalDisplayStatus<7||!e.includeInBuild||(e.sortableChildren&&e.sortChildren(),e.isSimple?function(e,t,r){if(e.renderPipeId&&(r.blendMode.setBlendMode(e,e.groupBlendMode,t),e.didViewUpdate=!1,r[e.renderPipeId].addRenderable(e,t)),!e.renderGroup){const n=e.children,s=n.length;for(let e=0;e<s;e++)d(n[e],t,r)}}(e,t,r):c(e,t,r,!1))}function c(e,t,r,n){if(!n&&e.renderGroup)r.renderGroup.addRenderGroup(e.renderGroup,t);else{for(let n=0;n<e.effects.length;n++){const s=e.effects[n];r[s.pipe].push(s,e,t)}const n=e.renderPipeId;n&&(r.blendMode.setBlendMode(e,e.groupBlendMode,t),e.didViewUpdate=!1,r[n].addRenderable(e,t));const s=e.children;if(s.length)for(let e=0;e<s.length;e++)d(s[e],t,r);for(let n=e.effects.length-1;n>=0;n--){const s=e.effects[n];r[s.pipe].pop(s,e,t)}}}function l(e,t){t||(t=0);for(let r=t;r<e.length&&e[r];r++)e[r]=null}function h(e,t=[]){t.push(e);for(let r=0;r<e.renderGroupChildren.length;r++)h(e.renderGroupChildren[r],t);return t}var p=r(4263);const f=16777215;function m(e,t){return e===f||t===f?e+t-f:function(e,t){const r=e>>16&255,n=e>>8&255,s=255&e;return(r+.5*((t>>16&255)-r)<<16)+(n+.5*((t>>8&255)-n)<<8)+(s+.5*((255&t)-s))}(e,t)}const g=new p.mc,x=p.fR|p.ig|p.u;function _(e,t=!1){!function(e){const t=e.root;let r;if(e.renderGroupParent){const n=e.renderGroupParent;e.worldTransform.appendFrom(t.relativeGroupTransform,n.worldTransform),e.worldColor=m(t.groupColor,n.worldColor),r=t.groupAlpha*n.worldAlpha}else e.worldTransform.copyFrom(t.localTransform),e.worldColor=t.localColor,r=t.localAlpha;r=r<0?0:r>1?1:r,e.worldAlpha=r,e.worldColorAlpha=e.worldColor+(255*r<<24)}(e);const r=e.childrenToUpdate,n=e.updateTick++;for(const t in r){const s=Number(t),i=r[t],o=i.list,a=i.index;for(let t=0;t<a;t++){const r=o[t];r.parentRenderGroup===e&&r.relativeRenderGroupDepth===s&&b(r,n,0)}l(o,a),i.index=0}if(t)for(let r=0;r<e.renderGroupChildren.length;r++)_(e.renderGroupChildren[r],t)}function b(e,t,r){if(t===e.updateTick)return;e.updateTick=t,e.didChange=!1;const n=e.localTransform;e.updateLocalTransform();const s=e.parent;if(s&&!s.renderGroup?(r|=e._updateFlags,e.relativeGroupTransform.appendFrom(n,s.relativeGroupTransform),r&x&&v(e,s,r)):(r=e._updateFlags,e.relativeGroupTransform.copyFrom(n),r&x&&v(e,g,r)),!e.renderGroup){const n=e.children,s=n.length;for(let e=0;e<s;e++)b(n[e],t,r);const i=e.parentRenderGroup;e.renderPipeId&&!i.structureDidChange&&i.updateRenderable(e)}}function v(e,t,r){if(r&p.ig){e.groupColor=m(e.localColor,t.groupColor);let r=e.localAlpha*t.groupAlpha;r=r<0?0:r>1?1:r,e.groupAlpha=r,e.groupColorAlpha=e.groupColor+(255*r<<24)}r&p.u&&(e.groupBlendMode="inherit"===e.localBlendMode?t.groupBlendMode:e.localBlendMode),r&p.fR&&(e.globalDisplayStatus=e.localDisplayStatus&t.globalDisplayStatus),e._updateFlags=0}function y(e,t){const{list:r,index:n}=e.childrenRenderablesToUpdate;let s=!1;for(let e=0;e<n;e++){const n=r[e];if(s=t[n.renderPipeId].validateRenderable(n),s)break}return e.structureDidChange=s,s}const T=new a.u;class S{constructor(e){this._renderer=e}render({container:e,transform:t}){e.isRenderGroup=!0;const r=e.parent,n=e.renderGroup.renderGroupParent;e.parent=null,e.renderGroup.renderGroupParent=null;const s=this._renderer,o=h(e.renderGroup,[]);let a=T;t&&(a=a.copyFrom(e.renderGroup.localTransform),e.renderGroup.localTransform.copyFrom(t));const d=s.renderPipes;for(let e=0;e<o.length;e++){const t=o[e];t.runOnRender(),t.instructionSet.renderPipes=d,t.structureDidChange?l(t.childrenRenderablesToUpdate.list,0):y(t,d),_(t),t.structureDidChange?(t.structureDidChange=!1,u(t,d)):P(t),t.childrenRenderablesToUpdate.index=0,s.renderPipes.batch.upload(t.instructionSet)}s.globalUniforms.start({worldTransformMatrix:t?e.renderGroup.localTransform:e.renderGroup.worldTransform,worldColor:e.renderGroup.worldColorAlpha}),i(e.renderGroup,d),d.uniformBatch&&d.uniformBatch.renderEnd(),t&&e.renderGroup.localTransform.copyFrom(a),e.parent=r,e.renderGroup.renderGroupParent=n}destroy(){this._renderer=null}}function P(e){const{list:t,index:r}=e.childrenRenderablesToUpdate;for(let n=0;n<r;n++){const r=t[n];r.didViewUpdate&&e.updateRenderable(r)}l(t,r)}S.extension={type:[n.Ag.WebGLSystem,n.Ag.WebGPUSystem,n.Ag.CanvasSystem],name:"renderGroup"};var w=r(8218),M=r(8422);class C{constructor(e){this._gpuSpriteHash=Object.create(null),this._renderer=e}addRenderable(e,t){const r=this._getGpuSprite(e);e._didSpriteUpdate&&this._updateBatchableSprite(e,r),this._renderer.renderPipes.batch.addToBatch(r)}updateRenderable(e){const t=this._gpuSpriteHash[e.uid];e._didSpriteUpdate&&this._updateBatchableSprite(e,t),t.batcher.updateElement(t)}validateRenderable(e){const t=e._texture,r=this._getGpuSprite(e);return r.texture._source!==t._source&&!r.batcher.checkAndUpdateTexture(r,t)}destroyRenderable(e){const t=this._gpuSpriteHash[e.uid];w.Z.return(t),this._gpuSpriteHash[e.uid]=null}_updateBatchableSprite(e,t){e._didSpriteUpdate=!1,t.bounds=e.bounds,t.texture=e._texture}_getGpuSprite(e){return this._gpuSpriteHash[e.uid]||this._initGPUSprite(e)}_initGPUSprite(e){const t=w.Z.get(M.K);return t.renderable=e,t.texture=e._texture,t.bounds=e.bounds,t.roundPixels=this._renderer._roundPixels|e._roundPixels,this._gpuSpriteHash[e.uid]=t,e._didSpriteUpdate=!1,e.on("destroyed",(()=>{this.destroyRenderable(e)})),t}destroy(){for(const e in this._gpuSpriteHash)w.Z.return(this._gpuSpriteHash[e]);this._gpuSpriteHash=null,this._renderer=null}}C.extension={type:[n.Ag.WebGLPipes,n.Ag.WebGPUPipes,n.Ag.CanvasPipes],name:"sprite"};var G=r(7073),B=r(7547),k=r(5130),A=r(1617);class U{constructor(e,t){this.state=B.U.for2d(),this._batches=Object.create(null),this._geometries=Object.create(null),this.renderer=e,this._adaptor=t,this._adaptor.init(this)}buildStart(e){if(!this._batches[e.uid]){const t=new k.i;this._batches[e.uid]=t,this._geometries[t.uid]=new A.J}this._activeBatch=this._batches[e.uid],this._activeGeometry=this._geometries[this._activeBatch.uid],this._activeBatch.begin()}addToBatch(e){this._activeBatch.add(e)}break(e){this._activeBatch.break(e)}buildEnd(e){const t=this._activeBatch,r=this._activeGeometry;t.finish(e),r.indexBuffer.setDataWithSize(t.indexBuffer,t.indexSize,!0),r.buffers[0].setDataWithSize(t.attributeBuffer.float32View,t.attributeSize,!1)}upload(e){const t=this._batches[e.uid],r=this._geometries[t.uid];t.dirty&&(t.dirty=!1,r.buffers[0].update(4*t.attributeSize))}execute(e){if("startBatch"===e.action){const t=e.batcher,r=this._geometries[t.uid];this._adaptor.start(this,r)}this._adaptor.execute(this,e)}destroy(){this.state=null,this.renderer=null,this._adaptor.destroy(),this._adaptor=null;for(const e in this._batches)this._batches[e].destroy();this._batches=null;for(const e in this._geometries)this._geometries[e].destroy();this._geometries=null}}U.extension={type:[n.Ag.WebGLPipes,n.Ag.WebGPUPipes,n.Ag.CanvasPipes],name:"batch"};var R=r(9049),E=r(9113),z=r(3012),I=r(5811),O=r(1196),F=r(8475);const D=class e extends F.M{constructor(t){super(t={...e.defaultOptions,...t}),this.enabled=!0,this._state=B.U.for2d(),this.blendMode=t.blendMode,this.padding=t.padding,"boolean"==typeof t.antialias?this.antialias=t.antialias?"on":"off":this.antialias=t.antialias,this.resolution=t.resolution,this.blendRequired=t.blendRequired,this.addResource("uTexture",0,1)}apply(e,t,r,n){e.applyFilter(this,t,r,n)}get blendMode(){return this._state.blendMode}set blendMode(e){this._state.blendMode=e}static from(t){const{gpu:r,gl:n,...s}=t;let i,o;return r&&(i=z.B.from(r)),n&&(o=E.M.from(n)),new e({gpuProgram:i,glProgram:o,...s})}};D.defaultOptions={blendMode:"normal",resolution:1,padding:0,antialias:"off",blendRequired:!1};let V=D;var L="struct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,  \n};\n\nstruct MaskUniforms {\n  uFilterMatrix:mat3x3<f32>,\n  uMaskClamp:vec4<f32>,\n  uAlpha:f32,\n};\n\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n\n@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;\n@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n    @location(1) filterUv : vec2<f32>,\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \n}\n\nfn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\n}\n\nfn getSize() -> vec2<f32>\n{\n\n  \n  return gfu.uGlobalFrame.zw;\n}\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition),\n   getFilterCoord(aPosition)\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @location(1) filterUv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n\n    var maskClamp = filterUniforms.uMaskClamp;\n\n     var clip = step(3.5,\n        step(maskClamp.x, filterUv.x) +\n        step(maskClamp.y, filterUv.y) +\n        step(filterUv.x, maskClamp.z) +\n        step(filterUv.y, maskClamp.w));\n\n    var mask = textureSample(uMaskTexture, uSampler, filterUv);\n    var source = textureSample(uTexture, uSampler, uv);\n    \n    var npmAlpha = 0.0;\n\n    var alphaMul = 1.0 - npmAlpha * (1.0 - mask.a);\n\n    var a = (alphaMul * mask.r) * clip;\n\n    return vec4(source.rgb, source.a) * a;\n}";class W extends V{constructor(e){const{sprite:t,...r}=e,n=new O.N(t.texture),s=new I.k({uFilterMatrix:{value:new a.u,type:"mat3x3<f32>"},uMaskClamp:{value:n.uClampFrame,type:"vec4<f32>"},uAlpha:{value:1,type:"f32"}});super({...r,gpuProgram:z.B.from({vertex:{source:L,entryPoint:"mainVertex"},fragment:{source:L,entryPoint:"mainFragment"}}),glProgram:E.M.from({vertex:"in vec2 aPosition;\n\nout vec2 vTextureCoord;\nout vec2 vMaskCoord;\n\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\nuniform mat3 uFilterMatrix;\n\nvec4 filterVertexPosition(  vec2 aPosition )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n       \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord(  vec2 aPosition )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvec2 getFilterCoord( vec2 aPosition )\n{\n    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\n}   \n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition(aPosition);\n    vTextureCoord = filterTextureCoord(aPosition);\n    vMaskCoord = getFilterCoord(aPosition);\n}\n",fragment:"in vec2 vMaskCoord;\nin vec2 vTextureCoord;\n\nuniform sampler2D uTexture;\nuniform sampler2D uMaskTexture;\n\nuniform float uAlpha;\nuniform vec4 uMaskClamp;\n\nout vec4 finalColor;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(uMaskClamp.x, vMaskCoord.x) +\n        step(uMaskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, uMaskClamp.z) +\n        step(vMaskCoord.y, uMaskClamp.w));\n\n    // TODO look into why this is needed\n    float npmAlpha = uAlpha; \n    vec4 original = texture(uTexture, vTextureCoord);\n    vec4 masky = texture(uMaskTexture, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * uAlpha * clip);\n\n    finalColor = original;\n}\n",name:"mask-filter"}),resources:{filterUniforms:s,uMaskTexture:t.texture.source}}),this.sprite=t,this._textureMatrix=n}apply(e,t,r,n){this._textureMatrix.texture=this.sprite.texture,e.calculateSpriteMatrix(this.resources.filterUniforms.uniforms.uFilterMatrix,this.sprite).prepend(this._textureMatrix.mapCoord),this.resources.uMaskTexture=this.sprite.texture.source,e.applyFilter(this,t,r,n)}}var H=r(9636),$=r(9443),j=r(6844),N=r(4492),K=r(2437),Y=r(5099);const X=new H.c;class q extends R.a{constructor(){super(),this.filters=[new W({sprite:new j.k(N.g.EMPTY),resolution:"inherit",antialias:"inherit"})]}get sprite(){return this.filters[0].sprite}set sprite(e){this.filters[0].sprite=e}}class Q{constructor(e){this._activeMaskStage=[],this._renderer=e}push(e,t,r){const n=this._renderer;if(n.renderPipes.batch.break(r),r.add({renderPipeId:"alphaMask",action:"pushMaskBegin",mask:e,canBundle:!1,maskedContainer:t}),e.renderMaskToTexture){const t=e.mask;t.includeInBuild=!0,d(t,r,n.renderPipes),t.includeInBuild=!1}n.renderPipes.batch.break(r),r.add({renderPipeId:"alphaMask",action:"pushMaskEnd",mask:e,maskedContainer:t,canBundle:!1})}pop(e,t,r){this._renderer.renderPipes.batch.break(r),r.add({renderPipeId:"alphaMask",action:"popMaskEnd",mask:e,canBundle:!1})}execute(e){const t=this._renderer,r=e.mask.renderMaskToTexture;if("pushMaskBegin"===e.action){const n=w.Z.get(q);if(r){e.mask.mask.measurable=!0;const r=(0,$.fB)(e.mask.mask,!0,X);e.mask.mask.measurable=!1,r.ceil();const s=t.renderTarget.renderTarget.colorTexture.source,i=K.W.getOptimalTexture(r.width,r.height,s._resolution,s.antialias);t.renderTarget.push(i,!0),t.globalUniforms.push({offset:r,worldColor:4294967295});const o=n.sprite;o.texture=i,o.worldTransform.tx=r.minX,o.worldTransform.ty=r.minY,this._activeMaskStage.push({filterEffect:n,maskedContainer:e.maskedContainer,filterTexture:i})}else n.sprite=e.mask.mask,this._activeMaskStage.push({filterEffect:n,maskedContainer:e.maskedContainer})}else if("pushMaskEnd"===e.action){const e=this._activeMaskStage[this._activeMaskStage.length-1];r&&(t.type===Y.W.WEBGL&&t.renderTarget.finishRenderPass(),t.renderTarget.pop(),t.globalUniforms.pop()),t.filter.push({renderPipeId:"filter",action:"pushFilter",container:e.maskedContainer,filterEffect:e.filterEffect,canBundle:!1})}else if("popMaskEnd"===e.action){t.filter.pop();const e=this._activeMaskStage.pop();r&&K.W.returnTexture(e.filterTexture),w.Z.return(e.filterEffect)}}destroy(){this._renderer=null,this._activeMaskStage=null}}Q.extension={type:[n.Ag.WebGLPipes,n.Ag.WebGPUPipes,n.Ag.CanvasPipes],name:"alphaMask"};class Z{constructor(e){this._colorStack=[],this._colorStackIndex=0,this._currentColor=0,this._renderer=e}buildStart(){this._colorStack[0]=15,this._colorStackIndex=1,this._currentColor=15}push(e,t,r){this._renderer.renderPipes.batch.break(r);const n=this._colorStack;n[this._colorStackIndex]=n[this._colorStackIndex-1]&e.mask;const s=this._colorStack[this._colorStackIndex];s!==this._currentColor&&(this._currentColor=s,r.add({renderPipeId:"colorMask",colorMask:s,canBundle:!1})),this._colorStackIndex++}pop(e,t,r){this._renderer.renderPipes.batch.break(r);const n=this._colorStack;this._colorStackIndex--;const s=n[this._colorStackIndex-1];s!==this._currentColor&&(this._currentColor=s,r.add({renderPipeId:"colorMask",colorMask:s,canBundle:!1}))}execute(e){this._renderer.colorMask.setMask(e.colorMask)}destroy(){this._colorStack=null}}Z.extension={type:[n.Ag.WebGLPipes,n.Ag.WebGPUPipes,n.Ag.CanvasPipes],name:"colorMask"};var J=r(1257),ee=r(1957);class te{constructor(e){this._maskStackHash={},this._maskHash=new WeakMap,this._renderer=e}push(e,t,r){var n;const s=e,i=this._renderer;i.renderPipes.batch.break(r),i.renderPipes.blendMode.setBlendMode(s.mask,"none",r),r.add({renderPipeId:"stencilMask",action:"pushMaskBegin",mask:e,canBundle:!1});const o=s.mask;o.includeInBuild=!0,this._maskHash.has(s)||this._maskHash.set(s,{instructionsStart:0,instructionsLength:0});const a=this._maskHash.get(s);a.instructionsStart=r.instructionSize,d(o,r,i.renderPipes),o.includeInBuild=!1,i.renderPipes.batch.break(r),r.add({renderPipeId:"stencilMask",action:"pushMaskEnd",mask:e,canBundle:!1});const u=r.instructionSize-a.instructionsStart-1;a.instructionsLength=u;const c=i.renderTarget.renderTarget.uid;(n=this._maskStackHash)[c]??(n[c]=0)}pop(e,t,r){const n=e,s=this._renderer;s.renderPipes.batch.break(r),s.renderPipes.blendMode.setBlendMode(n.mask,"none",r),r.add({renderPipeId:"stencilMask",action:"popMaskBegin",canBundle:!1});const i=this._maskHash.get(e);for(let e=0;e<i.instructionsLength;e++)r.instructions[r.instructionSize++]=r.instructions[i.instructionsStart++];r.add({renderPipeId:"stencilMask",action:"popMaskEnd",canBundle:!1})}execute(e){var t;const r=this._renderer,n=r.renderTarget.renderTarget.uid;let s=(t=this._maskStackHash)[n]??(t[n]=0);"pushMaskBegin"===e.action?(r.renderTarget.ensureDepthStencil(),r.stencil.setStencilMode(ee.K.RENDERING_MASK_ADD,s),s++,r.colorMask.setMask(0)):"pushMaskEnd"===e.action?(r.stencil.setStencilMode(ee.K.MASK_ACTIVE,s),r.colorMask.setMask(15)):"popMaskBegin"===e.action?(r.colorMask.setMask(0),0!==s?r.stencil.setStencilMode(ee.K.RENDERING_MASK_REMOVE,s):(r.renderTarget.clear(null,J.u.STENCIL),r.stencil.setStencilMode(ee.K.DISABLED,s)),s--):"popMaskEnd"===e.action&&(r.stencil.setStencilMode(ee.K.MASK_ACTIVE,s),r.colorMask.setMask(15)),this._maskStackHash[n]=s}destroy(){this._renderer=null,this._maskStackHash=null,this._maskHash=null}}te.extension={type:[n.Ag.WebGLPipes,n.Ag.WebGPUPipes,n.Ag.CanvasPipes],name:"stencilMask"};var re=r(2577);const ne=class e{constructor(){this.clearBeforeRender=!0,this._backgroundColor=new re.Q(0),this.color=this._backgroundColor,this.alpha=1}init(t){t={...e.defaultOptions,...t},this.clearBeforeRender=t.clearBeforeRender,this.color=t.background||t.backgroundColor||this._backgroundColor,this.alpha=t.backgroundAlpha,this._backgroundColor.setAlpha(t.backgroundAlpha)}get color(){return this._backgroundColor}set color(e){this._backgroundColor.setValue(e)}get alpha(){return this._backgroundColor.alpha}set alpha(e){this._backgroundColor.setAlpha(e)}get colorRgba(){return this._backgroundColor.toArray()}destroy(){}};ne.extension={type:[n.Ag.WebGLSystem,n.Ag.WebGPUSystem,n.Ag.CanvasSystem],name:"background",priority:0},ne.defaultOptions={backgroundAlpha:1,backgroundColor:0,clearBeforeRender:!0};let se=ne;var ie=r(268);const oe={};n.XO.handle(n.Ag.BlendMode,(e=>{if(!e.name)throw new Error("BlendMode extension must have a name property");oe[e.name]=e.ref}),(e=>{delete oe[e.name]}));class ae{constructor(e){this._isAdvanced=!1,this._filterHash=Object.create(null),this._renderer=e}setBlendMode(e,t,r){this._activeBlendMode!==t?(this._activeBlendMode=t,this._isAdvanced&&this._endAdvancedBlendMode(r),this._isAdvanced=!!oe[t],this._isAdvanced&&(this._beginAdvancedBlendMode(r),this._renderableList.push(e))):this._isAdvanced&&this._renderableList.push(e)}_beginAdvancedBlendMode(e){this._renderer.renderPipes.batch.break(e);const t=this._activeBlendMode;if(!oe[t])return void(0,ie.R)(`Unable to assign BlendMode: '${t}'. You may want to include: import 'pixi.js/advanced-blend-modes'`);let r=this._filterHash[t];r||(r=this._filterHash[t]=new R.a,r.filters=[new oe[t]]);const n={renderPipeId:"filter",action:"pushFilter",renderables:[],filterEffect:r,canBundle:!1};this._renderableList=n.renderables,e.add(n)}_endAdvancedBlendMode(e){this._renderableList=null,this._renderer.renderPipes.batch.break(e),e.add({renderPipeId:"filter",action:"popFilter",canBundle:!1})}buildStart(){this._isAdvanced=!1}buildEnd(e){this._isAdvanced&&this._endAdvancedBlendMode(e)}destroy(){this._renderer=null,this._renderableList=null;for(const e in this._filterHash)this._filterHash[e].destroy();this._filterHash=null}}ae.extension={type:[n.Ag.WebGLPipes,n.Ag.WebGPUPipes,n.Ag.CanvasPipes],name:"blendMode"};const ue={png:"image/png",jpg:"image/jpeg",webp:"image/webp"},de=class e{constructor(e){this._renderer=e}_normalizeOptions(e,t={}){return e instanceof p.mc||e instanceof N.g?{target:e,...t}:{...t,...e}}async image(e){const t=new Image;return t.src=await this.base64(e),t}async base64(t){t=this._normalizeOptions(t,e.defaultImageOptions);const{format:r,quality:n}=t,s=this.canvas(t);if(void 0!==s.toBlob)return new Promise(((e,t)=>{s.toBlob((r=>{if(!r)return void t(new Error("ICanvas.toBlob failed!"));const n=new FileReader;n.onload=()=>e(n.result),n.onerror=t,n.readAsDataURL(r)}),ue[r],n)}));if(void 0!==s.toDataURL)return s.toDataURL(ue[r],n);if(void 0!==s.convertToBlob){const e=await s.convertToBlob({type:ue[r],quality:n});return new Promise(((t,r)=>{const n=new FileReader;n.onload=()=>t(n.result),n.onerror=r,n.readAsDataURL(e)}))}throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented")}canvas(e){const t=(e=this._normalizeOptions(e)).target,r=this._renderer;if(t instanceof N.g)return r.texture.generateCanvas(t);const n=r.textureGenerator.generateTexture(e),s=r.texture.generateCanvas(n);return n.destroy(),s}pixels(e){const t=(e=this._normalizeOptions(e)).target,r=this._renderer,n=t instanceof N.g?t:r.textureGenerator.generateTexture(e),s=r.texture.getPixels(n);return t instanceof p.mc&&n.destroy(),s}texture(e){return(e=this._normalizeOptions(e)).target instanceof N.g?e.target:this._renderer.textureGenerator.generateTexture(e)}download(e){e=this._normalizeOptions(e);const t=this.canvas(e),r=document.createElement("a");r.download=e.filename??"image.png",r.href=t.toDataURL("image/png"),document.body.appendChild(r),r.click(),document.body.removeChild(r)}log(e){const t=e.width??200;e=this._normalizeOptions(e);const r=this.canvas(e),n=r.toDataURL();console.log(`[Pixi Texture] ${r.width}px ${r.height}px`);const s=["font-size: 1px;",`padding: ${t}px 300px;`,`background: url(${n}) no-repeat;`,"background-size: contain;"].join(" ");console.log("%c ",s)}destroy(){this._renderer=null}};de.extension={type:[n.Ag.WebGLSystem,n.Ag.WebGPUSystem],name:"extract"},de.defaultImageOptions={format:"png",quality:1};let ce=de;var le=r(9252),he=r(7269),pe=r(6932);class fe extends N.g{static create(e){return new N.g({source:new pe.v(e)})}resize(e,t,r){return this.source.resize(e,t,r),this}}const me=new le.M,ge=new H.c,xe=[0,0,0,0];class _e{constructor(e){this._renderer=e}generateTexture(e){e instanceof p.mc&&(e={target:e,frame:void 0,textureSourceOptions:{},resolution:void 0});const t=e.resolution||this._renderer.resolution,r=e.antialias||this._renderer.view.antialias,n=e.target;let s=e.clearColor;s=s?Array.isArray(s)&&4===s.length?s:re.Q.shared.setValue(s).toArray():xe;const i=e.frame?.copyTo(me)||(0,he.n)(n,ge).rectangle;i.width=0|Math.max(i.width,1/t),i.height=0|Math.max(i.height,1/t);const o=fe.create({...e.textureSourceOptions,width:i.width,height:i.height,resolution:t,antialias:r}),u=a.u.shared.translate(-i.x,-i.y);return this._renderer.render({container:n,transform:u,target:o,clearColor:s}),o.source.updateMipmaps(),o}destroy(){this._renderer=null}}_e.extension={type:[n.Ag.WebGLSystem,n.Ag.WebGPUSystem],name:"textureGenerator"};var be=r(5101),ve=r(2760),ye=r(3513);class Te{constructor(e){this._stackIndex=0,this._globalUniformDataStack=[],this._uniformsPool=[],this._activeUniforms=[],this._bindGroupPool=[],this._activeBindGroups=[],this._renderer=e}reset(){this._stackIndex=0;for(let e=0;e<this._activeUniforms.length;e++)this._uniformsPool.push(this._activeUniforms[e]);for(let e=0;e<this._activeBindGroups.length;e++)this._bindGroupPool.push(this._activeBindGroups[e]);this._activeUniforms.length=0,this._activeBindGroups.length=0}start(e){this.reset(),this.push(e)}bind({size:e,projectionMatrix:t,worldTransformMatrix:r,worldColor:n,offset:s}){const i=this._renderer.renderTarget.renderTarget,o=this._stackIndex?this._globalUniformDataStack[this._stackIndex-1]:{projectionData:i,worldTransformMatrix:new a.u,worldColor:4294967295,offset:new be.b},u={projectionMatrix:t||this._renderer.renderTarget.projectionMatrix,resolution:e||i.size,worldTransformMatrix:r||o.worldTransformMatrix,worldColor:n||o.worldColor,offset:s||o.offset,bindGroup:null},d=this._uniformsPool.pop()||this._createUniforms();this._activeUniforms.push(d);const c=d.uniforms;let l;c.uProjectionMatrix=u.projectionMatrix,c.uResolution=u.resolution,c.uWorldTransformMatrix.copyFrom(u.worldTransformMatrix),c.uWorldTransformMatrix.tx-=u.offset.x,c.uWorldTransformMatrix.ty-=u.offset.y,(0,ve.V)(u.worldColor,c.uWorldColorAlpha,0),d.update(),this._renderer.renderPipes.uniformBatch?l=this._renderer.renderPipes.uniformBatch.getUniformBindGroup(d,!1):(l=this._bindGroupPool.pop()||new ye.T,this._activeBindGroups.push(l),l.setResource(d,0)),u.bindGroup=l,this._currentGlobalUniformData=u}push(e){this.bind(e),this._globalUniformDataStack[this._stackIndex++]=this._currentGlobalUniformData}pop(){this._currentGlobalUniformData=this._globalUniformDataStack[--this._stackIndex-1],this._renderer.type===Y.W.WEBGL&&this._currentGlobalUniformData.bindGroup.resources[0].update()}get bindGroup(){return this._currentGlobalUniformData.bindGroup}get uniformGroup(){return this._currentGlobalUniformData.bindGroup.resources[0]}_createUniforms(){return new I.k({uProjectionMatrix:{value:new a.u,type:"mat3x3<f32>"},uWorldTransformMatrix:{value:new a.u,type:"mat3x3<f32>"},uWorldColorAlpha:{value:new Float32Array(4),type:"vec4<f32>"},uResolution:{value:[0,0],type:"vec2<f32>"}},{isStatic:!0})}destroy(){this._renderer=null}}Te.extension={type:[n.Ag.WebGLSystem,n.Ag.WebGPUSystem,n.Ag.CanvasSystem],name:"globalUniforms"};var Se=r(1761);let Pe=!1;const we="8.2.6";class Me{constructor(e){this._renderer=e}init(e){if(e.hello){let e=this._renderer.name;this._renderer.type===Y.W.WEBGL&&(e+=` ${this._renderer.context.webGLVersion}`),function(e){if(!Pe){if(Se.e.get().getNavigator().userAgent.toLowerCase().indexOf("chrome")>-1){const t=[`%c  %c  %c  %c  %c PixiJS %c v${we} (${e}) http://www.pixijs.com/\n\n`,"background: #E72264; padding:5px 0;","background: #6CA2EA; padding:5px 0;","background: #B5D33D; padding:5px 0;","background: #FED23F; padding:5px 0;","color: #FFFFFF; background: #E72264; padding:5px 0;","color: #E72264; background: #FFFFFF; padding:5px 0;"];globalThis.console.log(...t)}else globalThis.console&&globalThis.console.log(`PixiJS ${we} - ${e} - http://www.pixijs.com/`);Pe=!0}}(e)}}}Me.extension={type:[n.Ag.WebGLSystem,n.Ag.WebGPUSystem,n.Ag.CanvasSystem],name:"hello",priority:-2},Me.defaultOptions={hello:!1};const Ce=class e{constructor(e){this._renderer=e,this.count=0,this.checkCount=0}init(t){t={...e.defaultOptions,...t},this.checkCountMax=t.textureGCCheckCountMax,this.maxIdle=t.textureGCAMaxIdle,this.active=t.textureGCActive}postrender(){this._renderer.renderingToScreen&&(this.count++,this.active&&(this.checkCount++,this.checkCount>this.checkCountMax&&(this.checkCount=0,this.run())))}run(){const e=this._renderer.texture.managedTextures;for(let t=0;t<e.length;t++){const r=e[t];r.autoGarbageCollect&&r.resource&&r._touched>-1&&this.count-r._touched>this.maxIdle&&(r._touched=-1,r.unload())}}destroy(){this._renderer=null}};Ce.extension={type:[n.Ag.WebGLSystem,n.Ag.WebGPUSystem],name:"textureGC"},Ce.defaultOptions={textureGCActive:!0,textureGCAMaxIdle:3600,textureGCCheckCountMax:600};let Ge=Ce;n.XO.add(Ge);var Be=r(4670),ke=r(279),Ae=r(8725);const Ue=class e{get resolution(){return this.texture.source._resolution}set resolution(e){this.texture.source.resize(this.texture.source.width,this.texture.source.height,e)}init(t){(t={...e.defaultOptions,...t}).view&&((0,Be.t)(Be.l,"ViewSystem.view has been renamed to ViewSystem.canvas"),t.canvas=t.view),this.screen=new le.M(0,0,t.width,t.height),this.canvas=t.canvas||Se.e.get().createCanvas(),this.antialias=!!t.antialias,this.texture=(0,Ae.c)(this.canvas,t),this.renderTarget=new ke.O({colorTextures:[this.texture],depth:!!t.depth,isRoot:!0}),this.texture.source.transparent=t.backgroundAlpha<1,this.multiView=!!t.multiView,this.autoDensity&&(this.canvas.style.width=`${this.texture.width}px`,this.canvas.style.height=`${this.texture.height}px`),this.resolution=t.resolution}resize(e,t,r){this.texture.source.resize(e,t,r),this.screen.width=this.texture.frame.width,this.screen.height=this.texture.frame.height,this.autoDensity&&(this.canvas.style.width=`${e}px`,this.canvas.style.height=`${t}px`)}destroy(e=!1){("boolean"==typeof e?e:e?.removeView)&&this.canvas.parentNode&&this.canvas.parentNode.removeChild(this.canvas)}};Ue.extension={type:[n.Ag.WebGLSystem,n.Ag.WebGPUSystem,n.Ag.CanvasSystem],name:"view",priority:0},Ue.defaultOptions={width:800,height:600,autoDensity:!1,antialias:!1};const Re=[se,Te,Me,Ue,S,Ge,_e,ce,G.d],Ee=[ae,U,C,o,Q,te,Z,s]},7608:(e,t,r)=>{r.d(t,{N:()=>i});var n=r(1761),s=r(9939);const i=new class{constructor(e){this._canvasPool=Object.create(null),this.canvasOptions=e||{},this.enableFullScreen=!1}_createCanvasAndContext(e,t){const r=n.e.get().createCanvas();r.width=e,r.height=t;const s=r.getContext("2d");return{canvas:r,context:s}}getOptimalCanvasAndContext(e,t,r=1){e=Math.ceil(e*r-1e-6),t=Math.ceil(t*r-1e-6);const n=((e=(0,s.U5)(e))<<17)+((t=(0,s.U5)(t))<<1);this._canvasPool[n]||(this._canvasPool[n]=[]);let i=this._canvasPool[n].pop();return i||(i=this._createCanvasAndContext(e,t)),i}returnCanvasAndContext(e){const t=e.canvas,{width:r,height:n}=t,s=(r<<17)+(n<<1);this._canvasPool[s].push(e)}clear(){this._canvasPool={}}}},2437:(e,t,r)=>{r.d(t,{W:()=>a});var n=r(9939),s=r(6932),i=r(4492);let o=0;const a=new class{constructor(e){this._poolKeyHash=Object.create(null),this._texturePool={},this.textureOptions=e||{},this.enableFullScreen=!1}createTexture(e,t,r){const n=new s.v({...this.textureOptions,width:e,height:t,resolution:1,antialias:r,autoGarbageCollect:!0});return new i.g({source:n,label:"texturePool_"+o++})}getOptimalTexture(e,t,r=1,s){let i=Math.ceil(e*r-1e-6),o=Math.ceil(t*r-1e-6);i=(0,n.U5)(i),o=(0,n.U5)(o);const a=(i<<17)+(o<<1)+(s?1:0);this._texturePool[a]||(this._texturePool[a]=[]);let u=this._texturePool[a].pop();return u||(u=this.createTexture(i,o,s)),u.source._resolution=r,u.source.width=i/r,u.source.height=o/r,u.source.pixelWidth=i,u.source.pixelHeight=o,u.frame.x=0,u.frame.y=0,u.frame.width=e,u.frame.height=t,u.updateUvs(),this._poolKeyHash[u.uid]=a,u}getSameSizeTexture(e,t=!1){const r=e.source;return this.getOptimalTexture(e.width,e.height,r._resolution,t)}returnTexture(e){const t=this._poolKeyHash[e.uid];this._texturePool[t].push(e)}clear(e){if(e=!1!==e)for(const e in this._texturePool){const t=this._texturePool[e];if(t)for(let e=0;e<t.length;e++)t[e].destroy(!0)}this._texturePool={}}}},8725:(e,t,r)=>{r.d(t,{c:()=>o});var n=r(4884),s=r(4492);const i=new Map;function o(e,t){if(!i.has(e)){const r=new s.g({source:new n.q({resource:e,...t})}),o=()=>{i.get(e)===r&&i.delete(e)};r.once("destroy",o),r.source.once("destroy",o),i.set(e,r)}return i.get(e)}},7952:(e,t,r)=>{r.d(t,{X:()=>i});const n=Object.create(null),s=Object.create(null);function i(e,t){let r=s[e];return void 0===r&&(void 0===n[t]&&(n[t]=1),s[e]=r=n[t]++),r}},5099:(e,t,r)=>{r.d(t,{W:()=>n});var n=(e=>(e[e.WEBGL=1]="WEBGL",e[e.WEBGPU=2]="WEBGPU",e[e.BOTH=3]="BOTH",e))(n||{})},2760:(e,t,r)=>{function n(e,t,r){const n=(e>>24&255)/255;t[r++]=(255&e)/255*n,t[r++]=(e>>8&255)/255*n,t[r++]=(e>>16&255)/255*n,t[r++]=n}r.d(t,{V:()=>n})},8422:(e,t,r)=>{r.d(t,{K:()=>n});class n{constructor(){this.vertexSize=4,this.indexSize=6,this.location=0,this.batcher=null,this.batch=null,this.roundPixels=0}get blendMode(){return this.renderable.groupBlendMode}packAttributes(e,t,r,n){const s=this.renderable,i=this.texture,o=s.groupTransform,a=o.a,u=o.b,d=o.c,c=o.d,l=o.tx,h=o.ty,p=this.bounds,f=p.maxX,m=p.minX,g=p.maxY,x=p.minY,_=i.uvs,b=s.groupColorAlpha,v=n<<16|65535&this.roundPixels;e[r+0]=a*m+d*x+l,e[r+1]=c*x+u*m+h,e[r+2]=_.x0,e[r+3]=_.y0,t[r+4]=b,t[r+5]=v,e[r+6]=a*f+d*x+l,e[r+7]=c*x+u*f+h,e[r+8]=_.x1,e[r+9]=_.y1,t[r+10]=b,t[r+11]=v,e[r+12]=a*f+d*g+l,e[r+13]=c*g+u*f+h,e[r+14]=_.x2,e[r+15]=_.y2,t[r+16]=b,t[r+17]=v,e[r+18]=a*m+d*g+l,e[r+19]=c*g+u*m+h,e[r+20]=_.x3,e[r+21]=_.y3,t[r+22]=b,t[r+23]=v}packIndex(e,t,r){e[t]=r+0,e[t+1]=r+1,e[t+2]=r+2,e[t+3]=r+0,e[t+4]=r+2,e[t+5]=r+3}reset(){this.renderable=null,this.texture=null,this.batcher=null,this.batch=null,this.bounds=null}}}}]);