const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./browserAll-Bu47FzQx.js","./init-DdCadALS.js","./webworkerAll-2uI2OSlm.js"])))=>i.map(i=>d[i]);
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
let T_, dx, Dt, dw, pR, X0, Zf, K0, Z0, bg, wg, Q3, Bh, Ex, vx, Mt, fx, ox, Dw, Aw;
let __tla = (async () => {
  (function() {
    const t = document.createElement("link").relList;
    if (t && t.supports && t.supports("modulepreload")) return;
    for (const s of document.querySelectorAll('link[rel="modulepreload"]')) r(s);
    new MutationObserver((s) => {
      for (const n of s) if (n.type === "childList") for (const o of n.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && r(o);
    }).observe(document, {
      childList: true,
      subtree: true
    });
    function e(s) {
      const n = {};
      return s.integrity && (n.integrity = s.integrity), s.referrerPolicy && (n.referrerPolicy = s.referrerPolicy), s.crossOrigin === "use-credentials" ? n.credentials = "include" : s.crossOrigin === "anonymous" ? n.credentials = "omit" : n.credentials = "same-origin", n;
    }
    function r(s) {
      if (s.ep) return;
      s.ep = true;
      const n = e(s);
      fetch(s.href, n);
    }
  })();
  const xp = "modulepreload", vp = function(i, t) {
    return new URL(i, t).href;
  }, tc = {}, Cs = function(t, e, r) {
    let s = Promise.resolve();
    if (e && e.length > 0) {
      let o = function(u) {
        return Promise.all(u.map((h) => Promise.resolve(h).then((d) => ({
          status: "fulfilled",
          value: d
        }), (d) => ({
          status: "rejected",
          reason: d
        }))));
      };
      const a = document.getElementsByTagName("link"), c = document.querySelector("meta[property=csp-nonce]"), l = (c == null ? void 0 : c.nonce) || (c == null ? void 0 : c.getAttribute("nonce"));
      s = o(e.map((u) => {
        if (u = vp(u, r), u in tc) return;
        tc[u] = true;
        const h = u.endsWith(".css"), d = h ? '[rel="stylesheet"]' : "";
        if (!!r) for (let y = a.length - 1; y >= 0; y--) {
          const m = a[y];
          if (m.href === u && (!h || m.rel === "stylesheet")) return;
        }
        else if (document.querySelector(`link[href="${u}"]${d}`)) return;
        const g = document.createElement("link");
        if (g.rel = h ? "stylesheet" : xp, h || (g.as = "script"), g.crossOrigin = "", g.href = u, l && g.setAttribute("nonce", l), document.head.appendChild(g), h) return new Promise((y, m) => {
          g.addEventListener("load", y), g.addEventListener("error", () => m(new Error(`Unable to preload CSS for ${u}`)));
        });
      }));
    }
    function n(o) {
      const a = new Event("vite:preloadError", {
        cancelable: true
      });
      if (a.payload = o, window.dispatchEvent(a), !a.defaultPrevented) throw o;
    }
    return s.then((o) => {
      for (const a of o || []) a.status === "rejected" && n(a.reason);
      return t().catch(n);
    });
  };
  var P = ((i) => (i.Application = "application", i.WebGLPipes = "webgl-pipes", i.WebGLPipesAdaptor = "webgl-pipes-adaptor", i.WebGLSystem = "webgl-system", i.WebGPUPipes = "webgpu-pipes", i.WebGPUPipesAdaptor = "webgpu-pipes-adaptor", i.WebGPUSystem = "webgpu-system", i.CanvasSystem = "canvas-system", i.CanvasPipesAdaptor = "canvas-pipes-adaptor", i.CanvasPipes = "canvas-pipes", i.Asset = "asset", i.LoadParser = "load-parser", i.ResolveParser = "resolve-parser", i.CacheParser = "cache-parser", i.DetectionParser = "detection-parser", i.MaskEffect = "mask-effect", i.BlendMode = "blend-mode", i.TextureSource = "texture-source", i.Environment = "environment", i.ShapeBuilder = "shape-builder", i))(P || {});
  let bo, Vi, Sp, Ep;
  bo = (i) => {
    if (typeof i == "function" || typeof i == "object" && i.extension) {
      if (!i.extension) throw new Error("Extension class must have an extension object");
      i = {
        ...typeof i.extension != "object" ? {
          type: i.extension
        } : i.extension,
        ref: i
      };
    }
    if (typeof i == "object") i = {
      ...i
    };
    else throw new Error("Invalid extension type");
    return typeof i.type == "string" && (i.type = [
      i.type
    ]), i;
  };
  Vi = (i, t) => bo(i).priority ?? t;
  Mt = {
    _addHandlers: {},
    _removeHandlers: {},
    _queue: {},
    remove(...i) {
      return i.map(bo).forEach((t) => {
        t.type.forEach((e) => {
          var _a2, _b2;
          return (_b2 = (_a2 = this._removeHandlers)[e]) == null ? void 0 : _b2.call(_a2, t);
        });
      }), this;
    },
    add(...i) {
      return i.map(bo).forEach((t) => {
        t.type.forEach((e) => {
          var _a2, _b2;
          const r = this._addHandlers, s = this._queue;
          r[e] ? (_a2 = r[e]) == null ? void 0 : _a2.call(r, t) : (s[e] = s[e] || [], (_b2 = s[e]) == null ? void 0 : _b2.push(t));
        });
      }), this;
    },
    handle(i, t, e) {
      var _a2;
      const r = this._addHandlers, s = this._removeHandlers;
      if (r[i] || s[i]) throw new Error(`Extension type ${i} already has a handler`);
      r[i] = t, s[i] = e;
      const n = this._queue;
      return n[i] && ((_a2 = n[i]) == null ? void 0 : _a2.forEach((o) => t(o)), delete n[i]), this;
    },
    handleByMap(i, t) {
      return this.handle(i, (e) => {
        e.name && (t[e.name] = e.ref);
      }, (e) => {
        e.name && delete t[e.name];
      });
    },
    handleByNamedList(i, t, e = -1) {
      return this.handle(i, (r) => {
        t.findIndex((n) => n.name === r.name) >= 0 || (t.push({
          name: r.name,
          value: r.ref
        }), t.sort((n, o) => Vi(o.value, e) - Vi(n.value, e)));
      }, (r) => {
        const s = t.findIndex((n) => n.name === r.name);
        s !== -1 && t.splice(s, 1);
      });
    },
    handleByList(i, t, e = -1) {
      return this.handle(i, (r) => {
        t.includes(r.ref) || (t.push(r.ref), t.sort((s, n) => Vi(n, e) - Vi(s, e)));
      }, (r) => {
        const s = t.indexOf(r.ref);
        s !== -1 && t.splice(s, 1);
      });
    }
  };
  Sp = {
    extension: {
      type: P.Environment,
      name: "browser",
      priority: -1
    },
    test: () => true,
    load: async () => {
      await Cs(() => import("./browserAll-Bu47FzQx.js").then(async (m) => {
        await m.__tla;
        return m;
      }), __vite__mapDeps([0,1]), import.meta.url);
    }
  };
  Ep = {
    extension: {
      type: P.Environment,
      name: "webworker",
      priority: 0
    },
    test: () => typeof self < "u" && self.WorkerGlobalScope !== void 0,
    load: async () => {
      await Cs(() => import("./webworkerAll-2uI2OSlm.js").then(async (m) => {
        await m.__tla;
        return m;
      }), __vite__mapDeps([2,1]), import.meta.url);
    }
  };
  class Xt {
    constructor(t, e, r) {
      this._x = e || 0, this._y = r || 0, this._observer = t;
    }
    clone(t) {
      return new Xt(t ?? this._observer, this._x, this._y);
    }
    set(t = 0, e = t) {
      return (this._x !== t || this._y !== e) && (this._x = t, this._y = e, this._observer._onUpdate(this)), this;
    }
    copyFrom(t) {
      return (this._x !== t.x || this._y !== t.y) && (this._x = t.x, this._y = t.y, this._observer._onUpdate(this)), this;
    }
    copyTo(t) {
      return t.set(this._x, this._y), t;
    }
    equals(t) {
      return t.x === this._x && t.y === this._y;
    }
    toString() {
      return `[pixi.js/math:ObservablePoint x=0 y=0 scope=${this._observer}]`;
    }
    get x() {
      return this._x;
    }
    set x(t) {
      this._x !== t && (this._x = t, this._observer._onUpdate(this));
    }
    get y() {
      return this._y;
    }
    set y(t) {
      this._y !== t && (this._y = t, this._observer._onUpdate(this));
    }
  }
  function Vs(i) {
    return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
  }
  var xs = {
    exports: {}
  }, Z3 = xs.exports, ec;
  function Tp() {
    return ec || (ec = 1, function(i) {
      "use strict";
      var t = Object.prototype.hasOwnProperty, e = "~";
      function r() {
      }
      Object.create && (r.prototype = /* @__PURE__ */ Object.create(null), new r().__proto__ || (e = false));
      function s(c, l, u) {
        this.fn = c, this.context = l, this.once = u || false;
      }
      function n(c, l, u, h, d) {
        if (typeof u != "function") throw new TypeError("The listener must be a function");
        var p = new s(u, h || c, d), g = e ? e + l : l;
        return c._events[g] ? c._events[g].fn ? c._events[g] = [
          c._events[g],
          p
        ] : c._events[g].push(p) : (c._events[g] = p, c._eventsCount++), c;
      }
      function o(c, l) {
        --c._eventsCount === 0 ? c._events = new r() : delete c._events[l];
      }
      function a() {
        this._events = new r(), this._eventsCount = 0;
      }
      a.prototype.eventNames = function() {
        var l = [], u, h;
        if (this._eventsCount === 0) return l;
        for (h in u = this._events) t.call(u, h) && l.push(e ? h.slice(1) : h);
        return Object.getOwnPropertySymbols ? l.concat(Object.getOwnPropertySymbols(u)) : l;
      }, a.prototype.listeners = function(l) {
        var u = e ? e + l : l, h = this._events[u];
        if (!h) return [];
        if (h.fn) return [
          h.fn
        ];
        for (var d = 0, p = h.length, g = new Array(p); d < p; d++) g[d] = h[d].fn;
        return g;
      }, a.prototype.listenerCount = function(l) {
        var u = e ? e + l : l, h = this._events[u];
        return h ? h.fn ? 1 : h.length : 0;
      }, a.prototype.emit = function(l, u, h, d, p, g) {
        var y = e ? e + l : l;
        if (!this._events[y]) return false;
        var m = this._events[y], v = arguments.length, S, C;
        if (m.fn) {
          switch (m.once && this.removeListener(l, m.fn, void 0, true), v) {
            case 1:
              return m.fn.call(m.context), true;
            case 2:
              return m.fn.call(m.context, u), true;
            case 3:
              return m.fn.call(m.context, u, h), true;
            case 4:
              return m.fn.call(m.context, u, h, d), true;
            case 5:
              return m.fn.call(m.context, u, h, d, p), true;
            case 6:
              return m.fn.call(m.context, u, h, d, p, g), true;
          }
          for (C = 1, S = new Array(v - 1); C < v; C++) S[C - 1] = arguments[C];
          m.fn.apply(m.context, S);
        } else {
          var G = m.length, H;
          for (C = 0; C < G; C++) switch (m[C].once && this.removeListener(l, m[C].fn, void 0, true), v) {
            case 1:
              m[C].fn.call(m[C].context);
              break;
            case 2:
              m[C].fn.call(m[C].context, u);
              break;
            case 3:
              m[C].fn.call(m[C].context, u, h);
              break;
            case 4:
              m[C].fn.call(m[C].context, u, h, d);
              break;
            default:
              if (!S) for (H = 1, S = new Array(v - 1); H < v; H++) S[H - 1] = arguments[H];
              m[C].fn.apply(m[C].context, S);
          }
        }
        return true;
      }, a.prototype.on = function(l, u, h) {
        return n(this, l, u, h, false);
      }, a.prototype.once = function(l, u, h) {
        return n(this, l, u, h, true);
      }, a.prototype.removeListener = function(l, u, h, d) {
        var p = e ? e + l : l;
        if (!this._events[p]) return this;
        if (!u) return o(this, p), this;
        var g = this._events[p];
        if (g.fn) g.fn === u && (!d || g.once) && (!h || g.context === h) && o(this, p);
        else {
          for (var y = 0, m = [], v = g.length; y < v; y++) (g[y].fn !== u || d && !g[y].once || h && g[y].context !== h) && m.push(g[y]);
          m.length ? this._events[p] = m.length === 1 ? m[0] : m : o(this, p);
        }
        return this;
      }, a.prototype.removeAllListeners = function(l) {
        var u;
        return l ? (u = e ? e + l : l, this._events[u] && o(this, u)) : (this._events = new r(), this._eventsCount = 0), this;
      }, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = e, a.EventEmitter = a, i.exports = a;
    }(xs)), xs.exports;
  }
  var Cp = Tp();
  const me = Vs(Cp), Ap = Math.PI * 2, Rp = 180 / Math.PI, Pp = Math.PI / 180;
  class At {
    constructor(t = 0, e = 0) {
      this.x = 0, this.y = 0, this.x = t, this.y = e;
    }
    clone() {
      return new At(this.x, this.y);
    }
    copyFrom(t) {
      return this.set(t.x, t.y), this;
    }
    copyTo(t) {
      return t.set(this.x, this.y), t;
    }
    equals(t) {
      return t.x === this.x && t.y === this.y;
    }
    set(t = 0, e = t) {
      return this.x = t, this.y = e, this;
    }
    toString() {
      return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;
    }
    static get shared() {
      return Tn.x = 0, Tn.y = 0, Tn;
    }
  }
  const Tn = new At();
  class st {
    constructor(t = 1, e = 0, r = 0, s = 1, n = 0, o = 0) {
      this.array = null, this.a = t, this.b = e, this.c = r, this.d = s, this.tx = n, this.ty = o;
    }
    fromArray(t) {
      this.a = t[0], this.b = t[1], this.c = t[3], this.d = t[4], this.tx = t[2], this.ty = t[5];
    }
    set(t, e, r, s, n, o) {
      return this.a = t, this.b = e, this.c = r, this.d = s, this.tx = n, this.ty = o, this;
    }
    toArray(t, e) {
      this.array || (this.array = new Float32Array(9));
      const r = e || this.array;
      return t ? (r[0] = this.a, r[1] = this.b, r[2] = 0, r[3] = this.c, r[4] = this.d, r[5] = 0, r[6] = this.tx, r[7] = this.ty, r[8] = 1) : (r[0] = this.a, r[1] = this.c, r[2] = this.tx, r[3] = this.b, r[4] = this.d, r[5] = this.ty, r[6] = 0, r[7] = 0, r[8] = 1), r;
    }
    apply(t, e) {
      e = e || new At();
      const r = t.x, s = t.y;
      return e.x = this.a * r + this.c * s + this.tx, e.y = this.b * r + this.d * s + this.ty, e;
    }
    applyInverse(t, e) {
      e = e || new At();
      const r = this.a, s = this.b, n = this.c, o = this.d, a = this.tx, c = this.ty, l = 1 / (r * o + n * -s), u = t.x, h = t.y;
      return e.x = o * l * u + -n * l * h + (c * n - a * o) * l, e.y = r * l * h + -s * l * u + (-c * r + a * s) * l, e;
    }
    translate(t, e) {
      return this.tx += t, this.ty += e, this;
    }
    scale(t, e) {
      return this.a *= t, this.d *= e, this.c *= t, this.b *= e, this.tx *= t, this.ty *= e, this;
    }
    rotate(t) {
      const e = Math.cos(t), r = Math.sin(t), s = this.a, n = this.c, o = this.tx;
      return this.a = s * e - this.b * r, this.b = s * r + this.b * e, this.c = n * e - this.d * r, this.d = n * r + this.d * e, this.tx = o * e - this.ty * r, this.ty = o * r + this.ty * e, this;
    }
    append(t) {
      const e = this.a, r = this.b, s = this.c, n = this.d;
      return this.a = t.a * e + t.b * s, this.b = t.a * r + t.b * n, this.c = t.c * e + t.d * s, this.d = t.c * r + t.d * n, this.tx = t.tx * e + t.ty * s + this.tx, this.ty = t.tx * r + t.ty * n + this.ty, this;
    }
    appendFrom(t, e) {
      const r = t.a, s = t.b, n = t.c, o = t.d, a = t.tx, c = t.ty, l = e.a, u = e.b, h = e.c, d = e.d;
      return this.a = r * l + s * h, this.b = r * u + s * d, this.c = n * l + o * h, this.d = n * u + o * d, this.tx = a * l + c * h + e.tx, this.ty = a * u + c * d + e.ty, this;
    }
    setTransform(t, e, r, s, n, o, a, c, l) {
      return this.a = Math.cos(a + l) * n, this.b = Math.sin(a + l) * n, this.c = -Math.sin(a - c) * o, this.d = Math.cos(a - c) * o, this.tx = t - (r * this.a + s * this.c), this.ty = e - (r * this.b + s * this.d), this;
    }
    prepend(t) {
      const e = this.tx;
      if (t.a !== 1 || t.b !== 0 || t.c !== 0 || t.d !== 1) {
        const r = this.a, s = this.c;
        this.a = r * t.a + this.b * t.c, this.b = r * t.b + this.b * t.d, this.c = s * t.a + this.d * t.c, this.d = s * t.b + this.d * t.d;
      }
      return this.tx = e * t.a + this.ty * t.c + t.tx, this.ty = e * t.b + this.ty * t.d + t.ty, this;
    }
    decompose(t) {
      const e = this.a, r = this.b, s = this.c, n = this.d, o = t.pivot, a = -Math.atan2(-s, n), c = Math.atan2(r, e), l = Math.abs(a + c);
      return l < 1e-5 || Math.abs(Ap - l) < 1e-5 ? (t.rotation = c, t.skew.x = t.skew.y = 0) : (t.rotation = 0, t.skew.x = a, t.skew.y = c), t.scale.x = Math.sqrt(e * e + r * r), t.scale.y = Math.sqrt(s * s + n * n), t.position.x = this.tx + (o.x * e + o.y * s), t.position.y = this.ty + (o.x * r + o.y * n), t;
    }
    invert() {
      const t = this.a, e = this.b, r = this.c, s = this.d, n = this.tx, o = t * s - e * r;
      return this.a = s / o, this.b = -e / o, this.c = -r / o, this.d = t / o, this.tx = (r * this.ty - s * n) / o, this.ty = -(t * this.ty - e * n) / o, this;
    }
    isIdentity() {
      return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;
    }
    identity() {
      return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this;
    }
    clone() {
      const t = new st();
      return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t;
    }
    copyTo(t) {
      return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t;
    }
    copyFrom(t) {
      return this.a = t.a, this.b = t.b, this.c = t.c, this.d = t.d, this.tx = t.tx, this.ty = t.ty, this;
    }
    equals(t) {
      return t.a === this.a && t.b === this.b && t.c === this.c && t.d === this.d && t.tx === this.tx && t.ty === this.ty;
    }
    toString() {
      return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
    }
    static get IDENTITY() {
      return Mp.identity();
    }
    static get shared() {
      return Bp.identity();
    }
  }
  const Bp = new st(), Mp = new st(), Er = [
    1,
    1,
    0,
    -1,
    -1,
    -1,
    0,
    1,
    1,
    1,
    0,
    -1,
    -1,
    -1,
    0,
    1
  ], Tr = [
    0,
    1,
    1,
    1,
    0,
    -1,
    -1,
    -1,
    0,
    1,
    1,
    1,
    0,
    -1,
    -1,
    -1
  ], Cr = [
    0,
    -1,
    -1,
    -1,
    0,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    0,
    -1,
    -1,
    -1
  ], Ar = [
    1,
    1,
    0,
    -1,
    -1,
    -1,
    0,
    1,
    -1,
    -1,
    0,
    1,
    1,
    1,
    0,
    -1
  ], wo = [], Bl = [], Xi = Math.sign;
  function Dp() {
    for (let i = 0; i < 16; i++) {
      const t = [];
      wo.push(t);
      for (let e = 0; e < 16; e++) {
        const r = Xi(Er[i] * Er[e] + Cr[i] * Tr[e]), s = Xi(Tr[i] * Er[e] + Ar[i] * Tr[e]), n = Xi(Er[i] * Cr[e] + Cr[i] * Ar[e]), o = Xi(Tr[i] * Cr[e] + Ar[i] * Ar[e]);
        for (let a = 0; a < 16; a++) if (Er[a] === r && Tr[a] === s && Cr[a] === n && Ar[a] === o) {
          t.push(a);
          break;
        }
      }
    }
    for (let i = 0; i < 16; i++) {
      const t = new st();
      t.set(Er[i], Tr[i], Cr[i], Ar[i], 0, 0), Bl.push(t);
    }
  }
  Dp();
  const kt = {
    E: 0,
    SE: 1,
    S: 2,
    SW: 3,
    W: 4,
    NW: 5,
    N: 6,
    NE: 7,
    MIRROR_VERTICAL: 8,
    MAIN_DIAGONAL: 10,
    MIRROR_HORIZONTAL: 12,
    REVERSE_DIAGONAL: 14,
    uX: (i) => Er[i],
    uY: (i) => Tr[i],
    vX: (i) => Cr[i],
    vY: (i) => Ar[i],
    inv: (i) => i & 8 ? i & 15 : -i & 7,
    add: (i, t) => wo[i][t],
    sub: (i, t) => wo[i][kt.inv(t)],
    rotate180: (i) => i ^ 4,
    isVertical: (i) => (i & 3) === 2,
    byDirection: (i, t) => Math.abs(i) * 2 <= Math.abs(t) ? t >= 0 ? kt.S : kt.N : Math.abs(t) * 2 <= Math.abs(i) ? i > 0 ? kt.E : kt.W : t > 0 ? i > 0 ? kt.SE : kt.SW : i > 0 ? kt.NE : kt.NW,
    matrixAppendRotationInv: (i, t, e = 0, r = 0) => {
      const s = Bl[kt.inv(t)];
      s.tx = e, s.ty = r, i.append(s);
    }
  }, qi = [
    new At(),
    new At(),
    new At(),
    new At()
  ];
  class Et {
    constructor(t = 0, e = 0, r = 0, s = 0) {
      this.type = "rectangle", this.x = Number(t), this.y = Number(e), this.width = Number(r), this.height = Number(s);
    }
    get left() {
      return this.x;
    }
    get right() {
      return this.x + this.width;
    }
    get top() {
      return this.y;
    }
    get bottom() {
      return this.y + this.height;
    }
    isEmpty() {
      return this.left === this.right || this.top === this.bottom;
    }
    static get EMPTY() {
      return new Et(0, 0, 0, 0);
    }
    clone() {
      return new Et(this.x, this.y, this.width, this.height);
    }
    copyFromBounds(t) {
      return this.x = t.minX, this.y = t.minY, this.width = t.maxX - t.minX, this.height = t.maxY - t.minY, this;
    }
    copyFrom(t) {
      return this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height, this;
    }
    copyTo(t) {
      return t.copyFrom(this), t;
    }
    contains(t, e) {
      return this.width <= 0 || this.height <= 0 ? false : t >= this.x && t < this.x + this.width && e >= this.y && e < this.y + this.height;
    }
    strokeContains(t, e, r) {
      const { width: s, height: n } = this;
      if (s <= 0 || n <= 0) return false;
      const o = this.x, a = this.y, c = o - r / 2, l = o + s + r / 2, u = a - r / 2, h = a + n + r / 2, d = o + r / 2, p = o + s - r / 2, g = a + r / 2, y = a + n - r / 2;
      return t >= c && t <= l && e >= u && e <= h && !(t > d && t < p && e > g && e < y);
    }
    intersects(t, e) {
      if (!e) {
        const W = this.x < t.x ? t.x : this.x;
        if ((this.right > t.right ? t.right : this.right) <= W) return false;
        const I = this.y < t.y ? t.y : this.y;
        return (this.bottom > t.bottom ? t.bottom : this.bottom) > I;
      }
      const r = this.left, s = this.right, n = this.top, o = this.bottom;
      if (s <= r || o <= n) return false;
      const a = qi[0].set(t.left, t.top), c = qi[1].set(t.left, t.bottom), l = qi[2].set(t.right, t.top), u = qi[3].set(t.right, t.bottom);
      if (l.x <= a.x || c.y <= a.y) return false;
      const h = Math.sign(e.a * e.d - e.b * e.c);
      if (h === 0 || (e.apply(a, a), e.apply(c, c), e.apply(l, l), e.apply(u, u), Math.max(a.x, c.x, l.x, u.x) <= r || Math.min(a.x, c.x, l.x, u.x) >= s || Math.max(a.y, c.y, l.y, u.y) <= n || Math.min(a.y, c.y, l.y, u.y) >= o)) return false;
      const d = h * (c.y - a.y), p = h * (a.x - c.x), g = d * r + p * n, y = d * s + p * n, m = d * r + p * o, v = d * s + p * o;
      if (Math.max(g, y, m, v) <= d * a.x + p * a.y || Math.min(g, y, m, v) >= d * u.x + p * u.y) return false;
      const S = h * (a.y - l.y), C = h * (l.x - a.x), G = S * r + C * n, H = S * s + C * n, Y = S * r + C * o, L = S * s + C * o;
      return !(Math.max(G, H, Y, L) <= S * a.x + C * a.y || Math.min(G, H, Y, L) >= S * u.x + C * u.y);
    }
    pad(t = 0, e = t) {
      return this.x -= t, this.y -= e, this.width += t * 2, this.height += e * 2, this;
    }
    fit(t) {
      const e = Math.max(this.x, t.x), r = Math.min(this.x + this.width, t.x + t.width), s = Math.max(this.y, t.y), n = Math.min(this.y + this.height, t.y + t.height);
      return this.x = e, this.width = Math.max(r - e, 0), this.y = s, this.height = Math.max(n - s, 0), this;
    }
    ceil(t = 1, e = 1e-3) {
      const r = Math.ceil((this.x + this.width - e) * t) / t, s = Math.ceil((this.y + this.height - e) * t) / t;
      return this.x = Math.floor((this.x + e) * t) / t, this.y = Math.floor((this.y + e) * t) / t, this.width = r - this.x, this.height = s - this.y, this;
    }
    enlarge(t) {
      const e = Math.min(this.x, t.x), r = Math.max(this.x + this.width, t.x + t.width), s = Math.min(this.y, t.y), n = Math.max(this.y + this.height, t.y + t.height);
      return this.x = e, this.width = r - e, this.y = s, this.height = n - s, this;
    }
    getBounds(t) {
      return t = t || new Et(), t.copyFrom(this), t;
    }
    toString() {
      return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
    }
  }
  const Cn = {
    default: -1
  };
  function Ot(i = "default") {
    return Cn[i] === void 0 && (Cn[i] = -1), ++Cn[i];
  }
  const rc = {}, dt = "8.0.0";
  function lt(i, t, e = 3) {
    if (rc[t]) return;
    let r = new Error().stack;
    typeof r > "u" ? console.warn("PixiJS Deprecation Warning: ", `${t}
Deprecated since v${i}`) : (r = r.split(`
`).splice(e).join(`
`), console.groupCollapsed ? (console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", `${t}
Deprecated since v${i}`), console.warn(r), console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", `${t}
Deprecated since v${i}`), console.warn(r))), rc[t] = true;
  }
  const Ml = () => {
  };
  function Yr(i) {
    return i += i === 0 ? 1 : 0, --i, i |= i >>> 1, i |= i >>> 2, i |= i >>> 4, i |= i >>> 8, i |= i >>> 16, i + 1;
  }
  function ic(i) {
    return !(i & i - 1) && !!i;
  }
  function yo(i) {
    const t = {};
    for (const e in i) i[e] !== void 0 && (t[e] = i[e]);
    return t;
  }
  const sc = /* @__PURE__ */ Object.create(null);
  function Ip(i) {
    const t = sc[i];
    return t === void 0 && (sc[i] = Ot("resource")), t;
  }
  const Dl = class Il extends me {
    constructor(t = {}) {
      super(), this._resourceType = "textureSampler", this._touched = 0, this._maxAnisotropy = 1, this.destroyed = false, t = {
        ...Il.defaultOptions,
        ...t
      }, this.addressMode = t.addressMode, this.addressModeU = t.addressModeU ?? this.addressModeU, this.addressModeV = t.addressModeV ?? this.addressModeV, this.addressModeW = t.addressModeW ?? this.addressModeW, this.scaleMode = t.scaleMode, this.magFilter = t.magFilter ?? this.magFilter, this.minFilter = t.minFilter ?? this.minFilter, this.mipmapFilter = t.mipmapFilter ?? this.mipmapFilter, this.lodMinClamp = t.lodMinClamp, this.lodMaxClamp = t.lodMaxClamp, this.compare = t.compare, this.maxAnisotropy = t.maxAnisotropy ?? 1;
    }
    set addressMode(t) {
      this.addressModeU = t, this.addressModeV = t, this.addressModeW = t;
    }
    get addressMode() {
      return this.addressModeU;
    }
    set wrapMode(t) {
      lt(dt, "TextureStyle.wrapMode is now TextureStyle.addressMode"), this.addressMode = t;
    }
    get wrapMode() {
      return this.addressMode;
    }
    set scaleMode(t) {
      this.magFilter = t, this.minFilter = t, this.mipmapFilter = t;
    }
    get scaleMode() {
      return this.magFilter;
    }
    set maxAnisotropy(t) {
      this._maxAnisotropy = Math.min(t, 16), this._maxAnisotropy > 1 && (this.scaleMode = "linear");
    }
    get maxAnisotropy() {
      return this._maxAnisotropy;
    }
    get _resourceId() {
      return this._sharedResourceId || this._generateResourceId();
    }
    update() {
      this.emit("change", this), this._sharedResourceId = null;
    }
    _generateResourceId() {
      const t = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;
      return this._sharedResourceId = Ip(t), this._resourceId;
    }
    destroy() {
      this.destroyed = true, this.emit("destroy", this), this.emit("change", this), this.removeAllListeners();
    }
  };
  Dl.defaultOptions = {
    addressMode: "clamp-to-edge",
    scaleMode: "linear"
  };
  let Fp = Dl;
  const Fl = class Ul extends me {
    constructor(t = {}) {
      super(), this.options = t, this.uid = Ot("textureSource"), this._resourceType = "textureSource", this._resourceId = Ot("resource"), this.uploadMethodId = "unknown", this._resolution = 1, this.pixelWidth = 1, this.pixelHeight = 1, this.width = 1, this.height = 1, this.sampleCount = 1, this.mipLevelCount = 1, this.autoGenerateMipmaps = false, this.format = "rgba8unorm", this.dimension = "2d", this.antialias = false, this._touched = 0, this._batchTick = -1, this._textureBindLocation = -1, t = {
        ...Ul.defaultOptions,
        ...t
      }, this.label = t.label ?? "", this.resource = t.resource, this.autoGarbageCollect = t.autoGarbageCollect, this._resolution = t.resolution, t.width ? this.pixelWidth = t.width * this._resolution : this.pixelWidth = this.resource ? this.resourceWidth ?? 1 : 1, t.height ? this.pixelHeight = t.height * this._resolution : this.pixelHeight = this.resource ? this.resourceHeight ?? 1 : 1, this.width = this.pixelWidth / this._resolution, this.height = this.pixelHeight / this._resolution, this.format = t.format, this.dimension = t.dimensions, this.mipLevelCount = t.mipLevelCount, this.autoGenerateMipmaps = t.autoGenerateMipmaps, this.sampleCount = t.sampleCount, this.antialias = t.antialias, this.alphaMode = t.alphaMode, this.style = new Fp(yo(t)), this.destroyed = false, this._refreshPOT();
    }
    get source() {
      return this;
    }
    get style() {
      return this._style;
    }
    set style(t) {
      var _a2, _b2;
      this.style !== t && ((_a2 = this._style) == null ? void 0 : _a2.off("change", this._onStyleChange, this), this._style = t, (_b2 = this._style) == null ? void 0 : _b2.on("change", this._onStyleChange, this), this._onStyleChange());
    }
    get addressMode() {
      return this._style.addressMode;
    }
    set addressMode(t) {
      this._style.addressMode = t;
    }
    get repeatMode() {
      return this._style.addressMode;
    }
    set repeatMode(t) {
      this._style.addressMode = t;
    }
    get magFilter() {
      return this._style.magFilter;
    }
    set magFilter(t) {
      this._style.magFilter = t;
    }
    get minFilter() {
      return this._style.minFilter;
    }
    set minFilter(t) {
      this._style.minFilter = t;
    }
    get mipmapFilter() {
      return this._style.mipmapFilter;
    }
    set mipmapFilter(t) {
      this._style.mipmapFilter = t;
    }
    get lodMinClamp() {
      return this._style.lodMinClamp;
    }
    set lodMinClamp(t) {
      this._style.lodMinClamp = t;
    }
    get lodMaxClamp() {
      return this._style.lodMaxClamp;
    }
    set lodMaxClamp(t) {
      this._style.lodMaxClamp = t;
    }
    _onStyleChange() {
      this.emit("styleChange", this);
    }
    update() {
      if (this.resource) {
        const t = this._resolution;
        if (this.resize(this.resourceWidth / t, this.resourceHeight / t)) return;
      }
      this.emit("update", this);
    }
    destroy() {
      this.destroyed = true, this.emit("destroy", this), this.emit("change", this), this._style && (this._style.destroy(), this._style = null), this.uploadMethodId = null, this.resource = null, this.removeAllListeners();
    }
    unload() {
      this._resourceId = Ot("resource"), this.emit("change", this), this.emit("unload", this);
    }
    get resourceWidth() {
      const { resource: t } = this;
      return t.naturalWidth || t.videoWidth || t.displayWidth || t.width;
    }
    get resourceHeight() {
      const { resource: t } = this;
      return t.naturalHeight || t.videoHeight || t.displayHeight || t.height;
    }
    get resolution() {
      return this._resolution;
    }
    set resolution(t) {
      this._resolution !== t && (this._resolution = t, this.width = this.pixelWidth / t, this.height = this.pixelHeight / t);
    }
    resize(t, e, r) {
      r = r || this._resolution, t = t || this.width, e = e || this.height;
      const s = Math.round(t * r), n = Math.round(e * r);
      return this.width = s / r, this.height = n / r, this._resolution = r, this.pixelWidth === s && this.pixelHeight === n ? false : (this._refreshPOT(), this.pixelWidth = s, this.pixelHeight = n, this.emit("resize", this), this._resourceId = Ot("resource"), this.emit("change", this), true);
    }
    updateMipmaps() {
      this.autoGenerateMipmaps && this.mipLevelCount > 1 && this.emit("updateMipmaps", this);
    }
    set wrapMode(t) {
      this._style.wrapMode = t;
    }
    get wrapMode() {
      return this._style.wrapMode;
    }
    set scaleMode(t) {
      this._style.scaleMode = t;
    }
    get scaleMode() {
      return this._style.scaleMode;
    }
    _refreshPOT() {
      this.isPowerOfTwo = ic(this.pixelWidth) && ic(this.pixelHeight);
    }
    static test(t) {
      throw new Error("Unimplemented");
    }
  };
  Fl.defaultOptions = {
    resolution: 1,
    format: "bgra8unorm",
    alphaMode: "premultiply-alpha-on-upload",
    dimensions: "2d",
    mipLevelCount: 1,
    autoGenerateMipmaps: false,
    sampleCount: 1,
    antialias: false,
    autoGarbageCollect: false
  };
  let Ht = Fl;
  class Zo extends Ht {
    constructor(t) {
      const e = t.resource || new Float32Array(t.width * t.height * 4);
      let r = t.format;
      r || (e instanceof Float32Array ? r = "rgba32float" : e instanceof Int32Array || e instanceof Uint32Array ? r = "rgba32uint" : e instanceof Int16Array || e instanceof Uint16Array ? r = "rgba16uint" : (e instanceof Int8Array, r = "bgra8unorm")), super({
        ...t,
        resource: e,
        format: r
      }), this.uploadMethodId = "buffer";
    }
    static test(t) {
      return t instanceof Int8Array || t instanceof Uint8Array || t instanceof Uint8ClampedArray || t instanceof Int16Array || t instanceof Uint16Array || t instanceof Int32Array || t instanceof Uint32Array || t instanceof Float32Array;
    }
  }
  Zo.extension = P.TextureSource;
  const nc = new st();
  class kl {
    constructor(t, e) {
      this.mapCoord = new st(), this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, typeof e > "u" ? this.clampMargin = t.width < 10 ? 0 : 0.5 : this.clampMargin = e, this.isSimple = false, this.texture = t;
    }
    get texture() {
      return this._texture;
    }
    set texture(t) {
      var _a2;
      this.texture !== t && ((_a2 = this._texture) == null ? void 0 : _a2.removeListener("update", this.update, this), this._texture = t, this._texture.addListener("update", this.update, this), this.update());
    }
    multiplyUvs(t, e) {
      e === void 0 && (e = t);
      const r = this.mapCoord;
      for (let s = 0; s < t.length; s += 2) {
        const n = t[s], o = t[s + 1];
        e[s] = n * r.a + o * r.c + r.tx, e[s + 1] = n * r.b + o * r.d + r.ty;
      }
      return e;
    }
    update() {
      const t = this._texture;
      this._updateID++;
      const e = t.uvs;
      this.mapCoord.set(e.x1 - e.x0, e.y1 - e.y0, e.x3 - e.x0, e.y3 - e.y0, e.x0, e.y0);
      const r = t.orig, s = t.trim;
      s && (nc.set(r.width / s.width, 0, 0, r.height / s.height, -s.x / s.width, -s.y / s.height), this.mapCoord.append(nc));
      const n = t.source, o = this.uClampFrame, a = this.clampMargin / n._resolution, c = this.clampOffset;
      return o[0] = (t.frame.x + a + c) / n.width, o[1] = (t.frame.y + a + c) / n.height, o[2] = (t.frame.x + t.frame.width - a + c) / n.width, o[3] = (t.frame.y + t.frame.height - a + c) / n.height, this.uClampOffset[0] = c / n.pixelWidth, this.uClampOffset[1] = c / n.pixelHeight, this.isSimple = t.frame.width === n.width && t.frame.height === n.height && t.rotate === 0, true;
    }
  }
  class Z extends me {
    constructor({ source: t, label: e, frame: r, orig: s, trim: n, defaultAnchor: o, defaultBorders: a, rotate: c, dynamic: l } = {}) {
      if (super(), this.uid = Ot("texture"), this.uvs = {
        x0: 0,
        y0: 0,
        x1: 0,
        y1: 0,
        x2: 0,
        y2: 0,
        x3: 0,
        y3: 0
      }, this.frame = new Et(), this.noFrame = false, this.dynamic = false, this.isTexture = true, this.label = e, this.source = (t == null ? void 0 : t.source) ?? new Ht(), this.noFrame = !r, r) this.frame.copyFrom(r);
      else {
        const { width: u, height: h } = this._source;
        this.frame.width = u, this.frame.height = h;
      }
      this.orig = s || this.frame, this.trim = n, this.rotate = c ?? 0, this.defaultAnchor = o, this.defaultBorders = a, this.destroyed = false, this.dynamic = l || false, this.updateUvs();
    }
    set source(t) {
      this._source && this._source.off("resize", this.update, this), this._source = t, t.on("resize", this.update, this), this.emit("update", this);
    }
    get source() {
      return this._source;
    }
    get textureMatrix() {
      return this._textureMatrix || (this._textureMatrix = new kl(this)), this._textureMatrix;
    }
    get width() {
      return this.orig.width;
    }
    get height() {
      return this.orig.height;
    }
    updateUvs() {
      const { uvs: t, frame: e } = this, { width: r, height: s } = this._source, n = e.x / r, o = e.y / s, a = e.width / r, c = e.height / s;
      let l = this.rotate;
      if (l) {
        const u = a / 2, h = c / 2, d = n + u, p = o + h;
        l = kt.add(l, kt.NW), t.x0 = d + u * kt.uX(l), t.y0 = p + h * kt.uY(l), l = kt.add(l, 2), t.x1 = d + u * kt.uX(l), t.y1 = p + h * kt.uY(l), l = kt.add(l, 2), t.x2 = d + u * kt.uX(l), t.y2 = p + h * kt.uY(l), l = kt.add(l, 2), t.x3 = d + u * kt.uX(l), t.y3 = p + h * kt.uY(l);
      } else t.x0 = n, t.y0 = o, t.x1 = n + a, t.y1 = o, t.x2 = n + a, t.y2 = o + c, t.x3 = n, t.y3 = o + c;
    }
    destroy(t = false) {
      this._source && t && (this._source.destroy(), this._source = null), this._textureMatrix = null, this.destroyed = true, this.emit("destroy", this), this.removeAllListeners();
    }
    update() {
      this.noFrame && (this.frame.width = this._source.width, this.frame.height = this._source.height), this.updateUvs(), this.emit("update", this);
    }
    get baseTexture() {
      return lt(dt, "Texture.baseTexture is now Texture.source"), this._source;
    }
  }
  Z.EMPTY = new Z({
    label: "EMPTY",
    source: new Ht({
      label: "EMPTY"
    })
  });
  Z.EMPTY.destroy = Ml;
  Z.WHITE = new Z({
    source: new Zo({
      resource: new Uint8Array([
        255,
        255,
        255,
        255
      ]),
      width: 1,
      height: 1,
      alphaMode: "premultiply-alpha-on-upload",
      label: "WHITE"
    }),
    label: "WHITE"
  });
  Z.WHITE.destroy = Ml;
  function As(i, t, e, r) {
    const { width: s, height: n } = e.orig, o = e.trim;
    if (o) {
      const a = o.width, c = o.height;
      i.minX = o.x - t._x * s - r, i.maxX = i.minX + a, i.minY = o.y - t._y * n - r, i.maxY = i.minY + c;
    } else i.minX = -t._x * s - r, i.maxX = i.minX + s, i.minY = -t._y * n - r, i.maxY = i.minY + n;
  }
  var Up = {
    grad: 0.9,
    turn: 360,
    rad: 360 / (2 * Math.PI)
  }, We = function(i) {
    return typeof i == "string" ? i.length > 0 : typeof i == "number";
  }, Yt = function(i, t, e) {
    return t === void 0 && (t = 0), e === void 0 && (e = Math.pow(10, t)), Math.round(e * i) / e + 0;
  }, ye = function(i, t, e) {
    return t === void 0 && (t = 0), e === void 0 && (e = 1), i > e ? e : i > t ? i : t;
  }, Gl = function(i) {
    return (i = isFinite(i) ? i % 360 : 0) > 0 ? i : i + 360;
  }, oc = function(i) {
    return {
      r: ye(i.r, 0, 255),
      g: ye(i.g, 0, 255),
      b: ye(i.b, 0, 255),
      a: ye(i.a)
    };
  }, An = function(i) {
    return {
      r: Yt(i.r),
      g: Yt(i.g),
      b: Yt(i.b),
      a: Yt(i.a, 3)
    };
  }, kp = /^#([0-9a-f]{3,8})$/i, $i = function(i) {
    var t = i.toString(16);
    return t.length < 2 ? "0" + t : t;
  }, Ol = function(i) {
    var t = i.r, e = i.g, r = i.b, s = i.a, n = Math.max(t, e, r), o = n - Math.min(t, e, r), a = o ? n === t ? (e - r) / o : n === e ? 2 + (r - t) / o : 4 + (t - e) / o : 0;
    return {
      h: 60 * (a < 0 ? a + 6 : a),
      s: n ? o / n * 100 : 0,
      v: n / 255 * 100,
      a: s
    };
  }, Nl = function(i) {
    var t = i.h, e = i.s, r = i.v, s = i.a;
    t = t / 360 * 6, e /= 100, r /= 100;
    var n = Math.floor(t), o = r * (1 - e), a = r * (1 - (t - n) * e), c = r * (1 - (1 - t + n) * e), l = n % 6;
    return {
      r: 255 * [
        r,
        a,
        o,
        o,
        c,
        r
      ][l],
      g: 255 * [
        c,
        r,
        r,
        a,
        o,
        o
      ][l],
      b: 255 * [
        o,
        o,
        c,
        r,
        r,
        a
      ][l],
      a: s
    };
  }, ac = function(i) {
    return {
      h: Gl(i.h),
      s: ye(i.s, 0, 100),
      l: ye(i.l, 0, 100),
      a: ye(i.a)
    };
  }, cc = function(i) {
    return {
      h: Yt(i.h),
      s: Yt(i.s),
      l: Yt(i.l),
      a: Yt(i.a, 3)
    };
  }, uc = function(i) {
    return Nl((e = (t = i).s, {
      h: t.h,
      s: (e *= ((r = t.l) < 50 ? r : 100 - r) / 100) > 0 ? 2 * e / (r + e) * 100 : 0,
      v: r + e,
      a: t.a
    }));
    var t, e, r;
  }, yi = function(i) {
    return {
      h: (t = Ol(i)).h,
      s: (s = (200 - (e = t.s)) * (r = t.v) / 100) > 0 && s < 200 ? e * r / 100 / (s <= 100 ? s : 200 - s) * 100 : 0,
      l: s / 2,
      a: t.a
    };
    var t, e, r, s;
  }, Gp = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, Op = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, Np = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, Lp = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, xo = {
    string: [
      [
        function(i) {
          var t = kp.exec(i);
          return t ? (i = t[1]).length <= 4 ? {
            r: parseInt(i[0] + i[0], 16),
            g: parseInt(i[1] + i[1], 16),
            b: parseInt(i[2] + i[2], 16),
            a: i.length === 4 ? Yt(parseInt(i[3] + i[3], 16) / 255, 2) : 1
          } : i.length === 6 || i.length === 8 ? {
            r: parseInt(i.substr(0, 2), 16),
            g: parseInt(i.substr(2, 2), 16),
            b: parseInt(i.substr(4, 2), 16),
            a: i.length === 8 ? Yt(parseInt(i.substr(6, 2), 16) / 255, 2) : 1
          } : null : null;
        },
        "hex"
      ],
      [
        function(i) {
          var t = Np.exec(i) || Lp.exec(i);
          return t ? t[2] !== t[4] || t[4] !== t[6] ? null : oc({
            r: Number(t[1]) / (t[2] ? 100 / 255 : 1),
            g: Number(t[3]) / (t[4] ? 100 / 255 : 1),
            b: Number(t[5]) / (t[6] ? 100 / 255 : 1),
            a: t[7] === void 0 ? 1 : Number(t[7]) / (t[8] ? 100 : 1)
          }) : null;
        },
        "rgb"
      ],
      [
        function(i) {
          var t = Gp.exec(i) || Op.exec(i);
          if (!t) return null;
          var e, r, s = ac({
            h: (e = t[1], r = t[2], r === void 0 && (r = "deg"), Number(e) * (Up[r] || 1)),
            s: Number(t[3]),
            l: Number(t[4]),
            a: t[5] === void 0 ? 1 : Number(t[5]) / (t[6] ? 100 : 1)
          });
          return uc(s);
        },
        "hsl"
      ]
    ],
    object: [
      [
        function(i) {
          var t = i.r, e = i.g, r = i.b, s = i.a, n = s === void 0 ? 1 : s;
          return We(t) && We(e) && We(r) ? oc({
            r: Number(t),
            g: Number(e),
            b: Number(r),
            a: Number(n)
          }) : null;
        },
        "rgb"
      ],
      [
        function(i) {
          var t = i.h, e = i.s, r = i.l, s = i.a, n = s === void 0 ? 1 : s;
          if (!We(t) || !We(e) || !We(r)) return null;
          var o = ac({
            h: Number(t),
            s: Number(e),
            l: Number(r),
            a: Number(n)
          });
          return uc(o);
        },
        "hsl"
      ],
      [
        function(i) {
          var t = i.h, e = i.s, r = i.v, s = i.a, n = s === void 0 ? 1 : s;
          if (!We(t) || !We(e) || !We(r)) return null;
          var o = function(a) {
            return {
              h: Gl(a.h),
              s: ye(a.s, 0, 100),
              v: ye(a.v, 0, 100),
              a: ye(a.a)
            };
          }({
            h: Number(t),
            s: Number(e),
            v: Number(r),
            a: Number(n)
          });
          return Nl(o);
        },
        "hsv"
      ]
    ]
  }, lc = function(i, t) {
    for (var e = 0; e < t.length; e++) {
      var r = t[e][0](i);
      if (r) return [
        r,
        t[e][1]
      ];
    }
    return [
      null,
      void 0
    ];
  }, Hp = function(i) {
    return typeof i == "string" ? lc(i.trim(), xo.string) : typeof i == "object" && i !== null ? lc(i, xo.object) : [
      null,
      void 0
    ];
  };
  var Rn = function(i, t) {
    var e = yi(i);
    return {
      h: e.h,
      s: ye(e.s + 100 * t, 0, 100),
      l: e.l,
      a: e.a
    };
  }, Pn = function(i) {
    return (299 * i.r + 587 * i.g + 114 * i.b) / 1e3 / 255;
  }, hc = function(i, t) {
    var e = yi(i);
    return {
      h: e.h,
      s: e.s,
      l: ye(e.l + 100 * t, 0, 100),
      a: e.a
    };
  }, vo = function() {
    function i(t) {
      this.parsed = Hp(t)[0], this.rgba = this.parsed || {
        r: 0,
        g: 0,
        b: 0,
        a: 1
      };
    }
    return i.prototype.isValid = function() {
      return this.parsed !== null;
    }, i.prototype.brightness = function() {
      return Yt(Pn(this.rgba), 2);
    }, i.prototype.isDark = function() {
      return Pn(this.rgba) < 0.5;
    }, i.prototype.isLight = function() {
      return Pn(this.rgba) >= 0.5;
    }, i.prototype.toHex = function() {
      return t = An(this.rgba), e = t.r, r = t.g, s = t.b, o = (n = t.a) < 1 ? $i(Yt(255 * n)) : "", "#" + $i(e) + $i(r) + $i(s) + o;
      var t, e, r, s, n, o;
    }, i.prototype.toRgb = function() {
      return An(this.rgba);
    }, i.prototype.toRgbString = function() {
      return t = An(this.rgba), e = t.r, r = t.g, s = t.b, (n = t.a) < 1 ? "rgba(" + e + ", " + r + ", " + s + ", " + n + ")" : "rgb(" + e + ", " + r + ", " + s + ")";
      var t, e, r, s, n;
    }, i.prototype.toHsl = function() {
      return cc(yi(this.rgba));
    }, i.prototype.toHslString = function() {
      return t = cc(yi(this.rgba)), e = t.h, r = t.s, s = t.l, (n = t.a) < 1 ? "hsla(" + e + ", " + r + "%, " + s + "%, " + n + ")" : "hsl(" + e + ", " + r + "%, " + s + "%)";
      var t, e, r, s, n;
    }, i.prototype.toHsv = function() {
      return t = Ol(this.rgba), {
        h: Yt(t.h),
        s: Yt(t.s),
        v: Yt(t.v),
        a: Yt(t.a, 3)
      };
      var t;
    }, i.prototype.invert = function() {
      return Fe({
        r: 255 - (t = this.rgba).r,
        g: 255 - t.g,
        b: 255 - t.b,
        a: t.a
      });
      var t;
    }, i.prototype.saturate = function(t) {
      return t === void 0 && (t = 0.1), Fe(Rn(this.rgba, t));
    }, i.prototype.desaturate = function(t) {
      return t === void 0 && (t = 0.1), Fe(Rn(this.rgba, -t));
    }, i.prototype.grayscale = function() {
      return Fe(Rn(this.rgba, -1));
    }, i.prototype.lighten = function(t) {
      return t === void 0 && (t = 0.1), Fe(hc(this.rgba, t));
    }, i.prototype.darken = function(t) {
      return t === void 0 && (t = 0.1), Fe(hc(this.rgba, -t));
    }, i.prototype.rotate = function(t) {
      return t === void 0 && (t = 15), this.hue(this.hue() + t);
    }, i.prototype.alpha = function(t) {
      return typeof t == "number" ? Fe({
        r: (e = this.rgba).r,
        g: e.g,
        b: e.b,
        a: t
      }) : Yt(this.rgba.a, 3);
      var e;
    }, i.prototype.hue = function(t) {
      var e = yi(this.rgba);
      return typeof t == "number" ? Fe({
        h: t,
        s: e.s,
        l: e.l,
        a: e.a
      }) : Yt(e.h);
    }, i.prototype.isEqual = function(t) {
      return this.toHex() === Fe(t).toHex();
    }, i;
  }(), Fe = function(i) {
    return i instanceof vo ? i : new vo(i);
  }, dc = [], zp = function(i) {
    i.forEach(function(t) {
      dc.indexOf(t) < 0 && (t(vo, xo), dc.push(t));
    });
  };
  function jp(i, t) {
    var e = {
      white: "#ffffff",
      bisque: "#ffe4c4",
      blue: "#0000ff",
      cadetblue: "#5f9ea0",
      chartreuse: "#7fff00",
      chocolate: "#d2691e",
      coral: "#ff7f50",
      antiquewhite: "#faebd7",
      aqua: "#00ffff",
      azure: "#f0ffff",
      whitesmoke: "#f5f5f5",
      papayawhip: "#ffefd5",
      plum: "#dda0dd",
      blanchedalmond: "#ffebcd",
      black: "#000000",
      gold: "#ffd700",
      goldenrod: "#daa520",
      gainsboro: "#dcdcdc",
      cornsilk: "#fff8dc",
      cornflowerblue: "#6495ed",
      burlywood: "#deb887",
      aquamarine: "#7fffd4",
      beige: "#f5f5dc",
      crimson: "#dc143c",
      cyan: "#00ffff",
      darkblue: "#00008b",
      darkcyan: "#008b8b",
      darkgoldenrod: "#b8860b",
      darkkhaki: "#bdb76b",
      darkgray: "#a9a9a9",
      darkgreen: "#006400",
      darkgrey: "#a9a9a9",
      peachpuff: "#ffdab9",
      darkmagenta: "#8b008b",
      darkred: "#8b0000",
      darkorchid: "#9932cc",
      darkorange: "#ff8c00",
      darkslateblue: "#483d8b",
      gray: "#808080",
      darkslategray: "#2f4f4f",
      darkslategrey: "#2f4f4f",
      deeppink: "#ff1493",
      deepskyblue: "#00bfff",
      wheat: "#f5deb3",
      firebrick: "#b22222",
      floralwhite: "#fffaf0",
      ghostwhite: "#f8f8ff",
      darkviolet: "#9400d3",
      magenta: "#ff00ff",
      green: "#008000",
      dodgerblue: "#1e90ff",
      grey: "#808080",
      honeydew: "#f0fff0",
      hotpink: "#ff69b4",
      blueviolet: "#8a2be2",
      forestgreen: "#228b22",
      lawngreen: "#7cfc00",
      indianred: "#cd5c5c",
      indigo: "#4b0082",
      fuchsia: "#ff00ff",
      brown: "#a52a2a",
      maroon: "#800000",
      mediumblue: "#0000cd",
      lightcoral: "#f08080",
      darkturquoise: "#00ced1",
      lightcyan: "#e0ffff",
      ivory: "#fffff0",
      lightyellow: "#ffffe0",
      lightsalmon: "#ffa07a",
      lightseagreen: "#20b2aa",
      linen: "#faf0e6",
      mediumaquamarine: "#66cdaa",
      lemonchiffon: "#fffacd",
      lime: "#00ff00",
      khaki: "#f0e68c",
      mediumseagreen: "#3cb371",
      limegreen: "#32cd32",
      mediumspringgreen: "#00fa9a",
      lightskyblue: "#87cefa",
      lightblue: "#add8e6",
      midnightblue: "#191970",
      lightpink: "#ffb6c1",
      mistyrose: "#ffe4e1",
      moccasin: "#ffe4b5",
      mintcream: "#f5fffa",
      lightslategray: "#778899",
      lightslategrey: "#778899",
      navajowhite: "#ffdead",
      navy: "#000080",
      mediumvioletred: "#c71585",
      powderblue: "#b0e0e6",
      palegoldenrod: "#eee8aa",
      oldlace: "#fdf5e6",
      paleturquoise: "#afeeee",
      mediumturquoise: "#48d1cc",
      mediumorchid: "#ba55d3",
      rebeccapurple: "#663399",
      lightsteelblue: "#b0c4de",
      mediumslateblue: "#7b68ee",
      thistle: "#d8bfd8",
      tan: "#d2b48c",
      orchid: "#da70d6",
      mediumpurple: "#9370db",
      purple: "#800080",
      pink: "#ffc0cb",
      skyblue: "#87ceeb",
      springgreen: "#00ff7f",
      palegreen: "#98fb98",
      red: "#ff0000",
      yellow: "#ffff00",
      slateblue: "#6a5acd",
      lavenderblush: "#fff0f5",
      peru: "#cd853f",
      palevioletred: "#db7093",
      violet: "#ee82ee",
      teal: "#008080",
      slategray: "#708090",
      slategrey: "#708090",
      aliceblue: "#f0f8ff",
      darkseagreen: "#8fbc8f",
      darkolivegreen: "#556b2f",
      greenyellow: "#adff2f",
      seagreen: "#2e8b57",
      seashell: "#fff5ee",
      tomato: "#ff6347",
      silver: "#c0c0c0",
      sienna: "#a0522d",
      lavender: "#e6e6fa",
      lightgreen: "#90ee90",
      orange: "#ffa500",
      orangered: "#ff4500",
      steelblue: "#4682b4",
      royalblue: "#4169e1",
      turquoise: "#40e0d0",
      yellowgreen: "#9acd32",
      salmon: "#fa8072",
      saddlebrown: "#8b4513",
      sandybrown: "#f4a460",
      rosybrown: "#bc8f8f",
      darksalmon: "#e9967a",
      lightgoldenrodyellow: "#fafad2",
      snow: "#fffafa",
      lightgrey: "#d3d3d3",
      lightgray: "#d3d3d3",
      dimgray: "#696969",
      dimgrey: "#696969",
      olivedrab: "#6b8e23",
      olive: "#808000"
    }, r = {};
    for (var s in e) r[e[s]] = s;
    var n = {};
    i.prototype.toName = function(o) {
      if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b)) return "transparent";
      var a, c, l = r[this.toHex()];
      if (l) return l;
      if (o == null ? void 0 : o.closest) {
        var u = this.toRgb(), h = 1 / 0, d = "black";
        if (!n.length) for (var p in e) n[p] = new i(e[p]).toRgb();
        for (var g in e) {
          var y = (a = u, c = n[g], Math.pow(a.r - c.r, 2) + Math.pow(a.g - c.g, 2) + Math.pow(a.b - c.b, 2));
          y < h && (h = y, d = g);
        }
        return d;
      }
    }, t.string.push([
      function(o) {
        var a = o.toLowerCase(), c = a === "transparent" ? "#0000" : e[a];
        return c ? new i(c).toRgb() : null;
      },
      "name"
    ]);
  }
  zp([
    jp
  ]);
  const Kr = class gi {
    constructor(t = 16777215) {
      this._value = null, this._components = new Float32Array(4), this._components.fill(1), this._int = 16777215, this.value = t;
    }
    get red() {
      return this._components[0];
    }
    get green() {
      return this._components[1];
    }
    get blue() {
      return this._components[2];
    }
    get alpha() {
      return this._components[3];
    }
    setValue(t) {
      return this.value = t, this;
    }
    set value(t) {
      if (t instanceof gi) this._value = this._cloneSource(t._value), this._int = t._int, this._components.set(t._components);
      else {
        if (t === null) throw new Error("Cannot set Color#value to null");
        (this._value === null || !this._isSourceEqual(this._value, t)) && (this._normalize(t), this._value = this._cloneSource(t));
      }
    }
    get value() {
      return this._value;
    }
    _cloneSource(t) {
      return typeof t == "string" || typeof t == "number" || t instanceof Number || t === null ? t : Array.isArray(t) || ArrayBuffer.isView(t) ? t.slice(0) : typeof t == "object" && t !== null ? {
        ...t
      } : t;
    }
    _isSourceEqual(t, e) {
      const r = typeof t;
      if (r !== typeof e) return false;
      if (r === "number" || r === "string" || t instanceof Number) return t === e;
      if (Array.isArray(t) && Array.isArray(e) || ArrayBuffer.isView(t) && ArrayBuffer.isView(e)) return t.length !== e.length ? false : t.every((n, o) => n === e[o]);
      if (t !== null && e !== null) {
        const n = Object.keys(t), o = Object.keys(e);
        return n.length !== o.length ? false : n.every((a) => t[a] === e[a]);
      }
      return t === e;
    }
    toRgba() {
      const [t, e, r, s] = this._components;
      return {
        r: t,
        g: e,
        b: r,
        a: s
      };
    }
    toRgb() {
      const [t, e, r] = this._components;
      return {
        r: t,
        g: e,
        b: r
      };
    }
    toRgbaString() {
      const [t, e, r] = this.toUint8RgbArray();
      return `rgba(${t},${e},${r},${this.alpha})`;
    }
    toUint8RgbArray(t) {
      const [e, r, s] = this._components;
      return this._arrayRgb || (this._arrayRgb = []), t = t || this._arrayRgb, t[0] = Math.round(e * 255), t[1] = Math.round(r * 255), t[2] = Math.round(s * 255), t;
    }
    toArray(t) {
      this._arrayRgba || (this._arrayRgba = []), t = t || this._arrayRgba;
      const [e, r, s, n] = this._components;
      return t[0] = e, t[1] = r, t[2] = s, t[3] = n, t;
    }
    toRgbArray(t) {
      this._arrayRgb || (this._arrayRgb = []), t = t || this._arrayRgb;
      const [e, r, s] = this._components;
      return t[0] = e, t[1] = r, t[2] = s, t;
    }
    toNumber() {
      return this._int;
    }
    toBgrNumber() {
      const [t, e, r] = this.toUint8RgbArray();
      return (r << 16) + (e << 8) + t;
    }
    toLittleEndianNumber() {
      const t = this._int;
      return (t >> 16) + (t & 65280) + ((t & 255) << 16);
    }
    multiply(t) {
      const [e, r, s, n] = gi._temp.setValue(t)._components;
      return this._components[0] *= e, this._components[1] *= r, this._components[2] *= s, this._components[3] *= n, this._refreshInt(), this._value = null, this;
    }
    premultiply(t, e = true) {
      return e && (this._components[0] *= t, this._components[1] *= t, this._components[2] *= t), this._components[3] = t, this._refreshInt(), this._value = null, this;
    }
    toPremultiplied(t, e = true) {
      if (t === 1) return (255 << 24) + this._int;
      if (t === 0) return e ? 0 : this._int;
      let r = this._int >> 16 & 255, s = this._int >> 8 & 255, n = this._int & 255;
      return e && (r = r * t + 0.5 | 0, s = s * t + 0.5 | 0, n = n * t + 0.5 | 0), (t * 255 << 24) + (r << 16) + (s << 8) + n;
    }
    toHex() {
      const t = this._int.toString(16);
      return `#${"000000".substring(0, 6 - t.length) + t}`;
    }
    toHexa() {
      const e = Math.round(this._components[3] * 255).toString(16);
      return this.toHex() + "00".substring(0, 2 - e.length) + e;
    }
    setAlpha(t) {
      return this._components[3] = this._clamp(t), this;
    }
    _normalize(t) {
      let e, r, s, n;
      if ((typeof t == "number" || t instanceof Number) && t >= 0 && t <= 16777215) {
        const o = t;
        e = (o >> 16 & 255) / 255, r = (o >> 8 & 255) / 255, s = (o & 255) / 255, n = 1;
      } else if ((Array.isArray(t) || t instanceof Float32Array) && t.length >= 3 && t.length <= 4) t = this._clamp(t), [e, r, s, n = 1] = t;
      else if ((t instanceof Uint8Array || t instanceof Uint8ClampedArray) && t.length >= 3 && t.length <= 4) t = this._clamp(t, 0, 255), [e, r, s, n = 255] = t, e /= 255, r /= 255, s /= 255, n /= 255;
      else if (typeof t == "string" || typeof t == "object") {
        if (typeof t == "string") {
          const a = gi.HEX_PATTERN.exec(t);
          a && (t = `#${a[2]}`);
        }
        const o = Fe(t);
        o.isValid() && ({ r: e, g: r, b: s, a: n } = o.rgba, e /= 255, r /= 255, s /= 255);
      }
      if (e !== void 0) this._components[0] = e, this._components[1] = r, this._components[2] = s, this._components[3] = n, this._refreshInt();
      else throw new Error(`Unable to convert color ${t}`);
    }
    _refreshInt() {
      this._clamp(this._components);
      const [t, e, r] = this._components;
      this._int = (t * 255 << 16) + (e * 255 << 8) + (r * 255 | 0);
    }
    _clamp(t, e = 0, r = 1) {
      return typeof t == "number" ? Math.min(Math.max(t, e), r) : (t.forEach((s, n) => {
        t[n] = Math.min(Math.max(s, e), r);
      }), t);
    }
    static isColorLike(t) {
      return typeof t == "number" || typeof t == "string" || t instanceof Number || t instanceof gi || Array.isArray(t) || t instanceof Uint8Array || t instanceof Uint8ClampedArray || t instanceof Float32Array || t.r !== void 0 && t.g !== void 0 && t.b !== void 0 || t.r !== void 0 && t.g !== void 0 && t.b !== void 0 && t.a !== void 0 || t.h !== void 0 && t.s !== void 0 && t.l !== void 0 || t.h !== void 0 && t.s !== void 0 && t.l !== void 0 && t.a !== void 0 || t.h !== void 0 && t.s !== void 0 && t.v !== void 0 || t.h !== void 0 && t.s !== void 0 && t.v !== void 0 && t.a !== void 0;
    }
  };
  Kr.shared = new Kr();
  Kr._temp = new Kr();
  Kr.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;
  let Tt = Kr;
  const Wp = {
    cullArea: null,
    cullable: false,
    cullableChildren: true
  };
  class Qo {
    constructor(t, e) {
      this._pool = [], this._count = 0, this._index = 0, this._classType = t, e && this.prepopulate(e);
    }
    prepopulate(t) {
      for (let e = 0; e < t; e++) this._pool[this._index++] = new this._classType();
      this._count += t;
    }
    get(t) {
      var _a2;
      let e;
      return this._index > 0 ? e = this._pool[--this._index] : e = new this._classType(), (_a2 = e.init) == null ? void 0 : _a2.call(e, t), e;
    }
    return(t) {
      var _a2;
      (_a2 = t.reset) == null ? void 0 : _a2.call(t), this._pool[this._index++] = t;
    }
    get totalSize() {
      return this._count;
    }
    get totalFree() {
      return this._index;
    }
    get totalUsed() {
      return this._count - this._index;
    }
    clear() {
      this._pool.length = 0, this._index = 0;
    }
  }
  class Vp {
    constructor() {
      this._poolsByClass = /* @__PURE__ */ new Map();
    }
    prepopulate(t, e) {
      this.getPool(t).prepopulate(e);
    }
    get(t, e) {
      return this.getPool(t).get(e);
    }
    return(t) {
      this.getPool(t.constructor).return(t);
    }
    getPool(t) {
      return this._poolsByClass.has(t) || this._poolsByClass.set(t, new Qo(t)), this._poolsByClass.get(t);
    }
    stats() {
      const t = {};
      return this._poolsByClass.forEach((e) => {
        const r = t[e._classType.name] ? e._classType.name + e._classType.ID : e._classType.name;
        t[r] = {
          free: e.totalFree,
          used: e.totalUsed,
          size: e.totalSize
        };
      }), t;
    }
  }
  const vt = new Vp();
  function Ll(i, t, e) {
    const r = i.length;
    let s;
    if (t >= r || e === 0) return;
    e = t + e > r ? r - t : e;
    const n = r - e;
    for (s = t; s < n; ++s) i[s] = i[s + e];
    i.length = n;
  }
  const Xp = {
    allowChildren: true,
    removeChildren(i = 0, t) {
      const e = t ?? this.children.length, r = e - i, s = [];
      if (r > 0 && r <= e) {
        for (let o = e - 1; o >= i; o--) {
          const a = this.children[o];
          a && (s.push(a), a.parent = null);
        }
        Ll(this.children, i, e);
        const n = this.renderGroup || this.parentRenderGroup;
        n && n.removeChildren(s);
        for (let o = 0; o < s.length; ++o) this.emit("childRemoved", s[o], this, o), s[o].emit("removed", this);
        return s;
      } else if (r === 0 && this.children.length === 0) return s;
      throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
    },
    removeChildAt(i) {
      const t = this.getChildAt(i);
      return this.removeChild(t);
    },
    getChildAt(i) {
      if (i < 0 || i >= this.children.length) throw new Error(`getChildAt: Index (${i}) does not exist.`);
      return this.children[i];
    },
    setChildIndex(i, t) {
      if (t < 0 || t >= this.children.length) throw new Error(`The index ${t} supplied is out of bounds ${this.children.length}`);
      this.getChildIndex(i), this.addChildAt(i, t);
    },
    getChildIndex(i) {
      const t = this.children.indexOf(i);
      if (t === -1) throw new Error("The supplied Container must be a child of the caller");
      return t;
    },
    addChildAt(i, t) {
      this.allowChildren || lt(dt, "addChildAt: Only Containers will be allowed to add children in v8.0.0");
      const { children: e } = this;
      if (t < 0 || t > e.length) throw new Error(`${i}addChildAt: The index ${t} supplied is out of bounds ${e.length}`);
      if (i.parent) {
        const s = i.parent.children.indexOf(i);
        if (i.parent === this && s === t) return i;
        s !== -1 && i.parent.children.splice(s, 1);
      }
      t === e.length ? e.push(i) : e.splice(t, 0, i), i.parent = this, i.didChange = true, i.didViewUpdate = false, i._updateFlags = 15;
      const r = this.renderGroup || this.parentRenderGroup;
      return r && r.addChild(i), this.sortableChildren && (this.sortDirty = true), this.emit("childAdded", i, this, t), i.emit("added", this), i;
    },
    swapChildren(i, t) {
      if (i === t) return;
      const e = this.getChildIndex(i), r = this.getChildIndex(t);
      this.children[e] = t, this.children[r] = i;
      const s = this.renderGroup || this.parentRenderGroup;
      s && (s.structureDidChange = true), this._didChangeId++;
    },
    removeFromParent() {
      var _a2;
      (_a2 = this.parent) == null ? void 0 : _a2.removeChild(this);
    },
    reparentChild(...i) {
      return i.length === 1 ? this.reparentChildAt(i[0], this.children.length) : (i.forEach((t) => this.reparentChildAt(t, this.children.length)), i[0]);
    },
    reparentChildAt(i, t) {
      if (i.parent === this) return this.setChildIndex(i, t), i;
      const e = i.worldTransform.clone();
      i.removeFromParent(), this.addChildAt(i, t);
      const r = this.worldTransform.clone();
      return r.invert(), e.prepend(r), i.setFromMatrix(e), i;
    }
  };
  class Rs {
    constructor() {
      this.pipe = "filter", this.priority = 1;
    }
    destroy() {
      for (let t = 0; t < this.filters.length; t++) this.filters[t].destroy();
      this.filters = null, this.filterArea = null;
    }
  }
  class qp {
    constructor() {
      this._effectClasses = [], this._tests = [], this._initialized = false;
    }
    init() {
      this._initialized || (this._initialized = true, this._effectClasses.forEach((t) => {
        this.add({
          test: t.test,
          maskClass: t
        });
      }));
    }
    add(t) {
      this._tests.push(t);
    }
    getMaskEffect(t) {
      this._initialized || this.init();
      for (let e = 0; e < this._tests.length; e++) {
        const r = this._tests[e];
        if (r.test(t)) return vt.get(r.maskClass, t);
      }
      return t;
    }
    returnMaskEffect(t) {
      vt.return(t);
    }
  }
  const So = new qp();
  Mt.handleByList(P.MaskEffect, So._effectClasses);
  const $p = {
    _maskEffect: null,
    _filterEffect: null,
    effects: [],
    addEffect(i) {
      if (this.effects.indexOf(i) !== -1) return;
      this.effects.push(i), this.effects.sort((r, s) => r.priority - s.priority);
      const e = this.renderGroup || this.parentRenderGroup;
      e && (e.structureDidChange = true), this._updateIsSimple();
    },
    removeEffect(i) {
      const t = this.effects.indexOf(i);
      t !== -1 && (this.effects.splice(t, 1), this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = true), this._updateIsSimple());
    },
    set mask(i) {
      const t = this._maskEffect;
      (t == null ? void 0 : t.mask) !== i && (t && (this.removeEffect(t), So.returnMaskEffect(t), this._maskEffect = null), i != null && (this._maskEffect = So.getMaskEffect(i), this.addEffect(this._maskEffect)));
    },
    get mask() {
      var _a2;
      return (_a2 = this._maskEffect) == null ? void 0 : _a2.mask;
    },
    set filters(i) {
      var _a2;
      !Array.isArray(i) && i && (i = [
        i
      ]);
      const t = this._filterEffect || (this._filterEffect = new Rs());
      i = i;
      const e = (i == null ? void 0 : i.length) > 0, r = ((_a2 = t.filters) == null ? void 0 : _a2.length) > 0, s = e !== r;
      i = Array.isArray(i) ? i.slice(0) : i, t.filters = Object.freeze(i), s && (e ? this.addEffect(t) : (this.removeEffect(t), t.filters = i ?? null));
    },
    get filters() {
      var _a2;
      return (_a2 = this._filterEffect) == null ? void 0 : _a2.filters;
    },
    set filterArea(i) {
      this._filterEffect || (this._filterEffect = new Rs()), this._filterEffect.filterArea = i;
    },
    get filterArea() {
      var _a2;
      return (_a2 = this._filterEffect) == null ? void 0 : _a2.filterArea;
    }
  }, Yp = {
    label: null,
    get name() {
      return lt(dt, "Container.name property has been removed, use Container.label instead"), this.label;
    },
    set name(i) {
      lt(dt, "Container.name property has been removed, use Container.label instead"), this.label = i;
    },
    getChildByName(i, t = false) {
      return this.getChildByLabel(i, t);
    },
    getChildByLabel(i, t = false) {
      const e = this.children;
      for (let r = 0; r < e.length; r++) {
        const s = e[r];
        if (s.label === i || i instanceof RegExp && i.test(s.label)) return s;
      }
      if (t) for (let r = 0; r < e.length; r++) {
        const n = e[r].getChildByLabel(i, true);
        if (n) return n;
      }
      return null;
    },
    getChildrenByLabel(i, t = false, e = []) {
      const r = this.children;
      for (let s = 0; s < r.length; s++) {
        const n = r[s];
        (n.label === i || i instanceof RegExp && i.test(n.label)) && e.push(n);
      }
      if (t) for (let s = 0; s < r.length; s++) r[s].getChildrenByLabel(i, true, e);
      return e;
    }
  }, fc = new st();
  class re {
    constructor(t = 1 / 0, e = 1 / 0, r = -1 / 0, s = -1 / 0) {
      this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.matrix = fc, this.minX = t, this.minY = e, this.maxX = r, this.maxY = s;
    }
    isEmpty() {
      return this.minX > this.maxX || this.minY > this.maxY;
    }
    get rectangle() {
      this._rectangle || (this._rectangle = new Et());
      const t = this._rectangle;
      return this.minX > this.maxX || this.minY > this.maxY ? (t.x = 0, t.y = 0, t.width = 0, t.height = 0) : t.copyFromBounds(this), t;
    }
    clear() {
      return this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.matrix = fc, this;
    }
    set(t, e, r, s) {
      this.minX = t, this.minY = e, this.maxX = r, this.maxY = s;
    }
    addFrame(t, e, r, s, n) {
      n || (n = this.matrix);
      const o = n.a, a = n.b, c = n.c, l = n.d, u = n.tx, h = n.ty;
      let d = this.minX, p = this.minY, g = this.maxX, y = this.maxY, m = o * t + c * e + u, v = a * t + l * e + h;
      m < d && (d = m), v < p && (p = v), m > g && (g = m), v > y && (y = v), m = o * r + c * e + u, v = a * r + l * e + h, m < d && (d = m), v < p && (p = v), m > g && (g = m), v > y && (y = v), m = o * t + c * s + u, v = a * t + l * s + h, m < d && (d = m), v < p && (p = v), m > g && (g = m), v > y && (y = v), m = o * r + c * s + u, v = a * r + l * s + h, m < d && (d = m), v < p && (p = v), m > g && (g = m), v > y && (y = v), this.minX = d, this.minY = p, this.maxX = g, this.maxY = y;
    }
    addRect(t, e) {
      this.addFrame(t.x, t.y, t.x + t.width, t.y + t.height, e);
    }
    addBounds(t, e) {
      this.addFrame(t.minX, t.minY, t.maxX, t.maxY, e);
    }
    addBoundsMask(t) {
      this.minX = this.minX > t.minX ? this.minX : t.minX, this.minY = this.minY > t.minY ? this.minY : t.minY, this.maxX = this.maxX < t.maxX ? this.maxX : t.maxX, this.maxY = this.maxY < t.maxY ? this.maxY : t.maxY;
    }
    applyMatrix(t) {
      const e = this.minX, r = this.minY, s = this.maxX, n = this.maxY, { a: o, b: a, c, d: l, tx: u, ty: h } = t;
      let d = o * e + c * r + u, p = a * e + l * r + h;
      this.minX = d, this.minY = p, this.maxX = d, this.maxY = p, d = o * s + c * r + u, p = a * s + l * r + h, this.minX = d < this.minX ? d : this.minX, this.minY = p < this.minY ? p : this.minY, this.maxX = d > this.maxX ? d : this.maxX, this.maxY = p > this.maxY ? p : this.maxY, d = o * e + c * n + u, p = a * e + l * n + h, this.minX = d < this.minX ? d : this.minX, this.minY = p < this.minY ? p : this.minY, this.maxX = d > this.maxX ? d : this.maxX, this.maxY = p > this.maxY ? p : this.maxY, d = o * s + c * n + u, p = a * s + l * n + h, this.minX = d < this.minX ? d : this.minX, this.minY = p < this.minY ? p : this.minY, this.maxX = d > this.maxX ? d : this.maxX, this.maxY = p > this.maxY ? p : this.maxY;
    }
    fit(t) {
      return this.minX < t.left && (this.minX = t.left), this.maxX > t.right && (this.maxX = t.right), this.minY < t.top && (this.minY = t.top), this.maxY > t.bottom && (this.maxY = t.bottom), this;
    }
    fitBounds(t, e, r, s) {
      return this.minX < t && (this.minX = t), this.maxX > e && (this.maxX = e), this.minY < r && (this.minY = r), this.maxY > s && (this.maxY = s), this;
    }
    pad(t, e = t) {
      return this.minX -= t, this.maxX += t, this.minY -= e, this.maxY += e, this;
    }
    ceil() {
      return this.minX = Math.floor(this.minX), this.minY = Math.floor(this.minY), this.maxX = Math.ceil(this.maxX), this.maxY = Math.ceil(this.maxY), this;
    }
    clone() {
      return new re(this.minX, this.minY, this.maxX, this.maxY);
    }
    scale(t, e = t) {
      return this.minX *= t, this.minY *= e, this.maxX *= t, this.maxY *= e, this;
    }
    get x() {
      return this.minX;
    }
    set x(t) {
      const e = this.maxX - this.minX;
      this.minX = t, this.maxX = t + e;
    }
    get y() {
      return this.minY;
    }
    set y(t) {
      const e = this.maxY - this.minY;
      this.minY = t, this.maxY = t + e;
    }
    get width() {
      return this.maxX - this.minX;
    }
    set width(t) {
      this.maxX = this.minX + t;
    }
    get height() {
      return this.maxY - this.minY;
    }
    set height(t) {
      this.maxY = this.minY + t;
    }
    get left() {
      return this.minX;
    }
    get right() {
      return this.maxX;
    }
    get top() {
      return this.minY;
    }
    get bottom() {
      return this.maxY;
    }
    get isPositive() {
      return this.maxX - this.minX > 0 && this.maxY - this.minY > 0;
    }
    get isValid() {
      return this.minX + this.minY !== 1 / 0;
    }
    addVertexData(t, e, r, s) {
      let n = this.minX, o = this.minY, a = this.maxX, c = this.maxY;
      s || (s = this.matrix);
      const l = s.a, u = s.b, h = s.c, d = s.d, p = s.tx, g = s.ty;
      for (let y = e; y < r; y += 2) {
        const m = t[y], v = t[y + 1], S = l * m + h * v + p, C = u * m + d * v + g;
        n = S < n ? S : n, o = C < o ? C : o, a = S > a ? S : a, c = C > c ? C : c;
      }
      this.minX = n, this.minY = o, this.maxX = a, this.maxY = c;
    }
    containsPoint(t, e) {
      return this.minX <= t && this.minY <= e && this.maxX >= t && this.maxY >= e;
    }
    toString() {
      return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;
    }
  }
  const Ke = new Qo(st), Je = new Qo(re);
  function Xs(i, t, e) {
    e.clear();
    let r, s;
    return i.parent ? t ? r = i.parent.worldTransform : (s = Ke.get().identity(), r = Ps(i, s)) : r = st.IDENTITY, Hl(i, e, r, t), s && Ke.return(s), e.isValid || e.set(0, 0, 0, 0), e;
  }
  function Hl(i, t, e, r) {
    var _a2, _b2;
    if (!i.visible || !i.measurable) return;
    let s;
    r ? s = i.worldTransform : (i.updateLocalTransform(), s = Ke.get(), s.appendFrom(i.localTransform, e));
    const n = t, o = !!i.effects.length;
    if (o && (t = Je.get().clear()), i.boundsArea) t.addRect(i.boundsArea, s);
    else {
      i.addBounds && (t.matrix = s, i.addBounds(t));
      for (let a = 0; a < i.children.length; a++) Hl(i.children[a], t, s, r);
    }
    if (o) {
      for (let a = 0; a < i.effects.length; a++) (_b2 = (_a2 = i.effects[a]).addBounds) == null ? void 0 : _b2.call(_a2, t);
      n.addBounds(t, st.IDENTITY), Je.return(t);
    }
    r || Ke.return(s);
  }
  function Ps(i, t) {
    const e = i.parent;
    return e && (Ps(e, t), e.updateLocalTransform(), t.append(e.localTransform)), t;
  }
  let Bn = 0;
  const pc = 500;
  function ut(...i) {
    Bn !== pc && (Bn++, Bn === pc ? console.warn("PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.") : console.warn("PixiJS Warning: ", ...i));
  }
  function ta(i, t, e) {
    return t.clear(), e || (e = st.IDENTITY), zl(i, t, e, i, true), t.isValid || t.set(0, 0, 0, 0), t;
  }
  function zl(i, t, e, r, s) {
    var _a2, _b2;
    let n;
    if (s) n = Ke.get(), n = e.copyTo(n);
    else {
      if (!i.visible || !i.measurable) return;
      i.updateLocalTransform();
      const c = i.localTransform;
      n = Ke.get(), n.appendFrom(c, e);
    }
    const o = t, a = !!i.effects.length;
    if (a && (t = Je.get().clear()), i.boundsArea) t.addRect(i.boundsArea, n);
    else {
      i.renderPipeId && (t.matrix = n, i.addBounds(t));
      const c = i.children;
      for (let l = 0; l < c.length; l++) zl(c[l], t, n, r, false);
    }
    if (a) {
      for (let c = 0; c < i.effects.length; c++) (_b2 = (_a2 = i.effects[c]).addLocalBounds) == null ? void 0 : _b2.call(_a2, t, r);
      o.addBounds(t, st.IDENTITY), Je.return(t);
    }
    Ke.return(n);
  }
  function jl(i, t) {
    const e = i.children;
    for (let r = 0; r < e.length; r++) {
      const s = e[r], n = (s.uid & 255) << 24 | s._didChangeId & 16777215;
      t.data[t.index] !== n && (t.data[t.index] = n, t.didChange = true), t.index++, s.children.length && jl(s, t);
    }
    return t.didChange;
  }
  const Kp = new st(), Jp = {
    _localBoundsCacheId: -1,
    _localBoundsCacheData: null,
    _setWidth(i, t) {
      const e = Math.sign(this.scale.x) || 1;
      t !== 0 ? this.scale.x = i / t * e : this.scale.x = e;
    },
    _setHeight(i, t) {
      const e = Math.sign(this.scale.y) || 1;
      t !== 0 ? this.scale.y = i / t * e : this.scale.y = e;
    },
    getLocalBounds() {
      this._localBoundsCacheData || (this._localBoundsCacheData = {
        data: [],
        index: 1,
        didChange: false,
        localBounds: new re()
      });
      const i = this._localBoundsCacheData;
      return i.index = 1, i.didChange = false, i.data[0] !== this._didChangeId >> 12 && (i.didChange = true, i.data[0] = this._didChangeId >> 12), jl(this, i), i.didChange && ta(this, i.localBounds, Kp), i.localBounds;
    },
    getBounds(i, t) {
      return Xs(this, i, t || new re());
    }
  }, Zp = {
    _onRender: null,
    set onRender(i) {
      const t = this.renderGroup || this.parentRenderGroup;
      if (!i) {
        this._onRender && (t == null ? void 0 : t.removeOnRender(this)), this._onRender = null;
        return;
      }
      this._onRender || (t == null ? void 0 : t.addOnRender(this)), this._onRender = i;
    },
    get onRender() {
      return this._onRender;
    }
  }, Qp = {
    _zIndex: 0,
    sortDirty: false,
    sortableChildren: false,
    get zIndex() {
      return this._zIndex;
    },
    set zIndex(i) {
      this._zIndex !== i && (this._zIndex = i, this.depthOfChildModified());
    },
    depthOfChildModified() {
      this.parent && (this.parent.sortableChildren = true, this.parent.sortDirty = true), this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = true);
    },
    sortChildren() {
      this.sortDirty && (this.sortDirty = false, this.children.sort(t_));
    }
  };
  function t_(i, t) {
    return i._zIndex - t._zIndex;
  }
  const e_ = {
    getGlobalPosition(i = new At(), t = false) {
      return this.parent ? this.parent.toGlobal(this._position, i, t) : (i.x = this._position.x, i.y = this._position.y), i;
    },
    toGlobal(i, t, e = false) {
      if (!e) {
        this.updateLocalTransform();
        const r = Ps(this, new st());
        return r.append(this.localTransform), r.apply(i, t);
      }
      return this.worldTransform.apply(i, t);
    },
    toLocal(i, t, e, r) {
      if (t && (i = t.toGlobal(i, e, r)), !r) {
        this.updateLocalTransform();
        const s = Ps(this, new st());
        return s.append(this.localTransform), s.applyInverse(i, e);
      }
      return this.worldTransform.applyInverse(i, e);
    }
  };
  class Wl {
    constructor() {
      this.uid = Ot("instructionSet"), this.instructions = [], this.instructionSize = 0;
    }
    reset() {
      this.instructionSize = 0;
    }
    add(t) {
      this.instructions[this.instructionSize++] = t;
    }
    log() {
      this.instructions.length = this.instructionSize, console.table(this.instructions, [
        "type",
        "action"
      ]);
    }
  }
  class r_ {
    constructor() {
      this.renderPipeId = "renderGroup", this.root = null, this.canBundle = false, this.renderGroupParent = null, this.renderGroupChildren = [], this.worldTransform = new st(), this.worldColorAlpha = 4294967295, this.worldColor = 16777215, this.worldAlpha = 1, this.childrenToUpdate = /* @__PURE__ */ Object.create(null), this.updateTick = 0, this.childrenRenderablesToUpdate = {
        list: [],
        index: 0
      }, this.structureDidChange = true, this.instructionSet = new Wl(), this._onRenderContainers = [];
    }
    init(t) {
      this.root = t, t._onRender && this.addOnRender(t), t.didChange = true;
      const e = t.children;
      for (let r = 0; r < e.length; r++) this.addChild(e[r]);
    }
    reset() {
      this.renderGroupChildren.length = 0;
      for (const t in this.childrenToUpdate) {
        const e = this.childrenToUpdate[t];
        e.list.fill(null), e.index = 0;
      }
      this.childrenRenderablesToUpdate.index = 0, this.childrenRenderablesToUpdate.list.fill(null), this.root = null, this.updateTick = 0, this.structureDidChange = true, this._onRenderContainers.length = 0, this.renderGroupParent = null;
    }
    get localTransform() {
      return this.root.localTransform;
    }
    addRenderGroupChild(t) {
      t.renderGroupParent && t.renderGroupParent._removeRenderGroupChild(t), t.renderGroupParent = this, this.renderGroupChildren.push(t);
    }
    _removeRenderGroupChild(t) {
      const e = this.renderGroupChildren.indexOf(t);
      e > -1 && this.renderGroupChildren.splice(e, 1), t.renderGroupParent = null;
    }
    addChild(t) {
      if (this.structureDidChange = true, t.parentRenderGroup = this, t.updateTick = -1, t.parent === this.root ? t.relativeRenderGroupDepth = 1 : t.relativeRenderGroupDepth = t.parent.relativeRenderGroupDepth + 1, t.didChange = true, this.onChildUpdate(t), t.renderGroup) {
        this.addRenderGroupChild(t.renderGroup);
        return;
      }
      t._onRender && this.addOnRender(t);
      const e = t.children;
      for (let r = 0; r < e.length; r++) this.addChild(e[r]);
    }
    removeChild(t) {
      if (this.structureDidChange = true, t._onRender && (t.renderGroup || this.removeOnRender(t)), t.parentRenderGroup = null, t.renderGroup) {
        this._removeRenderGroupChild(t.renderGroup);
        return;
      }
      const e = t.children;
      for (let r = 0; r < e.length; r++) this.removeChild(e[r]);
    }
    removeChildren(t) {
      for (let e = 0; e < t.length; e++) this.removeChild(t[e]);
    }
    onChildUpdate(t) {
      let e = this.childrenToUpdate[t.relativeRenderGroupDepth];
      e || (e = this.childrenToUpdate[t.relativeRenderGroupDepth] = {
        index: 0,
        list: []
      }), e.list[e.index++] = t;
    }
    updateRenderable(t) {
      t.globalDisplayStatus < 7 || (t.didViewUpdate = false, this.instructionSet.renderPipes[t.renderPipeId].updateRenderable(t));
    }
    onChildViewUpdate(t) {
      this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = t;
    }
    get isRenderable() {
      return this.root.localDisplayStatus === 7 && this.worldAlpha > 0;
    }
    addOnRender(t) {
      this._onRenderContainers.push(t);
    }
    removeOnRender(t) {
      this._onRenderContainers.splice(this._onRenderContainers.indexOf(t), 1);
    }
    runOnRender() {
      for (let t = 0; t < this._onRenderContainers.length; t++) this._onRenderContainers[t]._onRender();
    }
    destroy() {
      this.renderGroupParent = null, this.root = null, this.childrenRenderablesToUpdate = null, this.childrenToUpdate = null, this.renderGroupChildren = null, this._onRenderContainers = null, this.instructionSet = null;
    }
    getChildren(t = []) {
      const e = this.root.children;
      for (let r = 0; r < e.length; r++) this._getChildren(e[r], t);
      return t;
    }
    _getChildren(t, e = []) {
      if (e.push(t), t.renderGroup) return e;
      const r = t.children;
      for (let s = 0; s < r.length; s++) this._getChildren(r[s], e);
      return e;
    }
  }
  function i_(i, t, e = {}) {
    for (const r in t) !e[r] && t[r] !== void 0 && (i[r] = t[r]);
  }
  const Mn = new Xt(null), Dn = new Xt(null), In = new Xt(null, 1, 1), Bs = 1, ea = 2, xi = 4;
  Dt = class extends me {
    constructor(t = {}) {
      var _a2, _b2;
      super(), this.uid = Ot("renderable"), this._updateFlags = 15, this.renderGroup = null, this.parentRenderGroup = null, this.parentRenderGroupIndex = 0, this.didChange = false, this.didViewUpdate = false, this.relativeRenderGroupDepth = 0, this.children = [], this.parent = null, this.includeInBuild = true, this.measurable = true, this.isSimple = true, this.updateTick = -1, this.localTransform = new st(), this.relativeGroupTransform = new st(), this.groupTransform = this.relativeGroupTransform, this.destroyed = false, this._position = new Xt(this, 0, 0), this._scale = In, this._pivot = Dn, this._skew = Mn, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._rotation = 0, this.localColor = 16777215, this.localAlpha = 1, this.groupAlpha = 1, this.groupColor = 16777215, this.groupColorAlpha = 4294967295, this.localBlendMode = "inherit", this.groupBlendMode = "normal", this.localDisplayStatus = 7, this.globalDisplayStatus = 7, this._didChangeId = 0, this._didLocalTransformChangeId = -1, i_(this, t, {
        children: true,
        parent: true,
        effects: true
      }), (_a2 = t.children) == null ? void 0 : _a2.forEach((e) => this.addChild(e)), this.effects = [], (_b2 = t.parent) == null ? void 0 : _b2.addChild(this);
    }
    static mixin(t) {
      Object.defineProperties(Dt.prototype, Object.getOwnPropertyDescriptors(t));
    }
    addChild(...t) {
      if (this.allowChildren || lt(dt, "addChild: Only Containers will be allowed to add children in v8.0.0"), t.length > 1) {
        for (let s = 0; s < t.length; s++) this.addChild(t[s]);
        return t[0];
      }
      const e = t[0];
      if (e.parent === this) return this.children.splice(this.children.indexOf(e), 1), this.children.push(e), this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = true), e;
      e.parent && e.parent.removeChild(e), this.children.push(e), this.sortableChildren && (this.sortDirty = true), e.parent = this, e.didChange = true, e.didViewUpdate = false, e._updateFlags = 15;
      const r = this.renderGroup || this.parentRenderGroup;
      return r && r.addChild(e), this.emit("childAdded", e, this, this.children.length - 1), e.emit("added", this), this._didChangeId += 4096, e._zIndex !== 0 && e.depthOfChildModified(), e;
    }
    removeChild(...t) {
      if (t.length > 1) {
        for (let s = 0; s < t.length; s++) this.removeChild(t[s]);
        return t[0];
      }
      const e = t[0], r = this.children.indexOf(e);
      return r > -1 && (this._didChangeId += 4096, this.children.splice(r, 1), this.renderGroup ? this.renderGroup.removeChild(e) : this.parentRenderGroup && this.parentRenderGroup.removeChild(e), e.parent = null, this.emit("childRemoved", e, this, r), e.emit("removed", this)), e;
    }
    _onUpdate(t) {
      t && t === this._skew && this._updateSkew(), this._didChangeId++, !this.didChange && (this.didChange = true, this.parentRenderGroup && this.parentRenderGroup.onChildUpdate(this));
    }
    set isRenderGroup(t) {
      !!this.renderGroup !== t && (t ? this.enableRenderGroup() : this.disableRenderGroup());
    }
    get isRenderGroup() {
      return !!this.renderGroup;
    }
    enableRenderGroup() {
      if (this.renderGroup) return;
      const t = this.parentRenderGroup;
      t == null ? void 0 : t.removeChild(this), this.renderGroup = vt.get(r_, this), this.groupTransform = st.IDENTITY, t == null ? void 0 : t.addChild(this), this._updateIsSimple();
    }
    disableRenderGroup() {
      if (!this.renderGroup) return;
      const t = this.parentRenderGroup;
      t == null ? void 0 : t.removeChild(this), vt.return(this.renderGroup), this.renderGroup = null, this.groupTransform = this.relativeGroupTransform, t == null ? void 0 : t.addChild(this), this._updateIsSimple();
    }
    _updateIsSimple() {
      this.isSimple = !this.renderGroup && this.effects.length === 0;
    }
    get worldTransform() {
      return this._worldTransform || (this._worldTransform = new st()), this.renderGroup ? this._worldTransform.copyFrom(this.renderGroup.worldTransform) : this.parentRenderGroup && this._worldTransform.appendFrom(this.relativeGroupTransform, this.parentRenderGroup.worldTransform), this._worldTransform;
    }
    get x() {
      return this._position.x;
    }
    set x(t) {
      this._position.x = t;
    }
    get y() {
      return this._position.y;
    }
    set y(t) {
      this._position.y = t;
    }
    get position() {
      return this._position;
    }
    set position(t) {
      this._position.copyFrom(t);
    }
    get rotation() {
      return this._rotation;
    }
    set rotation(t) {
      this._rotation !== t && (this._rotation = t, this._onUpdate(this._skew));
    }
    get angle() {
      return this.rotation * Rp;
    }
    set angle(t) {
      this.rotation = t * Pp;
    }
    get pivot() {
      return this._pivot === Dn && (this._pivot = new Xt(this, 0, 0)), this._pivot;
    }
    set pivot(t) {
      this._pivot === Dn && (this._pivot = new Xt(this, 0, 0)), typeof t == "number" ? this._pivot.set(t) : this._pivot.copyFrom(t);
    }
    get skew() {
      return this._skew === Mn && (this._skew = new Xt(this, 0, 0)), this._skew;
    }
    set skew(t) {
      this._skew === Mn && (this._skew = new Xt(this, 0, 0)), this._skew.copyFrom(t);
    }
    get scale() {
      return this._scale === In && (this._scale = new Xt(this, 1, 1)), this._scale;
    }
    set scale(t) {
      this._scale === In && (this._scale = new Xt(this, 0, 0)), typeof t == "number" ? this._scale.set(t) : this._scale.copyFrom(t);
    }
    get width() {
      return Math.abs(this.scale.x * this.getLocalBounds().width);
    }
    set width(t) {
      const e = this.getLocalBounds().width;
      this._setWidth(t, e);
    }
    get height() {
      return Math.abs(this.scale.y * this.getLocalBounds().height);
    }
    set height(t) {
      const e = this.getLocalBounds().height;
      this._setHeight(t, e);
    }
    getSize(t) {
      t || (t = {});
      const e = this.getLocalBounds();
      return t.width = Math.abs(this.scale.x * e.width), t.height = Math.abs(this.scale.y * e.height), t;
    }
    setSize(t, e) {
      const r = this.getLocalBounds();
      let s, n;
      typeof t != "object" ? (s = t, n = e ?? t) : (s = t.width, n = t.height ?? t.width), s !== void 0 && this._setWidth(s, r.width), n !== void 0 && this._setHeight(n, r.height);
    }
    _updateSkew() {
      const t = this._rotation, e = this._skew;
      this._cx = Math.cos(t + e._y), this._sx = Math.sin(t + e._y), this._cy = -Math.sin(t - e._x), this._sy = Math.cos(t - e._x);
    }
    updateTransform(t) {
      return this.position.set(typeof t.x == "number" ? t.x : this.position.x, typeof t.y == "number" ? t.y : this.position.y), this.scale.set(typeof t.scaleX == "number" ? t.scaleX || 1 : this.scale.x, typeof t.scaleY == "number" ? t.scaleY || 1 : this.scale.y), this.rotation = typeof t.rotation == "number" ? t.rotation : this.rotation, this.skew.set(typeof t.skewX == "number" ? t.skewX : this.skew.x, typeof t.skewY == "number" ? t.skewY : this.skew.y), this.pivot.set(typeof t.pivotX == "number" ? t.pivotX : this.pivot.x, typeof t.pivotY == "number" ? t.pivotY : this.pivot.y), this;
    }
    setFromMatrix(t) {
      t.decompose(this);
    }
    updateLocalTransform() {
      const t = this._didChangeId & 4095;
      if (this._didLocalTransformChangeId === t) return;
      this._didLocalTransformChangeId = t;
      const e = this.localTransform, r = this._scale, s = this._pivot, n = this._position, o = r._x, a = r._y, c = s._x, l = s._y;
      e.a = this._cx * o, e.b = this._sx * o, e.c = this._cy * a, e.d = this._sy * a, e.tx = n._x - (c * e.a + l * e.c), e.ty = n._y - (c * e.b + l * e.d);
    }
    set alpha(t) {
      t !== this.localAlpha && (this.localAlpha = t, this._updateFlags |= Bs, this._onUpdate());
    }
    get alpha() {
      return this.localAlpha;
    }
    set tint(t) {
      const r = Tt.shared.setValue(t ?? 16777215).toBgrNumber();
      r !== this.localColor && (this.localColor = r, this._updateFlags |= Bs, this._onUpdate());
    }
    get tint() {
      const t = this.localColor;
      return ((t & 255) << 16) + (t & 65280) + (t >> 16 & 255);
    }
    set blendMode(t) {
      this.localBlendMode !== t && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = true), this._updateFlags |= ea, this.localBlendMode = t, this._onUpdate());
    }
    get blendMode() {
      return this.localBlendMode;
    }
    get visible() {
      return !!(this.localDisplayStatus & 2);
    }
    set visible(t) {
      const e = t ? 2 : 0;
      (this.localDisplayStatus & 2) !== e && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = true), this._updateFlags |= xi, this.localDisplayStatus ^= 2, this._onUpdate());
    }
    get culled() {
      return !(this.localDisplayStatus & 4);
    }
    set culled(t) {
      const e = t ? 0 : 4;
      (this.localDisplayStatus & 4) !== e && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = true), this._updateFlags |= xi, this.localDisplayStatus ^= 4, this._onUpdate());
    }
    get renderable() {
      return !!(this.localDisplayStatus & 1);
    }
    set renderable(t) {
      const e = t ? 1 : 0;
      (this.localDisplayStatus & 1) !== e && (this._updateFlags |= xi, this.localDisplayStatus ^= 1, this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = true), this._onUpdate());
    }
    get isRenderable() {
      return this.localDisplayStatus === 7 && this.groupAlpha > 0;
    }
    destroy(t = false) {
      var _a2;
      if (this.destroyed) return;
      this.destroyed = true;
      const e = this.removeChildren(0, this.children.length);
      if (this.removeFromParent(), this.parent = null, this._maskEffect = null, this._filterEffect = null, this.effects = null, this._position = null, this._scale = null, this._pivot = null, this._skew = null, this.emit("destroyed", this), this.removeAllListeners(), typeof t == "boolean" ? t : t == null ? void 0 : t.children) for (let s = 0; s < e.length; ++s) e[s].destroy(t);
      (_a2 = this.renderGroup) == null ? void 0 : _a2.destroy(), this.renderGroup = null;
    }
  };
  Dt.mixin(Xp);
  Dt.mixin(e_);
  Dt.mixin(Zp);
  Dt.mixin(Jp);
  Dt.mixin($p);
  Dt.mixin(Yp);
  Dt.mixin(Qp);
  Dt.mixin(Wp);
  class hr extends Dt {
    constructor(t = Z.EMPTY) {
      t instanceof Z && (t = {
        texture: t
      });
      const { texture: e = Z.EMPTY, anchor: r, roundPixels: s, width: n, height: o, ...a } = t;
      super({
        label: "Sprite",
        ...a
      }), this.renderPipeId = "sprite", this.batched = true, this._didSpriteUpdate = false, this._bounds = {
        minX: 0,
        maxX: 1,
        minY: 0,
        maxY: 0
      }, this._sourceBounds = {
        minX: 0,
        maxX: 1,
        minY: 0,
        maxY: 0
      }, this._boundsDirty = true, this._sourceBoundsDirty = true, this._roundPixels = 0, this._anchor = new Xt({
        _onUpdate: () => {
          this.onViewUpdate();
        }
      }), r ? this.anchor = r : e.defaultAnchor && (this.anchor = e.defaultAnchor), this.texture = e, this.allowChildren = false, this.roundPixels = s ?? false, n !== void 0 && (this.width = n), o !== void 0 && (this.height = o);
    }
    static from(t, e = false) {
      return t instanceof Z ? new hr(t) : new hr(Z.from(t, e));
    }
    set texture(t) {
      t || (t = Z.EMPTY);
      const e = this._texture;
      e !== t && (e && e.dynamic && e.off("update", this.onViewUpdate, this), t.dynamic && t.on("update", this.onViewUpdate, this), this._texture = t, this._width && this._setWidth(this._width, this._texture.orig.width), this._height && this._setHeight(this._height, this._texture.orig.height), this.onViewUpdate());
    }
    get texture() {
      return this._texture;
    }
    get bounds() {
      return this._boundsDirty && (this._updateBounds(), this._boundsDirty = false), this._bounds;
    }
    get sourceBounds() {
      return this._sourceBoundsDirty && (this._updateSourceBounds(), this._sourceBoundsDirty = false), this._sourceBounds;
    }
    containsPoint(t) {
      const e = this.sourceBounds;
      return t.x >= e.maxX && t.x <= e.minX && t.y >= e.maxY && t.y <= e.minY;
    }
    addBounds(t) {
      const e = this._texture.trim ? this.sourceBounds : this.bounds;
      t.addFrame(e.minX, e.minY, e.maxX, e.maxY);
    }
    onViewUpdate() {
      if (this._didChangeId += 4096, this._didSpriteUpdate = true, this._sourceBoundsDirty = this._boundsDirty = true, this.didViewUpdate) return;
      this.didViewUpdate = true;
      const t = this.renderGroup || this.parentRenderGroup;
      t && t.onChildViewUpdate(this);
    }
    _updateBounds() {
      As(this._bounds, this._anchor, this._texture, 0);
    }
    _updateSourceBounds() {
      const t = this._anchor, e = this._texture, r = this._sourceBounds, { width: s, height: n } = e.orig;
      r.maxX = -t._x * s, r.minX = r.maxX + s, r.maxY = -t._y * n, r.minY = r.maxY + n;
    }
    destroy(t = false) {
      if (super.destroy(t), typeof t == "boolean" ? t : t == null ? void 0 : t.texture) {
        const r = typeof t == "boolean" ? t : t == null ? void 0 : t.textureSource;
        this._texture.destroy(r);
      }
      this._texture = null, this._bounds = null, this._sourceBounds = null, this._anchor = null;
    }
    get anchor() {
      return this._anchor;
    }
    set anchor(t) {
      typeof t == "number" ? this._anchor.set(t) : this._anchor.copyFrom(t);
    }
    get roundPixels() {
      return !!this._roundPixels;
    }
    set roundPixels(t) {
      this._roundPixels = t ? 1 : 0;
    }
    get width() {
      return Math.abs(this.scale.x) * this._texture.orig.width;
    }
    set width(t) {
      this._setWidth(t, this._texture.orig.width), this._width = t;
    }
    get height() {
      return Math.abs(this.scale.y) * this._texture.orig.height;
    }
    set height(t) {
      this._setHeight(t, this._texture.orig.height), this._height = t;
    }
    getSize(t) {
      return t || (t = {}), t.width = Math.abs(this.scale.x) * this._texture.orig.width, t.height = Math.abs(this.scale.y) * this._texture.orig.height, t;
    }
    setSize(t, e) {
      let r, s;
      typeof t != "object" ? (r = t, s = e ?? t) : (r = t.width, s = t.height ?? t.width), r !== void 0 && this._setWidth(r, this._texture.orig.width), s !== void 0 && this._setHeight(s, this._texture.orig.height);
    }
  }
  const s_ = new re();
  function Vl(i, t, e) {
    const r = s_;
    i.measurable = true, Xs(i, e, r), t.addBoundsMask(r), i.measurable = false;
  }
  function Xl(i, t, e) {
    const r = Je.get();
    i.measurable = true;
    const s = Ke.get().identity(), n = ql(i, e, s);
    ta(i, r, n), i.measurable = false, t.addBoundsMask(r), Ke.return(s), Je.return(r);
  }
  function ql(i, t, e) {
    return i ? (i !== t && (ql(i.parent, t, e), i.updateLocalTransform(), e.append(i.localTransform)), e) : (ut("Mask bounds, renderable is not inside the root container"), e);
  }
  class $l {
    constructor(t) {
      this.priority = 0, this.pipe = "alphaMask", (t == null ? void 0 : t.mask) && this.init(t.mask);
    }
    init(t) {
      this.mask = t, this.renderMaskToTexture = !(t instanceof hr), this.mask.renderable = this.renderMaskToTexture, this.mask.includeInBuild = !this.renderMaskToTexture, this.mask.measurable = false;
    }
    reset() {
      this.mask.measurable = true, this.mask = null;
    }
    addBounds(t, e) {
      Vl(this.mask, t, e);
    }
    addLocalBounds(t, e) {
      Xl(this.mask, t, e);
    }
    containsPoint(t, e) {
      const r = this.mask;
      return e(r, t);
    }
    destroy() {
      this.reset();
    }
    static test(t) {
      return t instanceof hr;
    }
  }
  $l.extension = P.MaskEffect;
  class Yl {
    constructor(t) {
      this.priority = 0, this.pipe = "colorMask", (t == null ? void 0 : t.mask) && this.init(t.mask);
    }
    init(t) {
      this.mask = t;
    }
    destroy() {
    }
    static test(t) {
      return typeof t == "number";
    }
  }
  Yl.extension = P.MaskEffect;
  class Kl {
    constructor(t) {
      this.priority = 0, this.pipe = "stencilMask", (t == null ? void 0 : t.mask) && this.init(t.mask);
    }
    init(t) {
      this.mask = t, this.mask.includeInBuild = false, this.mask.measurable = false;
    }
    reset() {
      this.mask.measurable = true, this.mask.includeInBuild = true, this.mask = null;
    }
    addBounds(t, e) {
      Vl(this.mask, t, e);
    }
    addLocalBounds(t, e) {
      Xl(this.mask, t, e);
    }
    containsPoint(t, e) {
      const r = this.mask;
      return e(r, t);
    }
    destroy() {
      this.reset();
    }
    static test(t) {
      return t instanceof Dt;
    }
  }
  Kl.extension = P.MaskEffect;
  const n_ = {
    createCanvas: (i, t) => {
      const e = document.createElement("canvas");
      return e.width = i, e.height = t, e;
    },
    getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
    getWebGLRenderingContext: () => WebGLRenderingContext,
    getNavigator: () => navigator,
    getBaseUrl: () => document.baseURI ?? window.location.href,
    getFontFaceSet: () => document.fonts,
    fetch: (i, t) => fetch(i, t),
    parseXML: (i) => new DOMParser().parseFromString(i, "text/xml")
  };
  let _c = n_;
  const St = {
    get() {
      return _c;
    },
    set(i) {
      _c = i;
    }
  };
  class Jr extends Ht {
    constructor(t) {
      t.resource || (t.resource = St.get().createCanvas()), t.width || (t.width = t.resource.width, t.autoDensity || (t.width /= t.resolution)), t.height || (t.height = t.resource.height, t.autoDensity || (t.height /= t.resolution)), super(t), this.uploadMethodId = "image", this.autoDensity = t.autoDensity;
      const e = t.resource;
      (this.pixelWidth !== e.width || this.pixelWidth !== e.height) && this.resizeCanvas(), this.transparent = !!t.transparent;
    }
    resizeCanvas() {
      this.autoDensity && (this.resource.style.width = `${this.width}px`, this.resource.style.height = `${this.height}px`), (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight) && (this.resource.width = this.pixelWidth, this.resource.height = this.pixelHeight);
    }
    resize(t = this.width, e = this.height, r = this._resolution) {
      const s = super.resize(t, e, r);
      return s && this.resizeCanvas(), s;
    }
    static test(t) {
      return globalThis.HTMLCanvasElement && t instanceof HTMLCanvasElement || globalThis.OffscreenCanvas && t instanceof OffscreenCanvas;
    }
  }
  Jr.extension = P.TextureSource;
  class ei extends Ht {
    constructor(t) {
      if (t.resource && globalThis.HTMLImageElement && t.resource instanceof HTMLImageElement) {
        const e = St.get().createCanvas(t.resource.width, t.resource.height);
        e.getContext("2d").drawImage(t.resource, 0, 0, t.resource.width, t.resource.height), t.resource = e, ut("ImageSource: Image element passed, converting to canvas. Use CanvasSource instead.");
      }
      super(t), this.uploadMethodId = "image", this.autoGarbageCollect = true;
    }
    static test(t) {
      return globalThis.HTMLImageElement && t instanceof HTMLImageElement || typeof ImageBitmap < "u" && t instanceof ImageBitmap;
    }
  }
  ei.extension = P.TextureSource;
  var dr = ((i) => (i[i.INTERACTION = 50] = "INTERACTION", i[i.HIGH = 25] = "HIGH", i[i.NORMAL = 0] = "NORMAL", i[i.LOW = -25] = "LOW", i[i.UTILITY = -50] = "UTILITY", i))(dr || {});
  class Fn {
    constructor(t, e = null, r = 0, s = false) {
      this.next = null, this.previous = null, this._destroyed = false, this._fn = t, this._context = e, this.priority = r, this._once = s;
    }
    match(t, e = null) {
      return this._fn === t && this._context === e;
    }
    emit(t) {
      this._fn && (this._context ? this._fn.call(this._context, t) : this._fn(t));
      const e = this.next;
      return this._once && this.destroy(true), this._destroyed && (this.next = null), e;
    }
    connect(t) {
      this.previous = t, t.next && (t.next.previous = this), this.next = t.next, t.next = this;
    }
    destroy(t = false) {
      this._destroyed = true, this._fn = null, this._context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous);
      const e = this.next;
      return this.next = t ? null : e, this.previous = null, e;
    }
  }
  const Jl = class le {
    constructor() {
      this.autoStart = false, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = false, this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this._protected = false, this._lastFrame = -1, this._head = new Fn(null, null, 1 / 0), this.deltaMS = 1 / le.targetFPMS, this.elapsedMS = 1 / le.targetFPMS, this._tick = (t) => {
        this._requestId = null, this.started && (this.update(t), this.started && this._requestId === null && this._head.next && (this._requestId = requestAnimationFrame(this._tick)));
      };
    }
    _requestIfNeeded() {
      this._requestId === null && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick));
    }
    _cancelIfNeeded() {
      this._requestId !== null && (cancelAnimationFrame(this._requestId), this._requestId = null);
    }
    _startIfPossible() {
      this.started ? this._requestIfNeeded() : this.autoStart && this.start();
    }
    add(t, e, r = dr.NORMAL) {
      return this._addListener(new Fn(t, e, r));
    }
    addOnce(t, e, r = dr.NORMAL) {
      return this._addListener(new Fn(t, e, r, true));
    }
    _addListener(t) {
      let e = this._head.next, r = this._head;
      if (!e) t.connect(r);
      else {
        for (; e; ) {
          if (t.priority > e.priority) {
            t.connect(r);
            break;
          }
          r = e, e = e.next;
        }
        t.previous || t.connect(r);
      }
      return this._startIfPossible(), this;
    }
    remove(t, e) {
      let r = this._head.next;
      for (; r; ) r.match(t, e) ? r = r.destroy() : r = r.next;
      return this._head.next || this._cancelIfNeeded(), this;
    }
    get count() {
      if (!this._head) return 0;
      let t = 0, e = this._head;
      for (; e = e.next; ) t++;
      return t;
    }
    start() {
      this.started || (this.started = true, this._requestIfNeeded());
    }
    stop() {
      this.started && (this.started = false, this._cancelIfNeeded());
    }
    destroy() {
      if (!this._protected) {
        this.stop();
        let t = this._head.next;
        for (; t; ) t = t.destroy(true);
        this._head.destroy(), this._head = null;
      }
    }
    update(t = performance.now()) {
      let e;
      if (t > this.lastTime) {
        if (e = this.elapsedMS = t - this.lastTime, e > this._maxElapsedMS && (e = this._maxElapsedMS), e *= this.speed, this._minElapsedMS) {
          const n = t - this._lastFrame | 0;
          if (n < this._minElapsedMS) return;
          this._lastFrame = t - n % this._minElapsedMS;
        }
        this.deltaMS = e, this.deltaTime = this.deltaMS * le.targetFPMS;
        const r = this._head;
        let s = r.next;
        for (; s; ) s = s.emit(this);
        r.next || this._cancelIfNeeded();
      } else this.deltaTime = this.deltaMS = this.elapsedMS = 0;
      this.lastTime = t;
    }
    get FPS() {
      return 1e3 / this.elapsedMS;
    }
    get minFPS() {
      return 1e3 / this._maxElapsedMS;
    }
    set minFPS(t) {
      const e = Math.min(this.maxFPS, t), r = Math.min(Math.max(0, e) / 1e3, le.targetFPMS);
      this._maxElapsedMS = 1 / r;
    }
    get maxFPS() {
      return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0;
    }
    set maxFPS(t) {
      if (t === 0) this._minElapsedMS = 0;
      else {
        const e = Math.max(this.minFPS, t);
        this._minElapsedMS = 1 / (e / 1e3);
      }
    }
    static get shared() {
      if (!le._shared) {
        const t = le._shared = new le();
        t.autoStart = true, t._protected = true;
      }
      return le._shared;
    }
    static get system() {
      if (!le._system) {
        const t = le._system = new le();
        t.autoStart = true, t._protected = true;
      }
      return le._system;
    }
  };
  Jl.targetFPMS = 0.06;
  let ae = Jl, Un;
  async function Zl() {
    return Un ?? (Un = (async () => {
      var _a2;
      const t = document.createElement("canvas").getContext("webgl");
      if (!t) return "premultiply-alpha-on-upload";
      const e = await new Promise((o) => {
        const a = document.createElement("video");
        a.onloadeddata = () => o(a), a.onerror = () => o(null), a.autoplay = false, a.crossOrigin = "anonymous", a.preload = "auto", a.src = "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=", a.load();
      });
      if (!e) return "premultiply-alpha-on-upload";
      const r = t.createTexture();
      t.bindTexture(t.TEXTURE_2D, r);
      const s = t.createFramebuffer();
      t.bindFramebuffer(t.FRAMEBUFFER, s), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, r, 0), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false), t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, t.NONE), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, e);
      const n = new Uint8Array(4);
      return t.readPixels(0, 0, 1, 1, t.RGBA, t.UNSIGNED_BYTE, n), t.deleteFramebuffer(s), t.deleteTexture(r), (_a2 = t.getExtension("WEBGL_lose_context")) == null ? void 0 : _a2.loseContext(), n[0] <= n[3] ? "premultiplied-alpha" : "premultiply-alpha-on-upload";
    })()), Un;
  }
  const qs = class Ql extends Ht {
    constructor(t) {
      super(t), this.isReady = false, this.uploadMethodId = "video", t = {
        ...Ql.defaultOptions,
        ...t
      }, this._autoUpdate = true, this._isConnectedToTicker = false, this._updateFPS = t.updateFPS || 0, this._msToNextUpdate = 0, this.autoPlay = t.autoPlay !== false, this.alphaMode = t.alphaMode ?? "premultiply-alpha-on-upload", this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this), this._videoFrameRequestCallbackHandle = null, this._load = null, this._resolve = null, this._reject = null, this._onCanPlay = this._onCanPlay.bind(this), this._onCanPlayThrough = this._onCanPlayThrough.bind(this), this._onError = this._onError.bind(this), this._onPlayStart = this._onPlayStart.bind(this), this._onPlayStop = this._onPlayStop.bind(this), this._onSeeked = this._onSeeked.bind(this), t.autoLoad !== false && this.load();
    }
    updateFrame() {
      if (!this.destroyed) {
        if (this._updateFPS) {
          const t = ae.shared.elapsedMS * this.resource.playbackRate;
          this._msToNextUpdate = Math.floor(this._msToNextUpdate - t);
        }
        (!this._updateFPS || this._msToNextUpdate <= 0) && (this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0), this.isValid && this.update();
      }
    }
    _videoFrameRequestCallback() {
      this.updateFrame(), this.destroyed ? this._videoFrameRequestCallbackHandle = null : this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(this._videoFrameRequestCallback);
    }
    get isValid() {
      return !!this.resource.videoWidth && !!this.resource.videoHeight;
    }
    async load() {
      if (this._load) return this._load;
      const t = this.resource, e = this.options;
      return (t.readyState === t.HAVE_ENOUGH_DATA || t.readyState === t.HAVE_FUTURE_DATA) && t.width && t.height && (t.complete = true), t.addEventListener("play", this._onPlayStart), t.addEventListener("pause", this._onPlayStop), t.addEventListener("seeked", this._onSeeked), this._isSourceReady() ? this._mediaReady() : (e.preload || t.addEventListener("canplay", this._onCanPlay), t.addEventListener("canplaythrough", this._onCanPlayThrough), t.addEventListener("error", this._onError, true)), this.alphaMode = await Zl(), this._load = new Promise((r, s) => {
        this.isValid ? r(this) : (this._resolve = r, this._reject = s, e.preloadTimeoutMs !== void 0 && (this._preloadTimeout = setTimeout(() => {
          this._onError(new ErrorEvent(`Preload exceeded timeout of ${e.preloadTimeoutMs}ms`));
        })), t.load());
      }), this._load;
    }
    _onError(t) {
      this.resource.removeEventListener("error", this._onError, true), this.emit("error", t), this._reject && (this._reject(t), this._reject = null, this._resolve = null);
    }
    _isSourcePlaying() {
      const t = this.resource;
      return !t.paused && !t.ended;
    }
    _isSourceReady() {
      return this.resource.readyState > 2;
    }
    _onPlayStart() {
      this.isValid || this._mediaReady(), this._configureAutoUpdate();
    }
    _onPlayStop() {
      this._configureAutoUpdate();
    }
    _onSeeked() {
      this._autoUpdate && !this._isSourcePlaying() && (this._msToNextUpdate = 0, this.updateFrame(), this._msToNextUpdate = 0);
    }
    _onCanPlay() {
      this.resource.removeEventListener("canplay", this._onCanPlay), this._mediaReady();
    }
    _onCanPlayThrough() {
      this.resource.removeEventListener("canplaythrough", this._onCanPlay), this._preloadTimeout && (clearTimeout(this._preloadTimeout), this._preloadTimeout = void 0), this._mediaReady();
    }
    _mediaReady() {
      const t = this.resource;
      this.isValid && (this.isReady = true, this.resize(t.videoWidth, t.videoHeight)), this._msToNextUpdate = 0, this.updateFrame(), this._msToNextUpdate = 0, this._resolve && (this._resolve(this), this._resolve = null, this._reject = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && this.resource.play();
    }
    destroy() {
      this._configureAutoUpdate();
      const t = this.resource;
      t && (t.removeEventListener("play", this._onPlayStart), t.removeEventListener("pause", this._onPlayStop), t.removeEventListener("seeked", this._onSeeked), t.removeEventListener("canplay", this._onCanPlay), t.removeEventListener("canplaythrough", this._onCanPlayThrough), t.removeEventListener("error", this._onError, true), t.pause(), t.src = "", t.load()), super.destroy();
    }
    get autoUpdate() {
      return this._autoUpdate;
    }
    set autoUpdate(t) {
      t !== this._autoUpdate && (this._autoUpdate = t, this._configureAutoUpdate());
    }
    get updateFPS() {
      return this._updateFPS;
    }
    set updateFPS(t) {
      t !== this._updateFPS && (this._updateFPS = t, this._configureAutoUpdate());
    }
    _configureAutoUpdate() {
      this._autoUpdate && this._isSourcePlaying() ? !this._updateFPS && this.resource.requestVideoFrameCallback ? (this._isConnectedToTicker && (ae.shared.remove(this.updateFrame, this), this._isConnectedToTicker = false, this._msToNextUpdate = 0), this._videoFrameRequestCallbackHandle === null && (this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(this._videoFrameRequestCallback))) : (this._videoFrameRequestCallbackHandle !== null && (this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker || (ae.shared.add(this.updateFrame, this), this._isConnectedToTicker = true, this._msToNextUpdate = 0)) : (this._videoFrameRequestCallbackHandle !== null && (this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker && (ae.shared.remove(this.updateFrame, this), this._isConnectedToTicker = false, this._msToNextUpdate = 0));
    }
    static test(t) {
      return globalThis.HTMLVideoElement && t instanceof HTMLVideoElement || globalThis.VideoFrame && t instanceof VideoFrame;
    }
  };
  qs.extension = P.TextureSource;
  qs.defaultOptions = {
    ...Ht.defaultOptions,
    autoLoad: true,
    autoPlay: true,
    updateFPS: 0,
    crossorigin: true,
    loop: false,
    muted: true,
    playsinline: true,
    preload: false
  };
  qs.MIME_TYPES = {
    ogv: "video/ogg",
    mov: "video/quicktime",
    m4v: "video/mp4"
  };
  let vs = qs;
  const Re = (i, t, e = false) => (Array.isArray(i) || (i = [
    i
  ]), t ? i.map((r) => typeof r == "string" || e ? t(r) : r) : i);
  class o_ {
    constructor() {
      this._parsers = [], this._cache = /* @__PURE__ */ new Map(), this._cacheMap = /* @__PURE__ */ new Map();
    }
    reset() {
      this._cacheMap.clear(), this._cache.clear();
    }
    has(t) {
      return this._cache.has(t);
    }
    get(t) {
      const e = this._cache.get(t);
      return e || ut(`[Assets] Asset id ${t} was not found in the Cache`), e;
    }
    set(t, e) {
      const r = Re(t);
      let s;
      for (let c = 0; c < this.parsers.length; c++) {
        const l = this.parsers[c];
        if (l.test(e)) {
          s = l.getCacheableAssets(r, e);
          break;
        }
      }
      const n = new Map(Object.entries(s || {}));
      s || r.forEach((c) => {
        n.set(c, e);
      });
      const o = [
        ...n.keys()
      ], a = {
        cacheKeys: o,
        keys: r
      };
      r.forEach((c) => {
        this._cacheMap.set(c, a);
      }), o.forEach((c) => {
        const l = s ? s[c] : e;
        this._cache.has(c) && this._cache.get(c) !== l && ut("[Cache] already has key:", c), this._cache.set(c, n.get(c));
      });
    }
    remove(t) {
      if (!this._cacheMap.has(t)) {
        ut(`[Assets] Asset id ${t} was not found in the Cache`);
        return;
      }
      const e = this._cacheMap.get(t);
      e.cacheKeys.forEach((s) => {
        this._cache.delete(s);
      }), e.keys.forEach((s) => {
        this._cacheMap.delete(s);
      });
    }
    get parsers() {
      return this._parsers;
    }
  }
  const Ct = new o_(), Eo = [];
  Mt.handleByList(P.TextureSource, Eo);
  function th(i = {}) {
    const t = i && i.resource, e = t ? i.resource : i, r = t ? i : {
      resource: i
    };
    for (let s = 0; s < Eo.length; s++) {
      const n = Eo[s];
      if (n.test(e)) return new n(r);
    }
    throw new Error(`Could not find a source type for resource: ${r.resource}`);
  }
  function a_(i = {}, t = false) {
    const e = i && i.resource, r = e ? i.resource : i, s = e ? i : {
      resource: i
    };
    if (!t && Ct.has(r)) return Ct.get(r);
    const n = new Z({
      source: th(s)
    });
    return n.on("destroy", () => {
      Ct.has(r) && Ct.remove(r);
    }), t || Ct.set(r, n), n;
  }
  function c_(i, t = false) {
    return typeof i == "string" ? Ct.get(i) : i instanceof Ht ? new Z({
      source: i
    }) : a_(i, t);
  }
  Z.from = c_;
  Ht.from = th;
  Mt.add($l, Yl, Kl, vs, ei, Jr, Zo);
  var ve = ((i) => (i[i.Low = 0] = "Low", i[i.Normal = 1] = "Normal", i[i.High = 2] = "High", i))(ve || {});
  function Te(i) {
    if (typeof i != "string") throw new TypeError(`Path must be a string. Received ${JSON.stringify(i)}`);
  }
  function oi(i) {
    return i.split("?")[0].split("#")[0];
  }
  function u_(i) {
    return i.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  function l_(i, t, e) {
    return i.replace(new RegExp(u_(t), "g"), e);
  }
  function h_(i, t) {
    let e = "", r = 0, s = -1, n = 0, o = -1;
    for (let a = 0; a <= i.length; ++a) {
      if (a < i.length) o = i.charCodeAt(a);
      else {
        if (o === 47) break;
        o = 47;
      }
      if (o === 47) {
        if (!(s === a - 1 || n === 1)) if (s !== a - 1 && n === 2) {
          if (e.length < 2 || r !== 2 || e.charCodeAt(e.length - 1) !== 46 || e.charCodeAt(e.length - 2) !== 46) {
            if (e.length > 2) {
              const c = e.lastIndexOf("/");
              if (c !== e.length - 1) {
                c === -1 ? (e = "", r = 0) : (e = e.slice(0, c), r = e.length - 1 - e.lastIndexOf("/")), s = a, n = 0;
                continue;
              }
            } else if (e.length === 2 || e.length === 1) {
              e = "", r = 0, s = a, n = 0;
              continue;
            }
          }
          t && (e.length > 0 ? e += "/.." : e = "..", r = 2);
        } else e.length > 0 ? e += `/${i.slice(s + 1, a)}` : e = i.slice(s + 1, a), r = a - s - 1;
        s = a, n = 0;
      } else o === 46 && n !== -1 ? ++n : n = -1;
    }
    return e;
  }
  const _e = {
    toPosix(i) {
      return l_(i, "\\", "/");
    },
    isUrl(i) {
      return /^https?:/.test(this.toPosix(i));
    },
    isDataUrl(i) {
      return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(i);
    },
    isBlobUrl(i) {
      return i.startsWith("blob:");
    },
    hasProtocol(i) {
      return /^[^/:]+:/.test(this.toPosix(i));
    },
    getProtocol(i) {
      Te(i), i = this.toPosix(i);
      const t = /^file:\/\/\//.exec(i);
      if (t) return t[0];
      const e = /^[^/:]+:\/{0,2}/.exec(i);
      return e ? e[0] : "";
    },
    toAbsolute(i, t, e) {
      if (Te(i), this.isDataUrl(i) || this.isBlobUrl(i)) return i;
      const r = oi(this.toPosix(t ?? St.get().getBaseUrl())), s = oi(this.toPosix(e ?? this.rootname(r)));
      return i = this.toPosix(i), i.startsWith("/") ? _e.join(s, i.slice(1)) : this.isAbsolute(i) ? i : this.join(r, i);
    },
    normalize(i) {
      if (Te(i), i.length === 0) return ".";
      if (this.isDataUrl(i) || this.isBlobUrl(i)) return i;
      i = this.toPosix(i);
      let t = "";
      const e = i.startsWith("/");
      this.hasProtocol(i) && (t = this.rootname(i), i = i.slice(t.length));
      const r = i.endsWith("/");
      return i = h_(i, false), i.length > 0 && r && (i += "/"), e ? `/${i}` : t + i;
    },
    isAbsolute(i) {
      return Te(i), i = this.toPosix(i), this.hasProtocol(i) ? true : i.startsWith("/");
    },
    join(...i) {
      if (i.length === 0) return ".";
      let t;
      for (let e = 0; e < i.length; ++e) {
        const r = i[e];
        if (Te(r), r.length > 0) if (t === void 0) t = r;
        else {
          const s = i[e - 1] ?? "";
          this.joinExtensions.includes(this.extname(s).toLowerCase()) ? t += `/../${r}` : t += `/${r}`;
        }
      }
      return t === void 0 ? "." : this.normalize(t);
    },
    dirname(i) {
      if (Te(i), i.length === 0) return ".";
      i = this.toPosix(i);
      let t = i.charCodeAt(0);
      const e = t === 47;
      let r = -1, s = true;
      const n = this.getProtocol(i), o = i;
      i = i.slice(n.length);
      for (let a = i.length - 1; a >= 1; --a) if (t = i.charCodeAt(a), t === 47) {
        if (!s) {
          r = a;
          break;
        }
      } else s = false;
      return r === -1 ? e ? "/" : this.isUrl(o) ? n + i : n : e && r === 1 ? "//" : n + i.slice(0, r);
    },
    rootname(i) {
      Te(i), i = this.toPosix(i);
      let t = "";
      if (i.startsWith("/") ? t = "/" : t = this.getProtocol(i), this.isUrl(i)) {
        const e = i.indexOf("/", t.length);
        e !== -1 ? t = i.slice(0, e) : t = i, t.endsWith("/") || (t += "/");
      }
      return t;
    },
    basename(i, t) {
      Te(i), t && Te(t), i = oi(this.toPosix(i));
      let e = 0, r = -1, s = true, n;
      if (t !== void 0 && t.length > 0 && t.length <= i.length) {
        if (t.length === i.length && t === i) return "";
        let o = t.length - 1, a = -1;
        for (n = i.length - 1; n >= 0; --n) {
          const c = i.charCodeAt(n);
          if (c === 47) {
            if (!s) {
              e = n + 1;
              break;
            }
          } else a === -1 && (s = false, a = n + 1), o >= 0 && (c === t.charCodeAt(o) ? --o === -1 && (r = n) : (o = -1, r = a));
        }
        return e === r ? r = a : r === -1 && (r = i.length), i.slice(e, r);
      }
      for (n = i.length - 1; n >= 0; --n) if (i.charCodeAt(n) === 47) {
        if (!s) {
          e = n + 1;
          break;
        }
      } else r === -1 && (s = false, r = n + 1);
      return r === -1 ? "" : i.slice(e, r);
    },
    extname(i) {
      Te(i), i = oi(this.toPosix(i));
      let t = -1, e = 0, r = -1, s = true, n = 0;
      for (let o = i.length - 1; o >= 0; --o) {
        const a = i.charCodeAt(o);
        if (a === 47) {
          if (!s) {
            e = o + 1;
            break;
          }
          continue;
        }
        r === -1 && (s = false, r = o + 1), a === 46 ? t === -1 ? t = o : n !== 1 && (n = 1) : t !== -1 && (n = -1);
      }
      return t === -1 || r === -1 || n === 0 || n === 1 && t === r - 1 && t === e + 1 ? "" : i.slice(t, r);
    },
    parse(i) {
      Te(i);
      const t = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
      };
      if (i.length === 0) return t;
      i = oi(this.toPosix(i));
      let e = i.charCodeAt(0);
      const r = this.isAbsolute(i);
      let s;
      const n = "";
      t.root = this.rootname(i), r || this.hasProtocol(i) ? s = 1 : s = 0;
      let o = -1, a = 0, c = -1, l = true, u = i.length - 1, h = 0;
      for (; u >= s; --u) {
        if (e = i.charCodeAt(u), e === 47) {
          if (!l) {
            a = u + 1;
            break;
          }
          continue;
        }
        c === -1 && (l = false, c = u + 1), e === 46 ? o === -1 ? o = u : h !== 1 && (h = 1) : o !== -1 && (h = -1);
      }
      return o === -1 || c === -1 || h === 0 || h === 1 && o === c - 1 && o === a + 1 ? c !== -1 && (a === 0 && r ? t.base = t.name = i.slice(1, c) : t.base = t.name = i.slice(a, c)) : (a === 0 && r ? (t.name = i.slice(1, o), t.base = i.slice(1, c)) : (t.name = i.slice(a, o), t.base = i.slice(a, c)), t.ext = i.slice(o, c)), t.dir = this.dirname(i), n && (t.dir = n + t.dir), t;
    },
    sep: "/",
    delimiter: ":",
    joinExtensions: [
      ".html"
    ]
  };
  function eh(i, t, e, r, s) {
    const n = t[e];
    for (let o = 0; o < n.length; o++) {
      const a = n[o];
      e < t.length - 1 ? eh(i.replace(r[e], a), t, e + 1, r, s) : s.push(i.replace(r[e], a));
    }
  }
  function d_(i) {
    const t = /\{(.*?)\}/g, e = i.match(t), r = [];
    if (e) {
      const s = [];
      e.forEach((n) => {
        const o = n.substring(1, n.length - 1).split(",");
        s.push(o);
      }), eh(i, s, 0, e, r);
    } else r.push(i);
    return r;
  }
  const Ms = (i) => !Array.isArray(i);
  class Ir {
    constructor() {
      this._defaultBundleIdentifierOptions = {
        connector: "-",
        createBundleAssetId: (t, e) => `${t}${this._bundleIdConnector}${e}`,
        extractAssetIdFromBundle: (t, e) => e.replace(`${t}${this._bundleIdConnector}`, "")
      }, this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector, this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId, this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle, this._assetMap = {}, this._preferredOrder = [], this._parsers = [], this._resolverHash = {}, this._bundles = {};
    }
    setBundleIdentifier(t) {
      if (this._bundleIdConnector = t.connector ?? this._bundleIdConnector, this._createBundleAssetId = t.createBundleAssetId ?? this._createBundleAssetId, this._extractAssetIdFromBundle = t.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle, this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar") throw new Error("[Resolver] GenerateBundleAssetId are not working correctly");
    }
    prefer(...t) {
      t.forEach((e) => {
        this._preferredOrder.push(e), e.priority || (e.priority = Object.keys(e.params));
      }), this._resolverHash = {};
    }
    set basePath(t) {
      this._basePath = t;
    }
    get basePath() {
      return this._basePath;
    }
    set rootPath(t) {
      this._rootPath = t;
    }
    get rootPath() {
      return this._rootPath;
    }
    get parsers() {
      return this._parsers;
    }
    reset() {
      this.setBundleIdentifier(this._defaultBundleIdentifierOptions), this._assetMap = {}, this._preferredOrder = [], this._resolverHash = {}, this._rootPath = null, this._basePath = null, this._manifest = null, this._bundles = {}, this._defaultSearchParams = null;
    }
    setDefaultSearchParams(t) {
      if (typeof t == "string") this._defaultSearchParams = t;
      else {
        const e = t;
        this._defaultSearchParams = Object.keys(e).map((r) => `${encodeURIComponent(r)}=${encodeURIComponent(e[r])}`).join("&");
      }
    }
    getAlias(t) {
      const { alias: e, src: r } = t;
      return Re(e || r, (n) => typeof n == "string" ? n : Array.isArray(n) ? n.map((o) => (o == null ? void 0 : o.src) ?? o) : (n == null ? void 0 : n.src) ? n.src : n, true);
    }
    addManifest(t) {
      this._manifest && ut("[Resolver] Manifest already exists, this will be overwritten"), this._manifest = t, t.bundles.forEach((e) => {
        this.addBundle(e.name, e.assets);
      });
    }
    addBundle(t, e) {
      const r = [];
      let s = e;
      Array.isArray(e) || (s = Object.entries(e).map(([n, o]) => typeof o == "string" || Array.isArray(o) ? {
        alias: n,
        src: o
      } : {
        alias: n,
        ...o
      })), s.forEach((n) => {
        const o = n.src, a = n.alias;
        let c;
        if (typeof a == "string") {
          const l = this._createBundleAssetId(t, a);
          r.push(l), c = [
            a,
            l
          ];
        } else {
          const l = a.map((u) => this._createBundleAssetId(t, u));
          r.push(...l), c = [
            ...a,
            ...l
          ];
        }
        this.add({
          ...n,
          alias: c,
          src: o
        });
      }), this._bundles[t] = r;
    }
    add(t) {
      const e = [];
      Array.isArray(t) ? e.push(...t) : e.push(t);
      let r;
      r = (n) => {
        this.hasKey(n) && ut(`[Resolver] already has key: ${n} overwriting`);
      }, Re(e).forEach((n) => {
        const { src: o } = n;
        let { data: a, format: c, loadParser: l } = n;
        const u = Re(o).map((p) => typeof p == "string" ? d_(p) : Array.isArray(p) ? p : [
          p
        ]), h = this.getAlias(n);
        Array.isArray(h) ? h.forEach(r) : r(h);
        const d = [];
        u.forEach((p) => {
          p.forEach((g) => {
            let y = {};
            if (typeof g != "object") {
              y.src = g;
              for (let m = 0; m < this._parsers.length; m++) {
                const v = this._parsers[m];
                if (v.test(g)) {
                  y = v.parse(g);
                  break;
                }
              }
            } else a = g.data ?? a, c = g.format ?? c, l = g.loadParser ?? l, y = {
              ...y,
              ...g
            };
            if (!h) throw new Error(`[Resolver] alias is undefined for this asset: ${y.src}`);
            y = this._buildResolvedAsset(y, {
              aliases: h,
              data: a,
              format: c,
              loadParser: l
            }), d.push(y);
          });
        }), h.forEach((p) => {
          this._assetMap[p] = d;
        });
      });
    }
    resolveBundle(t) {
      const e = Ms(t);
      t = Re(t);
      const r = {};
      return t.forEach((s) => {
        const n = this._bundles[s];
        if (n) {
          const o = this.resolve(n), a = {};
          for (const c in o) {
            const l = o[c];
            a[this._extractAssetIdFromBundle(s, c)] = l;
          }
          r[s] = a;
        }
      }), e ? r[t[0]] : r;
    }
    resolveUrl(t) {
      const e = this.resolve(t);
      if (typeof t != "string") {
        const r = {};
        for (const s in e) r[s] = e[s].src;
        return r;
      }
      return e.src;
    }
    resolve(t) {
      const e = Ms(t);
      t = Re(t);
      const r = {};
      return t.forEach((s) => {
        if (!this._resolverHash[s]) if (this._assetMap[s]) {
          let n = this._assetMap[s];
          const o = this._getPreferredOrder(n);
          o == null ? void 0 : o.priority.forEach((a) => {
            o.params[a].forEach((c) => {
              const l = n.filter((u) => u[a] ? u[a] === c : false);
              l.length && (n = l);
            });
          }), this._resolverHash[s] = n[0];
        } else this._resolverHash[s] = this._buildResolvedAsset({
          alias: [
            s
          ],
          src: s
        }, {});
        r[s] = this._resolverHash[s];
      }), e ? r[t[0]] : r;
    }
    hasKey(t) {
      return !!this._assetMap[t];
    }
    hasBundle(t) {
      return !!this._bundles[t];
    }
    _getPreferredOrder(t) {
      for (let e = 0; e < t.length; e++) {
        const r = t[0], s = this._preferredOrder.find((n) => n.params.format.includes(r.format));
        if (s) return s;
      }
      return this._preferredOrder[0];
    }
    _appendDefaultSearchParams(t) {
      if (!this._defaultSearchParams) return t;
      const e = /\?/.test(t) ? "&" : "?";
      return `${t}${e}${this._defaultSearchParams}`;
    }
    _buildResolvedAsset(t, e) {
      const { aliases: r, data: s, loadParser: n, format: o } = e;
      return (this._basePath || this._rootPath) && (t.src = _e.toAbsolute(t.src, this._basePath, this._rootPath)), t.alias = r ?? t.alias ?? [
        t.src
      ], t.src = this._appendDefaultSearchParams(t.src), t.data = {
        ...s || {},
        ...t.data
      }, t.loadParser = n ?? t.loadParser, t.format = o ?? t.format ?? f_(t.src), t;
    }
  }
  Ir.RETINA_PREFIX = /@([0-9\.]+)x/;
  function f_(i) {
    return i.split(".").pop().split("?").shift().split("#").shift();
  }
  const To = (i, t) => {
    const e = t.split("?")[1];
    return e && (i += `?${e}`), i;
  }, rh = class mi {
    constructor(t, e) {
      this.linkedSheets = [], this._texture = t instanceof Z ? t : null, this.textureSource = t.source, this.textures = {}, this.animations = {}, this.data = e;
      const r = parseFloat(e.meta.scale);
      r ? (this.resolution = r, t.source.resolution = this.resolution) : this.resolution = t.source._resolution, this._frames = this.data.frames, this._frameKeys = Object.keys(this._frames), this._batchIndex = 0, this._callback = null;
    }
    parse() {
      return new Promise((t) => {
        this._callback = t, this._batchIndex = 0, this._frameKeys.length <= mi.BATCH_SIZE ? (this._processFrames(0), this._processAnimations(), this._parseComplete()) : this._nextBatch();
      });
    }
    _processFrames(t) {
      let e = t;
      const r = mi.BATCH_SIZE;
      for (; e - t < r && e < this._frameKeys.length; ) {
        const s = this._frameKeys[e], n = this._frames[s], o = n.frame;
        if (o) {
          let a = null, c = null;
          const l = n.trimmed !== false && n.sourceSize ? n.sourceSize : n.frame, u = new Et(0, 0, Math.floor(l.w) / this.resolution, Math.floor(l.h) / this.resolution);
          n.rotated ? a = new Et(Math.floor(o.x) / this.resolution, Math.floor(o.y) / this.resolution, Math.floor(o.h) / this.resolution, Math.floor(o.w) / this.resolution) : a = new Et(Math.floor(o.x) / this.resolution, Math.floor(o.y) / this.resolution, Math.floor(o.w) / this.resolution, Math.floor(o.h) / this.resolution), n.trimmed !== false && n.spriteSourceSize && (c = new Et(Math.floor(n.spriteSourceSize.x) / this.resolution, Math.floor(n.spriteSourceSize.y) / this.resolution, Math.floor(o.w) / this.resolution, Math.floor(o.h) / this.resolution)), this.textures[s] = new Z({
            source: this.textureSource,
            frame: a,
            orig: u,
            trim: c,
            rotate: n.rotated ? 2 : 0,
            defaultAnchor: n.anchor,
            defaultBorders: n.borders,
            label: s.toString()
          });
        }
        e++;
      }
    }
    _processAnimations() {
      const t = this.data.animations || {};
      for (const e in t) {
        this.animations[e] = [];
        for (let r = 0; r < t[e].length; r++) {
          const s = t[e][r];
          this.animations[e].push(this.textures[s]);
        }
      }
    }
    _parseComplete() {
      const t = this._callback;
      this._callback = null, this._batchIndex = 0, t.call(this, this.textures);
    }
    _nextBatch() {
      this._processFrames(this._batchIndex * mi.BATCH_SIZE), this._batchIndex++, setTimeout(() => {
        this._batchIndex * mi.BATCH_SIZE < this._frameKeys.length ? this._nextBatch() : (this._processAnimations(), this._parseComplete());
      }, 0);
    }
    destroy(t = false) {
      var _a2;
      for (const e in this.textures) this.textures[e].destroy();
      this._frames = null, this._frameKeys = null, this.data = null, this.textures = null, t && ((_a2 = this._texture) == null ? void 0 : _a2.destroy(), this.textureSource.destroy()), this._texture = null, this.textureSource = null, this.linkedSheets = [];
    }
  };
  rh.BATCH_SIZE = 1e3;
  let gc = rh;
  const p_ = [
    "jpg",
    "png",
    "jpeg",
    "avif",
    "webp",
    "basis",
    "etc2",
    "bc7",
    "bc6h",
    "bc5",
    "bc4",
    "bc3",
    "bc2",
    "bc1",
    "eac",
    "astc"
  ];
  function ih(i, t, e) {
    const r = {};
    if (i.forEach((s) => {
      r[s] = t;
    }), Object.keys(t.textures).forEach((s) => {
      r[s] = t.textures[s];
    }), !e) {
      const s = _e.dirname(i[0]);
      t.linkedSheets.forEach((n, o) => {
        const a = ih([
          `${s}/${t.data.meta.related_multi_packs[o]}`
        ], n, true);
        Object.assign(r, a);
      });
    }
    return r;
  }
  const __ = {
    extension: P.Asset,
    cache: {
      test: (i) => i instanceof gc,
      getCacheableAssets: (i, t) => ih(i, t, false)
    },
    resolver: {
      extension: {
        type: P.ResolveParser,
        name: "resolveSpritesheet"
      },
      test: (i) => {
        const e = i.split("?")[0].split("."), r = e.pop(), s = e.pop();
        return r === "json" && p_.includes(s);
      },
      parse: (i) => {
        var _a2;
        const t = i.split(".");
        return {
          resolution: parseFloat(((_a2 = Ir.RETINA_PREFIX.exec(i)) == null ? void 0 : _a2[1]) ?? "1"),
          format: t[t.length - 2],
          src: i
        };
      }
    },
    loader: {
      name: "spritesheetLoader",
      extension: {
        type: P.LoadParser,
        priority: ve.Normal,
        name: "spritesheetLoader"
      },
      async testParse(i, t) {
        return _e.extname(t.src).toLowerCase() === ".json" && !!i.frames;
      },
      async parse(i, t, e) {
        var _a2, _b2;
        const { texture: r, imageFilename: s } = (t == null ? void 0 : t.data) ?? {};
        let n = _e.dirname(t.src);
        n && n.lastIndexOf("/") !== n.length - 1 && (n += "/");
        let o;
        if (r instanceof Z) o = r;
        else {
          const l = To(n + (s ?? i.meta.image), t.src);
          o = (await e.load([
            l
          ]))[l];
        }
        const a = new gc(o.source, i);
        await a.parse();
        const c = (_a2 = i == null ? void 0 : i.meta) == null ? void 0 : _a2.related_multi_packs;
        if (Array.isArray(c)) {
          const l = [];
          for (const h of c) {
            if (typeof h != "string") continue;
            let d = n + h;
            ((_b2 = t.data) == null ? void 0 : _b2.ignoreMultiPack) || (d = To(d, t.src), l.push(e.load({
              src: d,
              data: {
                ignoreMultiPack: true
              }
            })));
          }
          const u = await Promise.all(l);
          a.linkedSheets = u, u.forEach((h) => {
            h.linkedSheets = [
              a
            ].concat(a.linkedSheets.filter((d) => d !== h));
          });
        }
        return a;
      },
      async unload(i, t, e) {
        await e.unload(i.textureSource._sourceOrigin), i.destroy(false);
      }
    }
  };
  Mt.add(__);
  class Ii {
    constructor(t) {
      this.bubbles = true, this.cancelBubble = true, this.cancelable = false, this.composed = false, this.defaultPrevented = false, this.eventPhase = Ii.prototype.NONE, this.propagationStopped = false, this.propagationImmediatelyStopped = false, this.layer = new At(), this.page = new At(), this.NONE = 0, this.CAPTURING_PHASE = 1, this.AT_TARGET = 2, this.BUBBLING_PHASE = 3, this.manager = t;
    }
    get layerX() {
      return this.layer.x;
    }
    get layerY() {
      return this.layer.y;
    }
    get pageX() {
      return this.page.x;
    }
    get pageY() {
      return this.page.y;
    }
    get data() {
      return this;
    }
    composedPath() {
      return this.manager && (!this.path || this.path[this.path.length - 1] !== this.target) && (this.path = this.target ? this.manager.propagationPath(this.target) : []), this.path;
    }
    initEvent(t, e, r) {
      throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
    }
    initUIEvent(t, e, r, s, n) {
      throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
    }
    preventDefault() {
      this.nativeEvent instanceof Event && this.nativeEvent.cancelable && this.nativeEvent.preventDefault(), this.defaultPrevented = true;
    }
    stopImmediatePropagation() {
      this.propagationImmediatelyStopped = true;
    }
    stopPropagation() {
      this.propagationStopped = true;
    }
  }
  var kn = /iPhone/i, mc = /iPod/i, bc = /iPad/i, wc = /\biOS-universal(?:.+)Mac\b/i, Gn = /\bAndroid(?:.+)Mobile\b/i, yc = /Android/i, Nr = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i, Yi = /Silk/i, Ve = /Windows Phone/i, xc = /\bWindows(?:.+)ARM\b/i, vc = /BlackBerry/i, Sc = /BB10/i, Ec = /Opera Mini/i, Tc = /\b(CriOS|Chrome)(?:.+)Mobile/i, Cc = /Mobile(?:.+)Firefox\b/i, Ac = function(i) {
    return typeof i < "u" && i.platform === "MacIntel" && typeof i.maxTouchPoints == "number" && i.maxTouchPoints > 1 && typeof MSStream > "u";
  };
  function g_(i) {
    return function(t) {
      return t.test(i);
    };
  }
  function Rc(i) {
    var t = {
      userAgent: "",
      platform: "",
      maxTouchPoints: 0
    };
    !i && typeof navigator < "u" ? t = {
      userAgent: navigator.userAgent,
      platform: navigator.platform,
      maxTouchPoints: navigator.maxTouchPoints || 0
    } : typeof i == "string" ? t.userAgent = i : i && i.userAgent && (t = {
      userAgent: i.userAgent,
      platform: i.platform,
      maxTouchPoints: i.maxTouchPoints || 0
    });
    var e = t.userAgent, r = e.split("[FBAN");
    typeof r[1] < "u" && (e = r[0]), r = e.split("Twitter"), typeof r[1] < "u" && (e = r[0]);
    var s = g_(e), n = {
      apple: {
        phone: s(kn) && !s(Ve),
        ipod: s(mc),
        tablet: !s(kn) && (s(bc) || Ac(t)) && !s(Ve),
        universal: s(wc),
        device: (s(kn) || s(mc) || s(bc) || s(wc) || Ac(t)) && !s(Ve)
      },
      amazon: {
        phone: s(Nr),
        tablet: !s(Nr) && s(Yi),
        device: s(Nr) || s(Yi)
      },
      android: {
        phone: !s(Ve) && s(Nr) || !s(Ve) && s(Gn),
        tablet: !s(Ve) && !s(Nr) && !s(Gn) && (s(Yi) || s(yc)),
        device: !s(Ve) && (s(Nr) || s(Yi) || s(Gn) || s(yc)) || s(/\bokhttp\b/i)
      },
      windows: {
        phone: s(Ve),
        tablet: s(xc),
        device: s(Ve) || s(xc)
      },
      other: {
        blackberry: s(vc),
        blackberry10: s(Sc),
        opera: s(Ec),
        firefox: s(Cc),
        chrome: s(Tc),
        device: s(vc) || s(Sc) || s(Ec) || s(Cc) || s(Tc)
      },
      any: false,
      phone: false,
      tablet: false
    };
    return n.any = n.apple.device || n.android.device || n.windows.device || n.other.device, n.phone = n.apple.phone || n.android.phone || n.windows.phone, n.tablet = n.apple.tablet || n.android.tablet || n.windows.tablet, n;
  }
  const m_ = Rc.default ?? Rc, b_ = m_(globalThis.navigator), w_ = 9, Ki = 100, y_ = 0, x_ = 0, Pc = 2, Bc = 1, v_ = -1e3, S_ = -1e3, E_ = 2;
  T_ = class {
    constructor(t, e = b_) {
      this._mobileInfo = e, this.debug = false, this._isActive = false, this._isMobileAccessibility = false, this._pool = [], this._renderId = 0, this._children = [], this._androidUpdateCount = 0, this._androidUpdateFrequency = 500, this._hookDiv = null, (e.tablet || e.phone) && this._createTouchHook();
      const r = document.createElement("div");
      r.style.width = `${Ki}px`, r.style.height = `${Ki}px`, r.style.position = "absolute", r.style.top = `${y_}px`, r.style.left = `${x_}px`, r.style.zIndex = Pc.toString(), this._div = r, this._renderer = t, this._onKeyDown = this._onKeyDown.bind(this), this._onMouseMove = this._onMouseMove.bind(this), globalThis.addEventListener("keydown", this._onKeyDown, false);
    }
    get isActive() {
      return this._isActive;
    }
    get isMobileAccessibility() {
      return this._isMobileAccessibility;
    }
    get hookDiv() {
      return this._hookDiv;
    }
    _createTouchHook() {
      const t = document.createElement("button");
      t.style.width = `${Bc}px`, t.style.height = `${Bc}px`, t.style.position = "absolute", t.style.top = `${v_}px`, t.style.left = `${S_}px`, t.style.zIndex = E_.toString(), t.style.backgroundColor = "#FF0000", t.title = "select to enable accessibility for this content", t.addEventListener("focus", () => {
        this._isMobileAccessibility = true, this._activate(), this._destroyTouchHook();
      }), document.body.appendChild(t), this._hookDiv = t;
    }
    _destroyTouchHook() {
      this._hookDiv && (document.body.removeChild(this._hookDiv), this._hookDiv = null);
    }
    _activate() {
      var _a2;
      this._isActive || (this._isActive = true, globalThis.document.addEventListener("mousemove", this._onMouseMove, true), globalThis.removeEventListener("keydown", this._onKeyDown, false), this._renderer.runners.postrender.add(this), (_a2 = this._renderer.view.canvas.parentNode) == null ? void 0 : _a2.appendChild(this._div));
    }
    _deactivate() {
      var _a2;
      !this._isActive || this._isMobileAccessibility || (this._isActive = false, globalThis.document.removeEventListener("mousemove", this._onMouseMove, true), globalThis.addEventListener("keydown", this._onKeyDown, false), this._renderer.runners.postrender.remove(this), (_a2 = this._div.parentNode) == null ? void 0 : _a2.removeChild(this._div));
    }
    _updateAccessibleObjects(t) {
      if (!t.visible || !t.accessibleChildren) return;
      t.accessible && t.isInteractive() && (t._accessibleActive || this._addChild(t), t._renderId = this._renderId);
      const e = t.children;
      if (e) for (let r = 0; r < e.length; r++) this._updateAccessibleObjects(e[r]);
    }
    init(t) {
      this.debug = (t == null ? void 0 : t.debug) ?? this.debug, this._renderer.runners.postrender.remove(this);
    }
    postrender() {
      const t = performance.now();
      if (this._mobileInfo.android.device && t < this._androidUpdateCount || (this._androidUpdateCount = t + this._androidUpdateFrequency, !this._renderer.renderingToScreen || !this._renderer.view.canvas)) return;
      this._renderer.lastObjectRendered && this._updateAccessibleObjects(this._renderer.lastObjectRendered);
      const { x: e, y: r, width: s, height: n } = this._renderer.view.canvas.getBoundingClientRect(), { width: o, height: a, resolution: c } = this._renderer, l = s / o * c, u = n / a * c;
      let h = this._div;
      h.style.left = `${e}px`, h.style.top = `${r}px`, h.style.width = `${o}px`, h.style.height = `${a}px`;
      for (let d = 0; d < this._children.length; d++) {
        const p = this._children[d];
        if (p._renderId !== this._renderId) p._accessibleActive = false, Ll(this._children, d, 1), this._div.removeChild(p._accessibleDiv), this._pool.push(p._accessibleDiv), p._accessibleDiv = null, d--;
        else {
          h = p._accessibleDiv;
          let g = p.hitArea;
          const y = p.worldTransform;
          p.hitArea ? (h.style.left = `${(y.tx + g.x * y.a) * l}px`, h.style.top = `${(y.ty + g.y * y.d) * u}px`, h.style.width = `${g.width * y.a * l}px`, h.style.height = `${g.height * y.d * u}px`) : (g = p.getBounds().rectangle, this._capHitArea(g), h.style.left = `${g.x * l}px`, h.style.top = `${g.y * u}px`, h.style.width = `${g.width * l}px`, h.style.height = `${g.height * u}px`, h.title !== p.accessibleTitle && p.accessibleTitle !== null && (h.title = p.accessibleTitle || ""), h.getAttribute("aria-label") !== p.accessibleHint && p.accessibleHint !== null && h.setAttribute("aria-label", p.accessibleHint || "")), (p.accessibleTitle !== h.title || p.tabIndex !== h.tabIndex) && (h.title = p.accessibleTitle || "", h.tabIndex = p.tabIndex, this.debug && this._updateDebugHTML(h));
        }
      }
      this._renderId++;
    }
    _updateDebugHTML(t) {
      t.innerHTML = `type: ${t.type}</br> title : ${t.title}</br> tabIndex: ${t.tabIndex}`;
    }
    _capHitArea(t) {
      t.x < 0 && (t.width += t.x, t.x = 0), t.y < 0 && (t.height += t.y, t.y = 0);
      const { width: e, height: r } = this._renderer;
      t.x + t.width > e && (t.width = e - t.x), t.y + t.height > r && (t.height = r - t.y);
    }
    _addChild(t) {
      let e = this._pool.pop();
      e || (e = document.createElement("button"), e.style.width = `${Ki}px`, e.style.height = `${Ki}px`, e.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent", e.style.position = "absolute", e.style.zIndex = Pc.toString(), e.style.borderStyle = "none", navigator.userAgent.toLowerCase().includes("chrome") ? e.setAttribute("aria-live", "off") : e.setAttribute("aria-live", "polite"), navigator.userAgent.match(/rv:.*Gecko\//) ? e.setAttribute("aria-relevant", "additions") : e.setAttribute("aria-relevant", "text"), e.addEventListener("click", this._onClick.bind(this)), e.addEventListener("focus", this._onFocus.bind(this)), e.addEventListener("focusout", this._onFocusOut.bind(this))), e.style.pointerEvents = t.accessiblePointerEvents, e.type = t.accessibleType, t.accessibleTitle && t.accessibleTitle !== null ? e.title = t.accessibleTitle : (!t.accessibleHint || t.accessibleHint === null) && (e.title = `container ${t.tabIndex}`), t.accessibleHint && t.accessibleHint !== null && e.setAttribute("aria-label", t.accessibleHint), this.debug && this._updateDebugHTML(e), t._accessibleActive = true, t._accessibleDiv = e, e.container = t, this._children.push(t), this._div.appendChild(t._accessibleDiv), t._accessibleDiv.tabIndex = t.tabIndex;
    }
    _dispatchEvent(t, e) {
      const { container: r } = t.target, s = this._renderer.events.rootBoundary, n = Object.assign(new Ii(s), {
        target: r
      });
      s.rootTarget = this._renderer.lastObjectRendered, e.forEach((o) => s.dispatchEvent(n, o));
    }
    _onClick(t) {
      this._dispatchEvent(t, [
        "click",
        "pointertap",
        "tap"
      ]);
    }
    _onFocus(t) {
      t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "assertive"), this._dispatchEvent(t, [
        "mouseover"
      ]);
    }
    _onFocusOut(t) {
      t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "polite"), this._dispatchEvent(t, [
        "mouseout"
      ]);
    }
    _onKeyDown(t) {
      t.keyCode === w_ && this._activate();
    }
    _onMouseMove(t) {
      t.movementX === 0 && t.movementY === 0 || this._deactivate();
    }
    destroy() {
      this._destroyTouchHook(), this._div = null, globalThis.document.removeEventListener("mousemove", this._onMouseMove, true), globalThis.removeEventListener("keydown", this._onKeyDown), this._pool = null, this._children = null, this._renderer = null;
    }
  };
  T_.extension = {
    type: [
      P.WebGLSystem,
      P.WebGPUSystem
    ],
    name: "accessibility"
  };
  let On, Mc;
  Q3 = {
    accessible: false,
    accessibleTitle: null,
    accessibleHint: null,
    tabIndex: 0,
    _accessibleActive: false,
    _accessibleDiv: null,
    accessibleType: "button",
    accessiblePointerEvents: "auto",
    accessibleChildren: true,
    _renderId: -1
  };
  On = /* @__PURE__ */ Object.create(null);
  Mc = /* @__PURE__ */ Object.create(null);
  function $s(i, t) {
    let e = Mc[i];
    return e === void 0 && (On[t] === void 0 && (On[t] = 1), Mc[i] = e = On[t]++), e;
  }
  let Ji;
  function sh() {
    return (!Ji || (Ji == null ? void 0 : Ji.isContextLost())) && (Ji = St.get().createCanvas().getContext("webgl", {})), Ji;
  }
  let Zi;
  function C_() {
    if (!Zi) {
      Zi = "mediump";
      const i = sh();
      i && i.getShaderPrecisionFormat && (Zi = i.getShaderPrecisionFormat(i.FRAGMENT_SHADER, i.HIGH_FLOAT).precision ? "highp" : "mediump");
    }
    return Zi;
  }
  function A_(i, t, e) {
    return t ? i : e ? (i = i.replace("out vec4 finalColor;", ""), `
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in varying
        #define finalColor gl_FragColor
        #define texture texture2D
        #endif
        ${i}
        `) : `
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in attribute
        #define out varying
        #endif
        ${i}
        `;
  }
  function R_(i, t, e) {
    const r = e ? t.maxSupportedFragmentPrecision : t.maxSupportedVertexPrecision;
    if (i.substring(0, 9) !== "precision") {
      let s = e ? t.requestedFragmentPrecision : t.requestedVertexPrecision;
      return s === "highp" && r !== "highp" && (s = "mediump"), `precision ${s} float;
${i}`;
    } else if (r !== "highp" && i.substring(0, 15) === "precision highp") return i.replace("precision highp", "precision mediump");
    return i;
  }
  function P_(i, t) {
    return t ? `#version 300 es
${i}` : i;
  }
  const B_ = {}, M_ = {};
  function D_(i, { name: t = "pixi-program" }, e = true) {
    t = t.replace(/\s+/g, "-"), t += e ? "-fragment" : "-vertex";
    const r = e ? B_ : M_;
    return r[t] ? (r[t]++, t += `-${r[t]}`) : r[t] = 1, i.indexOf("#define SHADER_NAME") !== -1 ? i : `${`#define SHADER_NAME ${t}`}
${i}`;
  }
  function I_(i, t) {
    return t ? i.replace("#version 300 es", "") : i;
  }
  const Nn = {
    stripVersion: I_,
    ensurePrecision: R_,
    addProgramDefines: A_,
    setProgramName: D_,
    insertVersion: P_
  }, Ln = /* @__PURE__ */ Object.create(null), nh = class Co {
    constructor(t) {
      t = {
        ...Co.defaultOptions,
        ...t
      };
      const e = t.fragment.indexOf("#version 300 es") !== -1, r = {
        stripVersion: e,
        ensurePrecision: {
          requestedFragmentPrecision: t.preferredFragmentPrecision,
          requestedVertexPrecision: t.preferredVertexPrecision,
          maxSupportedVertexPrecision: "highp",
          maxSupportedFragmentPrecision: C_()
        },
        setProgramName: {
          name: t.name
        },
        addProgramDefines: e,
        insertVersion: e
      };
      let s = t.fragment, n = t.vertex;
      Object.keys(Nn).forEach((o) => {
        const a = r[o];
        s = Nn[o](s, a, true), n = Nn[o](n, a, false);
      }), this.fragment = s, this.vertex = n, this._key = $s(`${this.vertex}:${this.fragment}`, "gl-program");
    }
    destroy() {
      this.fragment = null, this.vertex = null, this._attributeData = null, this._uniformData = null, this._uniformBlockData = null, this.transformFeedbackVaryings = null;
    }
    static from(t) {
      const e = `${t.vertex}:${t.fragment}`;
      return Ln[e] || (Ln[e] = new Co(t)), Ln[e];
    }
  };
  nh.defaultOptions = {
    preferredVertexPrecision: "highp",
    preferredFragmentPrecision: "mediump"
  };
  let ir = nh;
  const Dc = {
    uint8x2: {
      size: 2,
      stride: 2,
      normalised: false
    },
    uint8x4: {
      size: 4,
      stride: 4,
      normalised: false
    },
    sint8x2: {
      size: 2,
      stride: 2,
      normalised: false
    },
    sint8x4: {
      size: 4,
      stride: 4,
      normalised: false
    },
    unorm8x2: {
      size: 2,
      stride: 2,
      normalised: true
    },
    unorm8x4: {
      size: 4,
      stride: 4,
      normalised: true
    },
    snorm8x2: {
      size: 2,
      stride: 2,
      normalised: true
    },
    snorm8x4: {
      size: 4,
      stride: 4,
      normalised: true
    },
    uint16x2: {
      size: 2,
      stride: 4,
      normalised: false
    },
    uint16x4: {
      size: 4,
      stride: 8,
      normalised: false
    },
    sint16x2: {
      size: 2,
      stride: 4,
      normalised: false
    },
    sint16x4: {
      size: 4,
      stride: 8,
      normalised: false
    },
    unorm16x2: {
      size: 2,
      stride: 4,
      normalised: true
    },
    unorm16x4: {
      size: 4,
      stride: 8,
      normalised: true
    },
    snorm16x2: {
      size: 2,
      stride: 4,
      normalised: true
    },
    snorm16x4: {
      size: 4,
      stride: 8,
      normalised: true
    },
    float16x2: {
      size: 2,
      stride: 4,
      normalised: false
    },
    float16x4: {
      size: 4,
      stride: 8,
      normalised: false
    },
    float32: {
      size: 1,
      stride: 4,
      normalised: false
    },
    float32x2: {
      size: 2,
      stride: 8,
      normalised: false
    },
    float32x3: {
      size: 3,
      stride: 12,
      normalised: false
    },
    float32x4: {
      size: 4,
      stride: 16,
      normalised: false
    },
    uint32: {
      size: 1,
      stride: 4,
      normalised: false
    },
    uint32x2: {
      size: 2,
      stride: 8,
      normalised: false
    },
    uint32x3: {
      size: 3,
      stride: 12,
      normalised: false
    },
    uint32x4: {
      size: 4,
      stride: 16,
      normalised: false
    },
    sint32: {
      size: 1,
      stride: 4,
      normalised: false
    },
    sint32x2: {
      size: 2,
      stride: 8,
      normalised: false
    },
    sint32x3: {
      size: 3,
      stride: 12,
      normalised: false
    },
    sint32x4: {
      size: 4,
      stride: 16,
      normalised: false
    }
  };
  function Ai(i) {
    return Dc[i] ?? Dc.float32;
  }
  const F_ = {
    f32: "float32",
    "vec2<f32>": "float32x2",
    "vec3<f32>": "float32x3",
    "vec4<f32>": "float32x4",
    vec2f: "float32x2",
    vec3f: "float32x3",
    vec4f: "float32x4",
    i32: "sint32",
    "vec2<i32>": "sint32x2",
    "vec3<i32>": "sint32x3",
    "vec4<i32>": "sint32x4",
    u32: "uint32",
    "vec2<u32>": "uint32x2",
    "vec3<u32>": "uint32x3",
    "vec4<u32>": "uint32x4",
    bool: "uint32",
    "vec2<bool>": "uint32x2",
    "vec3<bool>": "uint32x3",
    "vec4<bool>": "uint32x4"
  };
  function U_({ source: i, entryPoint: t }) {
    const e = {}, r = i.indexOf(`fn ${t}`);
    if (r !== -1) {
      const s = i.indexOf("->", r);
      if (s !== -1) {
        const n = i.substring(r, s), o = /@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g;
        let a;
        for (; (a = o.exec(n)) !== null; ) {
          const c = F_[a[3]] ?? "float32";
          e[a[2]] = {
            location: parseInt(a[1], 10),
            format: c,
            stride: Ai(c).stride,
            offset: 0,
            instance: false,
            start: 0
          };
        }
      }
    }
    return e;
  }
  function Hn(i) {
    var _a2, _b2;
    const t = /(^|[^/])@(group|binding)\(\d+\)[^;]+;/g, e = /@group\((\d+)\)/, r = /@binding\((\d+)\)/, s = /var(<[^>]+>)? (\w+)/, n = /:\s*(\w+)/, o = /struct\s+(\w+)\s*{([^}]+)}/g, a = /(\w+)\s*:\s*([\w\<\>]+)/g, c = /struct\s+(\w+)/, l = (_a2 = i.match(t)) == null ? void 0 : _a2.map((h) => ({
      group: parseInt(h.match(e)[1], 10),
      binding: parseInt(h.match(r)[1], 10),
      name: h.match(s)[2],
      isUniform: h.match(s)[1] === "<uniform>",
      type: h.match(n)[1]
    }));
    if (!l) return {
      groups: [],
      structs: []
    };
    const u = ((_b2 = i.match(o)) == null ? void 0 : _b2.map((h) => {
      const d = h.match(c)[1], p = h.match(a).reduce((g, y) => {
        const [m, v] = y.split(":");
        return g[m.trim()] = v.trim(), g;
      }, {});
      return p ? {
        name: d,
        members: p
      } : null;
    }).filter(({ name: h }) => l.some((d) => d.type === h))) ?? [];
    return {
      groups: l,
      structs: u
    };
  }
  var bi = ((i) => (i[i.VERTEX = 1] = "VERTEX", i[i.FRAGMENT = 2] = "FRAGMENT", i[i.COMPUTE = 4] = "COMPUTE", i))(bi || {});
  function k_({ groups: i }) {
    const t = [];
    for (let e = 0; e < i.length; e++) {
      const r = i[e];
      t[r.group] || (t[r.group] = []), r.isUniform ? t[r.group].push({
        binding: r.binding,
        visibility: bi.VERTEX | bi.FRAGMENT,
        buffer: {
          type: "uniform"
        }
      }) : r.type === "sampler" ? t[r.group].push({
        binding: r.binding,
        visibility: bi.FRAGMENT,
        sampler: {
          type: "filtering"
        }
      }) : r.type === "texture_2d" && t[r.group].push({
        binding: r.binding,
        visibility: bi.FRAGMENT,
        texture: {
          sampleType: "float",
          viewDimension: "2d",
          multisampled: false
        }
      });
    }
    return t;
  }
  function G_({ groups: i }) {
    const t = [];
    for (let e = 0; e < i.length; e++) {
      const r = i[e];
      t[r.group] || (t[r.group] = {}), t[r.group][r.name] = r.binding;
    }
    return t;
  }
  function O_(i, t) {
    const e = /* @__PURE__ */ new Set(), r = /* @__PURE__ */ new Set(), s = [
      ...i.structs,
      ...t.structs
    ].filter((o) => e.has(o.name) ? false : (e.add(o.name), true)), n = [
      ...i.groups,
      ...t.groups
    ].filter((o) => {
      const a = `${o.name}-${o.binding}`;
      return r.has(a) ? false : (r.add(a), true);
    });
    return {
      structs: s,
      groups: n
    };
  }
  const zn = /* @__PURE__ */ Object.create(null);
  class Ne {
    constructor(t) {
      var _a2, _b2;
      this._layoutKey = 0;
      const { fragment: e, vertex: r, layout: s, gpuLayout: n, name: o } = t;
      if (this.name = o, this.fragment = e, this.vertex = r, e.source === r.source) {
        const a = Hn(e.source);
        this.structsAndGroups = a;
      } else {
        const a = Hn(r.source), c = Hn(e.source);
        this.structsAndGroups = O_(a, c);
      }
      this.layout = s ?? G_(this.structsAndGroups), this.gpuLayout = n ?? k_(this.structsAndGroups), this.autoAssignGlobalUniforms = ((_a2 = this.layout[0]) == null ? void 0 : _a2.globalUniforms) !== void 0, this.autoAssignLocalUniforms = ((_b2 = this.layout[1]) == null ? void 0 : _b2.localUniforms) !== void 0, this._generateProgramKey();
    }
    _generateProgramKey() {
      const { vertex: t, fragment: e } = this, r = t.source + e.source + t.entryPoint + e.entryPoint;
      this._layoutKey = $s(r, "program");
    }
    get attributeData() {
      return this._attributeData ?? (this._attributeData = U_(this.vertex)), this._attributeData;
    }
    destroy() {
      this.gpuLayout = null, this.layout = null, this.structsAndGroups = null, this.fragment = null, this.vertex = null;
    }
    static from(t) {
      const e = `${t.vertex.source}:${t.fragment.source}:${t.fragment.entryPoint}:${t.vertex.entryPoint}`;
      return zn[e] || (zn[e] = new Ne(t)), zn[e];
    }
  }
  const oh = [
    "f32",
    "i32",
    "vec2<f32>",
    "vec3<f32>",
    "vec4<f32>",
    "mat2x2<f32>",
    "mat3x3<f32>",
    "mat4x4<f32>",
    "mat3x2<f32>",
    "mat4x2<f32>",
    "mat2x3<f32>",
    "mat4x3<f32>",
    "mat2x4<f32>",
    "mat3x4<f32>"
  ], N_ = oh.reduce((i, t) => (i[t] = true, i), {});
  function L_(i, t) {
    switch (i) {
      case "f32":
        return 0;
      case "vec2<f32>":
        return new Float32Array(2 * t);
      case "vec3<f32>":
        return new Float32Array(3 * t);
      case "vec4<f32>":
        return new Float32Array(4 * t);
      case "mat2x2<f32>":
        return new Float32Array([
          1,
          0,
          0,
          1
        ]);
      case "mat3x3<f32>":
        return new Float32Array([
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1
        ]);
      case "mat4x4<f32>":
        return new Float32Array([
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1
        ]);
    }
    return null;
  }
  const ah = class ch {
    constructor(t, e) {
      this._touched = 0, this.uid = Ot("uniform"), this._resourceType = "uniformGroup", this._resourceId = Ot("resource"), this.isUniformGroup = true, this._dirtyId = 0, this.destroyed = false, e = {
        ...ch.defaultOptions,
        ...e
      }, this.uniformStructures = t;
      const r = {};
      for (const s in t) {
        const n = t[s];
        if (n.name = s, n.size = n.size ?? 1, !N_[n.type]) throw new Error(`Uniform type ${n.type} is not supported. Supported uniform types are: ${oh.join(", ")}`);
        n.value ?? (n.value = L_(n.type, n.size)), r[s] = n.value;
      }
      this.uniforms = r, this._dirtyId = 1, this.ubo = e.ubo, this.isStatic = e.isStatic, this._signature = $s(Object.keys(r).map((s) => `${s}-${t[s].type}`).join("-"), "uniform-group");
    }
    update() {
      this._dirtyId++;
    }
  };
  ah.defaultOptions = {
    ubo: false,
    isStatic: false
  };
  let Qt = ah;
  class Ze {
    constructor(t) {
      this.resources = /* @__PURE__ */ Object.create(null), this._dirty = true;
      let e = 0;
      for (const r in t) {
        const s = t[r];
        this.setResource(s, e++);
      }
      this._updateKey();
    }
    _updateKey() {
      if (!this._dirty) return;
      this._dirty = false;
      const t = [];
      let e = 0;
      for (const r in this.resources) t[e++] = this.resources[r]._resourceId;
      this._key = t.join("|");
    }
    setResource(t, e) {
      var _a2, _b2;
      const r = this.resources[e];
      t !== r && (r && ((_a2 = t.off) == null ? void 0 : _a2.call(t, "change", this.onResourceChange, this)), (_b2 = t.on) == null ? void 0 : _b2.call(t, "change", this.onResourceChange, this), this.resources[e] = t, this._dirty = true);
    }
    getResource(t) {
      return this.resources[t];
    }
    _touch(t) {
      const e = this.resources;
      for (const r in e) e[r]._touched = t;
    }
    destroy() {
      var _a2, _b2;
      const t = this.resources;
      for (const e in t) (_b2 = (_a2 = t[e]).off) == null ? void 0 : _b2.call(_a2, "change", this.onResourceChange, this);
      this.resources = null;
    }
    onResourceChange(t) {
      if (this._dirty = true, t.destroyed) {
        const e = this.resources;
        for (const r in e) e[r] === t && (e[r] = null);
      } else this._updateKey();
    }
  }
  var ge = ((i) => (i[i.WEBGL = 1] = "WEBGL", i[i.WEBGPU = 2] = "WEBGPU", i[i.BOTH = 3] = "BOTH", i))(ge || {});
  class Se extends me {
    constructor(t) {
      super(), this._uniformBindMap = /* @__PURE__ */ Object.create(null), this._ownedBindGroups = [];
      let { gpuProgram: e, glProgram: r, groups: s, resources: n, compatibleRenderers: o, groupMap: a } = t;
      this.gpuProgram = e, this.glProgram = r, o === void 0 && (o = 0, e && (o |= ge.WEBGPU), r && (o |= ge.WEBGL)), this.compatibleRenderers = o;
      const c = {};
      if (!n && !s && (n = {}), n && s) throw new Error("[Shader] Cannot have both resources and groups");
      if (!e && s && !a) throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");
      if (!e && s && a) for (const l in a) for (const u in a[l]) {
        const h = a[l][u];
        c[h] = {
          group: l,
          binding: u,
          name: h
        };
      }
      else if (e && s && !a) {
        const l = e.structsAndGroups.groups;
        a = {}, l.forEach((u) => {
          a[u.group] = a[u.group] || {}, a[u.group][u.binding] = u.name, c[u.name] = u;
        });
      } else if (n) {
        s = {}, a = {}, e && e.structsAndGroups.groups.forEach((h) => {
          a[h.group] = a[h.group] || {}, a[h.group][h.binding] = h.name, c[h.name] = h;
        });
        let l = 0;
        for (const u in n) c[u] || (s[99] || (s[99] = new Ze(), this._ownedBindGroups.push(s[99])), c[u] = {
          group: 99,
          binding: l,
          name: u
        }, a[99] = a[99] || {}, a[99][l] = u, l++);
        for (const u in n) {
          const h = u;
          let d = n[u];
          !d.source && !d._resourceType && (d = new Qt(d));
          const p = c[h];
          p && (s[p.group] || (s[p.group] = new Ze(), this._ownedBindGroups.push(s[p.group])), s[p.group].setResource(d, p.binding));
        }
      }
      this.groups = s, this._uniformBindMap = a, this.resources = this._buildResourceAccessor(s, c);
    }
    addResource(t, e, r) {
      var s, n;
      (s = this._uniformBindMap)[e] || (s[e] = {}), (n = this._uniformBindMap[e])[r] || (n[r] = t), this.groups[e] || (this.groups[e] = new Ze(), this._ownedBindGroups.push(this.groups[e]));
    }
    _buildResourceAccessor(t, e) {
      const r = {};
      for (const s in e) {
        const n = e[s];
        Object.defineProperty(r, n.name, {
          get() {
            return t[n.group].getResource(n.binding);
          },
          set(o) {
            t[n.group].setResource(o, n.binding);
          }
        });
      }
      return r;
    }
    destroy(t = false) {
      var _a2, _b2;
      this.emit("destroy", this), t && ((_a2 = this.gpuProgram) == null ? void 0 : _a2.destroy(), (_b2 = this.glProgram) == null ? void 0 : _b2.destroy()), this.gpuProgram = null, this.glProgram = null, this.removeAllListeners(), this._uniformBindMap = null, this._ownedBindGroups.forEach((e) => {
        e.destroy();
      }), this._ownedBindGroups = null, this.resources = null, this.groups = null;
    }
    static from(t) {
      const { gpu: e, gl: r, ...s } = t;
      let n, o;
      return e && (n = Ne.from(e)), r && (o = ir.from(r)), new Se({
        gpuProgram: n,
        glProgram: o,
        ...s
      });
    }
  }
  const H_ = {
    normal: 0,
    add: 1,
    multiply: 2,
    screen: 3,
    overlay: 4,
    erase: 5,
    "normal-npm": 6,
    "add-npm": 7,
    "screen-npm": 8
  }, jn = 0, Wn = 1, Vn = 2, Xn = 3, qn = 4, $n = 5, Ao = class uh {
    constructor() {
      this.data = 0, this.blendMode = "normal", this.polygonOffset = 0, this.blend = true, this.depthMask = true;
    }
    get blend() {
      return !!(this.data & 1 << jn);
    }
    set blend(t) {
      !!(this.data & 1 << jn) !== t && (this.data ^= 1 << jn);
    }
    get offsets() {
      return !!(this.data & 1 << Wn);
    }
    set offsets(t) {
      !!(this.data & 1 << Wn) !== t && (this.data ^= 1 << Wn);
    }
    set cullMode(t) {
      if (t === "none") {
        this.culling = false;
        return;
      }
      this.culling = true, this.clockwiseFrontFace = t === "front";
    }
    get cullMode() {
      return this.culling ? this.clockwiseFrontFace ? "front" : "back" : "none";
    }
    get culling() {
      return !!(this.data & 1 << Vn);
    }
    set culling(t) {
      !!(this.data & 1 << Vn) !== t && (this.data ^= 1 << Vn);
    }
    get depthTest() {
      return !!(this.data & 1 << Xn);
    }
    set depthTest(t) {
      !!(this.data & 1 << Xn) !== t && (this.data ^= 1 << Xn);
    }
    get depthMask() {
      return !!(this.data & 1 << $n);
    }
    set depthMask(t) {
      !!(this.data & 1 << $n) !== t && (this.data ^= 1 << $n);
    }
    get clockwiseFrontFace() {
      return !!(this.data & 1 << qn);
    }
    set clockwiseFrontFace(t) {
      !!(this.data & 1 << qn) !== t && (this.data ^= 1 << qn);
    }
    get blendMode() {
      return this._blendMode;
    }
    set blendMode(t) {
      this.blend = t !== "none", this._blendMode = t, this._blendModeId = H_[t] || 0;
    }
    get polygonOffset() {
      return this._polygonOffset;
    }
    set polygonOffset(t) {
      this.offsets = !!t, this._polygonOffset = t;
    }
    toString() {
      return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;
    }
    static for2d() {
      const t = new uh();
      return t.depthTest = false, t.blend = true, t;
    }
  };
  Ao.default2d = Ao.for2d();
  let Le = Ao;
  const lh = class Ro extends Se {
    constructor(t) {
      t = {
        ...Ro.defaultOptions,
        ...t
      }, super(t), this.enabled = true, this._state = Le.for2d(), this.blendMode = t.blendMode, this.padding = t.padding, typeof t.antialias == "boolean" ? this.antialias = t.antialias ? "on" : "off" : this.antialias = t.antialias, this.resolution = t.resolution, this.blendRequired = t.blendRequired, this.addResource("uTexture", 0, 1);
    }
    apply(t, e, r, s) {
      t.applyFilter(this, e, r, s);
    }
    get blendMode() {
      return this._state.blendMode;
    }
    set blendMode(t) {
      this._state.blendMode = t;
    }
    static from(t) {
      const { gpu: e, gl: r, ...s } = t;
      let n, o;
      return e && (n = Ne.from(e)), r && (o = ir.from(r)), new Ro({
        gpuProgram: n,
        glProgram: o,
        ...s
      });
    }
  };
  lh.defaultOptions = {
    blendMode: "normal",
    resolution: 1,
    padding: 0,
    antialias: "off",
    blendRequired: false
  };
  let ri = lh;
  var z_ = `
in vec2 vTextureCoord;
in vec4 vColor;

out vec4 finalColor;

uniform float uBlend;

uniform sampler2D uTexture;
uniform sampler2D uBackTexture;

{FUNCTIONS}

void main()
{ 
    vec4 back = texture(uBackTexture, vTextureCoord);
    vec4 front = texture(uTexture, vTextureCoord);

    {MAIN}
}
`, j_ = `in vec2 aPosition;
out vec2 vTextureCoord;
out vec2 backgroundUv;

uniform vec4 uInputSize;
uniform vec4 uOutputFrame;
uniform vec4 uOutputTexture;

vec4 filterVertexPosition( void )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
    
    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aPosition * (uOutputFrame.zw * uInputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`, W_ = `
struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

struct BlendUniforms {
  uBlend:f32,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler : sampler;
@group(0) @binding(3) var uBackTexture: texture_2d<f32>;

@group(1) @binding(0) var<uniform> blendUniforms : BlendUniforms;


struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>
  };

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  
}
  
@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>, 
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition)
  );
}

{FUNCTIONS}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>
) -> @location(0) vec4<f32> {


   var back =  textureSample(uBackTexture, uSampler, uv);
   var front = textureSample(uTexture, uSampler, uv);
   
   var out = vec4<f32>(0.0,0.0,0.0,0.0);

   {MAIN}

   return out;
}`;
  class zt extends ri {
    constructor(t) {
      const e = t.gpu, r = Ic({
        source: W_,
        ...e
      }), s = Ne.from({
        vertex: {
          source: r,
          entryPoint: "mainVertex"
        },
        fragment: {
          source: r,
          entryPoint: "mainFragment"
        }
      }), n = t.gl, o = Ic({
        source: z_,
        ...n
      }), a = ir.from({
        vertex: j_,
        fragment: o
      }), c = new Qt({
        uBlend: {
          value: 1,
          type: "f32"
        }
      });
      super({
        gpuProgram: s,
        glProgram: a,
        blendRequired: true,
        resources: {
          blendUniforms: c,
          uBackTexture: Z.EMPTY
        }
      });
    }
  }
  function Ic(i) {
    const { source: t, functions: e, main: r } = i;
    return t.replace("{FUNCTIONS}", e).replace("{MAIN}", r);
  }
  const ra = `
	float getLuminosity(vec3 c) {
		return 0.3 * c.r + 0.59 * c.g + 0.11 * c.b;
	}

	vec3 setLuminosity(vec3 c, float lum) {
		float modLum = lum - getLuminosity(c);
		vec3 color = c.rgb + vec3(modLum);

		// clip back into legal range
		modLum = getLuminosity(color);
		vec3 modLumVec = vec3(modLum);

		float cMin = min(color.r, min(color.g, color.b));
		float cMax = max(color.r, max(color.g, color.b));

		if(cMin < 0.0) {
			color = mix(modLumVec, color, modLum / (modLum - cMin));
		}

		if(cMax > 1.0) {
			color = mix(modLumVec, color, (1.0 - modLum) / (cMax - modLum));
		}

		return color;
	}

	float getSaturation(vec3 c) {
		return max(c.r, max(c.g, c.b)) - min(c.r, min(c.g, c.b));
	}

	vec3 setSaturationMinMidMax(vec3 cSorted, float s) {
		vec3 colorSorted = cSorted;

		if(colorSorted.z > colorSorted.x) {
			colorSorted.y = (((colorSorted.y - colorSorted.x) * s) / (colorSorted.z - colorSorted.x));
			colorSorted.z = s;
		}
		else {
			colorSorted.y = 0.0;
			colorSorted.z = 0.0;
		}

		colorSorted.x = 0.0;

		return colorSorted;
	}

	vec3 setSaturation(vec3 c, float s) {
		vec3 color = c;

		if(color.r <= color.g && color.r <= color.b) {
			if(color.g <= color.b) {
				color = setSaturationMinMidMax(color.rgb, s).rgb;
			}
			else {
				color = setSaturationMinMidMax(color.rbg, s).rbg;
			}
		}
		else if(color.g <= color.r && color.g <= color.b) {
			if(color.r <= color.b) {
				color = setSaturationMinMidMax(color.grb, s).grb;
			}
			else {
				color = setSaturationMinMidMax(color.gbr, s).gbr;
			}
		}
		else {
			// Using bgr for both fixes part of hue
			if(color.r <= color.g) {
				color = setSaturationMinMidMax(color.brg, s).brg;
			}
			else {
				color = setSaturationMinMidMax(color.bgr, s).bgr;
			}
		}

		return color;
	}
    `, ia = `
	fn getLuminosity(c: vec3<f32>) -> f32
	{
		return 0.3*c.r + 0.59*c.g + 0.11*c.b;
	}

	fn setLuminosity(c: vec3<f32>, lum: f32) -> vec3<f32>
	{
		var modLum: f32 = lum - getLuminosity(c);
		var color: vec3<f32> = c.rgb + modLum;

		// clip back into legal range
		modLum = getLuminosity(color);
		let modLumVec = vec3<f32>(modLum);

		let cMin: f32 = min(color.r, min(color.g, color.b));
		let cMax: f32 = max(color.r, max(color.g, color.b));

		if(cMin < 0.0)
		{
			color = mix(modLumVec, color, modLum / (modLum - cMin));
		}

		if(cMax > 1.0)
		{
			color = mix(modLumVec, color, (1 - modLum) / (cMax - modLum));
		}

		return color;
	}

	fn getSaturation(c: vec3<f32>) -> f32
	{
		return max(c.r, max(c.g, c.b)) - min(c.r, min(c.g, c.b));
	}

	fn setSaturationMinMidMax(cSorted: vec3<f32>, s: f32) -> vec3<f32>
	{
		var colorSorted = cSorted;

		if(colorSorted.z > colorSorted.x)
		{
			colorSorted.y = (((colorSorted.y - colorSorted.x) * s) / (colorSorted.z - colorSorted.x));
			colorSorted.z = s;
		}
		else
		{
			colorSorted.y = 0;
			colorSorted.z = 0;
		}

		colorSorted.x = 0;

		return colorSorted;
	}

	fn setSaturation(c: vec3<f32>, s: f32) -> vec3<f32>
	{
		var color = c;

		if (color.r <= color.g && color.r <= color.b)
		{
			if (color.g <= color.b)
			{
				color = vec3<f32>(setSaturationMinMidMax(color.rgb, s)).rgb;
			}
			else
			{
				color = vec3<f32>(setSaturationMinMidMax(color.rbg, s)).rbg;
			}
		}
		else if (color.g <= color.r && color.g <= color.b)
		{
			if (color.r <= color.b)
			{
				color = vec3<f32>(setSaturationMinMidMax(color.grb, s)).grb;
			}
			else
			{
				color = vec3<f32>(setSaturationMinMidMax(color.gbr, s)).gbr;
			}
		}
		else
		{
			// Using bgr for both fixes part of hue
			if (color.r <= color.g)
			{
				color = vec3<f32>(setSaturationMinMidMax(color.brg, s)).brg;
			}
			else
			{
				color  = vec3<f32>(setSaturationMinMidMax(color.bgr, s)).bgr;
			}
		}

		return color;
	}
	`;
  class V_ extends zt {
    constructor() {
      super({
        gl: {
          functions: `
                ${ra}

                vec3 blendColor(vec3 base, vec3 blend,  float opacity)
                {
                    return (setLuminosity(blend, getLuminosity(base)) * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                finalColor = vec4(blendColor(back.rgb, front.rgb, front.a), uBlend);
                `
        },
        gpu: {
          functions: `
                ${ia}

                fn blendColorOpacity(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (setLuminosity(blend, getLuminosity(base)) * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                out = vec4<f32>(blendColorOpacity(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
        }
      });
    }
  }
  V_.extension = {
    name: "color",
    type: P.BlendMode
  };
  class X_ extends zt {
    constructor() {
      super({
        gl: {
          functions: `
                float colorBurn(float base, float blend)
                {
                    return max((1.0 - ((1.0 - base) / blend)), 0.0);
                }

                vec3 blendColorBurn(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        colorBurn(base.r, blend.r),
                        colorBurn(base.g, blend.g),
                        colorBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                finalColor = vec4(blendColorBurn(back.rgb, front.rgb, front.a), uBlend);
            `
        },
        gpu: {
          functions: `
                fn colorBurn(base:f32, blend:f32) -> f32
                {
                    return max((1.0-((1.0-base)/blend)),0.0);
                }

                fn blendColorBurn(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        colorBurn(base.r, blend.r),
                        colorBurn(base.g, blend.g),
                        colorBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                out = vec4<f32>(blendColorBurn(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
        }
      });
    }
  }
  X_.extension = {
    name: "color-burn",
    type: P.BlendMode
  };
  class q_ extends zt {
    constructor() {
      super({
        gl: {
          functions: `
                float colorDodge(float base, float blend)
                {
                    return base / (1.0 - blend);
                }

                vec3 blendColorDodge(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        colorDodge(base.r, blend.r),
                        colorDodge(base.g, blend.g),
                        colorDodge(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                finalColor = vec4(blendColorDodge(back.rgb, front.rgb, front.a), uBlend);
                `
        },
        gpu: {
          functions: `
                fn colorDodge(base: f32, blend: f32) -> f32
                {
                    return base / (1.0 - blend);
                }

                fn blendColorDodge(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        colorDodge(base.r, blend.r),
                        colorDodge(base.g, blend.g),
                        colorDodge(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                    out = vec4<f32>(blendColorDodge(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
        }
      });
    }
  }
  q_.extension = {
    name: "color-dodge",
    type: P.BlendMode
  };
  class $_ extends zt {
    constructor() {
      super({
        gl: {
          functions: `
                vec3 blendDarken(vec3 base, vec3 blend, float opacity)
                {
                    return (min(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                finalColor = vec4(blendDarken(back.rgb, front.rgb, front.a), uBlend);
                `
        },
        gpu: {
          functions: `
                fn blendDarken(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (min(blend,base) * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                out = vec4<f32>(blendDarken(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
        }
      });
    }
  }
  $_.extension = {
    name: "darken",
    type: P.BlendMode
  };
  class Y_ extends zt {
    constructor() {
      super({
        gl: {
          functions: `
                vec3 blendDifference(vec3 base, vec3 blend,  float opacity)
                {
                    return (abs(blend - base) * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                finalColor = vec4(blendDifference(back.rgb, front.rgb, front.a), uBlend);
            `
        },
        gpu: {
          functions: `
                fn blendDifference(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (abs(blend - base) * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                out = vec4<f32>(blendDifference(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
        }
      });
    }
  }
  Y_.extension = {
    name: "difference",
    type: P.BlendMode
  };
  class K_ extends zt {
    constructor() {
      super({
        gl: {
          functions: `
                float divide(float base, float blend)
                {
                    return (blend > 0.0) ? clamp(base / blend, 0.0, 1.0) : 1.0;
                }

                vec3 blendDivide(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        divide(base.r, blend.r),
                        divide(base.g, blend.g),
                        divide(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                finalColor = vec4(blendDivide(back.rgb, front.rgb, front.a), uBlend);
                `
        },
        gpu: {
          functions: `
                fn divide(base: f32, blend: f32) -> f32
                {
                    return select(1.0, clamp(base / blend, 0.0, 1.0), blend > 0.0);
                }

                fn blendDivide(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        divide(base.r, blend.r),
                        divide(base.g, blend.g),
                        divide(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                out = vec4<f32>(blendDivide(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
        }
      });
    }
  }
  K_.extension = {
    name: "divide",
    type: P.BlendMode
  };
  class J_ extends zt {
    constructor() {
      super({
        gl: {
          functions: `
                vec3 exclusion(vec3 base, vec3 blend)
                {
                    return base + blend - 2.0 * base * blend;
                }

                vec3 blendExclusion(vec3 base, vec3 blend, float opacity)
                {
                    return (exclusion(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                finalColor = vec4(blendExclusion(back.rgb, front.rgb, front.a), uBlend);
                `
        },
        gpu: {
          functions: `
                fn exclusion(base: vec3<f32>, blend: vec3<f32>) -> vec3<f32>
                {
                    return base+blend-2.0*base*blend;
                }

                fn blendExclusion(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    return (exclusion(base, blend) * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                out = vec4<f32>(blendExclusion(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
        }
      });
    }
  }
  J_.extension = {
    name: "exclusion",
    type: P.BlendMode
  };
  class Z_ extends zt {
    constructor() {
      super({
        gl: {
          functions: `
                float hardLight(float base, float blend)
                {
                    return (blend < 0.5) ? 2.0 * base * blend : 1.0 - 2.0 * (1.0 - base) * (1.0 - blend);
                }

                vec3 blendHardLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        hardLight(base.r, blend.r),
                        hardLight(base.g, blend.g),
                        hardLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                finalColor = vec4(blendHardLight(back.rgb, front.rgb, front.a), uBlend);
            `
        },
        gpu: {
          functions: `
                fn hardLight(base: f32, blend: f32) -> f32
                {
                    return select(1.0 - 2.0 * (1.0 - base) * (1.0 - blend), 2.0 * base * blend, blend < 0.5);
                }

                fn blendHardLight(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        hardLight(base.r, blend.r),
                        hardLight(base.g, blend.g),
                        hardLight(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                out = vec4<f32>(blendHardLight(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
        }
      });
    }
  }
  Z_.extension = {
    name: "hard-light",
    type: P.BlendMode
  };
  class Q_ extends zt {
    constructor() {
      super({
        gl: {
          functions: `
                float hardMix(float base, float blend)
                {
                    return (base + blend >= 1.0) ? 1.0 : 0.0;
                }

                vec3 blendHardMix(vec3 base, vec3 blend,  float opacity)
                {
                    vec3 blended = vec3(
                        hardMix(base.r, blend.r),
                        hardMix(base.g, blend.g),
                        hardMix(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                finalColor = vec4(blendHardMix(back.rgb, front.rgb, front.a), uBlend);
            `
        },
        gpu: {
          functions: `
                fn hardMix(base: f32, blend: f32) -> f32
                {
                    return select(0.0, 1.0, base + blend >= 1.0);
                }

                fn blendHardMix(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended: vec3<f32> = vec3<f32>(
                        hardMix(base.r, blend.r),
                        hardMix(base.g, blend.g),
                        hardMix(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                out = vec4<f32>(blendHardMix(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
        }
      });
    }
  }
  Q_.extension = {
    name: "hard-mix",
    type: P.BlendMode
  };
  class tg extends zt {
    constructor() {
      super({
        gl: {
          functions: `
                vec3 blendLighten(vec3 base, vec3 blend, float opacity)
                {
                    return (max(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                finalColor = vec4(blendLighten(back.rgb, front.rgb, front.a), uBlend);
                `
        },
        gpu: {
          functions: `
                fn blendLighten(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (max(base, blend) * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                out = vec4<f32>(blendLighten(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
        }
      });
    }
  }
  tg.extension = {
    name: "lighten",
    type: P.BlendMode
  };
  class eg extends zt {
    constructor() {
      super({
        gl: {
          functions: `
                float linearBurn(float base, float blend)
                {
                    return max(0.0, base + blend - 1.0);
                }

                vec3 blendLinearBurn(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        linearBurn(base.r, blend.r),
                        linearBurn(base.g, blend.g),
                        linearBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                finalColor = vec4(blendLinearBurn(back.rgb, front.rgb, front.a), uBlend);
                `
        },
        gpu: {
          functions: `
                fn linearBurn(base: f32, blend: f32) -> f32
                {
                    return max(0.0, base + blend - 1.0);
                }

                fn blendLinearBurn(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        linearBurn(base.r, blend.r),
                        linearBurn(base.g, blend.g),
                        linearBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                out = vec4<f32>(blendLinearBurn(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
        }
      });
    }
  }
  eg.extension = {
    name: "linear-burn",
    type: P.BlendMode
  };
  class rg extends zt {
    constructor() {
      super({
        gl: {
          functions: `
                float linearDodge(float base, float blend) {
                    return min(1.0, base + blend);
                }

                vec3 blendLinearDodge(vec3 base, vec3 blend, float opacity) {
                    vec3 blended = vec3(
                        linearDodge(base.r, blend.r),
                        linearDodge(base.g, blend.g),
                        linearDodge(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                finalColor = vec4(blendLinearDodge(back.rgb, front.rgb, front.a), uBlend);
                `
        },
        gpu: {
          functions: `
                fn linearDodge(base: f32, blend: f32) -> f32
                {
                    return min(1, base + blend);
                }

                fn blendLinearDodge(base:vec3<f32>, blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        linearDodge(base.r, blend.r),
                        linearDodge(base.g, blend.g),
                        linearDodge(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                out = vec4<f32>(blendLinearDodge(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
        }
      });
    }
  }
  rg.extension = {
    name: "linear-dodge",
    type: P.BlendMode
  };
  class ig extends zt {
    constructor() {
      super({
        gl: {
          functions: `
                float linearBurn(float base, float blend) {
                    return max(0.0, base + blend - 1.0);
                }

                float linearDodge(float base, float blend) {
                    return min(1.0, base + blend);
                }

                float linearLight(float base, float blend) {
                    return (blend <= 0.5) ? linearBurn(base,2.0*blend) : linearBurn(base,2.0*(blend-0.5));
                }

                vec3 blendLinearLight(vec3 base, vec3 blend, float opacity) {
                    vec3 blended = vec3(
                        linearLight(base.r, blend.r),
                        linearLight(base.g, blend.g),
                        linearLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                finalColor = vec4(blendLinearLight(back.rgb, front.rgb, front.a), uBlend);
                `
        },
        gpu: {
          functions: `
                fn linearBurn(base: f32, blend: f32) -> f32
                {
                    return max(0.0, base + blend - 1.0);
                }

                fn linearDodge(base: f32, blend: f32) -> f32
                {
                    return min(1.0, base + blend);
                }

                fn linearLight(base: f32, blend: f32) -> f32
                {
                    return select(linearBurn(base,2.0*(blend-0.5)), linearBurn(base,2.0*blend), blend <= 0.5);
                }

                fn blendLinearLightOpacity(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        linearLight(base.r, blend.r),
                        linearLight(base.g, blend.g),
                        linearLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                out = vec4<f32>(blendLinearLightOpacity(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
        }
      });
    }
  }
  ig.extension = {
    name: "linear-light",
    type: P.BlendMode
  };
  class sg extends zt {
    constructor() {
      super({
        gl: {
          functions: `
                ${ra}

                vec3 blendLuminosity(vec3 base, vec3 blend,  float opacity)
                {
                    vec3 blendLuminosity = setLuminosity(base, getLuminosity(blend));
                    return (blendLuminosity * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                finalColor = vec4(blendLuminosity(back.rgb, front.rgb, front.a), uBlend);
                `
        },
        gpu: {
          functions: `
                ${ia}

                fn blendLuminosity(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blendLuminosity: vec3<f32> = setLuminosity(base, getLuminosity(blend));
                    return (blendLuminosity * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                out = vec4<f32>(blendLuminosity(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
        }
      });
    }
  }
  sg.extension = {
    name: "luminosity",
    type: P.BlendMode
  };
  class ng extends zt {
    constructor() {
      super({
        gl: {
          functions: `
                vec3 negation(vec3 base, vec3 blend)
                {
                    return 1.0-abs(1.0-base-blend);
                }

                vec3 blendNegation(vec3 base, vec3 blend, float opacity)
                {
                    return (negation(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                finalColor = vec4(blendNegation(back.rgb, front.rgb, front.a), uBlend);
                `
        },
        gpu: {
          functions: `
                fn blendNegation(base: vec3<f32>, blend: vec3<f32>) -> vec3<f32>
                {
                    return 1.0-abs(1.0-base-blend);
                }

                fn blendNegationOpacity(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    return (blendNegation(base, blend) * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                out = vec4<f32>(blendNegationOpacity(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
        }
      });
    }
  }
  ng.extension = {
    name: "negation",
    type: P.BlendMode
  };
  class og extends zt {
    constructor() {
      super({
        gl: {
          functions: `
                float overlay(float base, float blend)
                {
                    return (base < 0.5) ? (2.0*base*blend) : (1.0-2.0*(1.0-base)*(1.0-blend));
                }

                vec3 blendOverlay(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        overlay(base.r, blend.r),
                        overlay(base.g, blend.g),
                        overlay(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                finalColor = vec4(blendOverlay(back.rgb, front.rgb, front.a), uBlend);
                `
        },
        gpu: {
          functions: `
                fn overlay(base: f32, blend: f32) -> f32
                {
                    return select((1.0-2.0*(1.0-base)*(1.0-blend)), (2.0*base*blend), base < 0.5);
                }

                fn blendOverlay(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        overlay(base.r, blend.r),
                        overlay(base.g, blend.g),
                        overlay(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                out = vec4<f32>(blendOverlay(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
        }
      });
    }
  }
  og.extension = {
    name: "overlay",
    type: P.BlendMode
  };
  class ag extends zt {
    constructor() {
      super({
        gl: {
          functions: `
                float pinLight(float base, float blend)
                {
                    return (blend <= 0.5) ? min(base, 2.0 * blend) : max(base, 2.0 * (blend - 0.5));
                }

                vec3 blendPinLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        pinLight(base.r, blend.r),
                        pinLight(base.g, blend.g),
                        pinLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                finalColor = vec4(blendPinLight(back.rgb, front.rgb, front.a), uBlend);
                `
        },
        gpu: {
          functions: `
                fn pinLight(base: f32, blend: f32) -> f32
                {
                    return select(max(base,2.0*(blend-0.5)), min(base,2.0*blend), blend <= 0.5);
                }

                fn blendPinLight(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        pinLight(base.r, blend.r),
                        pinLight(base.g, blend.g),
                        pinLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                out = vec4<f32>(blendPinLight(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
        }
      });
    }
  }
  ag.extension = {
    name: "pin-light",
    type: P.BlendMode
  };
  class cg extends zt {
    constructor() {
      super({
        gl: {
          functions: `
                ${ra}

                vec3 blendSaturation(vec3 base, vec3 blend,  float opacity)
                {
                    vec3 blendSaturation = setLuminosity(setSaturation(base, getSaturation(blend)), getLuminosity(base));
                    return (blendSaturation * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                finalColor = vec4(blendSaturation(back.rgb, front.rgb, front.a), uBlend);
            `
        },
        gpu: {
          functions: `
                ${ia}

                fn blendSaturation(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blendSaturation = setLuminosity(setSaturation(base, getSaturation(blend)), getLuminosity(base));
                    return (blendSaturation * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                out = vec4<f32>(blendSaturation(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
        }
      });
    }
  }
  cg.extension = {
    name: "saturation",
    type: P.BlendMode
  };
  class ug extends zt {
    constructor() {
      super({
        gl: {
          functions: `
                float softLight(float base, float blend)
                {
                    return (blend < 0.5) ? (2.0 * base * blend + base * base * (1.0 - 2.0 * blend)) : (sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend));
                }

                vec3 blendSoftLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        softLight(base.r, blend.r),
                        softLight(base.g, blend.g),
                        softLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                finalColor = vec4(blendSoftLight(back.rgb, front.rgb, front.a), uBlend);
                `
        },
        gpu: {
          functions: `
                fn softLight(base: f32, blend: f32) -> f32
                {
                    return select(2.0 * base * blend + base * base * (1.0 - 2.0 * blend), sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend), blend < 0.5);
                }

                fn blendSoftLight(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended: vec3<f32> = vec3<f32>(
                        softLight(base.r, blend.r),
                        softLight(base.g, blend.g),
                        softLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                out = vec4<f32>(blendSoftLight(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
        }
      });
    }
  }
  ug.extension = {
    name: "soft-light",
    type: P.BlendMode
  };
  class lg extends zt {
    constructor() {
      super({
        gl: {
          functions: `
                float subtract(float base, float blend)
                {
                    return max(0.0, base - blend);
                }

                vec3 blendSubtract(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        subtract(base.r, blend.r),
                        subtract(base.g, blend.g),
                        subtract(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                finalColor = vec4(blendSubtract(back.rgb, front.rgb, front.a), uBlend);
                `
        },
        gpu: {
          functions: `
                fn subtract(base: f32, blend: f32) -> f32
                {
                    return max(0, base - blend);
                }

                fn blendSubtract(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        subtract(base.r, blend.r),
                        subtract(base.g, blend.g),
                        subtract(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                out = vec4<f32>(blendSubtract(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
        }
      });
    }
  }
  lg.extension = {
    name: "subtract",
    type: P.BlendMode
  };
  class hg extends zt {
    constructor() {
      super({
        gl: {
          functions: `
                float colorBurn(float base, float blend)
                {
                    return max((1.0-((1.0-base)/blend)),0.0);
                }

                float colorDodge(float base, float blend)
                {
                    return min(1.0, base / (1.0-blend));
                }

                float vividLight(float base, float blend)
                {
                    return (blend < 0.5) ? colorBurn(base,(2.0*blend)) : colorDodge(base,(2.0*(blend-0.5)));
                }

                vec3 blendVividLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        vividLight(base.r, blend.r),
                        vividLight(base.g, blend.g),
                        vividLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                finalColor = vec4(blendVividLight(back.rgb, front.rgb, front.a), uBlend);
            `
        },
        gpu: {
          functions: `
                fn colorBurn(base:f32, blend:f32) -> f32
                {
                    return max((1.0-((1.0-base)/blend)),0.0);
                }

                fn colorDodge(base: f32, blend: f32) -> f32
                {
                    return min(1.0, base / (1.0-blend));
                }

                fn vividLight(base: f32, blend: f32) -> f32
                {
                    return select(colorDodge(base,(2.0*(blend-0.5))), colorBurn(base,(2.0*blend)), blend<0.5);
                }

                fn blendVividLight(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended: vec3<f32> = vec3<f32>(
                        vividLight(base.r, blend.r),
                        vividLight(base.g, blend.g),
                        vividLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                out = vec4<f32>(blendVividLight(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
        }
      });
    }
  }
  hg.extension = {
    name: "vivid-light",
    type: P.BlendMode
  };
  const Po = [];
  Mt.handleByNamedList(P.Environment, Po);
  async function dg(i) {
    if (!i) for (let t = 0; t < Po.length; t++) {
      const e = Po[t];
      if (e.value.test()) {
        await e.value.load();
        return;
      }
    }
  }
  let ai;
  function hh() {
    if (typeof ai == "boolean") return ai;
    try {
      ai = new Function("param1", "param2", "param3", "return param1[param2] === param3;")({
        a: "b"
      }, "a", "b") === true;
    } catch {
      ai = false;
    }
    return ai;
  }
  var wi = {
    exports: {}
  }, tR = wi.exports, Fc;
  function fg() {
    if (Fc) return wi.exports;
    Fc = 1, wi.exports = i, wi.exports.default = i;
    function i(x, R, E) {
      E = E || 2;
      var B = R && R.length, D = B ? R[0] * E : x.length, N = t(x, 0, D, E, true), O = [];
      if (!N || N.next === N.prev) return O;
      var q, V, $, ft, pt, it, gt;
      if (B && (N = c(x, R, N, E)), x.length > 80 * E) {
        q = $ = x[0], V = ft = x[1];
        for (var _t = E; _t < D; _t += E) pt = x[_t], it = x[_t + 1], pt < q && (q = pt), it < V && (V = it), pt > $ && ($ = pt), it > ft && (ft = it);
        gt = Math.max($ - q, ft - V), gt = gt !== 0 ? 32767 / gt : 0;
      }
      return r(N, O, E, q, V, gt, 0), O;
    }
    function t(x, R, E, B, D) {
      var N, O;
      if (D === Q(x, R, E, B) > 0) for (N = R; N < E; N += B) O = J(N, x[N], x[N + 1], O);
      else for (N = E - B; N >= R; N -= B) O = J(N, x[N], x[N + 1], O);
      return O && G(O, O.next) && (j(O), O = O.next), O;
    }
    function e(x, R) {
      if (!x) return x;
      R || (R = x);
      var E = x, B;
      do
        if (B = false, !E.steiner && (G(E, E.next) || C(E.prev, E, E.next) === 0)) {
          if (j(E), E = R = E.prev, E === E.next) break;
          B = true;
        } else E = E.next;
      while (B || E !== R);
      return R;
    }
    function r(x, R, E, B, D, N, O) {
      if (x) {
        !O && N && p(x, B, D, N);
        for (var q = x, V, $; x.prev !== x.next; ) {
          if (V = x.prev, $ = x.next, N ? n(x, B, D, N) : s(x)) {
            R.push(V.i / E | 0), R.push(x.i / E | 0), R.push($.i / E | 0), j(x), x = $.next, q = $.next;
            continue;
          }
          if (x = $, x === q) {
            O ? O === 1 ? (x = o(e(x), R, E), r(x, R, E, B, D, N, 2)) : O === 2 && a(x, R, E, B, D, N) : r(e(x), R, E, B, D, N, 1);
            break;
          }
        }
      }
    }
    function s(x) {
      var R = x.prev, E = x, B = x.next;
      if (C(R, E, B) >= 0) return false;
      for (var D = R.x, N = E.x, O = B.x, q = R.y, V = E.y, $ = B.y, ft = D < N ? D < O ? D : O : N < O ? N : O, pt = q < V ? q < $ ? q : $ : V < $ ? V : $, it = D > N ? D > O ? D : O : N > O ? N : O, gt = q > V ? q > $ ? q : $ : V > $ ? V : $, _t = B.next; _t !== R; ) {
        if (_t.x >= ft && _t.x <= it && _t.y >= pt && _t.y <= gt && v(D, q, N, V, O, $, _t.x, _t.y) && C(_t.prev, _t, _t.next) >= 0) return false;
        _t = _t.next;
      }
      return true;
    }
    function n(x, R, E, B) {
      var D = x.prev, N = x, O = x.next;
      if (C(D, N, O) >= 0) return false;
      for (var q = D.x, V = N.x, $ = O.x, ft = D.y, pt = N.y, it = O.y, gt = q < V ? q < $ ? q : $ : V < $ ? V : $, _t = ft < pt ? ft < it ? ft : it : pt < it ? pt : it, se = q > V ? q > $ ? q : $ : V > $ ? V : $, te = ft > pt ? ft > it ? ft : it : pt > it ? pt : it, ht = y(gt, _t, R, E, B), Ut = y(se, te, R, E, B), nt = x.prevZ, tt = x.nextZ; nt && nt.z >= ht && tt && tt.z <= Ut; ) {
        if (nt.x >= gt && nt.x <= se && nt.y >= _t && nt.y <= te && nt !== D && nt !== O && v(q, ft, V, pt, $, it, nt.x, nt.y) && C(nt.prev, nt, nt.next) >= 0 || (nt = nt.prevZ, tt.x >= gt && tt.x <= se && tt.y >= _t && tt.y <= te && tt !== D && tt !== O && v(q, ft, V, pt, $, it, tt.x, tt.y) && C(tt.prev, tt, tt.next) >= 0)) return false;
        tt = tt.nextZ;
      }
      for (; nt && nt.z >= ht; ) {
        if (nt.x >= gt && nt.x <= se && nt.y >= _t && nt.y <= te && nt !== D && nt !== O && v(q, ft, V, pt, $, it, nt.x, nt.y) && C(nt.prev, nt, nt.next) >= 0) return false;
        nt = nt.prevZ;
      }
      for (; tt && tt.z <= Ut; ) {
        if (tt.x >= gt && tt.x <= se && tt.y >= _t && tt.y <= te && tt !== D && tt !== O && v(q, ft, V, pt, $, it, tt.x, tt.y) && C(tt.prev, tt, tt.next) >= 0) return false;
        tt = tt.nextZ;
      }
      return true;
    }
    function o(x, R, E) {
      var B = x;
      do {
        var D = B.prev, N = B.next.next;
        !G(D, N) && H(D, B, B.next, N) && A(D, N) && A(N, D) && (R.push(D.i / E | 0), R.push(B.i / E | 0), R.push(N.i / E | 0), j(B), j(B.next), B = x = N), B = B.next;
      } while (B !== x);
      return e(B);
    }
    function a(x, R, E, B, D, N) {
      var O = x;
      do {
        for (var q = O.next.next; q !== O.prev; ) {
          if (O.i !== q.i && S(O, q)) {
            var V = z(O, q);
            O = e(O, O.next), V = e(V, V.next), r(O, R, E, B, D, N, 0), r(V, R, E, B, D, N, 0);
            return;
          }
          q = q.next;
        }
        O = O.next;
      } while (O !== x);
    }
    function c(x, R, E, B) {
      var D = [], N, O, q, V, $;
      for (N = 0, O = R.length; N < O; N++) q = R[N] * B, V = N < O - 1 ? R[N + 1] * B : x.length, $ = t(x, q, V, B, false), $ === $.next && ($.steiner = true), D.push(m($));
      for (D.sort(l), N = 0; N < D.length; N++) E = u(D[N], E);
      return E;
    }
    function l(x, R) {
      return x.x - R.x;
    }
    function u(x, R) {
      var E = h(x, R);
      if (!E) return R;
      var B = z(E, x);
      return e(B, B.next), e(E, E.next);
    }
    function h(x, R) {
      var E = R, B = x.x, D = x.y, N = -1 / 0, O;
      do {
        if (D <= E.y && D >= E.next.y && E.next.y !== E.y) {
          var q = E.x + (D - E.y) * (E.next.x - E.x) / (E.next.y - E.y);
          if (q <= B && q > N && (N = q, O = E.x < E.next.x ? E : E.next, q === B)) return O;
        }
        E = E.next;
      } while (E !== R);
      if (!O) return null;
      var V = O, $ = O.x, ft = O.y, pt = 1 / 0, it;
      E = O;
      do
        B >= E.x && E.x >= $ && B !== E.x && v(D < ft ? B : N, D, $, ft, D < ft ? N : B, D, E.x, E.y) && (it = Math.abs(D - E.y) / (B - E.x), A(E, x) && (it < pt || it === pt && (E.x > O.x || E.x === O.x && d(O, E))) && (O = E, pt = it)), E = E.next;
      while (E !== V);
      return O;
    }
    function d(x, R) {
      return C(x.prev, x, R.prev) < 0 && C(R.next, x, x.next) < 0;
    }
    function p(x, R, E, B) {
      var D = x;
      do
        D.z === 0 && (D.z = y(D.x, D.y, R, E, B)), D.prevZ = D.prev, D.nextZ = D.next, D = D.next;
      while (D !== x);
      D.prevZ.nextZ = null, D.prevZ = null, g(D);
    }
    function g(x) {
      var R, E, B, D, N, O, q, V, $ = 1;
      do {
        for (E = x, x = null, N = null, O = 0; E; ) {
          for (O++, B = E, q = 0, R = 0; R < $ && (q++, B = B.nextZ, !!B); R++) ;
          for (V = $; q > 0 || V > 0 && B; ) q !== 0 && (V === 0 || !B || E.z <= B.z) ? (D = E, E = E.nextZ, q--) : (D = B, B = B.nextZ, V--), N ? N.nextZ = D : x = D, D.prevZ = N, N = D;
          E = B;
        }
        N.nextZ = null, $ *= 2;
      } while (O > 1);
      return x;
    }
    function y(x, R, E, B, D) {
      return x = (x - E) * D | 0, R = (R - B) * D | 0, x = (x | x << 8) & 16711935, x = (x | x << 4) & 252645135, x = (x | x << 2) & 858993459, x = (x | x << 1) & 1431655765, R = (R | R << 8) & 16711935, R = (R | R << 4) & 252645135, R = (R | R << 2) & 858993459, R = (R | R << 1) & 1431655765, x | R << 1;
    }
    function m(x) {
      var R = x, E = x;
      do
        (R.x < E.x || R.x === E.x && R.y < E.y) && (E = R), R = R.next;
      while (R !== x);
      return E;
    }
    function v(x, R, E, B, D, N, O, q) {
      return (D - O) * (R - q) >= (x - O) * (N - q) && (x - O) * (B - q) >= (E - O) * (R - q) && (E - O) * (N - q) >= (D - O) * (B - q);
    }
    function S(x, R) {
      return x.next.i !== R.i && x.prev.i !== R.i && !W(x, R) && (A(x, R) && A(R, x) && I(x, R) && (C(x.prev, x, R.prev) || C(x, R.prev, R)) || G(x, R) && C(x.prev, x, x.next) > 0 && C(R.prev, R, R.next) > 0);
    }
    function C(x, R, E) {
      return (R.y - x.y) * (E.x - R.x) - (R.x - x.x) * (E.y - R.y);
    }
    function G(x, R) {
      return x.x === R.x && x.y === R.y;
    }
    function H(x, R, E, B) {
      var D = L(C(x, R, E)), N = L(C(x, R, B)), O = L(C(E, B, x)), q = L(C(E, B, R));
      return !!(D !== N && O !== q || D === 0 && Y(x, E, R) || N === 0 && Y(x, B, R) || O === 0 && Y(E, x, B) || q === 0 && Y(E, R, B));
    }
    function Y(x, R, E) {
      return R.x <= Math.max(x.x, E.x) && R.x >= Math.min(x.x, E.x) && R.y <= Math.max(x.y, E.y) && R.y >= Math.min(x.y, E.y);
    }
    function L(x) {
      return x > 0 ? 1 : x < 0 ? -1 : 0;
    }
    function W(x, R) {
      var E = x;
      do {
        if (E.i !== x.i && E.next.i !== x.i && E.i !== R.i && E.next.i !== R.i && H(E, E.next, x, R)) return true;
        E = E.next;
      } while (E !== x);
      return false;
    }
    function A(x, R) {
      return C(x.prev, x, x.next) < 0 ? C(x, R, x.next) >= 0 && C(x, x.prev, R) >= 0 : C(x, R, x.prev) < 0 || C(x, x.next, R) < 0;
    }
    function I(x, R) {
      var E = x, B = false, D = (x.x + R.x) / 2, N = (x.y + R.y) / 2;
      do
        E.y > N != E.next.y > N && E.next.y !== E.y && D < (E.next.x - E.x) * (N - E.y) / (E.next.y - E.y) + E.x && (B = !B), E = E.next;
      while (E !== x);
      return B;
    }
    function z(x, R) {
      var E = new X(x.i, x.x, x.y), B = new X(R.i, R.x, R.y), D = x.next, N = R.prev;
      return x.next = R, R.prev = x, E.next = D, D.prev = E, B.next = E, E.prev = B, N.next = B, B.prev = N, B;
    }
    function J(x, R, E, B) {
      var D = new X(x, R, E);
      return B ? (D.next = B.next, D.prev = B, B.next.prev = D, B.next = D) : (D.prev = D, D.next = D), D;
    }
    function j(x) {
      x.next.prev = x.prev, x.prev.next = x.next, x.prevZ && (x.prevZ.nextZ = x.nextZ), x.nextZ && (x.nextZ.prevZ = x.prevZ);
    }
    function X(x, R, E) {
      this.i = x, this.x = R, this.y = E, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = false;
    }
    i.deviation = function(x, R, E, B) {
      var D = R && R.length, N = D ? R[0] * E : x.length, O = Math.abs(Q(x, 0, N, E));
      if (D) for (var q = 0, V = R.length; q < V; q++) {
        var $ = R[q] * E, ft = q < V - 1 ? R[q + 1] * E : x.length;
        O -= Math.abs(Q(x, $, ft, E));
      }
      var pt = 0;
      for (q = 0; q < B.length; q += 3) {
        var it = B[q] * E, gt = B[q + 1] * E, _t = B[q + 2] * E;
        pt += Math.abs((x[it] - x[_t]) * (x[gt + 1] - x[it + 1]) - (x[it] - x[gt]) * (x[_t + 1] - x[it + 1]));
      }
      return O === 0 && pt === 0 ? 0 : Math.abs((pt - O) / O);
    };
    function Q(x, R, E, B) {
      for (var D = 0, N = R, O = E - B; N < E; N += B) D += (x[O] - x[N]) * (x[N + 1] + x[O + 1]), O = N;
      return D;
    }
    return i.flatten = function(x) {
      for (var R = x[0][0].length, E = {
        vertices: [],
        holes: [],
        dimensions: R
      }, B = 0, D = 0; D < x.length; D++) {
        for (var N = 0; N < x[D].length; N++) for (var O = 0; O < R; O++) E.vertices.push(x[D][N][O]);
        D > 0 && (B += x[D - 1].length, E.holes.push(B));
      }
      return E;
    }, wi.exports;
  }
  var pg = fg();
  const _g = Vs(pg);
  var pe = ((i) => (i[i.NONE = 0] = "NONE", i[i.COLOR = 16384] = "COLOR", i[i.STENCIL = 1024] = "STENCIL", i[i.DEPTH = 256] = "DEPTH", i[i.COLOR_DEPTH = 16640] = "COLOR_DEPTH", i[i.COLOR_STENCIL = 17408] = "COLOR_STENCIL", i[i.DEPTH_STENCIL = 1280] = "DEPTH_STENCIL", i[i.ALL = 17664] = "ALL", i))(pe || {});
  class dh {
    constructor(t) {
      this.items = [], this._name = t;
    }
    emit(t, e, r, s, n, o, a, c) {
      const { name: l, items: u } = this;
      for (let h = 0, d = u.length; h < d; h++) u[h][l](t, e, r, s, n, o, a, c);
      return this;
    }
    add(t) {
      return t[this._name] && (this.remove(t), this.items.push(t)), this;
    }
    remove(t) {
      const e = this.items.indexOf(t);
      return e !== -1 && this.items.splice(e, 1), this;
    }
    contains(t) {
      return this.items.indexOf(t) !== -1;
    }
    removeAll() {
      return this.items.length = 0, this;
    }
    destroy() {
      this.removeAll(), this.items = null, this._name = null;
    }
    get empty() {
      return this.items.length === 0;
    }
    get name() {
      return this._name;
    }
  }
  const gg = [
    "init",
    "destroy",
    "contextChange",
    "resolutionChange",
    "reset",
    "renderEnd",
    "renderStart",
    "render",
    "update",
    "postrender",
    "prerender"
  ], fh = class ph extends me {
    constructor(t) {
      super(), this.runners = /* @__PURE__ */ Object.create(null), this.renderPipes = /* @__PURE__ */ Object.create(null), this._initOptions = {}, this._systemsHash = /* @__PURE__ */ Object.create(null), this.type = t.type, this.name = t.name, this.config = t;
      const e = [
        ...gg,
        ...this.config.runners ?? []
      ];
      this._addRunners(...e), this._unsafeEvalCheck();
    }
    async init(t = {}) {
      const e = t.skipExtensionImports === true ? true : t.manageImports === false;
      await dg(e), this._addSystems(this.config.systems), this._addPipes(this.config.renderPipes, this.config.renderPipeAdaptors);
      for (const r in this._systemsHash) t = {
        ...this._systemsHash[r].constructor.defaultOptions,
        ...t
      };
      t = {
        ...ph.defaultOptions,
        ...t
      }, this._roundPixels = t.roundPixels ? 1 : 0;
      for (let r = 0; r < this.runners.init.items.length; r++) await this.runners.init.items[r].init(t);
      this._initOptions = t;
    }
    render(t, e) {
      let r = t;
      if (r instanceof Dt && (r = {
        container: r
      }, e && (lt(dt, "passing a second argument is deprecated, please use render options instead"), r.target = e.renderTexture)), r.target || (r.target = this.view.renderTarget), r.target === this.view.renderTarget && (this._lastObjectRendered = r.container, r.clearColor = this.background.colorRgba), r.clearColor) {
        const s = Array.isArray(r.clearColor) && r.clearColor.length === 4;
        r.clearColor = s ? r.clearColor : Tt.shared.setValue(r.clearColor).toArray();
      }
      r.transform || (r.container.updateLocalTransform(), r.transform = r.container.localTransform), this.runners.prerender.emit(r), this.runners.renderStart.emit(r), this.runners.render.emit(r), this.runners.renderEnd.emit(r), this.runners.postrender.emit(r);
    }
    resize(t, e, r) {
      this.view.resize(t, e, r), this.emit("resize", this.view.screen.width, this.view.screen.height);
    }
    clear(t = {}) {
      const e = this;
      t.target || (t.target = e.renderTarget.renderTarget), t.clearColor || (t.clearColor = this.background.colorRgba), t.clear ?? (t.clear = pe.ALL);
      const { clear: r, clearColor: s, target: n } = t;
      Tt.shared.setValue(s ?? this.background.colorRgba), e.renderTarget.clear(n, r, Tt.shared.toArray());
    }
    get resolution() {
      return this.view.resolution;
    }
    set resolution(t) {
      this.view.resolution = t, this.runners.resolutionChange.emit(t);
    }
    get width() {
      return this.view.texture.frame.width;
    }
    get height() {
      return this.view.texture.frame.height;
    }
    get canvas() {
      return this.view.canvas;
    }
    get lastObjectRendered() {
      return this._lastObjectRendered;
    }
    get renderingToScreen() {
      return this.renderTarget.renderingToScreen;
    }
    get screen() {
      return this.view.screen;
    }
    _addRunners(...t) {
      t.forEach((e) => {
        this.runners[e] = new dh(e);
      });
    }
    _addSystems(t) {
      let e;
      for (e in t) {
        const r = t[e];
        this._addSystem(r.value, r.name);
      }
    }
    _addSystem(t, e) {
      const r = new t(this);
      if (this[e]) throw new Error(`Whoops! The name "${e}" is already in use`);
      this[e] = r, this._systemsHash[e] = r;
      for (const s in this.runners) this.runners[s].add(r);
      return this;
    }
    _addPipes(t, e) {
      const r = e.reduce((s, n) => (s[n.name] = n.value, s), {});
      t.forEach((s) => {
        const n = s.value, o = s.name, a = r[o];
        this.renderPipes[o] = new n(this, a ? new a() : null);
      });
    }
    destroy(t = false) {
      this.runners.destroy.items.reverse(), this.runners.destroy.emit(t), Object.values(this.runners).forEach((e) => {
        e.destroy();
      }), this._systemsHash = null, this.renderPipes = null;
    }
    generateTexture(t) {
      return this.textureGenerator.generateTexture(t);
    }
    get roundPixels() {
      return !!this._roundPixels;
    }
    _unsafeEvalCheck() {
      if (!hh()) throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");
    }
  };
  fh.defaultOptions = {
    resolution: 1,
    failIfMajorPerformanceCaveat: false,
    roundPixels: false
  };
  let Ys = fh, Qi;
  function Ks(i) {
    return Qi !== void 0 || (Qi = (() => {
      var _a2;
      const t = {
        stencil: true,
        failIfMajorPerformanceCaveat: i ?? Ys.defaultOptions.failIfMajorPerformanceCaveat
      };
      try {
        if (!St.get().getWebGLRenderingContext()) return false;
        let r = St.get().createCanvas().getContext("webgl", t);
        const s = !!((_a2 = r == null ? void 0 : r.getContextAttributes()) == null ? void 0 : _a2.stencil);
        if (r) {
          const n = r.getExtension("WEBGL_lose_context");
          n && n.loseContext();
        }
        return r = null, s;
      } catch {
        return false;
      }
    })()), Qi;
  }
  let ts;
  async function Js(i = {}) {
    return ts !== void 0 || (ts = await (async () => {
      if (!St.get().getNavigator().gpu) return false;
      try {
        return await (await navigator.gpu.requestAdapter(i)).requestDevice(), true;
      } catch {
        return false;
      }
    })()), ts;
  }
  const Uc = [
    "webgl",
    "webgpu",
    "canvas"
  ];
  async function mg(i) {
    let t = [];
    i.preference ? (t.push(i.preference), Uc.forEach((n) => {
      n !== i.preference && t.push(n);
    })) : t = Uc.slice();
    let e, r = {};
    for (let n = 0; n < t.length; n++) {
      const o = t[n];
      if (o === "webgpu" && await Js()) {
        const { WebGPURenderer: a } = await Cs(async () => {
          const { WebGPURenderer: c } = await Promise.resolve().then(() => V0);
          return {
            WebGPURenderer: c
          };
        }, void 0, import.meta.url);
        e = a, r = {
          ...i,
          ...i.webgpu
        };
        break;
      } else if (o === "webgl" && Ks(i.failIfMajorPerformanceCaveat ?? Ys.defaultOptions.failIfMajorPerformanceCaveat)) {
        const { WebGLRenderer: a } = await Cs(async () => {
          const { WebGLRenderer: c } = await Promise.resolve().then(() => C0);
          return {
            WebGLRenderer: c
          };
        }, void 0, import.meta.url);
        e = a, r = {
          ...i,
          ...i.webgl
        };
        break;
      } else if (o === "canvas") throw r = {
        ...i
      }, new Error("CanvasRenderer is not yet implemented");
    }
    if (delete r.webgpu, delete r.webgl, !e) throw new Error("No available renderer for the current environment");
    const s = new e();
    return await s.init(r), s;
  }
  class _h {
    static init() {
      var _a2;
      (_a2 = globalThis.__PIXI_APP_INIT__) == null ? void 0 : _a2.call(globalThis, this);
    }
    static destroy() {
    }
  }
  _h.extension = P.Application;
  class gh {
    constructor(t) {
      this._renderer = t;
    }
    init() {
      var _a2;
      (_a2 = globalThis.__PIXI_RENDERER_INIT__) == null ? void 0 : _a2.call(globalThis, this._renderer);
    }
    destroy() {
      this._renderer = null;
    }
  }
  gh.extension = {
    type: [
      P.WebGLSystem,
      P.WebGPUSystem
    ],
    name: "initHook",
    priority: -10
  };
  const mh = class Bo {
    constructor(...t) {
      this.stage = new Dt(), t[0] !== void 0 && lt(dt, "Application constructor options are deprecated, please use Application.init() instead.");
    }
    async init(t) {
      t = {
        ...t
      }, this.renderer = await mg(t), Bo._plugins.forEach((e) => {
        e.init.call(this, t);
      });
    }
    render() {
      this.renderer.render({
        container: this.stage
      });
    }
    get canvas() {
      return this.renderer.canvas;
    }
    get view() {
      return lt(dt, "Application.view is deprecated, please use Application.canvas instead."), this.renderer.canvas;
    }
    get screen() {
      return this.renderer.screen;
    }
    destroy(t = false, e = false) {
      const r = Bo._plugins.slice(0);
      r.reverse(), r.forEach((s) => {
        s.destroy.call(this);
      }), this.stage.destroy(e), this.stage = null, this.renderer.destroy(t), this.renderer = null;
    }
  };
  mh._plugins = [];
  let bh = mh;
  Mt.handleByList(P.Application, bh._plugins);
  Mt.add(_h);
  bg = class {
    static init(t) {
      Object.defineProperty(this, "resizeTo", {
        set(e) {
          globalThis.removeEventListener("resize", this.queueResize), this._resizeTo = e, e && (globalThis.addEventListener("resize", this.queueResize), this.resize());
        },
        get() {
          return this._resizeTo;
        }
      }), this.queueResize = () => {
        this._resizeTo && (this._cancelResize(), this._resizeId = requestAnimationFrame(() => this.resize()));
      }, this._cancelResize = () => {
        this._resizeId && (cancelAnimationFrame(this._resizeId), this._resizeId = null);
      }, this.resize = () => {
        if (!this._resizeTo) return;
        this._cancelResize();
        let e, r;
        if (this._resizeTo === globalThis.window) e = globalThis.innerWidth, r = globalThis.innerHeight;
        else {
          const { clientWidth: s, clientHeight: n } = this._resizeTo;
          e = s, r = n;
        }
        this.renderer.resize(e, r), this.render();
      }, this._resizeId = null, this._resizeTo = null, this.resizeTo = t.resizeTo || null;
    }
    static destroy() {
      globalThis.removeEventListener("resize", this.queueResize), this._cancelResize(), this._cancelResize = null, this.queueResize = null, this.resizeTo = null, this.resize = null;
    }
  };
  bg.extension = P.Application;
  wg = class {
    static init(t) {
      t = Object.assign({
        autoStart: true,
        sharedTicker: false
      }, t), Object.defineProperty(this, "ticker", {
        set(e) {
          this._ticker && this._ticker.remove(this.render, this), this._ticker = e, e && e.add(this.render, this, dr.LOW);
        },
        get() {
          return this._ticker;
        }
      }), this.stop = () => {
        this._ticker.stop();
      }, this.start = () => {
        this._ticker.start();
      }, this._ticker = null, this.ticker = t.sharedTicker ? ae.shared : new ae(), t.autoStart && this.start();
    }
    static destroy() {
      if (this._ticker) {
        const t = this._ticker;
        this.ticker = null, t.destroy();
      }
    }
  };
  wg.extension = P.Application;
  class wh extends me {
    constructor() {
      super(...arguments), this.chars = /* @__PURE__ */ Object.create(null), this.lineHeight = 0, this.fontFamily = "", this.fontMetrics = {
        fontSize: 0,
        ascent: 0,
        descent: 0
      }, this.baseLineOffset = 0, this.distanceField = {
        type: "none",
        range: 0
      }, this.pages = [], this.applyFillAsTint = true, this.baseMeasurementFontSize = 100, this.baseRenderedFontSize = 100;
    }
    get font() {
      return lt(dt, "BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead."), this.fontFamily;
    }
    get pageTextures() {
      return lt(dt, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."), this.pages;
    }
    get size() {
      return lt(dt, "BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead."), this.fontMetrics.fontSize;
    }
    get distanceFieldRange() {
      return lt(dt, "BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead."), this.distanceField.range;
    }
    get distanceFieldType() {
      return lt(dt, "BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead."), this.distanceField.type;
    }
    destroy(t = false) {
      var _a2;
      this.emit("destroy", this), this.removeAllListeners();
      for (const e in this.chars) (_a2 = this.chars[e].texture) == null ? void 0 : _a2.destroy();
      this.chars = null, t && (this.pages.forEach((e) => e.texture.destroy(true)), this.pages = null);
    }
  }
  const yh = class Mo {
    constructor(t, e, r, s) {
      this.uid = Ot("fillGradient"), this.type = "linear", this.gradientStops = [], this._styleKey = null, this.x0 = t, this.y0 = e, this.x1 = r, this.y1 = s;
    }
    addColorStop(t, e) {
      return this.gradientStops.push({
        offset: t,
        color: Tt.shared.setValue(e).toHexa()
      }), this._styleKey = null, this;
    }
    buildLinearGradient() {
      const t = Mo.defaultTextureSize, { gradientStops: e } = this, r = St.get().createCanvas();
      r.width = t, r.height = t;
      const s = r.getContext("2d"), n = s.createLinearGradient(0, 0, Mo.defaultTextureSize, 1);
      for (let y = 0; y < e.length; y++) {
        const m = e[y];
        n.addColorStop(m.offset, m.color);
      }
      s.fillStyle = n, s.fillRect(0, 0, t, t), this.texture = new Z({
        source: new ei({
          resource: r,
          addressModeU: "clamp-to-edge",
          addressModeV: "repeat"
        })
      });
      const { x0: o, y0: a, x1: c, y1: l } = this, u = new st(), h = c - o, d = l - a, p = Math.sqrt(h * h + d * d), g = Math.atan2(d, h);
      u.translate(-o, -a), u.scale(1 / t, 1 / t), u.rotate(-g), u.scale(256 / p, 1), this.transform = u, this._styleKey = null;
    }
    get styleKey() {
      if (this._styleKey) return this._styleKey;
      const t = this.gradientStops.map((s) => `${s.offset}-${s.color}`).join("-"), e = this.texture.uid, r = this.transform.toArray().join("-");
      return `fill-gradient-${this.uid}-${t}-${e}-${r}-${this.x0}-${this.y0}-${this.x1}-${this.y1}`;
    }
  };
  yh.defaultTextureSize = 256;
  let Ri = yh;
  const kc = {
    repeat: {
      addressModeU: "repeat",
      addressModeV: "repeat"
    },
    "repeat-x": {
      addressModeU: "repeat",
      addressModeV: "clamp-to-edge"
    },
    "repeat-y": {
      addressModeU: "clamp-to-edge",
      addressModeV: "repeat"
    },
    "no-repeat": {
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge"
    }
  };
  class Zs {
    constructor(t, e) {
      this.uid = Ot("fillPattern"), this.transform = new st(), this._styleKey = null, this.texture = t, this.transform.scale(1 / t.frame.width, 1 / t.frame.height), e && (t.source.style.addressModeU = kc[e].addressModeU, t.source.style.addressModeV = kc[e].addressModeV);
    }
    setTransform(t) {
      const e = this.texture;
      this.transform.copyFrom(t), this.transform.invert(), this.transform.scale(1 / e.frame.width, 1 / e.frame.height), this._styleKey = null;
    }
    get styleKey() {
      return this._styleKey ? this._styleKey : (this._styleKey = `fill-pattern-${this.uid}-${this.texture.uid}-${this.transform.toArray().join("-")}`, this._styleKey);
    }
  }
  var Yn, Gc;
  function yg() {
    if (Gc) return Yn;
    Gc = 1, Yn = e;
    var i = {
      a: 7,
      c: 6,
      h: 1,
      l: 2,
      m: 2,
      q: 4,
      s: 4,
      t: 2,
      v: 1,
      z: 0
    }, t = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
    function e(n) {
      var o = [];
      return n.replace(t, function(a, c, l) {
        var u = c.toLowerCase();
        for (l = s(l), u == "m" && l.length > 2 && (o.push([
          c
        ].concat(l.splice(0, 2))), u = "l", c = c == "m" ? "l" : "L"); ; ) {
          if (l.length == i[u]) return l.unshift(c), o.push(l);
          if (l.length < i[u]) throw new Error("malformed path data");
          o.push([
            c
          ].concat(l.splice(0, i[u])));
        }
      }), o;
    }
    var r = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
    function s(n) {
      var o = n.match(r);
      return o ? o.map(Number) : [];
    }
    return Yn;
  }
  var xg = yg();
  const vg = Vs(xg);
  function Sg(i, t) {
    const e = vg(i), r = [];
    let s = null, n = 0, o = 0;
    for (let a = 0; a < e.length; a++) {
      const c = e[a], l = c[0], u = c;
      switch (l) {
        case "M":
          n = u[1], o = u[2], t.moveTo(n, o);
          break;
        case "m":
          n += u[1], o += u[2], t.moveTo(n, o);
          break;
        case "H":
          n = u[1], t.lineTo(n, o);
          break;
        case "h":
          n += u[1], t.lineTo(n, o);
          break;
        case "V":
          o = u[1], t.lineTo(n, o);
          break;
        case "v":
          o += u[1], t.lineTo(n, o);
          break;
        case "L":
          n = u[1], o = u[2], t.lineTo(n, o);
          break;
        case "l":
          n += u[1], o += u[2], t.lineTo(n, o);
          break;
        case "C":
          n = u[5], o = u[6], t.bezierCurveTo(u[1], u[2], u[3], u[4], n, o);
          break;
        case "c":
          t.bezierCurveTo(n + u[1], o + u[2], n + u[3], o + u[4], n + u[5], o + u[6]), n += u[5], o += u[6];
          break;
        case "S":
          n = u[3], o = u[4], t.bezierCurveToShort(u[1], u[2], n, o);
          break;
        case "s":
          t.bezierCurveToShort(n + u[1], o + u[2], n + u[3], o + u[4]), n += u[3], o += u[4];
          break;
        case "Q":
          n = u[3], o = u[4], t.quadraticCurveTo(u[1], u[2], n, o);
          break;
        case "q":
          t.quadraticCurveTo(n + u[1], o + u[2], n + u[3], o + u[4]), n += u[3], o += u[4];
          break;
        case "T":
          n = u[1], o = u[2], t.quadraticCurveToShort(n, o);
          break;
        case "t":
          n += u[1], o += u[2], t.quadraticCurveToShort(n, o);
          break;
        case "A":
          n = u[6], o = u[7], t.arcToSvg(u[1], u[2], u[3], u[4], u[5], n, o);
          break;
        case "a":
          n += u[6], o += u[7], t.arcToSvg(u[1], u[2], u[3], u[4], u[5], n, o);
          break;
        case "Z":
        case "z":
          t.closePath(), r.length > 0 && (s = r.pop(), s ? (n = s.startX, o = s.startY) : (n = 0, o = 0)), s = null;
          break;
        default:
          ut(`Unknown SVG path command: ${l}`);
      }
      l !== "Z" && l !== "z" && s === null && (s = {
        startX: n,
        startY: o
      }, r.push(s));
    }
    return t;
  }
  class sa {
    constructor(t = 0, e = 0, r = 0) {
      this.type = "circle", this.x = t, this.y = e, this.radius = r;
    }
    clone() {
      return new sa(this.x, this.y, this.radius);
    }
    contains(t, e) {
      if (this.radius <= 0) return false;
      const r = this.radius * this.radius;
      let s = this.x - t, n = this.y - e;
      return s *= s, n *= n, s + n <= r;
    }
    strokeContains(t, e, r) {
      if (this.radius === 0) return false;
      const s = this.x - t, n = this.y - e, o = this.radius, a = r / 2, c = Math.sqrt(s * s + n * n);
      return c < o + a && c > o - a;
    }
    getBounds(t) {
      return t = t || new Et(), t.x = this.x - this.radius, t.y = this.y - this.radius, t.width = this.radius * 2, t.height = this.radius * 2, t;
    }
    copyFrom(t) {
      return this.x = t.x, this.y = t.y, this.radius = t.radius, this;
    }
    copyTo(t) {
      return t.copyFrom(this), t;
    }
    toString() {
      return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
    }
  }
  class na {
    constructor(t = 0, e = 0, r = 0, s = 0) {
      this.type = "ellipse", this.x = t, this.y = e, this.halfWidth = r, this.halfHeight = s;
    }
    clone() {
      return new na(this.x, this.y, this.halfWidth, this.halfHeight);
    }
    contains(t, e) {
      if (this.halfWidth <= 0 || this.halfHeight <= 0) return false;
      let r = (t - this.x) / this.halfWidth, s = (e - this.y) / this.halfHeight;
      return r *= r, s *= s, r + s <= 1;
    }
    strokeContains(t, e, r) {
      const { halfWidth: s, halfHeight: n } = this;
      if (s <= 0 || n <= 0) return false;
      const o = r / 2, a = s - o, c = n - o, l = s + o, u = n + o, h = t - this.x, d = e - this.y, p = h * h / (a * a) + d * d / (c * c), g = h * h / (l * l) + d * d / (u * u);
      return p > 1 && g <= 1;
    }
    getBounds(t) {
      return t = t || new Et(), t.x = this.x - this.halfWidth, t.y = this.y - this.halfHeight, t.width = this.halfWidth * 2, t.height = this.halfHeight * 2, t;
    }
    copyFrom(t) {
      return this.x = t.x, this.y = t.y, this.halfWidth = t.halfWidth, this.halfHeight = t.halfHeight, this;
    }
    copyTo(t) {
      return t.copyFrom(this), t;
    }
    toString() {
      return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;
    }
  }
  function Eg(i, t, e, r, s, n) {
    const o = i - e, a = t - r, c = s - e, l = n - r, u = o * c + a * l, h = c * c + l * l;
    let d = -1;
    h !== 0 && (d = u / h);
    let p, g;
    d < 0 ? (p = e, g = r) : d > 1 ? (p = s, g = n) : (p = e + d * c, g = r + d * l);
    const y = i - p, m = t - g;
    return y * y + m * m;
  }
  class vi {
    constructor(...t) {
      this.type = "polygon";
      let e = Array.isArray(t[0]) ? t[0] : t;
      if (typeof e[0] != "number") {
        const r = [];
        for (let s = 0, n = e.length; s < n; s++) r.push(e[s].x, e[s].y);
        e = r;
      }
      this.points = e, this.closePath = true;
    }
    clone() {
      const t = this.points.slice(), e = new vi(t);
      return e.closePath = this.closePath, e;
    }
    contains(t, e) {
      let r = false;
      const s = this.points.length / 2;
      for (let n = 0, o = s - 1; n < s; o = n++) {
        const a = this.points[n * 2], c = this.points[n * 2 + 1], l = this.points[o * 2], u = this.points[o * 2 + 1];
        c > e != u > e && t < (l - a) * ((e - c) / (u - c)) + a && (r = !r);
      }
      return r;
    }
    strokeContains(t, e, r) {
      const s = r / 2, n = s * s, { points: o } = this, a = o.length - (this.closePath ? 0 : 2);
      for (let c = 0; c < a; c += 2) {
        const l = o[c], u = o[c + 1], h = o[(c + 2) % o.length], d = o[(c + 3) % o.length];
        if (Eg(t, e, l, u, h, d) <= n) return true;
      }
      return false;
    }
    getBounds(t) {
      t = t || new Et();
      const e = this.points;
      let r = 1 / 0, s = -1 / 0, n = 1 / 0, o = -1 / 0;
      for (let a = 0, c = e.length; a < c; a += 2) {
        const l = e[a], u = e[a + 1];
        r = l < r ? l : r, s = l > s ? l : s, n = u < n ? u : n, o = u > o ? u : o;
      }
      return t.x = r, t.width = s - r, t.y = n, t.height = o - n, t;
    }
    copyFrom(t) {
      return this.points = t.points.slice(), this.closePath = t.closePath, this;
    }
    copyTo(t) {
      return t.copyFrom(this), t;
    }
    toString() {
      return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((t, e) => `${t}, ${e}`, "")}]`;
    }
    get lastX() {
      return this.points[this.points.length - 2];
    }
    get lastY() {
      return this.points[this.points.length - 1];
    }
    get x() {
      return this.points[this.points.length - 2];
    }
    get y() {
      return this.points[this.points.length - 1];
    }
  }
  const es = (i, t, e, r, s, n) => {
    const o = i - e, a = t - r, c = Math.sqrt(o * o + a * a);
    return c >= s - n && c <= s + n;
  };
  class oa {
    constructor(t = 0, e = 0, r = 0, s = 0, n = 20) {
      this.type = "roundedRectangle", this.x = t, this.y = e, this.width = r, this.height = s, this.radius = n;
    }
    getBounds(t) {
      return t = t || new Et(), t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t;
    }
    clone() {
      return new oa(this.x, this.y, this.width, this.height, this.radius);
    }
    copyFrom(t) {
      return this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height, this;
    }
    copyTo(t) {
      return t.copyFrom(this), t;
    }
    contains(t, e) {
      if (this.width <= 0 || this.height <= 0) return false;
      if (t >= this.x && t <= this.x + this.width && e >= this.y && e <= this.y + this.height) {
        const r = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
        if (e >= this.y + r && e <= this.y + this.height - r || t >= this.x + r && t <= this.x + this.width - r) return true;
        let s = t - (this.x + r), n = e - (this.y + r);
        const o = r * r;
        if (s * s + n * n <= o || (s = t - (this.x + this.width - r), s * s + n * n <= o) || (n = e - (this.y + this.height - r), s * s + n * n <= o) || (s = t - (this.x + r), s * s + n * n <= o)) return true;
      }
      return false;
    }
    strokeContains(t, e, r) {
      const { x: s, y: n, width: o, height: a, radius: c } = this, l = r / 2, u = s + c, h = n + c, d = o - c * 2, p = a - c * 2, g = s + o, y = n + a;
      return (t >= s - l && t <= s + l || t >= g - l && t <= g + l) && e >= h && e <= h + p || (e >= n - l && e <= n + l || e >= y - l && e <= y + l) && t >= u && t <= u + d ? true : t < u && e < h && es(t, e, u, h, c, l) || t > g - c && e < h && es(t, e, g - c, h, c, l) || t > g - c && e > y - c && es(t, e, g - c, y - c, c, l) || t < u && e > y - c && es(t, e, u, y - c, c, l);
    }
    toString() {
      return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
    }
  }
  const Tg = [
    "precision mediump float;",
    "void main(void){",
    "float test = 0.1;",
    "%forloop%",
    "gl_FragColor = vec4(0.0);",
    "}"
  ].join(`
`);
  function Cg(i) {
    let t = "";
    for (let e = 0; e < i; ++e) e > 0 && (t += `
else `), e < i - 1 && (t += `if(test == ${e}.0){}`);
    return t;
  }
  function Ag(i, t) {
    if (i === 0) throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
    const e = t.createShader(t.FRAGMENT_SHADER);
    for (; ; ) {
      const r = Tg.replace(/%forloop%/gi, Cg(i));
      if (t.shaderSource(e, r), t.compileShader(e), !t.getShaderParameter(e, t.COMPILE_STATUS)) i = i / 2 | 0;
      else break;
    }
    return i;
  }
  let Lr = null;
  function Fr() {
    if (Lr) return Lr;
    const i = sh();
    return Lr = i.getParameter(i.MAX_TEXTURE_IMAGE_UNITS), Lr = Ag(Lr, i), Lr;
  }
  const xh = {};
  function aa(i, t) {
    let e = 0;
    for (let r = 0; r < t; r++) e = e * 31 + i[r].uid >>> 0;
    return xh[e] || Rg(i, t, e);
  }
  let Kn = 0;
  function Rg(i, t, e) {
    const r = {};
    let s = 0;
    Kn || (Kn = Fr());
    for (let o = 0; o < Kn; o++) {
      const a = o < t ? i[o] : Z.EMPTY.source;
      r[s++] = a.source, r[s++] = a.style;
    }
    const n = new Ze(r);
    return xh[e] = n, n;
  }
  class Oc {
    constructor(t) {
      typeof t == "number" ? this.rawBinaryData = new ArrayBuffer(t) : t instanceof Uint8Array ? this.rawBinaryData = t.buffer : this.rawBinaryData = t, this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData), this.size = this.rawBinaryData.byteLength;
    }
    get int8View() {
      return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View;
    }
    get uint8View() {
      return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View;
    }
    get int16View() {
      return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View;
    }
    get int32View() {
      return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View;
    }
    get float64View() {
      return this._float64Array || (this._float64Array = new Float64Array(this.rawBinaryData)), this._float64Array;
    }
    get bigUint64View() {
      return this._bigUint64Array || (this._bigUint64Array = new BigUint64Array(this.rawBinaryData)), this._bigUint64Array;
    }
    view(t) {
      return this[`${t}View`];
    }
    destroy() {
      this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this.uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null;
    }
    static sizeOf(t) {
      switch (t) {
        case "int8":
        case "uint8":
          return 1;
        case "int16":
        case "uint16":
          return 2;
        case "int32":
        case "uint32":
        case "float32":
          return 4;
        default:
          throw new Error(`${t} isn't a valid view type`);
      }
    }
  }
  function Do(i, t) {
    const e = i.byteLength / 8 | 0, r = new Float64Array(i, 0, e);
    new Float64Array(t, 0, e).set(r);
    const n = i.byteLength - e * 8;
    if (n > 0) {
      const o = new Uint8Array(i, e * 8, n);
      new Uint8Array(t, e * 8, n).set(o);
    }
  }
  const Pg = {
    normal: "normal-npm",
    add: "add-npm",
    screen: "screen-npm"
  };
  var Kt = ((i) => (i[i.DISABLED = 0] = "DISABLED", i[i.RENDERING_MASK_ADD = 1] = "RENDERING_MASK_ADD", i[i.MASK_ACTIVE = 2] = "MASK_ACTIVE", i[i.RENDERING_MASK_REMOVE = 3] = "RENDERING_MASK_REMOVE", i[i.NONE = 4] = "NONE", i))(Kt || {});
  function Ds(i, t) {
    return t.alphaMode === "no-premultiply-alpha" && Pg[i] || i;
  }
  class Bg {
    constructor() {
      this.ids = /* @__PURE__ */ Object.create(null), this.textures = [], this.count = 0;
    }
    clear() {
      for (let t = 0; t < this.count; t++) {
        const e = this.textures[t];
        this.textures[t] = null, this.ids[e.uid] = null;
      }
      this.count = 0;
    }
  }
  class Mg {
    constructor() {
      this.renderPipeId = "batch", this.action = "startBatch", this.start = 0, this.size = 0, this.textures = new Bg(), this.blendMode = "normal", this.canBundle = true;
    }
    destroy() {
      this.textures = null, this.gpuBindGroup = null, this.bindGroup = null, this.batcher = null;
    }
  }
  const vh = [];
  let Io = 0;
  function Nc() {
    return Io > 0 ? vh[--Io] : new Mg();
  }
  function Lc(i) {
    vh[Io++] = i;
  }
  let ci = 0;
  const Sh = class Eh {
    constructor(t = {}) {
      this.uid = Ot("batcher"), this.dirty = true, this.batchIndex = 0, this.batches = [], this._vertexSize = 6, this._elements = [], t = {
        ...Eh.defaultOptions,
        ...t
      };
      const { vertexSize: e, indexSize: r } = t;
      this.attributeBuffer = new Oc(e * this._vertexSize * 4), this.indexBuffer = new Uint16Array(r), this._maxTextures = Fr();
    }
    begin() {
      this.elementSize = 0, this.elementStart = 0, this.indexSize = 0, this.attributeSize = 0;
      for (let t = 0; t < this.batchIndex; t++) Lc(this.batches[t]);
      this.batchIndex = 0, this._batchIndexStart = 0, this._batchIndexSize = 0, this.dirty = true;
    }
    add(t) {
      this._elements[this.elementSize++] = t, t.indexStart = this.indexSize, t.location = this.attributeSize, t.batcher = this, this.indexSize += t.indexSize, this.attributeSize += t.vertexSize * this._vertexSize;
    }
    checkAndUpdateTexture(t, e) {
      const r = t.batch.textures.ids[e._source.uid];
      return !r && r !== 0 ? false : (t.textureId = r, t.texture = e, true);
    }
    updateElement(t) {
      this.dirty = true, t.packAttributes(this.attributeBuffer.float32View, this.attributeBuffer.uint32View, t.location, t.textureId);
    }
    break(t) {
      const e = this._elements;
      if (!e[this.elementStart]) return;
      let r = Nc(), s = r.textures;
      s.clear();
      const n = e[this.elementStart];
      let o = Ds(n.blendMode, n.texture._source);
      this.attributeSize * 4 > this.attributeBuffer.size && this._resizeAttributeBuffer(this.attributeSize * 4), this.indexSize > this.indexBuffer.length && this._resizeIndexBuffer(this.indexSize);
      const a = this.attributeBuffer.float32View, c = this.attributeBuffer.uint32View, l = this.indexBuffer;
      let u = this._batchIndexSize, h = this._batchIndexStart, d = "startBatch";
      const p = this._maxTextures;
      for (let g = this.elementStart; g < this.elementSize; ++g) {
        const y = e[g];
        e[g] = null;
        const v = y.texture._source, S = Ds(y.blendMode, v), C = o !== S;
        if (v._batchTick === ci && !C) {
          y.textureId = v._textureBindLocation, u += y.indexSize, y.packAttributes(a, c, y.location, y.textureId), y.packIndex(l, y.indexStart, y.location / this._vertexSize), y.batch = r;
          continue;
        }
        v._batchTick = ci, (s.count >= p || C) && (this._finishBatch(r, h, u - h, s, o, t, d), d = "renderBatch", h = u, o = S, r = Nc(), s = r.textures, s.clear(), ++ci), y.textureId = v._textureBindLocation = s.count, s.ids[v.uid] = s.count, s.textures[s.count++] = v, y.batch = r, u += y.indexSize, y.packAttributes(a, c, y.location, y.textureId), y.packIndex(l, y.indexStart, y.location / this._vertexSize);
      }
      s.count > 0 && (this._finishBatch(r, h, u - h, s, o, t, d), h = u, ++ci), this.elementStart = this.elementSize, this._batchIndexStart = h, this._batchIndexSize = u;
    }
    _finishBatch(t, e, r, s, n, o, a) {
      t.gpuBindGroup = null, t.bindGroup = null, t.action = a, t.batcher = this, t.textures = s, t.blendMode = n, t.start = e, t.size = r, ++ci, this.batches[this.batchIndex++] = t, o.add(t);
    }
    finish(t) {
      this.break(t);
    }
    ensureAttributeBuffer(t) {
      t * 4 <= this.attributeBuffer.size || this._resizeAttributeBuffer(t * 4);
    }
    ensureIndexBuffer(t) {
      t <= this.indexBuffer.length || this._resizeIndexBuffer(t);
    }
    _resizeAttributeBuffer(t) {
      const e = Math.max(t, this.attributeBuffer.size * 2), r = new Oc(e);
      Do(this.attributeBuffer.rawBinaryData, r.rawBinaryData), this.attributeBuffer = r;
    }
    _resizeIndexBuffer(t) {
      const e = this.indexBuffer;
      let r = Math.max(t, e.length * 1.5);
      r += r % 2;
      const s = r > 65535 ? new Uint32Array(r) : new Uint16Array(r);
      if (s.BYTES_PER_ELEMENT !== e.BYTES_PER_ELEMENT) for (let n = 0; n < e.length; n++) s[n] = e[n];
      else Do(e.buffer, s.buffer);
      this.indexBuffer = s;
    }
    destroy() {
      for (let t = 0; t < this.batches.length; t++) Lc(this.batches[t]);
      this.batches = null;
      for (let t = 0; t < this._elements.length; t++) this._elements[t].batch = null;
      this._elements = null, this.indexBuffer = null, this.attributeBuffer.destroy(), this.attributeBuffer = null;
    }
  };
  Sh.defaultOptions = {
    vertexSize: 4,
    indexSize: 6
  };
  let Th = Sh;
  var yt = ((i) => (i[i.MAP_READ = 1] = "MAP_READ", i[i.MAP_WRITE = 2] = "MAP_WRITE", i[i.COPY_SRC = 4] = "COPY_SRC", i[i.COPY_DST = 8] = "COPY_DST", i[i.INDEX = 16] = "INDEX", i[i.VERTEX = 32] = "VERTEX", i[i.UNIFORM = 64] = "UNIFORM", i[i.STORAGE = 128] = "STORAGE", i[i.INDIRECT = 256] = "INDIRECT", i[i.QUERY_RESOLVE = 512] = "QUERY_RESOLVE", i[i.STATIC = 1024] = "STATIC", i))(yt || {});
  let Pe = class extends me {
    constructor(t) {
      let { data: e, size: r } = t;
      const { usage: s, label: n, shrinkToFit: o } = t;
      super(), this.uid = Ot("buffer"), this._resourceType = "buffer", this._resourceId = Ot("resource"), this._touched = 0, this._updateID = 1, this.shrinkToFit = true, this.destroyed = false, e instanceof Array && (e = new Float32Array(e)), this._data = e, r = r ?? (e == null ? void 0 : e.byteLength);
      const a = !!e;
      this.descriptor = {
        size: r,
        usage: s,
        mappedAtCreation: a,
        label: n
      }, this.shrinkToFit = o ?? true;
    }
    get data() {
      return this._data;
    }
    set data(t) {
      this.setDataWithSize(t, t.length, true);
    }
    get static() {
      return !!(this.descriptor.usage & yt.STATIC);
    }
    set static(t) {
      t ? this.descriptor.usage |= yt.STATIC : this.descriptor.usage &= ~yt.STATIC;
    }
    setDataWithSize(t, e, r) {
      if (this._updateID++, this._updateSize = e * t.BYTES_PER_ELEMENT, this._data === t) {
        r && this.emit("update", this);
        return;
      }
      const s = this._data;
      if (this._data = t, s.length !== t.length) {
        !this.shrinkToFit && t.byteLength < s.byteLength ? r && this.emit("update", this) : (this.descriptor.size = t.byteLength, this._resourceId = Ot("resource"), this.emit("change", this));
        return;
      }
      r && this.emit("update", this);
    }
    update(t) {
      this._updateSize = t ?? this._updateSize, this._updateID++, this.emit("update", this);
    }
    destroy() {
      this.destroyed = true, this.emit("destroy", this), this.emit("change", this), this._data = null, this.descriptor = null, this.removeAllListeners();
    }
  };
  function Ch(i, t) {
    if (!(i instanceof Pe)) {
      let e = t ? yt.INDEX : yt.VERTEX;
      i instanceof Array && (t ? (i = new Uint32Array(i), e = yt.INDEX | yt.COPY_DST) : (i = new Float32Array(i), e = yt.VERTEX | yt.COPY_DST)), i = new Pe({
        data: i,
        label: t ? "index-mesh-buffer" : "vertex-mesh-buffer",
        usage: e
      });
    }
    return i;
  }
  function Dg(i, t, e) {
    const r = i.getAttribute(t);
    if (!r) return e.minX = 0, e.minY = 0, e.maxX = 0, e.maxY = 0, e;
    const s = r.buffer.data;
    let n = 1 / 0, o = 1 / 0, a = -1 / 0, c = -1 / 0;
    const l = s.BYTES_PER_ELEMENT, u = (r.offset || 0) / l, h = (r.stride || 2 * 4) / l;
    for (let d = u; d < s.length; d += h) {
      const p = s[d], g = s[d + 1];
      p > a && (a = p), g > c && (c = g), p < n && (n = p), g < o && (o = g);
    }
    return e.minX = n, e.minY = o, e.maxX = a, e.maxY = c, e;
  }
  function Ig(i) {
    return (i instanceof Pe || Array.isArray(i) || i.BYTES_PER_ELEMENT) && (i = {
      buffer: i
    }), i.buffer = Ch(i.buffer, false), i;
  }
  class Fi extends me {
    constructor(t) {
      const { attributes: e, indexBuffer: r, topology: s } = t;
      super(), this.uid = Ot("geometry"), this._layoutKey = 0, this.instanceCount = 1, this._bounds = new re(), this._boundsDirty = true, this.attributes = e, this.buffers = [], this.instanceCount = t.instanceCount || 1;
      for (const n in e) {
        const o = e[n] = Ig(e[n]);
        this.buffers.indexOf(o.buffer) === -1 && (this.buffers.push(o.buffer), o.buffer.on("update", this.onBufferUpdate, this), o.buffer.on("change", this.onBufferUpdate, this));
      }
      r && (this.indexBuffer = Ch(r, true), this.buffers.push(this.indexBuffer)), this.topology = s || "triangle-list";
    }
    onBufferUpdate() {
      this._boundsDirty = true, this.emit("update", this);
    }
    getAttribute(t) {
      return this.attributes[t];
    }
    getIndex() {
      return this.indexBuffer;
    }
    getBuffer(t) {
      return this.getAttribute(t).buffer;
    }
    getSize() {
      for (const t in this.attributes) {
        const e = this.attributes[t];
        return e.buffer.data.length / (e.stride / 4 || e.size);
      }
      return 0;
    }
    get bounds() {
      return this._boundsDirty ? (this._boundsDirty = false, Dg(this, "aPosition", this._bounds)) : this._bounds;
    }
    destroy(t = false) {
      this.emit("destroy", this), this.removeAllListeners(), t && this.buffers.forEach((e) => e.destroy()), this.attributes = null, this.buffers = null, this.indexBuffer = null, this._bounds = null;
    }
  }
  const Fg = new Float32Array(1), Ug = new Uint32Array(1);
  class Ah extends Fi {
    constructor() {
      const e = new Pe({
        data: Fg,
        label: "attribute-batch-buffer",
        usage: yt.VERTEX | yt.COPY_DST,
        shrinkToFit: false
      }), r = new Pe({
        data: Ug,
        label: "index-batch-buffer",
        usage: yt.INDEX | yt.COPY_DST,
        shrinkToFit: false
      }), s = 6 * 4;
      super({
        attributes: {
          aPosition: {
            buffer: e,
            format: "float32x2",
            stride: s,
            offset: 0,
            location: 1
          },
          aUV: {
            buffer: e,
            format: "float32x2",
            stride: s,
            offset: 2 * 4,
            location: 3
          },
          aColor: {
            buffer: e,
            format: "unorm8x4",
            stride: s,
            offset: 4 * 4,
            location: 0
          },
          aTextureIdAndRound: {
            buffer: e,
            format: "uint16x2",
            stride: s,
            offset: 5 * 4,
            location: 2
          }
        },
        indexBuffer: r
      });
    }
  }
  function kg(i, t, e, r, s, n, o, a = null) {
    let c = 0;
    e *= t, s *= n;
    const l = a.a, u = a.b, h = a.c, d = a.d, p = a.tx, g = a.ty;
    for (; c < o; ) {
      const y = i[e], m = i[e + 1];
      r[s] = l * y + h * m + p, r[s + 1] = u * y + d * m + g, s += n, e += t, c++;
    }
  }
  function Gg(i, t, e, r) {
    let s = 0;
    for (t *= e; s < r; ) i[t] = 0, i[t + 1] = 0, t += e, s++;
  }
  function Rh(i, t, e, r, s) {
    const n = t.a, o = t.b, a = t.c, c = t.d, l = t.tx, u = t.ty;
    e = e || 0, r = r || 2, s = s || i.length / r - e;
    let h = e * r;
    for (let d = 0; d < s; d++) {
      const p = i[h], g = i[h + 1];
      i[h] = n * p + a * g + l, i[h + 1] = o * p + c * g + u, h += r;
    }
  }
  function Og(i, t) {
    if (i === 16777215 || !t) return t;
    if (t === 16777215 || !i) return i;
    const e = i >> 16 & 255, r = i >> 8 & 255, s = i & 255, n = t >> 16 & 255, o = t >> 8 & 255, a = t & 255, c = e * n / 255, l = r * o / 255, u = s * a / 255;
    return (c << 16) + (l << 8) + u;
  }
  class ca {
    constructor() {
      this.batcher = null, this.batch = null, this.applyTransform = true, this.roundPixels = 0;
    }
    get blendMode() {
      return this.applyTransform ? this.renderable.groupBlendMode : "normal";
    }
    packIndex(t, e, r) {
      const s = this.geometryData.indices;
      for (let n = 0; n < this.indexSize; n++) t[e++] = s[n + this.indexOffset] + r - this.vertexOffset;
    }
    packAttributes(t, e, r, s) {
      const n = this.geometryData, o = this.renderable, a = n.vertices, c = n.uvs, l = this.vertexOffset * 2, u = (this.vertexOffset + this.vertexSize) * 2, h = this.color, d = h >> 16 | h & 65280 | (h & 255) << 16;
      if (this.applyTransform) {
        const p = Og(d, o.groupColor) + (this.alpha * o.groupAlpha * 255 << 24), g = o.groupTransform, y = s << 16 | this.roundPixels & 65535, m = g.a, v = g.b, S = g.c, C = g.d, G = g.tx, H = g.ty;
        for (let Y = l; Y < u; Y += 2) {
          const L = a[Y], W = a[Y + 1];
          t[r] = m * L + S * W + G, t[r + 1] = v * L + C * W + H, t[r + 2] = c[Y], t[r + 3] = c[Y + 1], e[r + 4] = p, e[r + 5] = y, r += 6;
        }
      } else {
        const p = d + (this.alpha * 255 << 24);
        for (let g = l; g < u; g += 2) t[r] = a[g], t[r + 1] = a[g + 1], t[r + 2] = c[g], t[r + 3] = c[g + 1], e[r + 4] = p, e[r + 5] = s << 16, r += 6;
      }
    }
    get vertSize() {
      return this.vertexSize;
    }
    copyTo(t) {
      t.indexOffset = this.indexOffset, t.indexSize = this.indexSize, t.vertexOffset = this.vertexOffset, t.vertexSize = this.vertexSize, t.color = this.color, t.alpha = this.alpha, t.texture = this.texture, t.geometryData = this.geometryData;
    }
    reset() {
      this.applyTransform = true;
    }
  }
  const Pi = {
    extension: {
      type: P.ShapeBuilder,
      name: "circle"
    },
    build(i, t) {
      let e, r, s, n, o, a;
      if (i.type === "circle") {
        const G = i;
        e = G.x, r = G.y, o = a = G.radius, s = n = 0;
      } else if (i.type === "ellipse") {
        const G = i;
        e = G.x, r = G.y, o = G.halfWidth, a = G.halfHeight, s = n = 0;
      } else {
        const G = i, H = G.width / 2, Y = G.height / 2;
        e = G.x + H, r = G.y + Y, o = a = Math.max(0, Math.min(G.radius, Math.min(H, Y))), s = H - o, n = Y - a;
      }
      if (!(o >= 0 && a >= 0 && s >= 0 && n >= 0)) return t;
      const c = Math.ceil(2.3 * Math.sqrt(o + a)), l = c * 8 + (s ? 4 : 0) + (n ? 4 : 0);
      if (l === 0) return t;
      if (c === 0) return t[0] = t[6] = e + s, t[1] = t[3] = r + n, t[2] = t[4] = e - s, t[5] = t[7] = r - n, t;
      let u = 0, h = c * 4 + (s ? 2 : 0) + 2, d = h, p = l, g = s + o, y = n, m = e + g, v = e - g, S = r + y;
      if (t[u++] = m, t[u++] = S, t[--h] = S, t[--h] = v, n) {
        const G = r - y;
        t[d++] = v, t[d++] = G, t[--p] = G, t[--p] = m;
      }
      for (let G = 1; G < c; G++) {
        const H = Math.PI / 2 * (G / c), Y = s + Math.cos(H) * o, L = n + Math.sin(H) * a, W = e + Y, A = e - Y, I = r + L, z = r - L;
        t[u++] = W, t[u++] = I, t[--h] = I, t[--h] = A, t[d++] = A, t[d++] = z, t[--p] = z, t[--p] = W;
      }
      g = s, y = n + a, m = e + g, v = e - g, S = r + y;
      const C = r - y;
      return t[u++] = m, t[u++] = S, t[--p] = C, t[--p] = m, s && (t[u++] = v, t[u++] = S, t[--p] = C, t[--p] = v), t;
    },
    triangulate(i, t, e, r, s, n) {
      if (i.length === 0) return;
      let o = 0, a = 0;
      for (let u = 0; u < i.length; u += 2) o += i[u], a += i[u + 1];
      o /= i.length / 2, a /= i.length / 2;
      let c = r;
      t[c * e] = o, t[c * e + 1] = a;
      const l = c++;
      for (let u = 0; u < i.length; u += 2) t[c * e] = i[u], t[c * e + 1] = i[u + 1], u > 0 && (s[n++] = c, s[n++] = l, s[n++] = c - 1), c++;
      s[n++] = l + 1, s[n++] = l, s[n++] = c - 1;
    }
  }, Ng = {
    ...Pi,
    extension: {
      ...Pi.extension,
      name: "ellipse"
    }
  }, Lg = {
    ...Pi,
    extension: {
      ...Pi.extension,
      name: "roundedRectangle"
    }
  }, Hg = 1e-4, Hc = 1e-4;
  function zg(i) {
    const t = i.length;
    if (t < 6) return 1;
    let e = 0;
    for (let r = 0, s = i[t - 2], n = i[t - 1]; r < t; r += 2) {
      const o = i[r], a = i[r + 1];
      e += (o - s) * (a + n), s = o, n = a;
    }
    return e < 0 ? -1 : 1;
  }
  function zc(i, t, e, r, s, n, o, a) {
    const c = i - e * s, l = t - r * s, u = i + e * n, h = t + r * n;
    let d, p;
    o ? (d = r, p = -e) : (d = -r, p = e);
    const g = c + d, y = l + p, m = u + d, v = h + p;
    return a.push(g, y), a.push(m, v), 2;
  }
  function yr(i, t, e, r, s, n, o, a) {
    const c = e - i, l = r - t;
    let u = Math.atan2(c, l), h = Math.atan2(s - i, n - t);
    a && u < h ? u += Math.PI * 2 : !a && u > h && (h += Math.PI * 2);
    let d = u;
    const p = h - u, g = Math.abs(p), y = Math.sqrt(c * c + l * l), m = (15 * g * Math.sqrt(y) / Math.PI >> 0) + 1, v = p / m;
    if (d += v, a) {
      o.push(i, t), o.push(e, r);
      for (let S = 1, C = d; S < m; S++, C += v) o.push(i, t), o.push(i + Math.sin(C) * y, t + Math.cos(C) * y);
      o.push(i, t), o.push(s, n);
    } else {
      o.push(e, r), o.push(i, t);
      for (let S = 1, C = d; S < m; S++, C += v) o.push(i + Math.sin(C) * y, t + Math.cos(C) * y), o.push(i, t);
      o.push(s, n), o.push(i, t);
    }
    return m * 2;
  }
  function jg(i, t, e, r, s, n, o, a, c) {
    const l = Hg;
    if (i.length === 0) return;
    const u = t;
    let h = u.alignment;
    if (t.alignment !== 0.5) {
      let O = zg(i);
      e && (O *= -1), h = (h - 0.5) * O + 0.5;
    }
    const d = new At(i[0], i[1]), p = new At(i[i.length - 2], i[i.length - 1]), g = r, y = Math.abs(d.x - p.x) < l && Math.abs(d.y - p.y) < l;
    if (g) {
      i = i.slice(), y && (i.pop(), i.pop(), p.set(i[i.length - 2], i[i.length - 1]));
      const O = (d.x + p.x) * 0.5, q = (p.y + d.y) * 0.5;
      i.unshift(O, q), i.push(O, q);
    }
    const m = s, v = i.length / 2;
    let S = i.length;
    const C = m.length / 2, G = u.width / 2, H = G * G, Y = u.miterLimit * u.miterLimit;
    let L = i[0], W = i[1], A = i[2], I = i[3], z = 0, J = 0, j = -(W - I), X = L - A, Q = 0, x = 0, R = Math.sqrt(j * j + X * X);
    j /= R, X /= R, j *= G, X *= G;
    const E = h, B = (1 - E) * 2, D = E * 2;
    g || (u.cap === "round" ? S += yr(L - j * (B - D) * 0.5, W - X * (B - D) * 0.5, L - j * B, W - X * B, L + j * D, W + X * D, m, true) + 2 : u.cap === "square" && (S += zc(L, W, j, X, B, D, true, m))), m.push(L - j * B, W - X * B), m.push(L + j * D, W + X * D);
    for (let O = 1; O < v - 1; ++O) {
      L = i[(O - 1) * 2], W = i[(O - 1) * 2 + 1], A = i[O * 2], I = i[O * 2 + 1], z = i[(O + 1) * 2], J = i[(O + 1) * 2 + 1], j = -(W - I), X = L - A, R = Math.sqrt(j * j + X * X), j /= R, X /= R, j *= G, X *= G, Q = -(I - J), x = A - z, R = Math.sqrt(Q * Q + x * x), Q /= R, x /= R, Q *= G, x *= G;
      const q = A - L, V = W - I, $ = A - z, ft = J - I, pt = q * $ + V * ft, it = V * $ - ft * q, gt = it < 0;
      if (Math.abs(it) < 1e-3 * Math.abs(pt)) {
        m.push(A - j * B, I - X * B), m.push(A + j * D, I + X * D), pt >= 0 && (u.join === "round" ? S += yr(A, I, A - j * B, I - X * B, A - Q * B, I - x * B, m, false) + 4 : S += 2, m.push(A - Q * D, I - x * D), m.push(A + Q * B, I + x * B));
        continue;
      }
      const _t = (-j + L) * (-X + I) - (-j + A) * (-X + W), se = (-Q + z) * (-x + I) - (-Q + A) * (-x + J), te = (q * se - $ * _t) / it, ht = (ft * _t - V * se) / it, Ut = (te - A) * (te - A) + (ht - I) * (ht - I), nt = A + (te - A) * B, tt = I + (ht - I) * B, be = A - (te - A) * D, we = I - (ht - I) * D, He = Math.min(q * q + V * V, $ * $ + ft * ft), sr = gt ? B : D, Pt = He + sr * sr * H;
      Ut <= Pt ? u.join === "bevel" || Ut / H > Y ? (gt ? (m.push(nt, tt), m.push(A + j * D, I + X * D), m.push(nt, tt), m.push(A + Q * D, I + x * D)) : (m.push(A - j * B, I - X * B), m.push(be, we), m.push(A - Q * B, I - x * B), m.push(be, we)), S += 2) : u.join === "round" ? gt ? (m.push(nt, tt), m.push(A + j * D, I + X * D), S += yr(A, I, A + j * D, I + X * D, A + Q * D, I + x * D, m, true) + 4, m.push(nt, tt), m.push(A + Q * D, I + x * D)) : (m.push(A - j * B, I - X * B), m.push(be, we), S += yr(A, I, A - j * B, I - X * B, A - Q * B, I - x * B, m, false) + 4, m.push(A - Q * B, I - x * B), m.push(be, we)) : (m.push(nt, tt), m.push(be, we)) : (m.push(A - j * B, I - X * B), m.push(A + j * D, I + X * D), u.join === "round" ? gt ? S += yr(A, I, A + j * D, I + X * D, A + Q * D, I + x * D, m, true) + 2 : S += yr(A, I, A - j * B, I - X * B, A - Q * B, I - x * B, m, false) + 2 : u.join === "miter" && Ut / H <= Y && (gt ? (m.push(be, we), m.push(be, we)) : (m.push(nt, tt), m.push(nt, tt)), S += 2), m.push(A - Q * B, I - x * B), m.push(A + Q * D, I + x * D), S += 2);
    }
    L = i[(v - 2) * 2], W = i[(v - 2) * 2 + 1], A = i[(v - 1) * 2], I = i[(v - 1) * 2 + 1], j = -(W - I), X = L - A, R = Math.sqrt(j * j + X * X), j /= R, X /= R, j *= G, X *= G, m.push(A - j * B, I - X * B), m.push(A + j * D, I + X * D), g || (u.cap === "round" ? S += yr(A - j * (B - D) * 0.5, I - X * (B - D) * 0.5, A - j * B, I - X * B, A + j * D, I + X * D, m, false) + 2 : u.cap === "square" && (S += zc(A, I, j, X, B, D, false, m)));
    const N = Hc * Hc;
    for (let O = C; O < S + C - 2; ++O) L = m[O * 2], W = m[O * 2 + 1], A = m[(O + 1) * 2], I = m[(O + 1) * 2 + 1], z = m[(O + 2) * 2], J = m[(O + 2) * 2 + 1], !(Math.abs(L * (I - J) + A * (J - W) + z * (W - I)) < N) && a.push(O, O + 1, O + 2);
  }
  function Ph(i, t, e, r, s, n, o) {
    const a = _g(i, t, 2);
    if (!a) return;
    for (let l = 0; l < a.length; l += 3) n[o++] = a[l] + s, n[o++] = a[l + 1] + s, n[o++] = a[l + 2] + s;
    let c = s * r;
    for (let l = 0; l < i.length; l += 2) e[c] = i[l], e[c + 1] = i[l + 1], c += r;
  }
  const Wg = [], Vg = {
    extension: {
      type: P.ShapeBuilder,
      name: "polygon"
    },
    build(i, t) {
      for (let e = 0; e < i.points.length; e++) t[e] = i.points[e];
      return t;
    },
    triangulate(i, t, e, r, s, n) {
      Ph(i, Wg, t, e, r, s, n);
    }
  }, Xg = {
    extension: {
      type: P.ShapeBuilder,
      name: "rectangle"
    },
    build(i, t) {
      const e = i, r = e.x, s = e.y, n = e.width, o = e.height;
      return n >= 0 && o >= 0 && (t[0] = r, t[1] = s, t[2] = r + n, t[3] = s, t[4] = r + n, t[5] = s + o, t[6] = r, t[7] = s + o), t;
    },
    triangulate(i, t, e, r, s, n) {
      let o = 0;
      r *= e, t[r + o] = i[0], t[r + o + 1] = i[1], o += e, t[r + o] = i[2], t[r + o + 1] = i[3], o += e, t[r + o] = i[6], t[r + o + 1] = i[7], o += e, t[r + o] = i[4], t[r + o + 1] = i[5], o += e;
      const a = r / e;
      s[n++] = a, s[n++] = a + 1, s[n++] = a + 2, s[n++] = a + 1, s[n++] = a + 3, s[n++] = a + 2;
    }
  }, qg = {
    extension: {
      type: P.ShapeBuilder,
      name: "triangle"
    },
    build(i, t) {
      return t[0] = i.x, t[1] = i.y, t[2] = i.x2, t[3] = i.y2, t[4] = i.x3, t[5] = i.y3, t;
    },
    triangulate(i, t, e, r, s, n) {
      let o = 0;
      r *= e, t[r + o] = i[0], t[r + o + 1] = i[1], o += e, t[r + o] = i[2], t[r + o + 1] = i[3], o += e, t[r + o] = i[4], t[r + o + 1] = i[5];
      const a = r / e;
      s[n++] = a, s[n++] = a + 1, s[n++] = a + 2;
    }
  }, Qs = {};
  Mt.handleByMap(P.ShapeBuilder, Qs);
  Mt.add(Xg, Vg, qg, Pi, Ng, Lg);
  const $g = new Et();
  function Yg(i, t) {
    const { geometryData: e, batches: r } = t;
    r.length = 0, e.indices.length = 0, e.vertices.length = 0, e.uvs.length = 0;
    for (let s = 0; s < i.instructions.length; s++) {
      const n = i.instructions[s];
      if (n.action === "texture") Kg(n.data, r, e);
      else if (n.action === "fill" || n.action === "stroke") {
        const o = n.action === "stroke", a = n.data.path.shapePath, c = n.data.style, l = n.data.hole;
        o && l && jc(l.shapePath, c, null, true, r, e), jc(a, c, l, o, r, e);
      }
    }
  }
  function Kg(i, t, e) {
    const { vertices: r, uvs: s, indices: n } = e, o = n.length, a = r.length / 2, c = [], l = Qs.rectangle, u = $g, h = i.image;
    u.x = i.dx, u.y = i.dy, u.width = i.dw, u.height = i.dh;
    const d = i.transform;
    l.build(u, c), d && Rh(c, d), l.triangulate(c, r, 2, a, n, o);
    const p = h.uvs;
    s.push(p.x0, p.y0, p.x1, p.y1, p.x3, p.y3, p.x2, p.y2);
    const g = vt.get(ca);
    g.indexOffset = o, g.indexSize = n.length - o, g.vertexOffset = a, g.vertexSize = r.length / 2 - a, g.color = i.style, g.alpha = i.alpha, g.texture = h, g.geometryData = e, t.push(g);
  }
  function jc(i, t, e, r, s, n) {
    const { vertices: o, uvs: a, indices: c } = n, l = i.shapePrimitives.length - 1;
    i.shapePrimitives.forEach(({ shape: u, transform: h }, d) => {
      const p = c.length, g = o.length / 2, y = [], m = Qs[u.type];
      if (m.build(u, y), h && Rh(y, h), r) {
        const G = u.closePath ?? true;
        jg(y, t, false, G, o, 2, g, c, p);
      } else if (e && l === d) {
        l !== 0 && console.warn("[Pixi Graphics] only the last shape have be cut out");
        const G = [], H = y.slice();
        Jg(e.shapePath).forEach((L) => {
          G.push(H.length / 2), H.push(...L);
        }), Ph(H, G, o, 2, g, c, p);
      } else m.triangulate(y, o, 2, g, c, p);
      const v = a.length / 2, S = t.texture;
      if (S !== Z.WHITE) {
        const G = t.matrix;
        G && (h && G.append(h.clone().invert()), kg(o, 2, g, a, v, 2, o.length / 2 - g, G));
      } else Gg(a, v, 2, o.length / 2 - g);
      const C = vt.get(ca);
      C.indexOffset = p, C.indexSize = c.length - p, C.vertexOffset = g, C.vertexSize = o.length / 2 - g, C.color = t.color, C.alpha = t.alpha, C.texture = S, C.geometryData = n, s.push(C);
    });
  }
  function Jg(i) {
    if (!i) return [];
    const t = i.shapePrimitives, e = [];
    for (let r = 0; r < t.length; r++) {
      const s = t[r].shape, n = [];
      Qs[s.type].build(s, n), e.push(n);
    }
    return e;
  }
  class Zg {
    constructor() {
      this.batcher = new Th(), this.batches = [], this.geometryData = {
        vertices: [],
        uvs: [],
        indices: []
      };
    }
  }
  class Qg {
    constructor() {
      this.geometry = new Ah(), this.instructions = new Wl();
    }
    init() {
      this.instructions.reset();
    }
  }
  const ua = class Fo {
    constructor() {
      this._gpuContextHash = {}, this._graphicsDataContextHash = /* @__PURE__ */ Object.create(null);
    }
    init(t) {
      Fo.defaultOptions.bezierSmoothness = (t == null ? void 0 : t.bezierSmoothness) ?? Fo.defaultOptions.bezierSmoothness;
    }
    getContextRenderData(t) {
      return this._graphicsDataContextHash[t.uid] || this._initContextRenderData(t);
    }
    updateGpuContext(t) {
      let e = this._gpuContextHash[t.uid] || this._initContext(t);
      if (t.dirty) {
        e ? this._cleanGraphicsContextData(t) : e = this._initContext(t), Yg(t, e);
        const r = t.batchMode;
        t.customShader || r === "no-batch" ? e.isBatchable = false : r === "auto" && (e.isBatchable = e.geometryData.vertices.length < 400), t.dirty = false;
      }
      return e;
    }
    getGpuContext(t) {
      return this._gpuContextHash[t.uid] || this._initContext(t);
    }
    _initContextRenderData(t) {
      const e = vt.get(Qg), { batches: r, geometryData: s, batcher: n } = this._gpuContextHash[t.uid], o = s.vertices.length, a = s.indices.length;
      for (let u = 0; u < r.length; u++) r[u].applyTransform = false;
      n.ensureAttributeBuffer(o), n.ensureIndexBuffer(a), n.begin();
      for (let u = 0; u < r.length; u++) {
        const h = r[u];
        n.add(h);
      }
      n.finish(e.instructions);
      const c = e.geometry;
      c.indexBuffer.setDataWithSize(n.indexBuffer, n.indexSize, true), c.buffers[0].setDataWithSize(n.attributeBuffer.float32View, n.attributeSize, true);
      const l = n.batches;
      for (let u = 0; u < l.length; u++) {
        const h = l[u];
        h.bindGroup = aa(h.textures.textures, h.textures.count);
      }
      return this._graphicsDataContextHash[t.uid] = e, e;
    }
    _initContext(t) {
      const e = new Zg();
      return e.context = t, this._gpuContextHash[t.uid] = e, t.on("destroy", this.onGraphicsContextDestroy, this), this._gpuContextHash[t.uid];
    }
    onGraphicsContextDestroy(t) {
      this._cleanGraphicsContextData(t), t.off("destroy", this.onGraphicsContextDestroy, this), this._gpuContextHash[t.uid] = null;
    }
    _cleanGraphicsContextData(t) {
      const e = this._gpuContextHash[t.uid];
      e.isBatchable || this._graphicsDataContextHash[t.uid] && (vt.return(this.getContextRenderData(t)), this._graphicsDataContextHash[t.uid] = null), e.batches && e.batches.forEach((r) => {
        vt.return(r);
      });
    }
    destroy() {
      for (const t in this._gpuContextHash) this._gpuContextHash[t] && this.onGraphicsContextDestroy(this._gpuContextHash[t].context);
    }
  };
  ua.extension = {
    type: [
      P.WebGLSystem,
      P.WebGPUSystem,
      P.CanvasSystem
    ],
    name: "graphicsContext"
  };
  ua.defaultOptions = {
    bezierSmoothness: 0.5
  };
  Bh = ua;
  const tm = 8, rs = 11920929e-14, em = 1, Jn = 0.01, Hr = 0, xr = 0;
  function Mh(i, t, e, r, s, n, o, a, c, l) {
    const h = Math.min(0.99, Math.max(0, l ?? Bh.defaultOptions.bezierSmoothness));
    let d = (em - h) / 1;
    return d *= d, rm(t, e, r, s, n, o, a, c, i, d), i;
  }
  function rm(i, t, e, r, s, n, o, a, c, l) {
    Uo(i, t, e, r, s, n, o, a, c, l, 0), c.push(o, a);
  }
  function Uo(i, t, e, r, s, n, o, a, c, l, u) {
    if (u > tm) return;
    const h = Math.PI, d = (i + e) / 2, p = (t + r) / 2, g = (e + s) / 2, y = (r + n) / 2, m = (s + o) / 2, v = (n + a) / 2, S = (d + g) / 2, C = (p + y) / 2, G = (g + m) / 2, H = (y + v) / 2, Y = (S + G) / 2, L = (C + H) / 2;
    if (u > 0) {
      let W = o - i, A = a - t;
      const I = Math.abs((e - o) * A - (r - a) * W), z = Math.abs((s - o) * A - (n - a) * W);
      let J, j;
      if (I > rs && z > rs) {
        if ((I + z) * (I + z) <= l * (W * W + A * A)) {
          if (Hr < Jn) {
            c.push(Y, L);
            return;
          }
          const X = Math.atan2(n - r, s - e);
          if (J = Math.abs(X - Math.atan2(r - t, e - i)), j = Math.abs(Math.atan2(a - n, o - s) - X), J >= h && (J = 2 * h - J), j >= h && (j = 2 * h - j), J + j < Hr) {
            c.push(Y, L);
            return;
          }
          if (xr !== 0) {
            if (J > xr) {
              c.push(e, r);
              return;
            }
            if (j > xr) {
              c.push(s, n);
              return;
            }
          }
        }
      } else if (I > rs) {
        if (I * I <= l * (W * W + A * A)) {
          if (Hr < Jn) {
            c.push(Y, L);
            return;
          }
          if (J = Math.abs(Math.atan2(n - r, s - e) - Math.atan2(r - t, e - i)), J >= h && (J = 2 * h - J), J < Hr) {
            c.push(e, r), c.push(s, n);
            return;
          }
          if (xr !== 0 && J > xr) {
            c.push(e, r);
            return;
          }
        }
      } else if (z > rs) {
        if (z * z <= l * (W * W + A * A)) {
          if (Hr < Jn) {
            c.push(Y, L);
            return;
          }
          if (J = Math.abs(Math.atan2(a - n, o - s) - Math.atan2(n - r, s - e)), J >= h && (J = 2 * h - J), J < Hr) {
            c.push(e, r), c.push(s, n);
            return;
          }
          if (xr !== 0 && J > xr) {
            c.push(s, n);
            return;
          }
        }
      } else if (W = Y - (i + o) / 2, A = L - (t + a) / 2, W * W + A * A <= l) {
        c.push(Y, L);
        return;
      }
    }
    Uo(i, t, d, p, S, C, Y, L, c, l, u + 1), Uo(Y, L, G, H, m, v, o, a, c, l, u + 1);
  }
  const im = 8, sm = 11920929e-14, nm = 1, om = 0.01, Wc = 0;
  function am(i, t, e, r, s, n, o, a) {
    const l = Math.min(0.99, Math.max(0, a ?? Bh.defaultOptions.bezierSmoothness));
    let u = (nm - l) / 1;
    return u *= u, cm(t, e, r, s, n, o, i, u), i;
  }
  function cm(i, t, e, r, s, n, o, a) {
    ko(o, i, t, e, r, s, n, a, 0), o.push(s, n);
  }
  function ko(i, t, e, r, s, n, o, a, c) {
    if (c > im) return;
    const l = Math.PI, u = (t + r) / 2, h = (e + s) / 2, d = (r + n) / 2, p = (s + o) / 2, g = (u + d) / 2, y = (h + p) / 2;
    let m = n - t, v = o - e;
    const S = Math.abs((r - n) * v - (s - o) * m);
    if (S > sm) {
      if (S * S <= a * (m * m + v * v)) {
        if (Wc < om) {
          i.push(g, y);
          return;
        }
        let C = Math.abs(Math.atan2(o - s, n - r) - Math.atan2(s - e, r - t));
        if (C >= l && (C = 2 * l - C), C < Wc) {
          i.push(g, y);
          return;
        }
      }
    } else if (m = g - (t + n) / 2, v = y - (e + o) / 2, m * m + v * v <= a) {
      i.push(g, y);
      return;
    }
    ko(i, t, e, u, h, g, y, a, c + 1), ko(i, g, y, d, p, n, o, a, c + 1);
  }
  function Dh(i, t, e, r, s, n, o, a) {
    let c = Math.abs(s - n);
    (!o && s > n || o && n > s) && (c = 2 * Math.PI - c), a = a || Math.max(6, Math.floor(6 * Math.pow(r, 1 / 3) * (c / Math.PI))), a = Math.max(a, 3);
    let l = c / a, u = s;
    l *= o ? -1 : 1;
    for (let h = 0; h < a + 1; h++) {
      const d = Math.cos(u), p = Math.sin(u), g = t + d * r, y = e + p * r;
      i.push(g, y), u += l;
    }
  }
  function um(i, t, e, r, s, n) {
    const o = i[i.length - 2], c = i[i.length - 1] - e, l = o - t, u = s - e, h = r - t, d = Math.abs(c * h - l * u);
    if (d < 1e-8 || n === 0) {
      (i[i.length - 2] !== t || i[i.length - 1] !== e) && i.push(t, e);
      return;
    }
    const p = c * c + l * l, g = u * u + h * h, y = c * u + l * h, m = n * Math.sqrt(p) / d, v = n * Math.sqrt(g) / d, S = m * y / p, C = v * y / g, G = m * h + v * l, H = m * u + v * c, Y = l * (v + S), L = c * (v + S), W = h * (m + C), A = u * (m + C), I = Math.atan2(L - H, Y - G), z = Math.atan2(A - H, W - G);
    Dh(i, G + t, H + e, n, I, z, l * u > h * c);
  }
  const Si = Math.PI * 2, Zn = {
    centerX: 0,
    centerY: 0,
    ang1: 0,
    ang2: 0
  }, Qn = ({ x: i, y: t }, e, r, s, n, o, a, c) => {
    i *= e, t *= r;
    const l = s * i - n * t, u = n * i + s * t;
    return c.x = l + o, c.y = u + a, c;
  };
  function lm(i, t) {
    const e = t === -1.5707963267948966 ? -0.551915024494 : 1.3333333333333333 * Math.tan(t / 4), r = t === 1.5707963267948966 ? 0.551915024494 : e, s = Math.cos(i), n = Math.sin(i), o = Math.cos(i + t), a = Math.sin(i + t);
    return [
      {
        x: s - n * r,
        y: n + s * r
      },
      {
        x: o + a * r,
        y: a - o * r
      },
      {
        x: o,
        y: a
      }
    ];
  }
  const Vc = (i, t, e, r) => {
    const s = i * r - t * e < 0 ? -1 : 1;
    let n = i * e + t * r;
    return n > 1 && (n = 1), n < -1 && (n = -1), s * Math.acos(n);
  }, hm = (i, t, e, r, s, n, o, a, c, l, u, h, d) => {
    const p = Math.pow(s, 2), g = Math.pow(n, 2), y = Math.pow(u, 2), m = Math.pow(h, 2);
    let v = p * g - p * m - g * y;
    v < 0 && (v = 0), v /= p * m + g * y, v = Math.sqrt(v) * (o === a ? -1 : 1);
    const S = v * s / n * h, C = v * -n / s * u, G = l * S - c * C + (i + e) / 2, H = c * S + l * C + (t + r) / 2, Y = (u - S) / s, L = (h - C) / n, W = (-u - S) / s, A = (-h - C) / n, I = Vc(1, 0, Y, L);
    let z = Vc(Y, L, W, A);
    a === 0 && z > 0 && (z -= Si), a === 1 && z < 0 && (z += Si), d.centerX = G, d.centerY = H, d.ang1 = I, d.ang2 = z;
  };
  function dm(i, t, e, r, s, n, o, a = 0, c = 0, l = 0) {
    if (n === 0 || o === 0) return;
    const u = Math.sin(a * Si / 360), h = Math.cos(a * Si / 360), d = h * (t - r) / 2 + u * (e - s) / 2, p = -u * (t - r) / 2 + h * (e - s) / 2;
    if (d === 0 && p === 0) return;
    n = Math.abs(n), o = Math.abs(o);
    const g = Math.pow(d, 2) / Math.pow(n, 2) + Math.pow(p, 2) / Math.pow(o, 2);
    g > 1 && (n *= Math.sqrt(g), o *= Math.sqrt(g)), hm(t, e, r, s, n, o, c, l, u, h, d, p, Zn);
    let { ang1: y, ang2: m } = Zn;
    const { centerX: v, centerY: S } = Zn;
    let C = Math.abs(m) / (Si / 4);
    Math.abs(1 - C) < 1e-7 && (C = 1);
    const G = Math.max(Math.ceil(C), 1);
    m /= G;
    let H = i[i.length - 2], Y = i[i.length - 1];
    const L = {
      x: 0,
      y: 0
    };
    for (let W = 0; W < G; W++) {
      const A = lm(y, m), { x: I, y: z } = Qn(A[0], n, o, h, u, v, S, L), { x: J, y: j } = Qn(A[1], n, o, h, u, v, S, L), { x: X, y: Q } = Qn(A[2], n, o, h, u, v, S, L);
      Mh(i, H, Y, I, z, J, j, X, Q), H = X, Y = Q, y += m;
    }
  }
  function fm(i, t, e) {
    const r = (o, a) => {
      const c = a.x - o.x, l = a.y - o.y, u = Math.sqrt(c * c + l * l), h = c / u, d = l / u;
      return {
        len: u,
        nx: h,
        ny: d
      };
    }, s = (o, a) => {
      o === 0 ? i.moveTo(a.x, a.y) : i.lineTo(a.x, a.y);
    };
    let n = t[t.length - 1];
    for (let o = 0; o < t.length; o++) {
      const a = t[o % t.length], c = a.radius ?? e;
      if (c <= 0) {
        s(o, a), n = a;
        continue;
      }
      const l = t[(o + 1) % t.length], u = r(a, n), h = r(a, l);
      if (u.len < 1e-4 || h.len < 1e-4) {
        s(o, a), n = a;
        continue;
      }
      let d = Math.asin(u.nx * h.ny - u.ny * h.nx), p = 1, g = false;
      u.nx * h.nx - u.ny * -h.ny < 0 ? d < 0 ? d = Math.PI + d : (d = Math.PI - d, p = -1, g = true) : d > 0 && (p = -1, g = true);
      const y = d / 2;
      let m, v = Math.abs(Math.cos(y) * c / Math.sin(y));
      v > Math.min(u.len / 2, h.len / 2) ? (v = Math.min(u.len / 2, h.len / 2), m = Math.abs(v * Math.sin(y) / Math.cos(y))) : m = c;
      const S = a.x + h.nx * v + -h.ny * m * p, C = a.y + h.ny * v + h.nx * m * p, G = Math.atan2(u.ny, u.nx) + Math.PI / 2 * p, H = Math.atan2(h.ny, h.nx) - Math.PI / 2 * p;
      o === 0 && i.moveTo(S + Math.cos(G) * m, C + Math.sin(G) * m), i.arc(S, C, m, G, H, g), n = a;
    }
  }
  function pm(i, t, e, r) {
    const s = (a, c) => Math.sqrt((a.x - c.x) ** 2 + (a.y - c.y) ** 2), n = (a, c, l) => ({
      x: a.x + (c.x - a.x) * l,
      y: a.y + (c.y - a.y) * l
    }), o = t.length;
    for (let a = 0; a < o; a++) {
      const c = t[(a + 1) % o], l = c.radius ?? e;
      if (l <= 0) {
        a === 0 ? i.moveTo(c.x, c.y) : i.lineTo(c.x, c.y);
        continue;
      }
      const u = t[a], h = t[(a + 2) % o], d = s(u, c);
      let p;
      if (d < 1e-4) p = c;
      else {
        const m = Math.min(d / 2, l);
        p = n(c, u, m / d);
      }
      const g = s(h, c);
      let y;
      if (g < 1e-4) y = c;
      else {
        const m = Math.min(g / 2, l);
        y = n(c, h, m / g);
      }
      a === 0 ? i.moveTo(p.x, p.y) : i.lineTo(p.x, p.y), i.quadraticCurveTo(c.x, c.y, y.x, y.y, r);
    }
  }
  const _m = new Et();
  class gm {
    constructor(t) {
      this.shapePrimitives = [], this._currentPoly = null, this._bounds = new re(), this._graphicsPath2D = t;
    }
    moveTo(t, e) {
      return this.startPoly(t, e), this;
    }
    lineTo(t, e) {
      this._ensurePoly();
      const r = this._currentPoly.points, s = r[r.length - 2], n = r[r.length - 1];
      return (s !== t || n !== e) && r.push(t, e), this;
    }
    arc(t, e, r, s, n, o) {
      this._ensurePoly(false);
      const a = this._currentPoly.points;
      return Dh(a, t, e, r, s, n, o), this;
    }
    arcTo(t, e, r, s, n) {
      this._ensurePoly();
      const o = this._currentPoly.points;
      return um(o, t, e, r, s, n), this;
    }
    arcToSvg(t, e, r, s, n, o, a) {
      const c = this._currentPoly.points;
      return dm(c, this._currentPoly.lastX, this._currentPoly.lastY, o, a, t, e, r, s, n), this;
    }
    bezierCurveTo(t, e, r, s, n, o, a) {
      this._ensurePoly();
      const c = this._currentPoly;
      return Mh(this._currentPoly.points, c.lastX, c.lastY, t, e, r, s, n, o, a), this;
    }
    quadraticCurveTo(t, e, r, s, n) {
      this._ensurePoly();
      const o = this._currentPoly;
      return am(this._currentPoly.points, o.lastX, o.lastY, t, e, r, s, n), this;
    }
    closePath() {
      return this.endPoly(true), this;
    }
    addPath(t, e) {
      this.endPoly(), e && !e.isIdentity() && (t = t.clone(true), t.transform(e));
      for (let r = 0; r < t.instructions.length; r++) {
        const s = t.instructions[r];
        this[s.action](...s.data);
      }
      return this;
    }
    finish(t = false) {
      this.endPoly(t);
    }
    rect(t, e, r, s, n) {
      return this.drawShape(new Et(t, e, r, s), n), this;
    }
    circle(t, e, r, s) {
      return this.drawShape(new sa(t, e, r), s), this;
    }
    poly(t, e, r) {
      const s = new vi(t);
      return s.closePath = e, this.drawShape(s, r), this;
    }
    regularPoly(t, e, r, s, n = 0, o) {
      s = Math.max(s | 0, 3);
      const a = -1 * Math.PI / 2 + n, c = Math.PI * 2 / s, l = [];
      for (let u = 0; u < s; u++) {
        const h = u * c + a;
        l.push(t + r * Math.cos(h), e + r * Math.sin(h));
      }
      return this.poly(l, true, o), this;
    }
    roundPoly(t, e, r, s, n, o = 0, a) {
      if (s = Math.max(s | 0, 3), n <= 0) return this.regularPoly(t, e, r, s, o);
      const c = r * Math.sin(Math.PI / s) - 1e-3;
      n = Math.min(n, c);
      const l = -1 * Math.PI / 2 + o, u = Math.PI * 2 / s, h = (s - 2) * Math.PI / s / 2;
      for (let d = 0; d < s; d++) {
        const p = d * u + l, g = t + r * Math.cos(p), y = e + r * Math.sin(p), m = p + Math.PI + h, v = p - Math.PI - h, S = g + n * Math.cos(m), C = y + n * Math.sin(m), G = g + n * Math.cos(v), H = y + n * Math.sin(v);
        d === 0 ? this.moveTo(S, C) : this.lineTo(S, C), this.quadraticCurveTo(g, y, G, H, a);
      }
      return this.closePath();
    }
    roundShape(t, e, r = false, s) {
      return t.length < 3 ? this : (r ? pm(this, t, e, s) : fm(this, t, e), this.closePath());
    }
    filletRect(t, e, r, s, n) {
      if (n === 0) return this.rect(t, e, r, s);
      const o = Math.min(r, s) / 2, a = Math.min(o, Math.max(-o, n)), c = t + r, l = e + s, u = a < 0 ? -a : 0, h = Math.abs(a);
      return this.moveTo(t, e + h).arcTo(t + u, e + u, t + h, e, h).lineTo(c - h, e).arcTo(c - u, e + u, c, e + h, h).lineTo(c, l - h).arcTo(c - u, l - u, t + r - h, l, h).lineTo(t + h, l).arcTo(t + u, l - u, t, l - h, h).closePath();
    }
    chamferRect(t, e, r, s, n, o) {
      if (n <= 0) return this.rect(t, e, r, s);
      const a = Math.min(n, Math.min(r, s) / 2), c = t + r, l = e + s, u = [
        t + a,
        e,
        c - a,
        e,
        c,
        e + a,
        c,
        l - a,
        c - a,
        l,
        t + a,
        l,
        t,
        l - a,
        t,
        e + a
      ];
      for (let h = u.length - 1; h >= 2; h -= 2) u[h] === u[h - 2] && u[h - 1] === u[h - 3] && u.splice(h - 1, 2);
      return this.poly(u, true, o);
    }
    ellipse(t, e, r, s, n) {
      return this.drawShape(new na(t, e, r, s), n), this;
    }
    roundRect(t, e, r, s, n, o) {
      return this.drawShape(new oa(t, e, r, s, n), o), this;
    }
    drawShape(t, e) {
      return this.endPoly(), this.shapePrimitives.push({
        shape: t,
        transform: e
      }), this;
    }
    startPoly(t, e) {
      let r = this._currentPoly;
      return r && this.endPoly(), r = new vi(), r.points.push(t, e), this._currentPoly = r, this;
    }
    endPoly(t = false) {
      const e = this._currentPoly;
      return e && e.points.length > 2 && (e.closePath = t, this.shapePrimitives.push({
        shape: e
      })), this._currentPoly = null, this;
    }
    _ensurePoly(t = true) {
      if (!this._currentPoly && (this._currentPoly = new vi(), t)) {
        const e = this.shapePrimitives[this.shapePrimitives.length - 1];
        if (e) {
          let r = e.shape.x, s = e.shape.y;
          if (e.transform && !e.transform.isIdentity()) {
            const n = e.transform, o = r;
            r = n.a * r + n.c * s + n.tx, s = n.b * o + n.d * s + n.ty;
          }
          this._currentPoly.points.push(r, s);
        } else this._currentPoly.points.push(0, 0);
      }
    }
    buildPath() {
      const t = this._graphicsPath2D;
      this.shapePrimitives.length = 0, this._currentPoly = null;
      for (let e = 0; e < t.instructions.length; e++) {
        const r = t.instructions[e];
        this[r.action](...r.data);
      }
      this.finish();
    }
    get bounds() {
      const t = this._bounds;
      t.clear();
      const e = this.shapePrimitives;
      for (let r = 0; r < e.length; r++) {
        const s = e[r], n = s.shape.getBounds(_m);
        s.transform ? t.addRect(n, s.transform) : t.addRect(n);
      }
      return t;
    }
  }
  class Zr {
    constructor(t) {
      this.instructions = [], this.uid = Ot("graphicsPath"), this._dirty = true, typeof t == "string" ? Sg(t, this) : this.instructions = (t == null ? void 0 : t.slice()) ?? [];
    }
    get shapePath() {
      return this._shapePath || (this._shapePath = new gm(this)), this._dirty && (this._dirty = false, this._shapePath.buildPath()), this._shapePath;
    }
    addPath(t, e) {
      return t = t.clone(), this.instructions.push({
        action: "addPath",
        data: [
          t,
          e
        ]
      }), this._dirty = true, this;
    }
    arc(...t) {
      return this.instructions.push({
        action: "arc",
        data: t
      }), this._dirty = true, this;
    }
    arcTo(...t) {
      return this.instructions.push({
        action: "arcTo",
        data: t
      }), this._dirty = true, this;
    }
    arcToSvg(...t) {
      return this.instructions.push({
        action: "arcToSvg",
        data: t
      }), this._dirty = true, this;
    }
    bezierCurveTo(...t) {
      return this.instructions.push({
        action: "bezierCurveTo",
        data: t
      }), this._dirty = true, this;
    }
    bezierCurveToShort(t, e, r, s, n) {
      const o = this.instructions[this.instructions.length - 1], a = this.getLastPoint(At.shared);
      let c = 0, l = 0;
      if (!o || o.action !== "bezierCurveTo") c = a.x, l = a.y;
      else {
        c = o.data[2], l = o.data[3];
        const u = a.x, h = a.y;
        c = u + (u - c), l = h + (h - l);
      }
      return this.instructions.push({
        action: "bezierCurveTo",
        data: [
          c,
          l,
          t,
          e,
          r,
          s,
          n
        ]
      }), this._dirty = true, this;
    }
    closePath() {
      return this.instructions.push({
        action: "closePath",
        data: []
      }), this._dirty = true, this;
    }
    ellipse(...t) {
      return this.instructions.push({
        action: "ellipse",
        data: t
      }), this._dirty = true, this;
    }
    lineTo(...t) {
      return this.instructions.push({
        action: "lineTo",
        data: t
      }), this._dirty = true, this;
    }
    moveTo(...t) {
      return this.instructions.push({
        action: "moveTo",
        data: t
      }), this;
    }
    quadraticCurveTo(...t) {
      return this.instructions.push({
        action: "quadraticCurveTo",
        data: t
      }), this._dirty = true, this;
    }
    quadraticCurveToShort(t, e, r) {
      const s = this.instructions[this.instructions.length - 1], n = this.getLastPoint(At.shared);
      let o = 0, a = 0;
      if (!s || s.action !== "quadraticCurveTo") o = n.x, a = n.y;
      else {
        o = s.data[0], a = s.data[1];
        const c = n.x, l = n.y;
        o = c + (c - o), a = l + (l - a);
      }
      return this.instructions.push({
        action: "quadraticCurveTo",
        data: [
          o,
          a,
          t,
          e,
          r
        ]
      }), this._dirty = true, this;
    }
    rect(t, e, r, s, n) {
      return this.instructions.push({
        action: "rect",
        data: [
          t,
          e,
          r,
          s,
          n
        ]
      }), this._dirty = true, this;
    }
    circle(t, e, r, s) {
      return this.instructions.push({
        action: "circle",
        data: [
          t,
          e,
          r,
          s
        ]
      }), this._dirty = true, this;
    }
    roundRect(...t) {
      return this.instructions.push({
        action: "roundRect",
        data: t
      }), this._dirty = true, this;
    }
    poly(...t) {
      return this.instructions.push({
        action: "poly",
        data: t
      }), this._dirty = true, this;
    }
    regularPoly(...t) {
      return this.instructions.push({
        action: "regularPoly",
        data: t
      }), this._dirty = true, this;
    }
    roundPoly(...t) {
      return this.instructions.push({
        action: "roundPoly",
        data: t
      }), this._dirty = true, this;
    }
    roundShape(...t) {
      return this.instructions.push({
        action: "roundShape",
        data: t
      }), this._dirty = true, this;
    }
    filletRect(...t) {
      return this.instructions.push({
        action: "filletRect",
        data: t
      }), this._dirty = true, this;
    }
    chamferRect(...t) {
      return this.instructions.push({
        action: "chamferRect",
        data: t
      }), this._dirty = true, this;
    }
    star(t, e, r, s, n, o, a) {
      n = n || s / 2;
      const c = -1 * Math.PI / 2 + o, l = r * 2, u = Math.PI * 2 / l, h = [];
      for (let d = 0; d < l; d++) {
        const p = d % 2 ? n : s, g = d * u + c;
        h.push(t + p * Math.cos(g), e + p * Math.sin(g));
      }
      return this.poly(h, true, a), this;
    }
    clone(t = false) {
      const e = new Zr();
      if (!t) e.instructions = this.instructions.slice();
      else for (let r = 0; r < this.instructions.length; r++) {
        const s = this.instructions[r];
        e.instructions.push({
          action: s.action,
          data: s.data.slice()
        });
      }
      return e;
    }
    clear() {
      return this.instructions.length = 0, this._dirty = true, this;
    }
    transform(t) {
      if (t.isIdentity()) return this;
      const e = t.a, r = t.b, s = t.c, n = t.d, o = t.tx, a = t.ty;
      let c = 0, l = 0, u = 0, h = 0, d = 0, p = 0, g = 0, y = 0;
      for (let m = 0; m < this.instructions.length; m++) {
        const v = this.instructions[m], S = v.data;
        switch (v.action) {
          case "moveTo":
          case "lineTo":
            c = S[0], l = S[1], S[0] = e * c + s * l + o, S[1] = r * c + n * l + a;
            break;
          case "bezierCurveTo":
            u = S[0], h = S[1], d = S[2], p = S[3], c = S[4], l = S[5], S[0] = e * u + s * h + o, S[1] = r * u + n * h + a, S[2] = e * d + s * p + o, S[3] = r * d + n * p + a, S[4] = e * c + s * l + o, S[5] = r * c + n * l + a;
            break;
          case "quadraticCurveTo":
            u = S[0], h = S[1], c = S[2], l = S[3], S[0] = e * u + s * h + o, S[1] = r * u + n * h + a, S[2] = e * c + s * l + o, S[3] = r * c + n * l + a;
            break;
          case "arcToSvg":
            c = S[5], l = S[6], g = S[0], y = S[1], S[0] = e * g + s * y, S[1] = r * g + n * y, S[5] = e * c + s * l + o, S[6] = r * c + n * l + a;
            break;
          case "circle":
            S[4] = ui(S[3], t);
            break;
          case "rect":
            S[4] = ui(S[4], t);
            break;
          case "ellipse":
            S[8] = ui(S[8], t);
            break;
          case "roundRect":
            S[5] = ui(S[5], t);
            break;
          case "addPath":
            S[0].transform(t);
            break;
          case "poly":
            S[2] = ui(S[2], t);
            break;
          default:
            ut("unknown transform action", v.action);
            break;
        }
      }
      return this._dirty = true, this;
    }
    get bounds() {
      return this.shapePath.bounds;
    }
    getLastPoint(t) {
      let e = this.instructions.length - 1, r = this.instructions[e];
      if (!r) return t.x = 0, t.y = 0, t;
      for (; r.action === "closePath"; ) {
        if (e--, e < 0) return t.x = 0, t.y = 0, t;
        r = this.instructions[e];
      }
      switch (r.action) {
        case "moveTo":
        case "lineTo":
          t.x = r.data[0], t.y = r.data[1];
          break;
        case "quadraticCurveTo":
          t.x = r.data[2], t.y = r.data[3];
          break;
        case "bezierCurveTo":
          t.x = r.data[4], t.y = r.data[5];
          break;
        case "arc":
        case "arcToSvg":
          t.x = r.data[5], t.y = r.data[6];
          break;
        case "addPath":
          r.data[0].getLastPoint(t);
          break;
      }
      return t;
    }
  }
  function ui(i, t) {
    return i ? i.prepend(t) : t.clone();
  }
  function mm(i, t) {
    if (typeof i == "string") {
      const r = document.createElement("div");
      r.innerHTML = i.trim(), i = r.querySelector("svg");
    }
    const e = {
      context: t,
      path: new Zr()
    };
    return Ih(i, e, null, null), t;
  }
  function Ih(i, t, e, r) {
    const s = i.children, { fillStyle: n, strokeStyle: o } = bm(i);
    n && e ? e = {
      ...e,
      ...n
    } : n && (e = n), o && r ? r = {
      ...r,
      ...o
    } : o && (r = o), t.context.fillStyle = e, t.context.strokeStyle = r;
    let a, c, l, u, h, d, p, g, y, m, v, S, C, G, H, Y, L;
    switch (i.nodeName.toLowerCase()) {
      case "path":
        G = i.getAttribute("d"), H = new Zr(G), t.context.path(H), e && t.context.fill(), r && t.context.stroke();
        break;
      case "circle":
        p = $t(i, "cx", 0), g = $t(i, "cy", 0), y = $t(i, "r", 0), t.context.ellipse(p, g, y, y), e && t.context.fill(), r && t.context.stroke();
        break;
      case "rect":
        a = $t(i, "x", 0), c = $t(i, "y", 0), Y = $t(i, "width", 0), L = $t(i, "height", 0), m = $t(i, "rx", 0), v = $t(i, "ry", 0), m || v ? t.context.roundRect(a, c, Y, L, m || v) : t.context.rect(a, c, Y, L), e && t.context.fill(), r && t.context.stroke();
        break;
      case "ellipse":
        p = $t(i, "cx", 0), g = $t(i, "cy", 0), m = $t(i, "rx", 0), v = $t(i, "ry", 0), t.context.beginPath(), t.context.ellipse(p, g, m, v), e && t.context.fill(), r && t.context.stroke();
        break;
      case "line":
        l = $t(i, "x1", 0), u = $t(i, "y1", 0), h = $t(i, "x2", 0), d = $t(i, "y2", 0), t.context.beginPath(), t.context.moveTo(l, u), t.context.lineTo(h, d), r && t.context.stroke();
        break;
      case "polygon":
        C = i.getAttribute("points"), S = C.match(/\d+/g).map((W) => parseInt(W, 10)), t.context.poly(S, true), e && t.context.fill(), r && t.context.stroke();
        break;
      case "polyline":
        C = i.getAttribute("points"), S = C.match(/\d+/g).map((W) => parseInt(W, 10)), t.context.poly(S, false), r && t.context.stroke();
        break;
      case "g":
      case "svg":
        break;
      default: {
        console.info(`[SVG parser] <${i.nodeName}> elements unsupported`);
        break;
      }
    }
    for (let W = 0; W < s.length; W++) Ih(s[W], t, e, r);
  }
  function $t(i, t, e) {
    const r = i.getAttribute(t);
    return r ? Number(r) : e;
  }
  function bm(i) {
    const t = i.getAttribute("style"), e = {}, r = {};
    let s = false, n = false;
    if (t) {
      const o = t.split(";");
      for (let a = 0; a < o.length; a++) {
        const c = o[a], [l, u] = c.split(":");
        switch (l) {
          case "stroke":
            u !== "none" && (e.color = Tt.shared.setValue(u).toNumber(), n = true);
            break;
          case "stroke-width":
            e.width = Number(u);
            break;
          case "fill":
            u !== "none" && (s = true, r.color = Tt.shared.setValue(u).toNumber());
            break;
          case "fill-opacity":
            r.alpha = Number(u);
            break;
          case "stroke-opacity":
            e.alpha = Number(u);
            break;
          case "opacity":
            r.alpha = Number(u), e.alpha = Number(u);
            break;
        }
      }
    } else {
      const o = i.getAttribute("stroke");
      o && o !== "none" && (n = true, e.color = Tt.shared.setValue(o).toNumber(), e.width = $t(i, "stroke-width", 1));
      const a = i.getAttribute("fill");
      a && a !== "none" && (s = true, r.color = Tt.shared.setValue(a).toNumber());
    }
    return {
      strokeStyle: n ? e : null,
      fillStyle: s ? r : null
    };
  }
  function wm(i) {
    return Tt.isColorLike(i);
  }
  function Xc(i) {
    return i instanceof Zs;
  }
  function qc(i) {
    return i instanceof Ri;
  }
  function ym(i, t, e) {
    const r = Tt.shared.setValue(t ?? 0);
    return i.color = r.toNumber(), i.alpha = r.alpha === 1 ? e.alpha : r.alpha, i.texture = Z.WHITE, {
      ...e,
      ...i
    };
  }
  function $c(i, t, e) {
    return i.fill = t, i.color = 16777215, i.texture = t.texture, i.matrix = t.transform, {
      ...e,
      ...i
    };
  }
  function Yc(i, t, e) {
    return t.buildLinearGradient(), i.fill = t, i.color = 16777215, i.texture = t.texture, i.matrix = t.transform, {
      ...e,
      ...i
    };
  }
  function xm(i, t) {
    var _a2;
    const e = {
      ...t,
      ...i
    };
    if (e.texture) {
      if (e.texture !== Z.WHITE) {
        const n = ((_a2 = e.matrix) == null ? void 0 : _a2.invert()) || new st();
        n.translate(e.texture.frame.x, e.texture.frame.y), n.scale(1 / e.texture.source.width, 1 / e.texture.source.height), e.matrix = n;
      }
      const s = e.texture.source.style;
      s.addressMode === "clamp-to-edge" && (s.addressMode = "repeat", s.update());
    }
    const r = Tt.shared.setValue(e.color);
    return e.alpha *= r.alpha, e.color = r.toNumber(), e.matrix = e.matrix ? e.matrix.clone() : null, e;
  }
  function Pr(i, t) {
    if (i == null) return null;
    const e = {}, r = i;
    return wm(i) ? ym(e, i, t) : Xc(i) ? $c(e, i, t) : qc(i) ? Yc(e, i, t) : r.fill && Xc(r.fill) ? $c(r, r.fill, t) : r.fill && qc(r.fill) ? Yc(r, r.fill, t) : xm(r, t);
  }
  function Is(i, t) {
    const { width: e, alignment: r, miterLimit: s, cap: n, join: o, ...a } = t, c = Pr(i, a);
    return c ? {
      width: e,
      alignment: r,
      miterLimit: s,
      cap: n,
      join: o,
      ...c
    } : null;
  }
  const vm = new At(), Kc = new st(), la = class Ue extends me {
    constructor() {
      super(...arguments), this.uid = Ot("graphicsContext"), this.dirty = true, this.batchMode = "auto", this.instructions = [], this._activePath = new Zr(), this._transform = new st(), this._fillStyle = {
        ...Ue.defaultFillStyle
      }, this._strokeStyle = {
        ...Ue.defaultStrokeStyle
      }, this._stateStack = [], this._tick = 0, this._bounds = new re(), this._boundsDirty = true;
    }
    clone() {
      const t = new Ue();
      return t.batchMode = this.batchMode, t.instructions = this.instructions.slice(), t._activePath = this._activePath.clone(), t._transform = this._transform.clone(), t._fillStyle = {
        ...this._fillStyle
      }, t._strokeStyle = {
        ...this._strokeStyle
      }, t._stateStack = this._stateStack.slice(), t._bounds = this._bounds.clone(), t._boundsDirty = true, t;
    }
    get fillStyle() {
      return this._fillStyle;
    }
    set fillStyle(t) {
      this._fillStyle = Pr(t, Ue.defaultFillStyle);
    }
    get strokeStyle() {
      return this._strokeStyle;
    }
    set strokeStyle(t) {
      this._strokeStyle = Is(t, Ue.defaultStrokeStyle);
    }
    setFillStyle(t) {
      return this._fillStyle = Pr(t, Ue.defaultFillStyle), this;
    }
    setStrokeStyle(t) {
      return this._strokeStyle = Pr(t, Ue.defaultStrokeStyle), this;
    }
    texture(t, e, r, s, n, o) {
      return this.instructions.push({
        action: "texture",
        data: {
          image: t,
          dx: r || 0,
          dy: s || 0,
          dw: n || t.frame.width,
          dh: o || t.frame.height,
          transform: this._transform.clone(),
          alpha: this._fillStyle.alpha,
          style: e ? Tt.shared.setValue(e).toNumber() : 16777215
        }
      }), this.onUpdate(), this;
    }
    beginPath() {
      return this._activePath = new Zr(), this;
    }
    fill(t, e) {
      let r;
      const s = this.instructions[this.instructions.length - 1];
      return this._tick === 0 && s && s.action === "stroke" ? r = s.data.path : r = this._activePath.clone(), r ? (t != null && (e !== void 0 && typeof t == "number" && (lt(dt, "GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead"), t = {
        color: t,
        alpha: e
      }), this._fillStyle = Pr(t, Ue.defaultFillStyle)), this.instructions.push({
        action: "fill",
        data: {
          style: this.fillStyle,
          path: r
        }
      }), this.onUpdate(), this._initNextPathLocation(), this._tick = 0, this) : this;
    }
    _initNextPathLocation() {
      const { x: t, y: e } = this._activePath.getLastPoint(At.shared);
      this._activePath.clear(), this._activePath.moveTo(t, e);
    }
    stroke(t) {
      let e;
      const r = this.instructions[this.instructions.length - 1];
      return this._tick === 0 && r && r.action === "fill" ? e = r.data.path : e = this._activePath.clone(), e ? (t != null && (this._strokeStyle = Is(t, Ue.defaultStrokeStyle)), this.instructions.push({
        action: "stroke",
        data: {
          style: this.strokeStyle,
          path: e
        }
      }), this.onUpdate(), this._initNextPathLocation(), this._tick = 0, this) : this;
    }
    cut() {
      for (let t = 0; t < 2; t++) {
        const e = this.instructions[this.instructions.length - 1 - t], r = this._activePath.clone();
        if (e && (e.action === "stroke" || e.action === "fill")) if (e.data.hole) e.data.hole.addPath(r);
        else {
          e.data.hole = r;
          break;
        }
      }
      return this._initNextPathLocation(), this;
    }
    arc(t, e, r, s, n, o) {
      this._tick++;
      const a = this._transform;
      return this._activePath.arc(a.a * t + a.c * e + a.tx, a.b * t + a.d * e + a.ty, r, s, n, o), this;
    }
    arcTo(t, e, r, s, n) {
      this._tick++;
      const o = this._transform;
      return this._activePath.arcTo(o.a * t + o.c * e + o.tx, o.b * t + o.d * e + o.ty, o.a * r + o.c * s + o.tx, o.b * r + o.d * s + o.ty, n), this;
    }
    arcToSvg(t, e, r, s, n, o, a) {
      this._tick++;
      const c = this._transform;
      return this._activePath.arcToSvg(t, e, r, s, n, c.a * o + c.c * a + c.tx, c.b * o + c.d * a + c.ty), this;
    }
    bezierCurveTo(t, e, r, s, n, o, a) {
      this._tick++;
      const c = this._transform;
      return this._activePath.bezierCurveTo(c.a * t + c.c * e + c.tx, c.b * t + c.d * e + c.ty, c.a * r + c.c * s + c.tx, c.b * r + c.d * s + c.ty, c.a * n + c.c * o + c.tx, c.b * n + c.d * o + c.ty, a), this;
    }
    closePath() {
      var _a2;
      return this._tick++, (_a2 = this._activePath) == null ? void 0 : _a2.closePath(), this;
    }
    ellipse(t, e, r, s) {
      return this._tick++, this._activePath.ellipse(t, e, r, s, this._transform.clone()), this;
    }
    circle(t, e, r) {
      return this._tick++, this._activePath.circle(t, e, r, this._transform.clone()), this;
    }
    path(t) {
      return this._tick++, this._activePath.addPath(t, this._transform.clone()), this;
    }
    lineTo(t, e) {
      this._tick++;
      const r = this._transform;
      return this._activePath.lineTo(r.a * t + r.c * e + r.tx, r.b * t + r.d * e + r.ty), this;
    }
    moveTo(t, e) {
      this._tick++;
      const r = this._transform, s = this._activePath.instructions, n = r.a * t + r.c * e + r.tx, o = r.b * t + r.d * e + r.ty;
      return s.length === 1 && s[0].action === "moveTo" ? (s[0].data[0] = n, s[0].data[1] = o, this) : (this._activePath.moveTo(n, o), this);
    }
    quadraticCurveTo(t, e, r, s, n) {
      this._tick++;
      const o = this._transform;
      return this._activePath.quadraticCurveTo(o.a * t + o.c * e + o.tx, o.b * t + o.d * e + o.ty, o.a * r + o.c * s + o.tx, o.b * r + o.d * s + o.ty, n), this;
    }
    rect(t, e, r, s) {
      return this._tick++, this._activePath.rect(t, e, r, s, this._transform.clone()), this;
    }
    roundRect(t, e, r, s, n) {
      return this._tick++, this._activePath.roundRect(t, e, r, s, n, this._transform.clone()), this;
    }
    poly(t, e) {
      return this._tick++, this._activePath.poly(t, e, this._transform.clone()), this;
    }
    regularPoly(t, e, r, s, n = 0, o) {
      return this._tick++, this._activePath.regularPoly(t, e, r, s, n, o), this;
    }
    roundPoly(t, e, r, s, n, o) {
      return this._tick++, this._activePath.roundPoly(t, e, r, s, n, o), this;
    }
    roundShape(t, e, r, s) {
      return this._tick++, this._activePath.roundShape(t, e, r, s), this;
    }
    filletRect(t, e, r, s, n) {
      return this._tick++, this._activePath.filletRect(t, e, r, s, n), this;
    }
    chamferRect(t, e, r, s, n, o) {
      return this._tick++, this._activePath.chamferRect(t, e, r, s, n, o), this;
    }
    star(t, e, r, s, n = 0, o = 0) {
      return this._tick++, this._activePath.star(t, e, r, s, n, o, this._transform.clone()), this;
    }
    svg(t) {
      return this._tick++, mm(t, this), this;
    }
    restore() {
      const t = this._stateStack.pop();
      return t && (this._transform = t.transform, this._fillStyle = t.fillStyle, this._strokeStyle = t.strokeStyle), this;
    }
    save() {
      return this._stateStack.push({
        transform: this._transform.clone(),
        fillStyle: {
          ...this._fillStyle
        },
        strokeStyle: {
          ...this._strokeStyle
        }
      }), this;
    }
    getTransform() {
      return this._transform;
    }
    resetTransform() {
      return this._transform.identity(), this;
    }
    rotate(t) {
      return this._transform.rotate(t), this;
    }
    scale(t, e = t) {
      return this._transform.scale(t, e), this;
    }
    setTransform(t, e, r, s, n, o) {
      return t instanceof st ? (this._transform.set(t.a, t.b, t.c, t.d, t.tx, t.ty), this) : (this._transform.set(t, e, r, s, n, o), this);
    }
    transform(t, e, r, s, n, o) {
      return t instanceof st ? (this._transform.append(t), this) : (Kc.set(t, e, r, s, n, o), this._transform.append(Kc), this);
    }
    translate(t, e = t) {
      return this._transform.translate(t, e), this;
    }
    clear() {
      return this._activePath.clear(), this.instructions.length = 0, this.resetTransform(), this.onUpdate(), this;
    }
    onUpdate() {
      this.dirty || (this.emit("update", this, 16), this.dirty = true, this._boundsDirty = true);
    }
    get bounds() {
      if (!this._boundsDirty) return this._bounds;
      const t = this._bounds;
      t.clear();
      for (let e = 0; e < this.instructions.length; e++) {
        const r = this.instructions[e], s = r.action;
        if (s === "fill") {
          const n = r.data;
          t.addBounds(n.path.bounds);
        } else if (s === "texture") {
          const n = r.data;
          t.addFrame(n.dx, n.dy, n.dx + n.dw, n.dy + n.dh, n.transform);
        }
        if (s === "stroke") {
          const n = r.data, o = n.style.width / 2, a = n.path.bounds;
          t.addFrame(a.minX - o, a.minY - o, a.maxX + o, a.maxY + o);
        }
      }
      return t;
    }
    containsPoint(t) {
      var _a2;
      if (!this.bounds.containsPoint(t.x, t.y)) return false;
      const e = this.instructions;
      let r = false;
      for (let s = 0; s < e.length; s++) {
        const n = e[s], o = n.data, a = o.path;
        if (!n.action || !a) continue;
        const c = o.style, l = a.shapePath.shapePrimitives;
        for (let u = 0; u < l.length; u++) {
          const h = l[u].shape;
          if (!c || !h) continue;
          const d = l[u].transform, p = d ? d.applyInverse(t, vm) : t;
          n.action === "fill" ? r = h.contains(p.x, p.y) : r = h.strokeContains(p.x, p.y, c.width);
          const g = o.hole;
          if (g) {
            const y = (_a2 = g.shapePath) == null ? void 0 : _a2.shapePrimitives;
            if (y) for (let m = 0; m < y.length; m++) y[m].shape.contains(p.x, p.y) && (r = false);
          }
          if (r) return true;
        }
      }
      return r;
    }
    destroy(t = false) {
      if (this._stateStack.length = 0, this._transform = null, this.emit("destroy", this), this.removeAllListeners(), typeof t == "boolean" ? t : t == null ? void 0 : t.texture) {
        const r = typeof t == "boolean" ? t : t == null ? void 0 : t.textureSource;
        this._fillStyle.texture && this._fillStyle.texture.destroy(r), this._strokeStyle.texture && this._strokeStyle.texture.destroy(r);
      }
      this._fillStyle = null, this._strokeStyle = null, this.instructions = null, this._activePath = null, this._bounds = null, this._stateStack = null, this.customShader = null, this._transform = null;
    }
  };
  la.defaultFillStyle = {
    color: 16777215,
    alpha: 1,
    texture: Z.WHITE,
    matrix: null,
    fill: null
  };
  la.defaultStrokeStyle = {
    width: 1,
    color: 16777215,
    alpha: 1,
    alignment: 0.5,
    miterLimit: 10,
    cap: "butt",
    join: "miter",
    texture: Z.WHITE,
    matrix: null,
    fill: null
  };
  let oe = la;
  const Jc = [
    "align",
    "breakWords",
    "cssOverrides",
    "fontVariant",
    "fontWeight",
    "leading",
    "letterSpacing",
    "lineHeight",
    "padding",
    "textBaseline",
    "trim",
    "whiteSpace",
    "wordWrap",
    "wordWrapWidth",
    "fontFamily",
    "fontStyle",
    "fontSize"
  ];
  function Fh(i) {
    const t = [];
    let e = 0;
    for (let r = 0; r < Jc.length; r++) {
      const s = `_${Jc[r]}`;
      t[e++] = i[s];
    }
    return e = Uh(i._fill, t, e), e = Sm(i._stroke, t, e), e = Em(i.dropShadow, t, e), t.join("-");
  }
  function Uh(i, t, e) {
    var _a2;
    return i && (t[e++] = i.color, t[e++] = i.alpha, t[e++] = (_a2 = i.fill) == null ? void 0 : _a2.styleKey), e;
  }
  function Sm(i, t, e) {
    return i && (e = Uh(i, t, e), t[e++] = i.width, t[e++] = i.alignment, t[e++] = i.cap, t[e++] = i.join, t[e++] = i.miterLimit), e;
  }
  function Em(i, t, e) {
    return i && (t[e++] = i.alpha, t[e++] = i.angle, t[e++] = i.blur, t[e++] = i.distance, t[e++] = Tt.shared.setValue(i.color).toNumber()), e;
  }
  const ha = class jr extends me {
    constructor(t = {}) {
      super(), Tm(t);
      const e = {
        ...jr.defaultTextStyle,
        ...t
      };
      for (const r in e) {
        const s = r;
        this[s] = e[r];
      }
      this.update();
    }
    get align() {
      return this._align;
    }
    set align(t) {
      this._align = t, this.update();
    }
    get breakWords() {
      return this._breakWords;
    }
    set breakWords(t) {
      this._breakWords = t, this.update();
    }
    get dropShadow() {
      return this._dropShadow;
    }
    set dropShadow(t) {
      t !== null && typeof t == "object" ? this._dropShadow = this._createProxy({
        ...jr.defaultDropShadow,
        ...t
      }) : this._dropShadow = t ? this._createProxy({
        ...jr.defaultDropShadow
      }) : null, this.update();
    }
    get fontFamily() {
      return this._fontFamily;
    }
    set fontFamily(t) {
      this._fontFamily = t, this.update();
    }
    get fontSize() {
      return this._fontSize;
    }
    set fontSize(t) {
      typeof t == "string" ? this._fontSize = parseInt(t, 10) : this._fontSize = t, this.update();
    }
    get fontStyle() {
      return this._fontStyle;
    }
    set fontStyle(t) {
      this._fontStyle = t, this.update();
    }
    get fontVariant() {
      return this._fontVariant;
    }
    set fontVariant(t) {
      this._fontVariant = t, this.update();
    }
    get fontWeight() {
      return this._fontWeight;
    }
    set fontWeight(t) {
      this._fontWeight = t, this.update();
    }
    get leading() {
      return this._leading;
    }
    set leading(t) {
      this._leading = t, this.update();
    }
    get letterSpacing() {
      return this._letterSpacing;
    }
    set letterSpacing(t) {
      this._letterSpacing = t, this.update();
    }
    get lineHeight() {
      return this._lineHeight;
    }
    set lineHeight(t) {
      this._lineHeight = t, this.update();
    }
    get padding() {
      return this._padding;
    }
    set padding(t) {
      this._padding = t, this.update();
    }
    get trim() {
      return this._trim;
    }
    set trim(t) {
      this._trim = t, this.update();
    }
    get textBaseline() {
      return this._textBaseline;
    }
    set textBaseline(t) {
      this._textBaseline = t, this.update();
    }
    get whiteSpace() {
      return this._whiteSpace;
    }
    set whiteSpace(t) {
      this._whiteSpace = t, this.update();
    }
    get wordWrap() {
      return this._wordWrap;
    }
    set wordWrap(t) {
      this._wordWrap = t, this.update();
    }
    get wordWrapWidth() {
      return this._wordWrapWidth;
    }
    set wordWrapWidth(t) {
      this._wordWrapWidth = t, this.update();
    }
    get fill() {
      return this._originalFill;
    }
    set fill(t) {
      t !== this._originalFill && (this._originalFill = t, this._isFillStyle(t) && (this._originalFill = this._createProxy({
        ...oe.defaultFillStyle,
        ...t
      }, () => {
        this._fill = Pr({
          ...this._originalFill
        }, oe.defaultFillStyle);
      })), this._fill = Pr(t === 0 ? "black" : t, oe.defaultFillStyle), this.update());
    }
    get stroke() {
      return this._originalStroke;
    }
    set stroke(t) {
      t !== this._originalStroke && (this._originalStroke = t, this._isFillStyle(t) && (this._originalStroke = this._createProxy({
        ...oe.defaultStrokeStyle,
        ...t
      }, () => {
        this._stroke = Is({
          ...this._originalStroke
        }, oe.defaultStrokeStyle);
      })), this._stroke = Is(t, oe.defaultStrokeStyle), this.update());
    }
    _generateKey() {
      return this._styleKey = Fh(this), this._styleKey;
    }
    update() {
      this._styleKey = null, this.emit("update", this);
    }
    reset() {
      const t = jr.defaultTextStyle;
      for (const e in t) this[e] = t[e];
    }
    get styleKey() {
      return this._styleKey || this._generateKey();
    }
    clone() {
      return new jr({
        align: this.align,
        breakWords: this.breakWords,
        dropShadow: this._dropShadow ? {
          ...this._dropShadow
        } : null,
        fill: this._fill,
        fontFamily: this.fontFamily,
        fontSize: this.fontSize,
        fontStyle: this.fontStyle,
        fontVariant: this.fontVariant,
        fontWeight: this.fontWeight,
        leading: this.leading,
        letterSpacing: this.letterSpacing,
        lineHeight: this.lineHeight,
        padding: this.padding,
        stroke: this._stroke,
        textBaseline: this.textBaseline,
        whiteSpace: this.whiteSpace,
        wordWrap: this.wordWrap,
        wordWrapWidth: this.wordWrapWidth
      });
    }
    destroy(t = false) {
      var _a2, _b2, _c2, _d2;
      if (this.removeAllListeners(), typeof t == "boolean" ? t : t == null ? void 0 : t.texture) {
        const r = typeof t == "boolean" ? t : t == null ? void 0 : t.textureSource;
        ((_a2 = this._fill) == null ? void 0 : _a2.texture) && this._fill.texture.destroy(r), ((_b2 = this._originalFill) == null ? void 0 : _b2.texture) && this._originalFill.texture.destroy(r), ((_c2 = this._stroke) == null ? void 0 : _c2.texture) && this._stroke.texture.destroy(r), ((_d2 = this._originalStroke) == null ? void 0 : _d2.texture) && this._originalStroke.texture.destroy(r);
      }
      this._fill = null, this._stroke = null, this.dropShadow = null, this._originalStroke = null, this._originalFill = null;
    }
    _createProxy(t, e) {
      return new Proxy(t, {
        set: (r, s, n) => (r[s] = n, e == null ? void 0 : e(s, n), this.update(), true)
      });
    }
    _isFillStyle(t) {
      return (t ?? null) !== null && !(Tt.isColorLike(t) || t instanceof Ri || t instanceof Zs);
    }
  };
  ha.defaultDropShadow = {
    alpha: 1,
    angle: Math.PI / 6,
    blur: 0,
    color: "black",
    distance: 5
  };
  ha.defaultTextStyle = {
    align: "left",
    breakWords: false,
    dropShadow: null,
    fill: "black",
    fontFamily: "Arial",
    fontSize: 26,
    fontStyle: "normal",
    fontVariant: "normal",
    fontWeight: "normal",
    leading: 0,
    letterSpacing: 0,
    lineHeight: 0,
    padding: 0,
    stroke: null,
    textBaseline: "alphabetic",
    trim: false,
    whiteSpace: "pre",
    wordWrap: false,
    wordWrapWidth: 100
  };
  let Oe = ha;
  function Tm(i) {
    const t = i;
    if (typeof t.dropShadow == "boolean" && t.dropShadow) {
      const e = Oe.defaultDropShadow;
      i.dropShadow = {
        alpha: t.dropShadowAlpha ?? e.alpha,
        angle: t.dropShadowAngle ?? e.angle,
        blur: t.dropShadowBlur ?? e.blur,
        color: t.dropShadowColor ?? e.color,
        distance: t.dropShadowDistance ?? e.distance
      };
    }
    if (t.strokeThickness !== void 0) {
      lt(dt, "strokeThickness is now a part of stroke");
      const e = t.stroke;
      let r = {};
      if (Tt.isColorLike(e)) r.color = e;
      else if (e instanceof Ri || e instanceof Zs) r.fill = e;
      else if (Object.hasOwnProperty.call(e, "color") || Object.hasOwnProperty.call(e, "fill")) r = e;
      else throw new Error("Invalid stroke value.");
      i.stroke = {
        ...r,
        width: t.strokeThickness
      };
    }
    if (Array.isArray(t.fillGradientStops)) {
      lt(dt, "gradient fill is now a fill pattern: `new FillGradient(...)`");
      let e;
      i.fontSize == null ? i.fontSize = Oe.defaultTextStyle.fontSize : typeof i.fontSize == "string" ? e = parseInt(i.fontSize, 10) : e = i.fontSize;
      const r = new Ri(0, 0, 0, e * 1.7), s = t.fillGradientStops.map((n) => Tt.shared.setValue(n).toNumber());
      s.forEach((n, o) => {
        const a = o / (s.length - 1);
        r.addColorStop(a, n);
      }), i.fill = {
        fill: r
      };
    }
  }
  class Cm {
    constructor(t) {
      this._canvasPool = /* @__PURE__ */ Object.create(null), this.canvasOptions = t || {}, this.enableFullScreen = false;
    }
    _createCanvasAndContext(t, e) {
      const r = St.get().createCanvas();
      r.width = t, r.height = e;
      const s = r.getContext("2d");
      return {
        canvas: r,
        context: s
      };
    }
    getOptimalCanvasAndContext(t, e, r = 1) {
      t = Math.ceil(t * r - 1e-6), e = Math.ceil(e * r - 1e-6), t = Yr(t), e = Yr(e);
      const s = (t << 17) + (e << 1);
      this._canvasPool[s] || (this._canvasPool[s] = []);
      let n = this._canvasPool[s].pop();
      return n || (n = this._createCanvasAndContext(t, e)), n;
    }
    returnCanvasAndContext(t) {
      const e = t.canvas, { width: r, height: s } = e, n = (r << 17) + (s << 1);
      this._canvasPool[n].push(t);
    }
    clear() {
      this._canvasPool = {};
    }
  }
  const Qe = new Cm(), Am = [
    "serif",
    "sans-serif",
    "monospace",
    "cursive",
    "fantasy",
    "system-ui"
  ];
  function Fs(i) {
    const t = typeof i.fontSize == "number" ? `${i.fontSize}px` : i.fontSize;
    let e = i.fontFamily;
    Array.isArray(i.fontFamily) || (e = i.fontFamily.split(","));
    for (let r = e.length - 1; r >= 0; r--) {
      let s = e[r].trim();
      !/([\"\'])[^\'\"]+\1/.test(s) && !Am.includes(s) && (s = `"${s}"`), e[r] = s;
    }
    return `${i.fontStyle} ${i.fontVariant} ${i.fontWeight} ${t} ${e.join(",")}`;
  }
  const to = {
    willReadFrequently: true
  }, Be = class rt {
    static get experimentalLetterSpacingSupported() {
      let t = rt._experimentalLetterSpacingSupported;
      if (t !== void 0) {
        const e = St.get().getCanvasRenderingContext2D().prototype;
        t = rt._experimentalLetterSpacingSupported = "letterSpacing" in e || "textLetterSpacing" in e;
      }
      return t;
    }
    constructor(t, e, r, s, n, o, a, c, l) {
      this.text = t, this.style = e, this.width = r, this.height = s, this.lines = n, this.lineWidths = o, this.lineHeight = a, this.maxLineWidth = c, this.fontProperties = l;
    }
    static measureText(t = " ", e, r = rt._canvas, s = e.wordWrap) {
      var _a2;
      const n = `${t}:${e.styleKey}`;
      if (rt._measurementCache[n]) return rt._measurementCache[n];
      const o = Fs(e), a = rt.measureFont(o);
      a.fontSize === 0 && (a.fontSize = e.fontSize, a.ascent = e.fontSize);
      const c = rt.__context;
      c.font = o;
      const u = (s ? rt._wordWrap(t, e, r) : t).split(/(?:\r\n|\r|\n)/), h = new Array(u.length);
      let d = 0;
      for (let S = 0; S < u.length; S++) {
        const C = rt._measureText(u[S], e.letterSpacing, c);
        h[S] = C, d = Math.max(d, C);
      }
      const p = ((_a2 = e._stroke) == null ? void 0 : _a2.width) || 0;
      let g = d + p;
      e.dropShadow && (g += e.dropShadow.distance);
      const y = e.lineHeight || a.fontSize;
      let m = Math.max(y, a.fontSize + p) + (u.length - 1) * (y + e.leading);
      return e.dropShadow && (m += e.dropShadow.distance), new rt(t, e, g, m, u, h, y + e.leading, d, a);
    }
    static _measureText(t, e, r) {
      let s = false;
      rt.experimentalLetterSpacingSupported && (rt.experimentalLetterSpacing ? (r.letterSpacing = `${e}px`, r.textLetterSpacing = `${e}px`, s = true) : (r.letterSpacing = "0px", r.textLetterSpacing = "0px"));
      let n = r.measureText(t).width;
      return n > 0 && (s ? n -= e : n += (rt.graphemeSegmenter(t).length - 1) * e), n;
    }
    static _wordWrap(t, e, r = rt._canvas) {
      const s = r.getContext("2d", to);
      let n = 0, o = "", a = "";
      const c = /* @__PURE__ */ Object.create(null), { letterSpacing: l, whiteSpace: u } = e, h = rt._collapseSpaces(u), d = rt._collapseNewlines(u);
      let p = !h;
      const g = e.wordWrapWidth + l, y = rt._tokenize(t);
      for (let m = 0; m < y.length; m++) {
        let v = y[m];
        if (rt._isNewline(v)) {
          if (!d) {
            a += rt._addLine(o), p = !h, o = "", n = 0;
            continue;
          }
          v = " ";
        }
        if (h) {
          const C = rt.isBreakingSpace(v), G = rt.isBreakingSpace(o[o.length - 1]);
          if (C && G) continue;
        }
        const S = rt._getFromCache(v, l, c, s);
        if (S > g) if (o !== "" && (a += rt._addLine(o), o = "", n = 0), rt.canBreakWords(v, e.breakWords)) {
          const C = rt.wordWrapSplit(v);
          for (let G = 0; G < C.length; G++) {
            let H = C[G], Y = H, L = 1;
            for (; C[G + L]; ) {
              const A = C[G + L];
              if (!rt.canBreakChars(Y, A, v, G, e.breakWords)) H += A;
              else break;
              Y = A, L++;
            }
            G += L - 1;
            const W = rt._getFromCache(H, l, c, s);
            W + n > g && (a += rt._addLine(o), p = false, o = "", n = 0), o += H, n += W;
          }
        } else {
          o.length > 0 && (a += rt._addLine(o), o = "", n = 0);
          const C = m === y.length - 1;
          a += rt._addLine(v, !C), p = false, o = "", n = 0;
        }
        else S + n > g && (p = false, a += rt._addLine(o), o = "", n = 0), (o.length > 0 || !rt.isBreakingSpace(v) || p) && (o += v, n += S);
      }
      return a += rt._addLine(o, false), a;
    }
    static _addLine(t, e = true) {
      return t = rt._trimRight(t), t = e ? `${t}
` : t, t;
    }
    static _getFromCache(t, e, r, s) {
      let n = r[t];
      return typeof n != "number" && (n = rt._measureText(t, e, s) + e, r[t] = n), n;
    }
    static _collapseSpaces(t) {
      return t === "normal" || t === "pre-line";
    }
    static _collapseNewlines(t) {
      return t === "normal";
    }
    static _trimRight(t) {
      if (typeof t != "string") return "";
      for (let e = t.length - 1; e >= 0; e--) {
        const r = t[e];
        if (!rt.isBreakingSpace(r)) break;
        t = t.slice(0, -1);
      }
      return t;
    }
    static _isNewline(t) {
      return typeof t != "string" ? false : rt._newlines.includes(t.charCodeAt(0));
    }
    static isBreakingSpace(t, e) {
      return typeof t != "string" ? false : rt._breakingSpaces.includes(t.charCodeAt(0));
    }
    static _tokenize(t) {
      const e = [];
      let r = "";
      if (typeof t != "string") return e;
      for (let s = 0; s < t.length; s++) {
        const n = t[s], o = t[s + 1];
        if (rt.isBreakingSpace(n, o) || rt._isNewline(n)) {
          r !== "" && (e.push(r), r = ""), e.push(n);
          continue;
        }
        r += n;
      }
      return r !== "" && e.push(r), e;
    }
    static canBreakWords(t, e) {
      return e;
    }
    static canBreakChars(t, e, r, s, n) {
      return true;
    }
    static wordWrapSplit(t) {
      return rt.graphemeSegmenter(t);
    }
    static measureFont(t) {
      if (rt._fonts[t]) return rt._fonts[t];
      const e = rt._context;
      e.font = t;
      const r = e.measureText(rt.METRICS_STRING + rt.BASELINE_SYMBOL), s = {
        ascent: r.actualBoundingBoxAscent,
        descent: r.actualBoundingBoxDescent,
        fontSize: r.actualBoundingBoxAscent + r.actualBoundingBoxDescent
      };
      return rt._fonts[t] = s, s;
    }
    static clearMetrics(t = "") {
      t ? delete rt._fonts[t] : rt._fonts = {};
    }
    static get _canvas() {
      var _a2;
      if (!rt.__canvas) {
        let t;
        try {
          const e = new OffscreenCanvas(0, 0);
          if ((_a2 = e.getContext("2d", to)) == null ? void 0 : _a2.measureText) return rt.__canvas = e, e;
          t = St.get().createCanvas();
        } catch {
          t = St.get().createCanvas();
        }
        t.width = t.height = 10, rt.__canvas = t;
      }
      return rt.__canvas;
    }
    static get _context() {
      return rt.__context || (rt.__context = rt._canvas.getContext("2d", to)), rt.__context;
    }
  };
  Be.METRICS_STRING = "|\xC9q\xC5";
  Be.BASELINE_SYMBOL = "M";
  Be.BASELINE_MULTIPLIER = 1.4;
  Be.HEIGHT_MULTIPLIER = 2;
  Be.graphemeSegmenter = (() => {
    if (typeof (Intl == null ? void 0 : Intl.Segmenter) == "function") {
      const i = new Intl.Segmenter();
      return (t) => [
        ...i.segment(t)
      ].map((e) => e.segment);
    }
    return (i) => [
      ...i
    ];
  })();
  Be.experimentalLetterSpacing = false;
  Be._fonts = {};
  Be._newlines = [
    10,
    13
  ];
  Be._breakingSpaces = [
    9,
    32,
    8192,
    8193,
    8194,
    8195,
    8196,
    8197,
    8198,
    8200,
    8201,
    8202,
    8287,
    12288
  ];
  Be._measurementCache = {};
  let Ge = Be;
  function Us(i, t) {
    if (i.texture === Z.WHITE && !i.fill) return Tt.shared.setValue(i.color).toHex();
    if (i.fill) {
      if (i.fill instanceof Zs) {
        const e = i.fill, r = t.createPattern(e.texture.source.resource, "repeat"), s = e.transform.copyTo(st.shared);
        return s.scale(e.texture.frame.width, e.texture.frame.height), r.setTransform(s), r;
      } else if (i.fill instanceof Ri) {
        const e = i.fill;
        if (e.type === "linear") {
          const r = t.createLinearGradient(e.x0, e.y0, e.x1, e.y1);
          return e.gradientStops.forEach((s) => {
            r.addColorStop(s.offset, Tt.shared.setValue(s.color).toHex());
          }), r;
        }
      }
    } else {
      const e = t.createPattern(i.texture.source.resource, "repeat"), r = i.matrix.copyTo(st.shared);
      return r.scale(i.texture.frame.width, i.texture.frame.height), e.setTransform(r), e;
    }
    return ut("FillStyle not recognised", i), "red";
  }
  function kh(i) {
    if (i === "") return [];
    typeof i == "string" && (i = [
      i
    ]);
    const t = [];
    for (let e = 0, r = i.length; e < r; e++) {
      const s = i[e];
      if (Array.isArray(s)) {
        if (s.length !== 2) throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${s.length}.`);
        if (s[0].length === 0 || s[1].length === 0) throw new Error("[BitmapFont]: Invalid character delimiter.");
        const n = s[0].charCodeAt(0), o = s[1].charCodeAt(0);
        if (o < n) throw new Error("[BitmapFont]: Invalid character range.");
        for (let a = n, c = o; a <= c; a++) t.push(String.fromCharCode(a));
      } else t.push(...Array.from(s));
    }
    if (t.length === 0) throw new Error("[BitmapFont]: Empty set when resolving characters.");
    return t;
  }
  const Gh = class Oh extends wh {
    constructor(t) {
      super(), this.resolution = 1, this.pages = [], this._padding = 0, this._measureCache = /* @__PURE__ */ Object.create(null), this._currentChars = [], this._currentX = 0, this._currentY = 0, this._currentPageIndex = -1, this._skipKerning = false;
      const e = {
        ...Oh.defaultOptions,
        ...t
      };
      this._textureSize = e.textureSize, this._mipmap = e.mipmap;
      const r = e.style.clone();
      e.overrideFill && (r._fill.color = 16777215, r._fill.alpha = 1, r._fill.texture = Z.WHITE, r._fill.fill = null), this.applyFillAsTint = e.overrideFill;
      const s = r.fontSize;
      r.fontSize = this.baseMeasurementFontSize;
      const n = Fs(r);
      e.overrideSize ? r._stroke && (r._stroke.width *= this.baseRenderedFontSize / s) : r.fontSize = this.baseRenderedFontSize = s, this._style = r, this._skipKerning = e.skipKerning ?? false, this.resolution = e.resolution ?? 1, this._padding = e.padding ?? 4, this.fontMetrics = Ge.measureFont(n), this.lineHeight = r.lineHeight || this.fontMetrics.fontSize || r.fontSize;
    }
    ensureCharacters(t) {
      var _a2, _b2;
      const e = kh(t).filter((y) => !this._currentChars.includes(y)).filter((y, m, v) => v.indexOf(y) === m);
      if (!e.length) return;
      this._currentChars = [
        ...this._currentChars,
        ...e
      ];
      let r;
      this._currentPageIndex === -1 ? r = this._nextPage() : r = this.pages[this._currentPageIndex];
      let { canvas: s, context: n } = r.canvasAndContext, o = r.texture.source;
      const a = this._style;
      let c = this._currentX, l = this._currentY;
      const u = this.baseRenderedFontSize / this.baseMeasurementFontSize, h = this._padding * u, d = a.fontStyle === "italic" ? 2 : 1;
      let p = 0, g = false;
      for (let y = 0; y < e.length; y++) {
        const m = e[y], v = Ge.measureText(m, a, s, false);
        v.lineHeight = v.height;
        const S = d * v.width * u, C = v.height * u, G = S + h * 2, H = C + h * 2;
        if (g = false, m !== `
` && m !== "\r" && m !== "	" && m !== " " && (g = true, p = Math.ceil(Math.max(H, p))), c + G > this._textureSize && (l += p, p = H, c = 0, l + p > this._textureSize)) {
          o.update();
          const L = this._nextPage();
          s = L.canvasAndContext.canvas, n = L.canvasAndContext.context, o = L.texture.source, l = 0;
        }
        const Y = S / u - (((_a2 = a.dropShadow) == null ? void 0 : _a2.distance) ?? 0) - (((_b2 = a._stroke) == null ? void 0 : _b2.width) ?? 0);
        if (this.chars[m] = {
          id: m.codePointAt(0),
          xOffset: -this._padding,
          yOffset: -this._padding,
          xAdvance: Y,
          kerning: {}
        }, g) {
          this._drawGlyph(n, v, c + h, l + h, u, a);
          const L = o.width * u, W = o.height * u, A = new Et(c / L * o.width, l / W * o.height, G / L * o.width, H / W * o.height);
          this.chars[m].texture = new Z({
            source: o,
            frame: A
          }), c += Math.ceil(G);
        }
      }
      o.update(), this._currentX = c, this._currentY = l, this._skipKerning && this._applyKerning(e, n);
    }
    get pageTextures() {
      return lt(dt, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."), this.pages;
    }
    _applyKerning(t, e) {
      const r = this._measureCache;
      for (let s = 0; s < t.length; s++) {
        const n = t[s];
        for (let o = 0; o < this._currentChars.length; o++) {
          const a = this._currentChars[o];
          let c = r[n];
          c || (c = r[n] = e.measureText(n).width);
          let l = r[a];
          l || (l = r[a] = e.measureText(a).width);
          let u = e.measureText(n + a).width, h = u - (c + l);
          h && (this.chars[n].kerning[a] = h), u = e.measureText(n + a).width, h = u - (c + l), h && (this.chars[a].kerning[n] = h);
        }
      }
    }
    _nextPage() {
      this._currentPageIndex++;
      const t = this.resolution, e = Qe.getOptimalCanvasAndContext(this._textureSize, this._textureSize, t);
      this._setupContext(e.context, this._style, t);
      const r = t * (this.baseRenderedFontSize / this.baseMeasurementFontSize), s = new Z({
        source: new ei({
          resource: e.canvas,
          resolution: r,
          alphaMode: "premultiply-alpha-on-upload",
          autoGenerateMipmaps: this._mipmap
        })
      }), n = {
        canvasAndContext: e,
        texture: s
      };
      return this.pages[this._currentPageIndex] = n, n;
    }
    _setupContext(t, e, r) {
      e.fontSize = this.baseRenderedFontSize, t.scale(r, r), t.font = Fs(e), e.fontSize = this.baseMeasurementFontSize, t.textBaseline = e.textBaseline;
      const s = e._stroke, n = (s == null ? void 0 : s.width) ?? 0;
      if (s && (t.lineWidth = n, t.lineJoin = s.join, t.miterLimit = s.miterLimit, t.strokeStyle = Us(s, t)), e._fill && (t.fillStyle = Us(e._fill, t)), e.dropShadow) {
        const o = e.dropShadow, a = Tt.shared.setValue(o.color).toArray(), c = o.blur * r, l = o.distance * r;
        t.shadowColor = `rgba(${a[0] * 255},${a[1] * 255},${a[2] * 255},${o.alpha})`, t.shadowBlur = c, t.shadowOffsetX = Math.cos(o.angle) * l, t.shadowOffsetY = Math.sin(o.angle) * l;
      } else t.shadowColor = "black", t.shadowBlur = 0, t.shadowOffsetX = 0, t.shadowOffsetY = 0;
    }
    _drawGlyph(t, e, r, s, n, o) {
      var _a2;
      const a = e.text, c = e.fontProperties, u = (((_a2 = o._stroke) == null ? void 0 : _a2.width) ?? 0) * n, h = r + u / 2, d = s - u / 2, p = c.descent * n, g = e.lineHeight * n;
      o.stroke && u && t.strokeText(a, h, d + g - p), o._fill && t.fillText(a, h, d + g - p);
    }
    destroy() {
      super.destroy();
      for (let t = 0; t < this.pages.length; t++) {
        const { canvasAndContext: e, texture: r } = this.pages[t];
        e.canvas.width = e.canvas.width, Qe.returnCanvasAndContext(e), r.destroy(true);
      }
      this.pages = null;
    }
  };
  Gh.defaultOptions = {
    textureSize: 512,
    style: new Oe(),
    mipmap: true
  };
  let Zc = Gh;
  function Nh(i, t, e) {
    const r = {
      width: 0,
      height: 0,
      offsetY: 0,
      scale: t.fontSize / e.baseMeasurementFontSize,
      lines: [
        {
          width: 0,
          charPositions: [],
          spaceWidth: 0,
          spacesIndex: [],
          chars: []
        }
      ]
    };
    r.offsetY = e.baseLineOffset;
    let s = r.lines[0], n = null, o = true;
    const a = {
      spaceWord: false,
      width: 0,
      start: 0,
      index: 0,
      positions: [],
      chars: []
    }, c = (p) => {
      const g = s.width;
      for (let y = 0; y < a.index; y++) {
        const m = p.positions[y];
        s.chars.push(p.chars[y]), s.charPositions.push(m + g);
      }
      s.width += p.width, o = false, a.width = 0, a.index = 0, a.chars.length = 0;
    }, l = () => {
      let p = s.chars.length - 1, g = s.chars[p];
      for (; g === " "; ) s.width -= e.chars[g].xAdvance, g = s.chars[--p];
      r.width = Math.max(r.width, s.width), s = {
        width: 0,
        charPositions: [],
        chars: [],
        spaceWidth: 0,
        spacesIndex: []
      }, o = true, r.lines.push(s), r.height += e.lineHeight;
    }, u = e.baseMeasurementFontSize / t.fontSize, h = t.letterSpacing * u, d = t.wordWrapWidth * u;
    for (let p = 0; p < i.length + 1; p++) {
      let g;
      const y = p === i.length;
      y || (g = i[p]);
      const m = e.chars[g] || e.chars[" "];
      if (/(?:\s)/.test(g) || g === "\r" || g === `
` || y) {
        if (!o && t.wordWrap && s.width + a.width - h > d ? (l(), c(a), y || s.charPositions.push(0)) : (a.start = s.width, c(a), y || s.charPositions.push(0)), g === "\r" || g === `
`) s.width !== 0 && l();
        else if (!y) {
          const G = m.xAdvance + (m.kerning[n] || 0) + h;
          s.width += G, s.spaceWidth = G, s.spacesIndex.push(s.charPositions.length), s.chars.push(g);
        }
      } else {
        const C = m.kerning[n] || 0, G = m.xAdvance + C + h;
        a.positions[a.index++] = a.width + C, a.chars.push(g), a.width += G;
      }
      n = g;
    }
    return l(), t.align === "center" ? Rm(r) : t.align === "right" ? Pm(r) : t.align === "justify" && Bm(r), r;
  }
  function Rm(i) {
    for (let t = 0; t < i.lines.length; t++) {
      const e = i.lines[t], r = i.width / 2 - e.width / 2;
      for (let s = 0; s < e.charPositions.length; s++) e.charPositions[s] += r;
    }
  }
  function Pm(i) {
    for (let t = 0; t < i.lines.length; t++) {
      const e = i.lines[t], r = i.width - e.width;
      for (let s = 0; s < e.charPositions.length; s++) e.charPositions[s] += r;
    }
  }
  function Bm(i) {
    const t = i.width;
    for (let e = 0; e < i.lines.length; e++) {
      const r = i.lines[e];
      let s = 0, n = r.spacesIndex[s++], o = 0;
      const a = r.spacesIndex.length, l = (t - r.width) / a;
      for (let u = 0; u < r.charPositions.length; u++) u === n && (n = r.spacesIndex[s++], o += l), r.charPositions[u] += o;
    }
  }
  let is = 0;
  class Mm {
    constructor() {
      this.ALPHA = [
        [
          "a",
          "z"
        ],
        [
          "A",
          "Z"
        ],
        " "
      ], this.NUMERIC = [
        [
          "0",
          "9"
        ]
      ], this.ALPHANUMERIC = [
        [
          "a",
          "z"
        ],
        [
          "A",
          "Z"
        ],
        [
          "0",
          "9"
        ],
        " "
      ], this.ASCII = [
        [
          " ",
          "~"
        ]
      ], this.defaultOptions = {
        chars: this.ALPHANUMERIC,
        resolution: 1,
        padding: 4,
        skipKerning: false
      };
    }
    getFont(t, e) {
      var _a2;
      let r = `${e.fontFamily}-bitmap`, s = true;
      if (e._fill.fill && !e._stroke) r += e._fill.fill.styleKey, s = false;
      else if (e._stroke || e.dropShadow) {
        let o = e.styleKey;
        o = o.substring(0, o.lastIndexOf("-")), r = `${o}-bitmap`, s = false;
      }
      if (!Ct.has(r)) {
        const o = new Zc({
          style: e,
          overrideFill: s,
          overrideSize: true,
          ...this.defaultOptions
        });
        is++, is > 50 && ut("BitmapText", `You have dynamically created ${is} bitmap fonts, this can be inefficient. Try pre installing your font styles using \`BitmapFont.install({name:"style1", style})\``), o.once("destroy", () => {
          is--, Ct.remove(r);
        }), Ct.set(r, o);
      }
      const n = Ct.get(r);
      return (_a2 = n.ensureCharacters) == null ? void 0 : _a2.call(n, t), n;
    }
    getLayout(t, e) {
      const r = this.getFont(t, e);
      return Nh([
        ...t
      ], e, r);
    }
    measureText(t, e) {
      return this.getLayout(t, e);
    }
    install(...t) {
      var _a2, _b2, _c2, _d2;
      let e = t[0];
      typeof e == "string" && (e = {
        name: e,
        style: t[1],
        chars: (_a2 = t[2]) == null ? void 0 : _a2.chars,
        resolution: (_b2 = t[2]) == null ? void 0 : _b2.resolution,
        padding: (_c2 = t[2]) == null ? void 0 : _c2.padding,
        skipKerning: (_d2 = t[2]) == null ? void 0 : _d2.skipKerning
      }, lt(dt, "BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})"));
      const r = e == null ? void 0 : e.name;
      if (!r) throw new Error("[BitmapFontManager] Property `name` is required.");
      e = {
        ...this.defaultOptions,
        ...e
      };
      const s = e.style, n = s instanceof Oe ? s : new Oe(s), o = n._fill.fill !== null && n._fill.fill !== void 0, a = new Zc({
        style: n,
        overrideFill: o,
        skipKerning: e.skipKerning,
        padding: e.padding,
        resolution: e.resolution,
        overrideSize: false
      }), c = kh(e.chars);
      return a.ensureCharacters(c.join("")), Ct.set(`${r}-bitmap`, a), a.once("destroy", () => Ct.remove(`${r}-bitmap`)), a;
    }
    uninstall(t) {
      const e = `${t}-bitmap`, r = Ct.get(e);
      r && (Ct.remove(e), r.destroy());
    }
  }
  const ks = new Mm();
  class Lh extends wh {
    constructor(t, e) {
      super();
      const { textures: r, data: s } = t;
      Object.keys(s.pages).forEach((n) => {
        const o = s.pages[parseInt(n, 10)], a = r[o.id];
        this.pages.push({
          texture: a
        });
      }), Object.keys(s.chars).forEach((n) => {
        const o = s.chars[n], { frame: a, source: c } = r[o.page], l = new Et(o.x + a.x, o.y + a.y, o.width, o.height), u = new Z({
          source: c,
          frame: l
        });
        this.chars[n] = {
          id: n.codePointAt(0),
          xOffset: o.xOffset,
          yOffset: o.yOffset,
          xAdvance: o.xAdvance,
          kerning: o.kerning ?? {},
          texture: u
        };
      }), this.baseRenderedFontSize = s.fontSize, this.baseMeasurementFontSize = s.fontSize, this.fontMetrics = {
        ascent: 0,
        descent: 0,
        fontSize: s.fontSize
      }, this.baseLineOffset = s.baseLineOffset, this.lineHeight = s.lineHeight, this.fontFamily = s.fontFamily, this.distanceField = s.distanceField ?? {
        type: "none",
        range: 0
      }, this.url = e;
    }
    destroy() {
      super.destroy();
      for (let t = 0; t < this.pages.length; t++) {
        const { texture: e } = this.pages[t];
        e.destroy(true);
      }
      this.pages = null;
    }
    static install(t) {
      ks.install(t);
    }
    static uninstall(t) {
      ks.uninstall(t);
    }
  }
  const eo = {
    test(i) {
      return typeof i == "string" && i.startsWith("info face=");
    },
    parse(i) {
      const t = i.match(/^[a-z]+\s+.+$/gm), e = {
        info: [],
        common: [],
        page: [],
        char: [],
        chars: [],
        kerning: [],
        kernings: [],
        distanceField: []
      };
      for (const h in t) {
        const d = t[h].match(/^[a-z]+/gm)[0], p = t[h].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm), g = {};
        for (const y in p) {
          const m = p[y].split("="), v = m[0], S = m[1].replace(/"/gm, ""), C = parseFloat(S), G = isNaN(C) ? S : C;
          g[v] = G;
        }
        e[d].push(g);
      }
      const r = {
        chars: {},
        pages: [],
        lineHeight: 0,
        fontSize: 0,
        fontFamily: "",
        distanceField: null,
        baseLineOffset: 0
      }, [s] = e.info, [n] = e.common, [o] = e.distanceField ?? [];
      o && (r.distanceField = {
        range: parseInt(o.distanceRange, 10),
        type: o.fieldType
      }), r.fontSize = parseInt(s.size, 10), r.fontFamily = s.face, r.lineHeight = parseInt(n.lineHeight, 10);
      const a = e.page;
      for (let h = 0; h < a.length; h++) r.pages.push({
        id: parseInt(a[h].id, 10) || 0,
        file: a[h].file
      });
      const c = {};
      r.baseLineOffset = r.lineHeight - parseInt(n.base, 10);
      const l = e.char;
      for (let h = 0; h < l.length; h++) {
        const d = l[h], p = parseInt(d.id, 10);
        let g = d.letter ?? d.char ?? String.fromCharCode(p);
        g === "space" && (g = " "), c[p] = g, r.chars[g] = {
          id: p,
          page: parseInt(d.page, 10) || 0,
          x: parseInt(d.x, 10),
          y: parseInt(d.y, 10),
          width: parseInt(d.width, 10),
          height: parseInt(d.height, 10),
          xOffset: parseInt(d.xoffset, 10),
          yOffset: parseInt(d.yoffset, 10),
          xAdvance: parseInt(d.xadvance, 10),
          kerning: {}
        };
      }
      const u = e.kerning || [];
      for (let h = 0; h < u.length; h++) {
        const d = parseInt(u[h].first, 10), p = parseInt(u[h].second, 10), g = parseInt(u[h].amount, 10);
        r.chars[c[p]].kerning[c[d]] = g;
      }
      return r;
    }
  }, Qc = {
    test(i) {
      const t = i;
      return typeof t != "string" && "getElementsByTagName" in t && t.getElementsByTagName("page").length && t.getElementsByTagName("info")[0].getAttribute("face") !== null;
    },
    parse(i) {
      const t = {
        chars: {},
        pages: [],
        lineHeight: 0,
        fontSize: 0,
        fontFamily: "",
        distanceField: null,
        baseLineOffset: 0
      }, e = i.getElementsByTagName("info")[0], r = i.getElementsByTagName("common")[0], s = i.getElementsByTagName("distanceField")[0];
      s && (t.distanceField = {
        type: s.getAttribute("fieldType"),
        range: parseInt(s.getAttribute("distanceRange"), 10)
      });
      const n = i.getElementsByTagName("page"), o = i.getElementsByTagName("char"), a = i.getElementsByTagName("kerning");
      t.fontSize = parseInt(e.getAttribute("size"), 10), t.fontFamily = e.getAttribute("face"), t.lineHeight = parseInt(r.getAttribute("lineHeight"), 10);
      for (let l = 0; l < n.length; l++) t.pages.push({
        id: parseInt(n[l].getAttribute("id"), 10) || 0,
        file: n[l].getAttribute("file")
      });
      const c = {};
      t.baseLineOffset = t.lineHeight - parseInt(r.getAttribute("base"), 10);
      for (let l = 0; l < o.length; l++) {
        const u = o[l], h = parseInt(u.getAttribute("id"), 10);
        let d = u.getAttribute("letter") ?? u.getAttribute("char") ?? String.fromCharCode(h);
        d === "space" && (d = " "), c[h] = d, t.chars[d] = {
          id: h,
          page: parseInt(u.getAttribute("page"), 10) || 0,
          x: parseInt(u.getAttribute("x"), 10),
          y: parseInt(u.getAttribute("y"), 10),
          width: parseInt(u.getAttribute("width"), 10),
          height: parseInt(u.getAttribute("height"), 10),
          xOffset: parseInt(u.getAttribute("xoffset"), 10),
          yOffset: parseInt(u.getAttribute("yoffset"), 10),
          xAdvance: parseInt(u.getAttribute("xadvance"), 10),
          kerning: {}
        };
      }
      for (let l = 0; l < a.length; l++) {
        const u = parseInt(a[l].getAttribute("first"), 10), h = parseInt(a[l].getAttribute("second"), 10), d = parseInt(a[l].getAttribute("amount"), 10);
        t.chars[c[h]].kerning[c[u]] = d;
      }
      return t;
    }
  }, tu = {
    test(i) {
      return typeof i == "string" && i.includes("<font>") ? Qc.test(St.get().parseXML(i)) : false;
    },
    parse(i) {
      return Qc.parse(St.get().parseXML(i));
    }
  }, Dm = [
    ".xml",
    ".fnt"
  ], Im = {
    extension: {
      type: P.CacheParser,
      name: "cacheBitmapFont"
    },
    test: (i) => i instanceof Lh,
    getCacheableAssets(i, t) {
      const e = {};
      return i.forEach((r) => {
        e[r] = t, e[`${r}-bitmap`] = t;
      }), e[`${t.fontFamily}-bitmap`] = t, e;
    }
  }, Fm = {
    extension: {
      type: P.LoadParser,
      priority: ve.Normal
    },
    name: "loadBitmapFont",
    test(i) {
      return Dm.includes(_e.extname(i).toLowerCase());
    },
    async testParse(i) {
      return eo.test(i) || tu.test(i);
    },
    async parse(i, t, e) {
      const r = eo.test(i) ? eo.parse(i) : tu.parse(i), { src: s } = t, { pages: n } = r, o = [], a = r.distanceField ? {
        scaleMode: "linear",
        alphaMode: "premultiply-alpha-on-upload",
        autoGenerateMipmaps: false,
        resolution: 1
      } : {};
      for (let h = 0; h < n.length; ++h) {
        const d = n[h].file;
        let p = _e.join(_e.dirname(s), d);
        p = To(p, s), o.push({
          src: p,
          data: a
        });
      }
      const c = await e.load(o), l = o.map((h) => c[h.src]);
      return new Lh({
        data: r,
        textures: l
      }, s);
    },
    async load(i, t) {
      return await (await St.get().fetch(i)).text();
    },
    async unload(i, t, e) {
      await Promise.all(i.pages.map((r) => e.unload(r.texture.source._sourceOrigin))), i.destroy();
    }
  };
  class Um {
    constructor(t, e = false) {
      this._loader = t, this._assetList = [], this._isLoading = false, this._maxConcurrent = 1, this.verbose = e;
    }
    add(t) {
      t.forEach((e) => {
        this._assetList.push(e);
      }), this.verbose && console.log("[BackgroundLoader] assets: ", this._assetList), this._isActive && !this._isLoading && this._next();
    }
    async _next() {
      if (this._assetList.length && this._isActive) {
        this._isLoading = true;
        const t = [], e = Math.min(this._assetList.length, this._maxConcurrent);
        for (let r = 0; r < e; r++) t.push(this._assetList.pop());
        await this._loader.load(t), this._isLoading = false, this._next();
      }
    }
    get active() {
      return this._isActive;
    }
    set active(t) {
      this._isActive !== t && (this._isActive = t, t && !this._isLoading && this._next());
    }
  }
  const km = {
    extension: {
      type: P.CacheParser,
      name: "cacheTextureArray"
    },
    test: (i) => Array.isArray(i) && i.every((t) => t instanceof Z),
    getCacheableAssets: (i, t) => {
      const e = {};
      return i.forEach((r) => {
        t.forEach((s, n) => {
          e[r + (n === 0 ? "" : n + 1)] = s;
        });
      }), e;
    }
  };
  async function Hh(i) {
    if ("Image" in globalThis) return new Promise((t) => {
      const e = new Image();
      e.onload = () => {
        t(true);
      }, e.onerror = () => {
        t(false);
      }, e.src = i;
    });
    if ("createImageBitmap" in globalThis && "fetch" in globalThis) {
      try {
        const t = await (await fetch(i)).blob();
        await createImageBitmap(t);
      } catch {
        return false;
      }
      return true;
    }
    return false;
  }
  const Gm = {
    extension: {
      type: P.DetectionParser,
      priority: 1
    },
    test: async () => Hh("data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A="),
    add: async (i) => [
      ...i,
      "avif"
    ],
    remove: async (i) => i.filter((t) => t !== "avif")
  }, eu = [
    "png",
    "jpg",
    "jpeg"
  ], Om = {
    extension: {
      type: P.DetectionParser,
      priority: -1
    },
    test: () => Promise.resolve(true),
    add: async (i) => [
      ...i,
      ...eu
    ],
    remove: async (i) => i.filter((t) => !eu.includes(t))
  }, Nm = "WorkerGlobalScope" in globalThis && globalThis instanceof globalThis.WorkerGlobalScope;
  function da(i) {
    return Nm ? false : document.createElement("video").canPlayType(i) !== "";
  }
  const Lm = {
    extension: {
      type: P.DetectionParser,
      priority: 0
    },
    test: async () => da("video/mp4"),
    add: async (i) => [
      ...i,
      "mp4",
      "m4v"
    ],
    remove: async (i) => i.filter((t) => t !== "mp4" && t !== "m4v")
  }, Hm = {
    extension: {
      type: P.DetectionParser,
      priority: 0
    },
    test: async () => da("video/ogg"),
    add: async (i) => [
      ...i,
      "ogv"
    ],
    remove: async (i) => i.filter((t) => t !== "ogv")
  }, zm = {
    extension: {
      type: P.DetectionParser,
      priority: 0
    },
    test: async () => da("video/webm"),
    add: async (i) => [
      ...i,
      "webm"
    ],
    remove: async (i) => i.filter((t) => t !== "webm")
  }, jm = {
    extension: {
      type: P.DetectionParser,
      priority: 0
    },
    test: async () => Hh("data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA="),
    add: async (i) => [
      ...i,
      "webp"
    ],
    remove: async (i) => i.filter((t) => t !== "webp")
  };
  class Wm {
    constructor() {
      this._parsers = [], this._parsersValidated = false, this.parsers = new Proxy(this._parsers, {
        set: (t, e, r) => (this._parsersValidated = false, t[e] = r, true)
      }), this.promiseCache = {};
    }
    reset() {
      this._parsersValidated = false, this.promiseCache = {};
    }
    _getLoadPromiseAndParser(t, e) {
      const r = {
        promise: null,
        parser: null
      };
      return r.promise = (async () => {
        var _a2, _b2;
        let s = null, n = null;
        if (e.loadParser && (n = this._parserHash[e.loadParser], n || ut(`[Assets] specified load parser "${e.loadParser}" not found while loading ${t}`)), !n) {
          for (let o = 0; o < this.parsers.length; o++) {
            const a = this.parsers[o];
            if (a.load && ((_a2 = a.test) == null ? void 0 : _a2.call(a, t, e, this))) {
              n = a;
              break;
            }
          }
          if (!n) return ut(`[Assets] ${t} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`), null;
        }
        s = await n.load(t, e, this), r.parser = n;
        for (let o = 0; o < this.parsers.length; o++) {
          const a = this.parsers[o];
          a.parse && a.parse && await ((_b2 = a.testParse) == null ? void 0 : _b2.call(a, s, e, this)) && (s = await a.parse(s, e, this) || s, r.parser = a);
        }
        return s;
      })(), r;
    }
    async load(t, e) {
      this._parsersValidated || this._validateParsers();
      let r = 0;
      const s = {}, n = Ms(t), o = Re(t, (l) => ({
        alias: [
          l
        ],
        src: l,
        data: {}
      })), a = o.length, c = o.map(async (l) => {
        const u = _e.toAbsolute(l.src);
        if (!s[l.src]) try {
          this.promiseCache[u] || (this.promiseCache[u] = this._getLoadPromiseAndParser(u, l)), s[l.src] = await this.promiseCache[u].promise, e && e(++r / a);
        } catch (h) {
          throw delete this.promiseCache[u], delete s[l.src], new Error(`[Loader.load] Failed to load ${u}.
${h}`);
        }
      });
      return await Promise.all(c), n ? s[o[0].src] : s;
    }
    async unload(t) {
      const r = Re(t, (s) => ({
        alias: [
          s
        ],
        src: s
      })).map(async (s) => {
        var _a2, _b2;
        const n = _e.toAbsolute(s.src), o = this.promiseCache[n];
        if (o) {
          const a = await o.promise;
          delete this.promiseCache[n], await ((_b2 = (_a2 = o.parser) == null ? void 0 : _a2.unload) == null ? void 0 : _b2.call(_a2, a, s, this));
        }
      });
      await Promise.all(r);
    }
    _validateParsers() {
      this._parsersValidated = true, this._parserHash = this._parsers.filter((t) => t.name).reduce((t, e) => (e.name ? t[e.name] && ut(`[Assets] loadParser name conflict "${e.name}"`) : ut("[Assets] loadParser should have a name"), {
        ...t,
        [e.name]: e
      }), {});
    }
  }
  function ii(i, t) {
    if (Array.isArray(t)) {
      for (const e of t) if (i.startsWith(`data:${e}`)) return true;
      return false;
    }
    return i.startsWith(`data:${t}`);
  }
  function Me(i, t) {
    const e = i.split("?")[0], r = _e.extname(e).toLowerCase();
    return Array.isArray(t) ? t.includes(r) : r === t;
  }
  const Vm = ".json", Xm = "application/json", qm = {
    extension: {
      type: P.LoadParser,
      priority: ve.Low
    },
    name: "loadJson",
    test(i) {
      return ii(i, Xm) || Me(i, Vm);
    },
    async load(i) {
      return await (await St.get().fetch(i)).json();
    }
  }, $m = ".txt", Ym = "text/plain", Km = {
    name: "loadTxt",
    extension: {
      type: P.LoadParser,
      priority: ve.Low,
      name: "loadTxt"
    },
    test(i) {
      return ii(i, Ym) || Me(i, $m);
    },
    async load(i) {
      return await (await St.get().fetch(i)).text();
    }
  }, Jm = [
    "normal",
    "bold",
    "100",
    "200",
    "300",
    "400",
    "500",
    "600",
    "700",
    "800",
    "900"
  ], Zm = [
    ".ttf",
    ".otf",
    ".woff",
    ".woff2"
  ], Qm = [
    "font/ttf",
    "font/otf",
    "font/woff",
    "font/woff2"
  ], tb = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;
  function eb(i) {
    const t = _e.extname(i), s = _e.basename(i, t).replace(/(-|_)/g, " ").toLowerCase().split(" ").map((a) => a.charAt(0).toUpperCase() + a.slice(1));
    let n = s.length > 0;
    for (const a of s) if (!a.match(tb)) {
      n = false;
      break;
    }
    let o = s.join(" ");
    return n || (o = `"${o.replace(/[\\"]/g, "\\$&")}"`), o;
  }
  const rb = /^[0-9A-Za-z%:/?#\[\]@!\$&'()\*\+,;=\-._~]*$/;
  function ib(i) {
    return rb.test(i) ? i : encodeURI(i);
  }
  const sb = {
    extension: {
      type: P.LoadParser,
      priority: ve.Low
    },
    name: "loadWebFont",
    test(i) {
      return ii(i, Qm) || Me(i, Zm);
    },
    async load(i, t) {
      var _a2, _b2, _c2;
      const e = St.get().getFontFaceSet();
      if (e) {
        const r = [], s = ((_a2 = t.data) == null ? void 0 : _a2.family) ?? eb(i), n = ((_c2 = (_b2 = t.data) == null ? void 0 : _b2.weights) == null ? void 0 : _c2.filter((a) => Jm.includes(a))) ?? [
          "normal"
        ], o = t.data ?? {};
        for (let a = 0; a < n.length; a++) {
          const c = n[a], l = new FontFace(s, `url(${ib(i)})`, {
            ...o,
            weight: c
          });
          await l.load(), e.add(l), r.push(l);
        }
        return Ct.set(`${s}-and-url`, {
          url: i,
          fontFaces: r
        }), r.length === 1 ? r[0] : r;
      }
      return ut("[loadWebFont] FontFace API is not supported. Skipping loading font"), null;
    },
    unload(i) {
      (Array.isArray(i) ? i : [
        i
      ]).forEach((t) => {
        Ct.remove(t.family), St.get().getFontFaceSet().delete(t);
      });
    }
  };
  function fa(i, t = 1) {
    var _a2;
    const e = (_a2 = Ir.RETINA_PREFIX) == null ? void 0 : _a2.exec(i);
    return e ? parseFloat(e[1]) : t;
  }
  function Ur(i, t, e) {
    i.label = e, i._sourceOrigin = e;
    const r = new Z({
      source: i,
      label: e
    }), s = () => {
      delete t.promiseCache[e], Ct.has(e) && Ct.remove(e);
    };
    return r.source.once("destroy", () => {
      t.promiseCache[e] && (ut("[Assets] A TextureSource managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the TextureSource."), s());
    }), r.once("destroy", () => {
      i.destroyed || (ut("[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture."), s());
    }), r;
  }
  const nb = ".svg", ob = "image/svg+xml", ab = {
    extension: {
      type: P.LoadParser,
      priority: ve.Low,
      name: "loadSVG"
    },
    name: "loadSVG",
    config: {
      crossOrigin: "anonymous",
      parseAsGraphicsContext: false
    },
    test(i) {
      return ii(i, ob) || Me(i, nb);
    },
    async load(i, t, e) {
      return t.data.parseAsGraphicsContext ?? this.config.parseAsGraphicsContext ? ub(i) : cb(i, t, e, this.config.crossOrigin);
    },
    unload(i) {
      i.destroy(true);
    }
  };
  async function cb(i, t, e, r) {
    var _a2, _b2, _c2;
    const n = await (await St.get().fetch(i)).blob(), o = URL.createObjectURL(n), a = new Image();
    a.src = o, a.crossOrigin = r, await a.decode(), URL.revokeObjectURL(o);
    const c = document.createElement("canvas"), l = c.getContext("2d"), u = ((_a2 = t.data) == null ? void 0 : _a2.resolution) || fa(i), h = ((_b2 = t.data) == null ? void 0 : _b2.width) ?? a.width, d = ((_c2 = t.data) == null ? void 0 : _c2.height) ?? a.height;
    c.width = h * u, c.height = d * u, l.drawImage(a, 0, 0, h * u, d * u);
    const { parseAsGraphicsContext: p, ...g } = t.data, y = new ei({
      resource: c,
      alphaMode: "premultiply-alpha-on-upload",
      resolution: u,
      ...g
    });
    return Ur(y, e, i);
  }
  async function ub(i) {
    const e = await (await St.get().fetch(i)).text(), r = new oe();
    return r.svg(e), r;
  }
  const lb = `(function () {
    'use strict';

    const WHITE_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";
    async function checkImageBitmap() {
      try {
        if (typeof createImageBitmap !== "function")
          return false;
        const response = await fetch(WHITE_PNG);
        const imageBlob = await response.blob();
        const imageBitmap = await createImageBitmap(imageBlob);
        return imageBitmap.width === 1 && imageBitmap.height === 1;
      } catch (e) {
        return false;
      }
    }
    void checkImageBitmap().then((result) => {
      self.postMessage(result);
    });

})();
`;
  let Vr = null, Go = class {
    constructor() {
      Vr || (Vr = URL.createObjectURL(new Blob([
        lb
      ], {
        type: "application/javascript"
      }))), this.worker = new Worker(Vr);
    }
  };
  Go.revokeObjectURL = function() {
    Vr && (URL.revokeObjectURL(Vr), Vr = null);
  };
  const hb = `(function () {
    'use strict';

    async function loadImageBitmap(url) {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(\`[WorkerManager.loadImageBitmap] Failed to fetch \${url}: \${response.status} \${response.statusText}\`);
      }
      const imageBlob = await response.blob();
      const imageBitmap = await createImageBitmap(imageBlob);
      return imageBitmap;
    }
    self.onmessage = async (event) => {
      try {
        const imageBitmap = await loadImageBitmap(event.data.data[0]);
        self.postMessage({
          data: imageBitmap,
          uuid: event.data.uuid,
          id: event.data.id
        }, [imageBitmap]);
      } catch (e) {
        self.postMessage({
          error: e,
          uuid: event.data.uuid,
          id: event.data.id
        });
      }
    };

})();
`;
  let Xr = null, zh = class {
    constructor() {
      Xr || (Xr = URL.createObjectURL(new Blob([
        hb
      ], {
        type: "application/javascript"
      }))), this.worker = new Worker(Xr);
    }
  };
  zh.revokeObjectURL = function() {
    Xr && (URL.revokeObjectURL(Xr), Xr = null);
  };
  let ru = 0, ro;
  class db {
    constructor() {
      this._initialized = false, this._createdWorkers = 0, this._workerPool = [], this._queue = [], this._resolveHash = {};
    }
    isImageBitmapSupported() {
      return this._isImageBitmapSupported !== void 0 ? this._isImageBitmapSupported : (this._isImageBitmapSupported = new Promise((t) => {
        const { worker: e } = new Go();
        e.addEventListener("message", (r) => {
          e.terminate(), Go.revokeObjectURL(), t(r.data);
        });
      }), this._isImageBitmapSupported);
    }
    loadImageBitmap(t) {
      return this._run("loadImageBitmap", [
        t
      ]);
    }
    async _initWorkers() {
      this._initialized || (this._initialized = true);
    }
    _getWorker() {
      ro === void 0 && (ro = navigator.hardwareConcurrency || 4);
      let t = this._workerPool.pop();
      return !t && this._createdWorkers < ro && (this._createdWorkers++, t = new zh().worker, t.addEventListener("message", (e) => {
        this._complete(e.data), this._returnWorker(e.target), this._next();
      })), t;
    }
    _returnWorker(t) {
      this._workerPool.push(t);
    }
    _complete(t) {
      t.error !== void 0 ? this._resolveHash[t.uuid].reject(t.error) : this._resolveHash[t.uuid].resolve(t.data), this._resolveHash[t.uuid] = null;
    }
    async _run(t, e) {
      await this._initWorkers();
      const r = new Promise((s, n) => {
        this._queue.push({
          id: t,
          arguments: e,
          resolve: s,
          reject: n
        });
      });
      return this._next(), r;
    }
    _next() {
      if (!this._queue.length) return;
      const t = this._getWorker();
      if (!t) return;
      const e = this._queue.pop(), r = e.id;
      this._resolveHash[ru] = {
        resolve: e.resolve,
        reject: e.reject
      }, t.postMessage({
        data: e.arguments,
        uuid: ru++,
        id: r
      });
    }
  }
  const iu = new db(), fb = [
    ".jpeg",
    ".jpg",
    ".png",
    ".webp",
    ".avif"
  ], pb = [
    "image/jpeg",
    "image/png",
    "image/webp",
    "image/avif"
  ];
  async function _b(i) {
    const t = await St.get().fetch(i);
    if (!t.ok) throw new Error(`[loadImageBitmap] Failed to fetch ${i}: ${t.status} ${t.statusText}`);
    const e = await t.blob();
    return await createImageBitmap(e);
  }
  const jh = {
    name: "loadTextures",
    extension: {
      type: P.LoadParser,
      priority: ve.High,
      name: "loadTextures"
    },
    config: {
      preferWorkers: true,
      preferCreateImageBitmap: true,
      crossOrigin: "anonymous"
    },
    test(i) {
      return ii(i, pb) || Me(i, fb);
    },
    async load(i, t, e) {
      var _a2;
      let r = null;
      globalThis.createImageBitmap && this.config.preferCreateImageBitmap ? this.config.preferWorkers && await iu.isImageBitmapSupported() ? r = await iu.loadImageBitmap(i) : r = await _b(i) : r = await new Promise((n) => {
        r = new Image(), r.crossOrigin = this.config.crossOrigin, r.src = i, r.complete ? n(r) : r.onload = () => {
          n(r);
        };
      });
      const s = new ei({
        resource: r,
        alphaMode: "premultiply-alpha-on-upload",
        resolution: ((_a2 = t.data) == null ? void 0 : _a2.resolution) || fa(i),
        ...t.data
      });
      return Ur(s, e, i);
    },
    unload(i) {
      i.destroy(true);
    }
  }, Wh = [
    ".mp4",
    ".m4v",
    ".webm",
    ".ogg",
    ".ogv",
    ".h264",
    ".avi",
    ".mov"
  ], gb = Wh.map((i) => `video/${i.substring(1)}`);
  function mb(i, t, e) {
    e === void 0 && !t.startsWith("data:") ? i.crossOrigin = wb(t) : e !== false && (i.crossOrigin = typeof e == "string" ? e : "anonymous");
  }
  function bb(i) {
    return new Promise((t, e) => {
      i.addEventListener("canplaythrough", r), i.addEventListener("error", s), i.load();
      function r() {
        n(), t();
      }
      function s(o) {
        n(), e(o);
      }
      function n() {
        i.removeEventListener("canplaythrough", r), i.removeEventListener("error", s);
      }
    });
  }
  function wb(i, t = globalThis.location) {
    if (i.startsWith("data:")) return "";
    t = t || globalThis.location;
    const e = new URL(i, document.baseURI);
    return e.hostname !== t.hostname || e.port !== t.port || e.protocol !== t.protocol ? "anonymous" : "";
  }
  const yb = {
    name: "loadVideo",
    extension: {
      type: P.LoadParser,
      name: "loadVideo"
    },
    test(i) {
      const t = ii(i, gb), e = Me(i, Wh);
      return t || e;
    },
    async load(i, t, e) {
      var _a2, _b2;
      const r = {
        ...vs.defaultOptions,
        resolution: ((_a2 = t.data) == null ? void 0 : _a2.resolution) || fa(i),
        alphaMode: ((_b2 = t.data) == null ? void 0 : _b2.alphaMode) || await Zl(),
        ...t.data
      }, s = document.createElement("video"), n = {
        preload: r.autoLoad !== false ? "auto" : void 0,
        "webkit-playsinline": r.playsinline !== false ? "" : void 0,
        playsinline: r.playsinline !== false ? "" : void 0,
        muted: r.muted === true ? "" : void 0,
        loop: r.loop === true ? "" : void 0,
        autoplay: r.autoPlay !== false ? "" : void 0
      };
      Object.keys(n).forEach((c) => {
        const l = n[c];
        l !== void 0 && s.setAttribute(c, l);
      }), r.muted === true && (s.muted = true), mb(s, i, r.crossorigin);
      const o = document.createElement("source");
      let a;
      if (i.startsWith("data:")) a = i.slice(5, i.indexOf(";"));
      else if (!i.startsWith("blob:")) {
        const c = i.split("?")[0].slice(i.lastIndexOf(".") + 1).toLowerCase();
        a = vs.MIME_TYPES[c] || `video/${c}`;
      }
      return o.src = i, a && (o.type = a), new Promise((c) => {
        const l = async () => {
          const u = new vs({
            ...r,
            resource: s
          });
          s.removeEventListener("canplay", l), t.data.preload && await bb(s), c(Ur(u, e, i));
        };
        s.addEventListener("canplay", l), s.appendChild(o);
      });
    },
    unload(i) {
      i.destroy(true);
    }
  }, Vh = {
    extension: {
      type: P.ResolveParser,
      name: "resolveTexture"
    },
    test: jh.test,
    parse: (i) => {
      var _a2;
      return {
        resolution: parseFloat(((_a2 = Ir.RETINA_PREFIX.exec(i)) == null ? void 0 : _a2[1]) ?? "1"),
        format: i.split(".").pop(),
        src: i
      };
    }
  }, xb = {
    extension: {
      type: P.ResolveParser,
      priority: -2,
      name: "resolveJson"
    },
    test: (i) => Ir.RETINA_PREFIX.test(i) && i.endsWith(".json"),
    parse: Vh.parse
  };
  class vb {
    constructor() {
      this._detections = [], this._initialized = false, this.resolver = new Ir(), this.loader = new Wm(), this.cache = Ct, this._backgroundLoader = new Um(this.loader), this._backgroundLoader.active = true, this.reset();
    }
    async init(t = {}) {
      var _a2, _b2;
      if (this._initialized) {
        ut("[Assets]AssetManager already initialized, did you load before calling this Assets.init()?");
        return;
      }
      if (this._initialized = true, t.defaultSearchParams && this.resolver.setDefaultSearchParams(t.defaultSearchParams), t.basePath && (this.resolver.basePath = t.basePath), t.bundleIdentifier && this.resolver.setBundleIdentifier(t.bundleIdentifier), t.manifest) {
        let n = t.manifest;
        typeof n == "string" && (n = await this.load(n)), this.resolver.addManifest(n);
      }
      const e = ((_a2 = t.texturePreference) == null ? void 0 : _a2.resolution) ?? 1, r = typeof e == "number" ? [
        e
      ] : e, s = await this._detectFormats({
        preferredFormats: (_b2 = t.texturePreference) == null ? void 0 : _b2.format,
        skipDetections: t.skipDetections,
        detections: this._detections
      });
      this.resolver.prefer({
        params: {
          format: s,
          resolution: r
        }
      }), t.preferences && this.setPreferences(t.preferences);
    }
    add(t) {
      this.resolver.add(t);
    }
    async load(t, e) {
      this._initialized || await this.init();
      const r = Ms(t), s = Re(t).map((a) => {
        if (typeof a != "string") {
          const c = this.resolver.getAlias(a);
          return c.some((l) => !this.resolver.hasKey(l)) && this.add(a), Array.isArray(c) ? c[0] : c;
        }
        return this.resolver.hasKey(a) || this.add({
          alias: a,
          src: a
        }), a;
      }), n = this.resolver.resolve(s), o = await this._mapLoadToResolve(n, e);
      return r ? o[s[0]] : o;
    }
    addBundle(t, e) {
      this.resolver.addBundle(t, e);
    }
    async loadBundle(t, e) {
      this._initialized || await this.init();
      let r = false;
      typeof t == "string" && (r = true, t = [
        t
      ]);
      const s = this.resolver.resolveBundle(t), n = {}, o = Object.keys(s);
      let a = 0, c = 0;
      const l = () => {
        e == null ? void 0 : e(++a / c);
      }, u = o.map((h) => {
        const d = s[h];
        return c += Object.keys(d).length, this._mapLoadToResolve(d, l).then((p) => {
          n[h] = p;
        });
      });
      return await Promise.all(u), r ? n[t[0]] : n;
    }
    async backgroundLoad(t) {
      this._initialized || await this.init(), typeof t == "string" && (t = [
        t
      ]);
      const e = this.resolver.resolve(t);
      this._backgroundLoader.add(Object.values(e));
    }
    async backgroundLoadBundle(t) {
      this._initialized || await this.init(), typeof t == "string" && (t = [
        t
      ]);
      const e = this.resolver.resolveBundle(t);
      Object.values(e).forEach((r) => {
        this._backgroundLoader.add(Object.values(r));
      });
    }
    reset() {
      this.resolver.reset(), this.loader.reset(), this.cache.reset(), this._initialized = false;
    }
    get(t) {
      if (typeof t == "string") return Ct.get(t);
      const e = {};
      for (let r = 0; r < t.length; r++) e[r] = Ct.get(t[r]);
      return e;
    }
    async _mapLoadToResolve(t, e) {
      const r = [
        ...new Set(Object.values(t))
      ];
      this._backgroundLoader.active = false;
      const s = await this.loader.load(r, e);
      this._backgroundLoader.active = true;
      const n = {};
      return r.forEach((o) => {
        const a = s[o.src], c = [
          o.src
        ];
        o.alias && c.push(...o.alias), c.forEach((l) => {
          n[l] = a;
        }), Ct.set(c, a);
      }), n;
    }
    async unload(t) {
      this._initialized || await this.init();
      const e = Re(t).map((s) => typeof s != "string" ? s.src : s), r = this.resolver.resolve(e);
      await this._unloadFromResolved(r);
    }
    async unloadBundle(t) {
      this._initialized || await this.init(), t = Re(t);
      const e = this.resolver.resolveBundle(t), r = Object.keys(e).map((s) => this._unloadFromResolved(e[s]));
      await Promise.all(r);
    }
    async _unloadFromResolved(t) {
      const e = Object.values(t);
      e.forEach((r) => {
        Ct.remove(r.src);
      }), await this.loader.unload(e);
    }
    async _detectFormats(t) {
      let e = [];
      t.preferredFormats && (e = Array.isArray(t.preferredFormats) ? t.preferredFormats : [
        t.preferredFormats
      ]);
      for (const r of t.detections) t.skipDetections || await r.test() ? e = await r.add(e) : t.skipDetections || (e = await r.remove(e));
      return e = e.filter((r, s) => e.indexOf(r) === s), e;
    }
    get detections() {
      return this._detections;
    }
    setPreferences(t) {
      this.loader.parsers.forEach((e) => {
        e.config && Object.keys(e.config).filter((r) => r in t).forEach((r) => {
          e.config[r] = t[r];
        });
      });
    }
  }
  const ss = new vb();
  Mt.handleByList(P.LoadParser, ss.loader.parsers).handleByList(P.ResolveParser, ss.resolver.parsers).handleByList(P.CacheParser, ss.cache.parsers).handleByList(P.DetectionParser, ss.detections);
  Mt.add(km, Om, Gm, jm, Lm, Hm, zm, qm, Km, sb, ab, jh, yb, Fm, Im, Vh, xb);
  const su = {
    loader: P.LoadParser,
    resolver: P.ResolveParser,
    cache: P.CacheParser,
    detection: P.DetectionParser
  };
  Mt.handle(P.Asset, (i) => {
    const t = i.ref;
    Object.entries(su).filter(([e]) => !!t[e]).forEach(([e, r]) => Mt.add(Object.assign(t[e], {
      extension: t[e].extension ?? r
    })));
  }, (i) => {
    const t = i.ref;
    Object.keys(su).filter((e) => !!t[e]).forEach((e) => Mt.remove(t[e]));
  });
  const sR = {
    extension: {
      type: P.DetectionParser,
      priority: 3
    },
    test: async () => !!(await Js() || Ks()),
    add: async (i) => [
      ...i,
      "basis"
    ],
    remove: async (i) => i.filter((t) => t !== "basis")
  };
  class tn extends Ht {
    constructor(t) {
      super(t), this.uploadMethodId = "compressed", this.resource = t.resource, this.mipLevelCount = this.resource.length;
    }
  }
  let ns;
  function nu() {
    if (ns) return ns;
    const t = document.createElement("canvas").getContext("webgl");
    return t ? (ns = [
      ...t.getExtension("EXT_texture_compression_bptc") ? [
        "bc6h-rgb-ufloat",
        "bc6h-rgb-float",
        "bc7-rgba-unorm",
        "bc7-rgba-unorm-srgb"
      ] : [],
      ...t.getExtension("WEBGL_compressed_texture_s3tc") ? [
        "bc1-rgba-unorm",
        "bc2-rgba-unorm",
        "bc3-rgba-unorm"
      ] : [],
      ...t.getExtension("WEBGL_compressed_texture_s3tc_srgb") ? [
        "bc1-rgba-unorm-srgb",
        "bc2-rgba-unorm-srgb",
        "bc3-rgba-unorm-srgb"
      ] : [],
      ...t.getExtension("EXT_texture_compression_rgtc") ? [
        "bc4-r-unorm",
        "bc4-r-snorm",
        "bc5-rg-unorm",
        "bc5-rg-snorm"
      ] : [],
      ...t.getExtension("WEBGL_compressed_texture_etc") ? [
        "etc2-rgb8unorm",
        "etc2-rgb8unorm-srgb",
        "etc2-rgba8unorm",
        "etc2-rgba8unorm-srgb",
        "etc2-rgb8a1unorm",
        "etc2-rgb8a1unorm-srgb",
        "eac-r11unorm",
        "eac-rg11unorm"
      ] : [],
      ...t.getExtension("WEBGL_compressed_texture_astc") ? [
        "astc-4x4-unorm",
        "astc-4x4-unorm-srgb",
        "astc-5x4-unorm",
        "astc-5x4-unorm-srgb",
        "astc-5x5-unorm",
        "astc-5x5-unorm-srgb",
        "astc-6x5-unorm",
        "astc-6x5-unorm-srgb",
        "astc-6x6-unorm",
        "astc-6x6-unorm-srgb",
        "astc-8x5-unorm",
        "astc-8x5-unorm-srgb",
        "astc-8x6-unorm",
        "astc-8x6-unorm-srgb",
        "astc-8x8-unorm",
        "astc-8x8-unorm-srgb",
        "astc-10x5-unorm",
        "astc-10x5-unorm-srgb",
        "astc-10x6-unorm",
        "astc-10x6-unorm-srgb",
        "astc-10x8-unorm",
        "astc-10x8-unorm-srgb",
        "astc-10x10-unorm",
        "astc-10x10-unorm-srgb",
        "astc-12x10-unorm",
        "astc-12x10-unorm-srgb",
        "astc-12x12-unorm",
        "astc-12x12-unorm-srgb"
      ] : []
    ], ns) : [];
  }
  let os;
  async function ou() {
    if (os) return os;
    const i = await navigator.gpu.requestAdapter();
    return os = [
      ...i.features.has("texture-compression-bc") ? [
        "bc1-rgba-unorm",
        "bc1-rgba-unorm-srgb",
        "bc2-rgba-unorm",
        "bc2-rgba-unorm-srgb",
        "bc3-rgba-unorm",
        "bc3-rgba-unorm-srgb",
        "bc4-r-unorm",
        "bc4-r-snorm",
        "bc5-rg-unorm",
        "bc5-rg-snorm",
        "bc6h-rgb-ufloat",
        "bc6h-rgb-float",
        "bc7-rgba-unorm",
        "bc7-rgba-unorm-srgb"
      ] : [],
      ...i.features.has("texture-compression-etc2") ? [
        "etc2-rgb8unorm",
        "etc2-rgb8unorm-srgb",
        "etc2-rgb8a1unorm",
        "etc2-rgb8a1unorm-srgb",
        "etc2-rgba8unorm",
        "etc2-rgba8unorm-srgb",
        "eac-r11unorm",
        "eac-r11snorm",
        "eac-rg11unorm",
        "eac-rg11snorm"
      ] : [],
      ...i.features.has("texture-compression-astc") ? [
        "astc-4x4-unorm",
        "astc-4x4-unorm-srgb",
        "astc-5x4-unorm",
        "astc-5x4-unorm-srgb",
        "astc-5x5-unorm",
        "astc-5x5-unorm-srgb",
        "astc-6x5-unorm",
        "astc-6x5-unorm-srgb",
        "astc-6x6-unorm",
        "astc-6x6-unorm-srgb",
        "astc-8x5-unorm",
        "astc-8x5-unorm-srgb",
        "astc-8x6-unorm",
        "astc-8x6-unorm-srgb",
        "astc-8x8-unorm",
        "astc-8x8-unorm-srgb",
        "astc-10x5-unorm",
        "astc-10x5-unorm-srgb",
        "astc-10x6-unorm",
        "astc-10x6-unorm-srgb",
        "astc-10x8-unorm",
        "astc-10x8-unorm-srgb",
        "astc-10x10-unorm",
        "astc-10x10-unorm-srgb",
        "astc-12x10-unorm",
        "astc-12x10-unorm-srgb",
        "astc-12x12-unorm",
        "astc-12x12-unorm-srgb"
      ] : []
    ], os;
  }
  let as;
  async function Xh() {
    return as !== void 0 || (as = await (async () => {
      const i = await Js(), t = Ks();
      if (i && t) {
        const e = await ou(), r = nu();
        return e.filter((s) => r.includes(s));
      } else {
        if (i) return await ou();
        if (t) return nu();
      }
      return [];
    })()), as;
  }
  const Sb = [
    "r8unorm",
    "r8snorm",
    "r8uint",
    "r8sint",
    "r16uint",
    "r16sint",
    "r16float",
    "rg8unorm",
    "rg8snorm",
    "rg8uint",
    "rg8sint",
    "r32uint",
    "r32sint",
    "r32float",
    "rg16uint",
    "rg16sint",
    "rg16float",
    "rgba8unorm",
    "rgba8unorm-srgb",
    "rgba8snorm",
    "rgba8uint",
    "rgba8sint",
    "bgra8unorm",
    "bgra8unorm-srgb",
    "rgb9e5ufloat",
    "rgb10a2unorm",
    "rg11b10ufloat",
    "rg32uint",
    "rg32sint",
    "rg32float",
    "rgba16uint",
    "rgba16sint",
    "rgba16float",
    "rgba32uint",
    "rgba32sint",
    "rgba32float",
    "stencil8",
    "depth16unorm",
    "depth24plus",
    "depth24plus-stencil8",
    "depth32float",
    "depth32float-stencil8"
  ];
  let cs;
  async function en() {
    if (cs !== void 0) return cs;
    const i = await Xh();
    return cs = [
      ...Sb,
      ...i
    ], cs;
  }
  const Eb = `(function () {
    'use strict';

    function createLevelBuffers(basisTexture, basisTranscoderFormat) {
      const images = basisTexture.getNumImages();
      const levels = basisTexture.getNumLevels(0);
      const success = basisTexture.startTranscoding();
      if (!success) {
        throw new Error("startTranscoding failed");
      }
      const levelBuffers = [];
      for (let levelIndex = 0; levelIndex < levels; ++levelIndex) {
        for (let sliceIndex = 0; sliceIndex < images; ++sliceIndex) {
          const transcodeSize = basisTexture.getImageTranscodedSizeInBytes(sliceIndex, levelIndex, basisTranscoderFormat);
          const levelBuffer = new Uint8Array(transcodeSize);
          const success2 = basisTexture.transcodeImage(levelBuffer, sliceIndex, levelIndex, basisTranscoderFormat, 1, 0);
          if (!success2) {
            throw new Error("transcodeImage failed");
          }
          levelBuffers.push(levelBuffer);
        }
      }
      return levelBuffers;
    }

    const gpuFormatToBasisTranscoderFormatMap = {
      "bc3-rgba-unorm": 3,
      // cTFBC3_RGBA
      "bc7-rgba-unorm": 6,
      // cTFBC7_RGBA,
      "etc2-rgba8unorm": 1,
      // cTFETC2_RGBA,
      "astc-4x4-unorm": 10,
      // cTFASTC_4x4_RGBA,
      // Uncompressed
      rgba8unorm: 13,
      // cTFRGBA32,
      rgba4unorm: 16
      // cTFRGBA4444,
    };
    function gpuFormatToBasisTranscoderFormat(transcoderFormat) {
      const format = gpuFormatToBasisTranscoderFormatMap[transcoderFormat];
      if (format) {
        return format;
      }
      throw new Error(\`Unsupported transcoderFormat: \${transcoderFormat}\`);
    }

    const settings = {
      jsUrl: "basis/basis_transcoder.js",
      wasmUrl: "basis/basis_transcoder.wasm"
    };
    let basisTranscoderFormat;
    let basisTranscodedTextureFormat;
    let basisPromise;
    async function getBasis() {
      if (!basisPromise) {
        const absoluteJsUrl = new URL(settings.jsUrl, location.origin).href;
        const absoluteWasmUrl = new URL(settings.wasmUrl, location.origin).href;
        importScripts(absoluteJsUrl);
        basisPromise = new Promise((resolve) => {
          BASIS({
            locateFile: (_file) => absoluteWasmUrl
          }).then((module) => {
            module.initializeBasis();
            resolve(module.BasisFile);
          });
        });
      }
      return basisPromise;
    }
    async function fetchBasisTexture(url, BasisTexture) {
      const basisResponse = await fetch(url);
      if (basisResponse.ok) {
        const basisArrayBuffer = await basisResponse.arrayBuffer();
        return new BasisTexture(new Uint8Array(basisArrayBuffer));
      }
      throw new Error(\`Failed to load Basis texture: \${url}\`);
    }
    const preferredTranscodedFormat = [
      "bc7-rgba-unorm",
      "astc-4x4-unorm",
      "etc2-rgba8unorm",
      "bc3-rgba-unorm",
      "rgba8unorm"
    ];
    async function load(url) {
      const BasisTexture = await getBasis();
      const basisTexture = await fetchBasisTexture(url, BasisTexture);
      const levelBuffers = createLevelBuffers(basisTexture, basisTranscoderFormat);
      return {
        width: basisTexture.getImageWidth(0, 0),
        height: basisTexture.getImageHeight(0, 0),
        format: basisTranscodedTextureFormat,
        resource: levelBuffers,
        alphaMode: "no-premultiply-alpha"
      };
    }
    async function init(jsUrl, wasmUrl, supportedTextures) {
      if (jsUrl)
        settings.jsUrl = jsUrl;
      if (wasmUrl)
        settings.wasmUrl = wasmUrl;
      basisTranscodedTextureFormat = preferredTranscodedFormat.filter((format) => supportedTextures.includes(format))[0];
      basisTranscoderFormat = gpuFormatToBasisTranscoderFormat(basisTranscodedTextureFormat);
      await getBasis();
    }
    const messageHandlers = {
      init: async (data) => {
        const { jsUrl, wasmUrl, supportedTextures } = data;
        await init(jsUrl, wasmUrl, supportedTextures);
      },
      load: async (data) => {
        try {
          const textureOptions = await load(data.url);
          return {
            type: "load",
            url: data.url,
            success: true,
            textureOptions,
            transferables: textureOptions.resource?.map((arr) => arr.buffer)
          };
        } catch (e) {
          throw e;
        }
      }
    };
    self.onmessage = async (messageEvent) => {
      const message = messageEvent.data;
      const response = await messageHandlers[message.type](message);
      if (response) {
        self.postMessage(response, response.transferables);
      }
    };

})();
`;
  let qr = null, qh = class {
    constructor() {
      qr || (qr = URL.createObjectURL(new Blob([
        Eb
      ], {
        type: "application/javascript"
      }))), this.worker = new Worker(qr);
    }
  };
  qh.revokeObjectURL = function() {
    qr && (URL.revokeObjectURL(qr), qr = null);
  };
  const au = {
    jsUrl: "https://files.pixijs.download/transcoders/basis/basis_transcoder.js",
    wasmUrl: "https://files.pixijs.download/transcoders/basis/basis_transcoder.wasm"
  };
  let li;
  const $h = {};
  function Tb(i) {
    return li || (li = new qh().worker, li.onmessage = (t) => {
      const { success: e, url: r, textureOptions: s } = t.data;
      e || console.warn("Failed to load Basis texture", r), $h[r](s);
    }, li.postMessage({
      type: "init",
      jsUrl: au.jsUrl,
      wasmUrl: au.wasmUrl,
      supportedTextures: i
    })), li;
  }
  function Cb(i, t) {
    const e = Tb(t);
    return new Promise((r) => {
      $h[i] = r, e.postMessage({
        type: "load",
        url: i
      });
    });
  }
  const oR = {
    extension: {
      type: P.LoadParser,
      priority: ve.High,
      name: "loadBasis"
    },
    name: "loadBasis",
    test(i) {
      return Me(i, [
        ".basis"
      ]);
    },
    async load(i, t, e) {
      const r = await en(), s = await Cb(i, r), n = new tn(s);
      return Ur(n, e, i);
    },
    unload(i) {
      Array.isArray(i) ? i.forEach((t) => t.destroy(true)) : i.destroy(true);
    }
  };
  const Ab = {
    MAGIC: 0,
    SIZE: 1,
    FLAGS: 2,
    HEIGHT: 3,
    WIDTH: 4,
    MIPMAP_COUNT: 7,
    PIXEL_FORMAT: 19,
    PF_FLAGS: 20,
    FOURCC: 21,
    RGB_BITCOUNT: 22,
    R_BIT_MASK: 23,
    G_BIT_MASK: 24,
    B_BIT_MASK: 25,
    A_BIT_MASK: 26
  }, Rb = {
    DXGI_FORMAT: 0,
    RESOURCE_DIMENSION: 1,
    MISC_FLAG: 2,
    ARRAY_SIZE: 3,
    MISC_FLAGS2: 4
  };
  var Yh = ((i) => (i[i.DXGI_FORMAT_UNKNOWN = 0] = "DXGI_FORMAT_UNKNOWN", i[i.DXGI_FORMAT_R32G32B32A32_TYPELESS = 1] = "DXGI_FORMAT_R32G32B32A32_TYPELESS", i[i.DXGI_FORMAT_R32G32B32A32_FLOAT = 2] = "DXGI_FORMAT_R32G32B32A32_FLOAT", i[i.DXGI_FORMAT_R32G32B32A32_UINT = 3] = "DXGI_FORMAT_R32G32B32A32_UINT", i[i.DXGI_FORMAT_R32G32B32A32_SINT = 4] = "DXGI_FORMAT_R32G32B32A32_SINT", i[i.DXGI_FORMAT_R32G32B32_TYPELESS = 5] = "DXGI_FORMAT_R32G32B32_TYPELESS", i[i.DXGI_FORMAT_R32G32B32_FLOAT = 6] = "DXGI_FORMAT_R32G32B32_FLOAT", i[i.DXGI_FORMAT_R32G32B32_UINT = 7] = "DXGI_FORMAT_R32G32B32_UINT", i[i.DXGI_FORMAT_R32G32B32_SINT = 8] = "DXGI_FORMAT_R32G32B32_SINT", i[i.DXGI_FORMAT_R16G16B16A16_TYPELESS = 9] = "DXGI_FORMAT_R16G16B16A16_TYPELESS", i[i.DXGI_FORMAT_R16G16B16A16_FLOAT = 10] = "DXGI_FORMAT_R16G16B16A16_FLOAT", i[i.DXGI_FORMAT_R16G16B16A16_UNORM = 11] = "DXGI_FORMAT_R16G16B16A16_UNORM", i[i.DXGI_FORMAT_R16G16B16A16_UINT = 12] = "DXGI_FORMAT_R16G16B16A16_UINT", i[i.DXGI_FORMAT_R16G16B16A16_SNORM = 13] = "DXGI_FORMAT_R16G16B16A16_SNORM", i[i.DXGI_FORMAT_R16G16B16A16_SINT = 14] = "DXGI_FORMAT_R16G16B16A16_SINT", i[i.DXGI_FORMAT_R32G32_TYPELESS = 15] = "DXGI_FORMAT_R32G32_TYPELESS", i[i.DXGI_FORMAT_R32G32_FLOAT = 16] = "DXGI_FORMAT_R32G32_FLOAT", i[i.DXGI_FORMAT_R32G32_UINT = 17] = "DXGI_FORMAT_R32G32_UINT", i[i.DXGI_FORMAT_R32G32_SINT = 18] = "DXGI_FORMAT_R32G32_SINT", i[i.DXGI_FORMAT_R32G8X24_TYPELESS = 19] = "DXGI_FORMAT_R32G8X24_TYPELESS", i[i.DXGI_FORMAT_D32_FLOAT_S8X24_UINT = 20] = "DXGI_FORMAT_D32_FLOAT_S8X24_UINT", i[i.DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS = 21] = "DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS", i[i.DXGI_FORMAT_X32_TYPELESS_G8X24_UINT = 22] = "DXGI_FORMAT_X32_TYPELESS_G8X24_UINT", i[i.DXGI_FORMAT_R10G10B10A2_TYPELESS = 23] = "DXGI_FORMAT_R10G10B10A2_TYPELESS", i[i.DXGI_FORMAT_R10G10B10A2_UNORM = 24] = "DXGI_FORMAT_R10G10B10A2_UNORM", i[i.DXGI_FORMAT_R10G10B10A2_UINT = 25] = "DXGI_FORMAT_R10G10B10A2_UINT", i[i.DXGI_FORMAT_R11G11B10_FLOAT = 26] = "DXGI_FORMAT_R11G11B10_FLOAT", i[i.DXGI_FORMAT_R8G8B8A8_TYPELESS = 27] = "DXGI_FORMAT_R8G8B8A8_TYPELESS", i[i.DXGI_FORMAT_R8G8B8A8_UNORM = 28] = "DXGI_FORMAT_R8G8B8A8_UNORM", i[i.DXGI_FORMAT_R8G8B8A8_UNORM_SRGB = 29] = "DXGI_FORMAT_R8G8B8A8_UNORM_SRGB", i[i.DXGI_FORMAT_R8G8B8A8_UINT = 30] = "DXGI_FORMAT_R8G8B8A8_UINT", i[i.DXGI_FORMAT_R8G8B8A8_SNORM = 31] = "DXGI_FORMAT_R8G8B8A8_SNORM", i[i.DXGI_FORMAT_R8G8B8A8_SINT = 32] = "DXGI_FORMAT_R8G8B8A8_SINT", i[i.DXGI_FORMAT_R16G16_TYPELESS = 33] = "DXGI_FORMAT_R16G16_TYPELESS", i[i.DXGI_FORMAT_R16G16_FLOAT = 34] = "DXGI_FORMAT_R16G16_FLOAT", i[i.DXGI_FORMAT_R16G16_UNORM = 35] = "DXGI_FORMAT_R16G16_UNORM", i[i.DXGI_FORMAT_R16G16_UINT = 36] = "DXGI_FORMAT_R16G16_UINT", i[i.DXGI_FORMAT_R16G16_SNORM = 37] = "DXGI_FORMAT_R16G16_SNORM", i[i.DXGI_FORMAT_R16G16_SINT = 38] = "DXGI_FORMAT_R16G16_SINT", i[i.DXGI_FORMAT_R32_TYPELESS = 39] = "DXGI_FORMAT_R32_TYPELESS", i[i.DXGI_FORMAT_D32_FLOAT = 40] = "DXGI_FORMAT_D32_FLOAT", i[i.DXGI_FORMAT_R32_FLOAT = 41] = "DXGI_FORMAT_R32_FLOAT", i[i.DXGI_FORMAT_R32_UINT = 42] = "DXGI_FORMAT_R32_UINT", i[i.DXGI_FORMAT_R32_SINT = 43] = "DXGI_FORMAT_R32_SINT", i[i.DXGI_FORMAT_R24G8_TYPELESS = 44] = "DXGI_FORMAT_R24G8_TYPELESS", i[i.DXGI_FORMAT_D24_UNORM_S8_UINT = 45] = "DXGI_FORMAT_D24_UNORM_S8_UINT", i[i.DXGI_FORMAT_R24_UNORM_X8_TYPELESS = 46] = "DXGI_FORMAT_R24_UNORM_X8_TYPELESS", i[i.DXGI_FORMAT_X24_TYPELESS_G8_UINT = 47] = "DXGI_FORMAT_X24_TYPELESS_G8_UINT", i[i.DXGI_FORMAT_R8G8_TYPELESS = 48] = "DXGI_FORMAT_R8G8_TYPELESS", i[i.DXGI_FORMAT_R8G8_UNORM = 49] = "DXGI_FORMAT_R8G8_UNORM", i[i.DXGI_FORMAT_R8G8_UINT = 50] = "DXGI_FORMAT_R8G8_UINT", i[i.DXGI_FORMAT_R8G8_SNORM = 51] = "DXGI_FORMAT_R8G8_SNORM", i[i.DXGI_FORMAT_R8G8_SINT = 52] = "DXGI_FORMAT_R8G8_SINT", i[i.DXGI_FORMAT_R16_TYPELESS = 53] = "DXGI_FORMAT_R16_TYPELESS", i[i.DXGI_FORMAT_R16_FLOAT = 54] = "DXGI_FORMAT_R16_FLOAT", i[i.DXGI_FORMAT_D16_UNORM = 55] = "DXGI_FORMAT_D16_UNORM", i[i.DXGI_FORMAT_R16_UNORM = 56] = "DXGI_FORMAT_R16_UNORM", i[i.DXGI_FORMAT_R16_UINT = 57] = "DXGI_FORMAT_R16_UINT", i[i.DXGI_FORMAT_R16_SNORM = 58] = "DXGI_FORMAT_R16_SNORM", i[i.DXGI_FORMAT_R16_SINT = 59] = "DXGI_FORMAT_R16_SINT", i[i.DXGI_FORMAT_R8_TYPELESS = 60] = "DXGI_FORMAT_R8_TYPELESS", i[i.DXGI_FORMAT_R8_UNORM = 61] = "DXGI_FORMAT_R8_UNORM", i[i.DXGI_FORMAT_R8_UINT = 62] = "DXGI_FORMAT_R8_UINT", i[i.DXGI_FORMAT_R8_SNORM = 63] = "DXGI_FORMAT_R8_SNORM", i[i.DXGI_FORMAT_R8_SINT = 64] = "DXGI_FORMAT_R8_SINT", i[i.DXGI_FORMAT_A8_UNORM = 65] = "DXGI_FORMAT_A8_UNORM", i[i.DXGI_FORMAT_R1_UNORM = 66] = "DXGI_FORMAT_R1_UNORM", i[i.DXGI_FORMAT_R9G9B9E5_SHAREDEXP = 67] = "DXGI_FORMAT_R9G9B9E5_SHAREDEXP", i[i.DXGI_FORMAT_R8G8_B8G8_UNORM = 68] = "DXGI_FORMAT_R8G8_B8G8_UNORM", i[i.DXGI_FORMAT_G8R8_G8B8_UNORM = 69] = "DXGI_FORMAT_G8R8_G8B8_UNORM", i[i.DXGI_FORMAT_BC1_TYPELESS = 70] = "DXGI_FORMAT_BC1_TYPELESS", i[i.DXGI_FORMAT_BC1_UNORM = 71] = "DXGI_FORMAT_BC1_UNORM", i[i.DXGI_FORMAT_BC1_UNORM_SRGB = 72] = "DXGI_FORMAT_BC1_UNORM_SRGB", i[i.DXGI_FORMAT_BC2_TYPELESS = 73] = "DXGI_FORMAT_BC2_TYPELESS", i[i.DXGI_FORMAT_BC2_UNORM = 74] = "DXGI_FORMAT_BC2_UNORM", i[i.DXGI_FORMAT_BC2_UNORM_SRGB = 75] = "DXGI_FORMAT_BC2_UNORM_SRGB", i[i.DXGI_FORMAT_BC3_TYPELESS = 76] = "DXGI_FORMAT_BC3_TYPELESS", i[i.DXGI_FORMAT_BC3_UNORM = 77] = "DXGI_FORMAT_BC3_UNORM", i[i.DXGI_FORMAT_BC3_UNORM_SRGB = 78] = "DXGI_FORMAT_BC3_UNORM_SRGB", i[i.DXGI_FORMAT_BC4_TYPELESS = 79] = "DXGI_FORMAT_BC4_TYPELESS", i[i.DXGI_FORMAT_BC4_UNORM = 80] = "DXGI_FORMAT_BC4_UNORM", i[i.DXGI_FORMAT_BC4_SNORM = 81] = "DXGI_FORMAT_BC4_SNORM", i[i.DXGI_FORMAT_BC5_TYPELESS = 82] = "DXGI_FORMAT_BC5_TYPELESS", i[i.DXGI_FORMAT_BC5_UNORM = 83] = "DXGI_FORMAT_BC5_UNORM", i[i.DXGI_FORMAT_BC5_SNORM = 84] = "DXGI_FORMAT_BC5_SNORM", i[i.DXGI_FORMAT_B5G6R5_UNORM = 85] = "DXGI_FORMAT_B5G6R5_UNORM", i[i.DXGI_FORMAT_B5G5R5A1_UNORM = 86] = "DXGI_FORMAT_B5G5R5A1_UNORM", i[i.DXGI_FORMAT_B8G8R8A8_UNORM = 87] = "DXGI_FORMAT_B8G8R8A8_UNORM", i[i.DXGI_FORMAT_B8G8R8X8_UNORM = 88] = "DXGI_FORMAT_B8G8R8X8_UNORM", i[i.DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM = 89] = "DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM", i[i.DXGI_FORMAT_B8G8R8A8_TYPELESS = 90] = "DXGI_FORMAT_B8G8R8A8_TYPELESS", i[i.DXGI_FORMAT_B8G8R8A8_UNORM_SRGB = 91] = "DXGI_FORMAT_B8G8R8A8_UNORM_SRGB", i[i.DXGI_FORMAT_B8G8R8X8_TYPELESS = 92] = "DXGI_FORMAT_B8G8R8X8_TYPELESS", i[i.DXGI_FORMAT_B8G8R8X8_UNORM_SRGB = 93] = "DXGI_FORMAT_B8G8R8X8_UNORM_SRGB", i[i.DXGI_FORMAT_BC6H_TYPELESS = 94] = "DXGI_FORMAT_BC6H_TYPELESS", i[i.DXGI_FORMAT_BC6H_UF16 = 95] = "DXGI_FORMAT_BC6H_UF16", i[i.DXGI_FORMAT_BC6H_SF16 = 96] = "DXGI_FORMAT_BC6H_SF16", i[i.DXGI_FORMAT_BC7_TYPELESS = 97] = "DXGI_FORMAT_BC7_TYPELESS", i[i.DXGI_FORMAT_BC7_UNORM = 98] = "DXGI_FORMAT_BC7_UNORM", i[i.DXGI_FORMAT_BC7_UNORM_SRGB = 99] = "DXGI_FORMAT_BC7_UNORM_SRGB", i[i.DXGI_FORMAT_AYUV = 100] = "DXGI_FORMAT_AYUV", i[i.DXGI_FORMAT_Y410 = 101] = "DXGI_FORMAT_Y410", i[i.DXGI_FORMAT_Y416 = 102] = "DXGI_FORMAT_Y416", i[i.DXGI_FORMAT_NV12 = 103] = "DXGI_FORMAT_NV12", i[i.DXGI_FORMAT_P010 = 104] = "DXGI_FORMAT_P010", i[i.DXGI_FORMAT_P016 = 105] = "DXGI_FORMAT_P016", i[i.DXGI_FORMAT_420_OPAQUE = 106] = "DXGI_FORMAT_420_OPAQUE", i[i.DXGI_FORMAT_YUY2 = 107] = "DXGI_FORMAT_YUY2", i[i.DXGI_FORMAT_Y210 = 108] = "DXGI_FORMAT_Y210", i[i.DXGI_FORMAT_Y216 = 109] = "DXGI_FORMAT_Y216", i[i.DXGI_FORMAT_NV11 = 110] = "DXGI_FORMAT_NV11", i[i.DXGI_FORMAT_AI44 = 111] = "DXGI_FORMAT_AI44", i[i.DXGI_FORMAT_IA44 = 112] = "DXGI_FORMAT_IA44", i[i.DXGI_FORMAT_P8 = 113] = "DXGI_FORMAT_P8", i[i.DXGI_FORMAT_A8P8 = 114] = "DXGI_FORMAT_A8P8", i[i.DXGI_FORMAT_B4G4R4A4_UNORM = 115] = "DXGI_FORMAT_B4G4R4A4_UNORM", i[i.DXGI_FORMAT_P208 = 116] = "DXGI_FORMAT_P208", i[i.DXGI_FORMAT_V208 = 117] = "DXGI_FORMAT_V208", i[i.DXGI_FORMAT_V408 = 118] = "DXGI_FORMAT_V408", i[i.DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE = 119] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE", i[i.DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE = 120] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE", i[i.DXGI_FORMAT_FORCE_UINT = 121] = "DXGI_FORMAT_FORCE_UINT", i))(Yh || {}), Kh = ((i) => (i[i.DDS_DIMENSION_TEXTURE1D = 2] = "DDS_DIMENSION_TEXTURE1D", i[i.DDS_DIMENSION_TEXTURE2D = 3] = "DDS_DIMENSION_TEXTURE2D", i[i.DDS_DIMENSION_TEXTURE3D = 6] = "DDS_DIMENSION_TEXTURE3D", i))(Kh || {});
  function qt(i) {
    return i.charCodeAt(0) + (i.charCodeAt(1) << 8) + (i.charCodeAt(2) << 16) + (i.charCodeAt(3) << 24);
  }
  var he = ((i) => (i[i.UNKNOWN = 0] = "UNKNOWN", i[i.R8G8B8 = 20] = "R8G8B8", i[i.A8R8G8B8 = 21] = "A8R8G8B8", i[i.X8R8G8B8 = 22] = "X8R8G8B8", i[i.R5G6B5 = 23] = "R5G6B5", i[i.X1R5G5B5 = 24] = "X1R5G5B5", i[i.A1R5G5B5 = 25] = "A1R5G5B5", i[i.A4R4G4B4 = 26] = "A4R4G4B4", i[i.R3G3B2 = 27] = "R3G3B2", i[i.A8 = 28] = "A8", i[i.A8R3G3B2 = 29] = "A8R3G3B2", i[i.X4R4G4B4 = 30] = "X4R4G4B4", i[i.A2B10G10R10 = 31] = "A2B10G10R10", i[i.A8B8G8R8 = 32] = "A8B8G8R8", i[i.X8B8G8R8 = 33] = "X8B8G8R8", i[i.G16R16 = 34] = "G16R16", i[i.A2R10G10B10 = 35] = "A2R10G10B10", i[i.A16B16G16R16 = 36] = "A16B16G16R16", i[i.A8P8 = 40] = "A8P8", i[i.P8 = 41] = "P8", i[i.L8 = 50] = "L8", i[i.A8L8 = 51] = "A8L8", i[i.A4L4 = 52] = "A4L4", i[i.V8U8 = 60] = "V8U8", i[i.L6V5U5 = 61] = "L6V5U5", i[i.X8L8V8U8 = 62] = "X8L8V8U8", i[i.Q8W8V8U8 = 63] = "Q8W8V8U8", i[i.V16U16 = 64] = "V16U16", i[i.A2W10V10U10 = 67] = "A2W10V10U10", i[i.Q16W16V16U16 = 110] = "Q16W16V16U16", i[i.R16F = 111] = "R16F", i[i.G16R16F = 112] = "G16R16F", i[i.A16B16G16R16F = 113] = "A16B16G16R16F", i[i.R32F = 114] = "R32F", i[i.G32R32F = 115] = "G32R32F", i[i.A32B32G32R32F = 116] = "A32B32G32R32F", i[i.UYVY = qt("UYVY")] = "UYVY", i[i.R8G8_B8G8 = qt("RGBG")] = "R8G8_B8G8", i[i.YUY2 = qt("YUY2")] = "YUY2", i[i.D3DFMT_G8R8_G8B8 = qt("GRGB")] = "D3DFMT_G8R8_G8B8", i[i.DXT1 = qt("DXT1")] = "DXT1", i[i.DXT2 = qt("DXT2")] = "DXT2", i[i.DXT3 = qt("DXT3")] = "DXT3", i[i.DXT4 = qt("DXT4")] = "DXT4", i[i.DXT5 = qt("DXT5")] = "DXT5", i[i.ATI1 = qt("ATI1")] = "ATI1", i[i.AT1N = qt("AT1N")] = "AT1N", i[i.ATI2 = qt("ATI2")] = "ATI2", i[i.AT2N = qt("AT2N")] = "AT2N", i[i.BC4U = qt("BC4U")] = "BC4U", i[i.BC4S = qt("BC4S")] = "BC4S", i[i.BC5U = qt("BC5U")] = "BC5U", i[i.BC5S = qt("BC5S")] = "BC5S", i[i.DX10 = qt("DX10")] = "DX10", i))(he || {});
  const cu = {
    [he.DXT1]: "bc1-rgba-unorm",
    [he.DXT2]: "bc2-rgba-unorm",
    [he.DXT3]: "bc2-rgba-unorm",
    [he.DXT4]: "bc3-rgba-unorm",
    [he.DXT5]: "bc3-rgba-unorm",
    [he.ATI1]: "bc4-r-unorm",
    [he.BC4U]: "bc4-r-unorm",
    [he.BC4S]: "bc4-r-snorm",
    [he.ATI2]: "bc5-rg-unorm",
    [he.BC5U]: "bc5-rg-unorm",
    [he.BC5S]: "bc5-rg-snorm",
    36: "rgba16uint",
    110: "rgba16sint",
    111: "r16float",
    112: "rg16float",
    113: "rgba16float",
    114: "r32float",
    115: "rg32float",
    116: "rgba32float"
  }, de = {
    70: "bc1-rgba-unorm",
    71: "bc1-rgba-unorm",
    72: "bc1-rgba-unorm-srgb",
    73: "bc2-rgba-unorm",
    74: "bc2-rgba-unorm",
    75: "bc2-rgba-unorm-srgb",
    76: "bc3-rgba-unorm",
    77: "bc3-rgba-unorm",
    78: "bc3-rgba-unorm-srgb",
    79: "bc4-r-unorm",
    80: "bc4-r-unorm",
    81: "bc4-r-snorm",
    82: "bc5-rg-unorm",
    83: "bc5-rg-unorm",
    84: "bc5-rg-snorm",
    94: "bc6h-rgb-ufloat",
    95: "bc6h-rgb-ufloat",
    96: "bc6h-rgb-float",
    97: "bc7-rgba-unorm",
    98: "bc7-rgba-unorm",
    99: "bc7-rgba-unorm-srgb",
    28: "rgba8unorm",
    29: "rgba8unorm-srgb",
    87: "bgra8unorm",
    91: "bgra8unorm-srgb",
    41: "r32float",
    49: "rg8unorm",
    56: "r16uint",
    61: "r8unorm",
    24: "rgb10a2unorm",
    11: "rgba16uint",
    13: "rgba16sint",
    10: "rgba16float",
    54: "r16float",
    34: "rg16float",
    16: "rg32float",
    2: "rgba32float"
  }, at = {
    MAGIC_VALUE: 542327876,
    MAGIC_SIZE: 4,
    HEADER_SIZE: 124,
    HEADER_DX10_SIZE: 20,
    PIXEL_FORMAT_FLAGS: {
      ALPHAPIXELS: 1,
      ALPHA: 2,
      FOURCC: 4,
      RGB: 64,
      RGBA: 65,
      YUV: 512,
      LUMINANCE: 131072,
      LUMINANCEA: 131073
    },
    RESOURCE_MISC_TEXTURECUBE: 4,
    HEADER_FIELDS: Ab,
    HEADER_DX10_FIELDS: Rb,
    DXGI_FORMAT: Yh,
    D3D10_RESOURCE_DIMENSION: Kh,
    D3DFMT: he
  }, Pb = {
    "bc1-rgba-unorm": 8,
    "bc1-rgba-unorm-srgb": 8,
    "bc2-rgba-unorm": 16,
    "bc2-rgba-unorm-srgb": 16,
    "bc3-rgba-unorm": 16,
    "bc3-rgba-unorm-srgb": 16,
    "bc4-r-unorm": 8,
    "bc4-r-snorm": 8,
    "bc5-rg-unorm": 16,
    "bc5-rg-snorm": 16,
    "bc6h-rgb-ufloat": 16,
    "bc6h-rgb-float": 16,
    "bc7-rgba-unorm": 16,
    "bc7-rgba-unorm-srgb": 16
  };
  function Bb(i, t) {
    const { format: e, fourCC: r, width: s, height: n, dataOffset: o, mipmapCount: a } = Db(i);
    if (!t.includes(e)) throw new Error(`Unsupported texture format: ${r} ${e}, supported: ${t}`);
    if (a <= 1) return {
      format: e,
      width: s,
      height: n,
      resource: [
        new Uint8Array(i, o)
      ],
      alphaMode: "no-premultiply-alpha"
    };
    const c = Mb(e, s, n, o, a, i);
    return {
      format: e,
      width: s,
      height: n,
      resource: c,
      alphaMode: "no-premultiply-alpha"
    };
  }
  function Mb(i, t, e, r, s, n) {
    const o = [], a = Pb[i];
    let c = t, l = e, u = r;
    for (let h = 0; h < s; ++h) {
      const d = a ? Math.max(4, c) / 4 * Math.max(4, l) / 4 * a : c * l * 4, p = new Uint8Array(n, u, d);
      o.push(p), u += d, c = Math.max(c >> 1, 1), l = Math.max(l >> 1, 1);
    }
    return o;
  }
  function Db(i) {
    const t = new Uint32Array(i, 0, at.HEADER_SIZE / Uint32Array.BYTES_PER_ELEMENT);
    if (t[at.HEADER_FIELDS.MAGIC] !== at.MAGIC_VALUE) throw new Error("Invalid magic number in DDS header");
    const e = t[at.HEADER_FIELDS.HEIGHT], r = t[at.HEADER_FIELDS.WIDTH], s = Math.max(1, t[at.HEADER_FIELDS.MIPMAP_COUNT]), n = t[at.HEADER_FIELDS.PF_FLAGS], o = t[at.HEADER_FIELDS.FOURCC], a = Ib(t, n, o, i), c = at.MAGIC_SIZE + at.HEADER_SIZE + (o === at.D3DFMT.DX10 ? at.HEADER_DX10_SIZE : 0);
    return {
      format: a,
      fourCC: o,
      width: r,
      height: e,
      dataOffset: c,
      mipmapCount: s
    };
  }
  function Ib(i, t, e, r) {
    if (t & at.PIXEL_FORMAT_FLAGS.FOURCC) {
      if (e === at.D3DFMT.DX10) {
        const s = new Uint32Array(r, at.MAGIC_SIZE + at.HEADER_SIZE, at.HEADER_DX10_SIZE / Uint32Array.BYTES_PER_ELEMENT);
        if (s[at.HEADER_DX10_FIELDS.MISC_FLAG] === at.RESOURCE_MISC_TEXTURECUBE) throw new Error("DDSParser does not support cubemap textures");
        if (s[at.HEADER_DX10_FIELDS.RESOURCE_DIMENSION] === at.D3D10_RESOURCE_DIMENSION.DDS_DIMENSION_TEXTURE3D) throw new Error("DDSParser does not supported 3D texture data");
        const a = s[at.HEADER_DX10_FIELDS.DXGI_FORMAT];
        if (a in de) return de[a];
        throw new Error(`DDSParser cannot parse texture data with DXGI format ${a}`);
      }
      if (e in cu) return cu[e];
      throw new Error(`DDSParser cannot parse texture data with fourCC format ${e}`);
    }
    if (t & at.PIXEL_FORMAT_FLAGS.RGB || t & at.PIXEL_FORMAT_FLAGS.RGBA) return Fb(i);
    throw t & at.PIXEL_FORMAT_FLAGS.YUV ? new Error("DDSParser does not supported YUV uncompressed texture data.") : t & at.PIXEL_FORMAT_FLAGS.LUMINANCE || t & at.PIXEL_FORMAT_FLAGS.LUMINANCEA ? new Error("DDSParser does not support single-channel (lumninance) texture data!") : t & at.PIXEL_FORMAT_FLAGS.ALPHA || t & at.PIXEL_FORMAT_FLAGS.ALPHAPIXELS ? new Error("DDSParser does not support single-channel (alpha) texture data!") : new Error("DDSParser failed to load a texture file due to an unknown reason!");
  }
  function Fb(i) {
    const t = i[at.HEADER_FIELDS.RGB_BITCOUNT], e = i[at.HEADER_FIELDS.R_BIT_MASK], r = i[at.HEADER_FIELDS.G_BIT_MASK], s = i[at.HEADER_FIELDS.B_BIT_MASK], n = i[at.HEADER_FIELDS.A_BIT_MASK];
    switch (t) {
      case 32:
        if (e === 255 && r === 65280 && s === 16711680 && n === 4278190080) return de[at.DXGI_FORMAT.DXGI_FORMAT_R8G8B8A8_UNORM];
        if (e === 16711680 && r === 65280 && s === 255 && n === 4278190080) return de[at.DXGI_FORMAT.DXGI_FORMAT_B8G8R8A8_UNORM];
        if (e === 1072693248 && r === 1047552 && s === 1023 && n === 3221225472) return de[at.DXGI_FORMAT.DXGI_FORMAT_R10G10B10A2_UNORM];
        if (e === 65535 && r === 4294901760 && s === 0 && n === 0) return de[at.DXGI_FORMAT.DXGI_FORMAT_R16G16_UNORM];
        if (e === 4294967295 && r === 0 && s === 0 && n === 0) return de[at.DXGI_FORMAT.DXGI_FORMAT_R32_FLOAT];
        break;
      case 24:
        break;
      case 16:
        if (e === 31744 && r === 992 && s === 31 && n === 32768) return de[at.DXGI_FORMAT.DXGI_FORMAT_B5G5R5A1_UNORM];
        if (e === 63488 && r === 2016 && s === 31 && n === 0) return de[at.DXGI_FORMAT.DXGI_FORMAT_B5G6R5_UNORM];
        if (e === 3840 && r === 240 && s === 15 && n === 61440) return de[at.DXGI_FORMAT.DXGI_FORMAT_B4G4R4A4_UNORM];
        if (e === 255 && r === 0 && s === 0 && n === 65280) return de[at.DXGI_FORMAT.DXGI_FORMAT_R8G8_UNORM];
        if (e === 65535 && r === 0 && s === 0 && n === 0) return de[at.DXGI_FORMAT.DXGI_FORMAT_R16_UNORM];
        break;
      case 8:
        if (e === 255 && r === 0 && s === 0 && n === 0) return de[at.DXGI_FORMAT.DXGI_FORMAT_R8_UNORM];
        break;
    }
    throw new Error(`DDSParser does not support uncompressed texture with configuration:
                bitCount = ${t}, rBitMask = ${e}, gBitMask = ${r}, aBitMask = ${n}`);
  }
  const aR = {
    extension: {
      type: P.LoadParser,
      priority: ve.High,
      name: "loadDDS"
    },
    name: "loadDDS",
    test(i) {
      return Me(i, [
        ".dds"
      ]);
    },
    async load(i, t, e) {
      const r = await en(), n = await (await fetch(i)).arrayBuffer(), o = Bb(n, r), a = new tn(o);
      return Ur(a, e, i);
    },
    unload(i) {
      Array.isArray(i) ? i.forEach((t) => t.destroy(true)) : i.destroy(true);
    }
  };
  const Ub = {
    33776: "bc1-rgba-unorm",
    33777: "bc1-rgba-unorm",
    33778: "bc2-rgba-unorm",
    33779: "bc3-rgba-unorm",
    35916: "bc1-rgba-unorm-srgb",
    35917: "bc1-rgba-unorm-srgb",
    35918: "bc2-rgba-unorm-srgb",
    35919: "bc3-rgba-unorm-srgb",
    36283: "bc4-r-unorm",
    36284: "bc4-r-snorm",
    36285: "bc5-rg-unorm",
    36286: "bc5-rg-snorm",
    37488: "eac-r11unorm",
    37490: "eac-rg11snorm",
    37492: "etc2-rgb8unorm",
    37496: "etc2-rgba8unorm",
    37493: "etc2-rgb8unorm-srgb",
    37497: "etc2-rgba8unorm-srgb",
    37494: "etc2-rgb8a1unorm",
    37495: "etc2-rgb8a1unorm-srgb",
    37808: "astc-4x4-unorm",
    37840: "astc-4x4-unorm-srgb",
    37809: "astc-5x4-unorm",
    37841: "astc-5x4-unorm-srgb",
    37810: "astc-5x5-unorm",
    37842: "astc-5x5-unorm-srgb",
    37811: "astc-6x5-unorm",
    37843: "astc-6x5-unorm-srgb",
    37812: "astc-6x6-unorm",
    37844: "astc-6x6-unorm-srgb",
    37813: "astc-8x5-unorm",
    37845: "astc-8x5-unorm-srgb",
    37814: "astc-8x6-unorm",
    37846: "astc-8x6-unorm-srgb",
    37815: "astc-8x8-unorm",
    37847: "astc-8x8-unorm-srgb",
    37816: "astc-10x5-unorm",
    37848: "astc-10x5-unorm-srgb",
    37817: "astc-10x6-unorm",
    37849: "astc-10x6-unorm-srgb",
    37818: "astc-10x8-unorm",
    37850: "astc-10x8-unorm-srgb",
    37819: "astc-10x10-unorm",
    37851: "astc-10x10-unorm-srgb",
    37820: "astc-12x10-unorm",
    37852: "astc-12x10-unorm-srgb",
    37821: "astc-12x12-unorm",
    37853: "astc-12x12-unorm-srgb",
    36492: "bc7-rgba-unorm",
    36493: "bc7-rgba-unorm-srgb",
    36494: "bc6h-rgb-float",
    36495: "bc6h-rgb-ufloat",
    35907: "rgba8unorm-srgb",
    36759: "rgba8snorm",
    36220: "rgba8uint",
    36238: "rgba8sint",
    6408: "rgba8unorm"
  }, kb = [
    171,
    75,
    84,
    88,
    32,
    49,
    49,
    187,
    13,
    10,
    26,
    10
  ], Gb = {
    FILE_IDENTIFIER: 0,
    ENDIANNESS: 12,
    GL_TYPE: 16,
    GL_TYPE_SIZE: 20,
    GL_FORMAT: 24,
    GL_INTERNAL_FORMAT: 28,
    GL_BASE_INTERNAL_FORMAT: 32,
    PIXEL_WIDTH: 36,
    PIXEL_HEIGHT: 40,
    PIXEL_DEPTH: 44,
    NUMBER_OF_ARRAY_ELEMENTS: 48,
    NUMBER_OF_FACES: 52,
    NUMBER_OF_MIPMAP_LEVELS: 56,
    BYTES_OF_KEY_VALUE_DATA: 60
  }, Ob = 64, Nb = 67305985, Lb = {
    5121: 1,
    5123: 2,
    5124: 4,
    5125: 4,
    5126: 4,
    36193: 8
  }, Hb = {
    6408: 4,
    6407: 3,
    33319: 2,
    6403: 1,
    6409: 1,
    6410: 2,
    6406: 1
  }, zb = {
    32819: 2,
    32820: 2,
    33635: 2
  }, jb = {
    33776: 0.5,
    33777: 0.5,
    33778: 1,
    33779: 1,
    35916: 0.5,
    35917: 0.5,
    35918: 1,
    35919: 1,
    36283: 0.5,
    36284: 0.5,
    36285: 1,
    36286: 1,
    37488: 0.5,
    37489: 0.5,
    37490: 1,
    37491: 1,
    37492: 0.5,
    37496: 1,
    37493: 0.5,
    37497: 1,
    37494: 0.5,
    37495: 0.5,
    37808: 1,
    37840: 1,
    37809: 0.8,
    37841: 0.8,
    37810: 0.64,
    37842: 0.64,
    37811: 0.53375,
    37843: 0.53375,
    37812: 0.445,
    37844: 0.445,
    37813: 0.4,
    37845: 0.4,
    37814: 0.33375,
    37846: 0.33375,
    37815: 0.25,
    37847: 0.25,
    37816: 0.32,
    37848: 0.32,
    37817: 0.26625,
    37849: 0.26625,
    37818: 0.2,
    37850: 0.2,
    37819: 0.16,
    37851: 0.16,
    37820: 0.13375,
    37852: 0.13375,
    37821: 0.11125,
    37853: 0.11125,
    36492: 1,
    36493: 1,
    36494: 1,
    36495: 1
  }, Lt = {
    FILE_HEADER_SIZE: Ob,
    FILE_IDENTIFIER: kb,
    FORMATS_TO_COMPONENTS: Hb,
    INTERNAL_FORMAT_TO_BYTES_PER_PIXEL: jb,
    INTERNAL_FORMAT_TO_TEXTURE_FORMATS: Ub,
    FIELDS: Gb,
    TYPES_TO_BYTES_PER_COMPONENT: Lb,
    TYPES_TO_BYTES_PER_PIXEL: zb,
    ENDIANNESS: Nb
  };
  function Wb(i, t) {
    const e = new DataView(i);
    if (!$b(e)) throw new Error("Invalid KTX identifier in header");
    const { littleEndian: r, glType: s, glFormat: n, glInternalFormat: o, pixelWidth: a, pixelHeight: c, numberOfMipmapLevels: l, offset: u } = qb(e), h = Lt.INTERNAL_FORMAT_TO_TEXTURE_FORMATS[o];
    if (!h) throw new Error(`Unknown texture format ${o}`);
    if (!t.includes(h)) throw new Error(`Unsupported texture format: ${h}, supportedFormats: ${t}`);
    const d = Xb(s, n, o), p = Vb(e, s, d, a, c, u, l, r);
    return {
      format: h,
      width: a,
      height: c,
      resource: p,
      alphaMode: "no-premultiply-alpha"
    };
  }
  function Vb(i, t, e, r, s, n, o, a) {
    const c = r + 3 & -4, l = s + 3 & -4;
    let u = r * s;
    t === 0 && (u = c * l);
    let h = u * e, d = r, p = s, g = c, y = l, m = n;
    const v = new Array(o);
    for (let S = 0; S < o; S++) {
      const C = i.getUint32(m, a);
      let G = m + 4;
      v[S] = new Uint8Array(i.buffer, G, h), G += h, m += C + 4, m = m % 4 !== 0 ? m + 4 - m % 4 : m, d = d >> 1 || 1, p = p >> 1 || 1, g = d + 4 - 1 & -4, y = p + 4 - 1 & -4, h = g * y * e;
    }
    return v;
  }
  function Xb(i, t, e) {
    let r = Lt.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[e];
    if (i !== 0 && (Lt.TYPES_TO_BYTES_PER_COMPONENT[i] ? r = Lt.TYPES_TO_BYTES_PER_COMPONENT[i] * Lt.FORMATS_TO_COMPONENTS[t] : r = Lt.TYPES_TO_BYTES_PER_PIXEL[i]), r === void 0) throw new Error("Unable to resolve the pixel format stored in the *.ktx file!");
    return r;
  }
  function qb(i) {
    const t = i.getUint32(Lt.FIELDS.ENDIANNESS, true) === Lt.ENDIANNESS, e = i.getUint32(Lt.FIELDS.GL_TYPE, t), r = i.getUint32(Lt.FIELDS.GL_FORMAT, t), s = i.getUint32(Lt.FIELDS.GL_INTERNAL_FORMAT, t), n = i.getUint32(Lt.FIELDS.PIXEL_WIDTH, t), o = i.getUint32(Lt.FIELDS.PIXEL_HEIGHT, t) || 1, a = i.getUint32(Lt.FIELDS.PIXEL_DEPTH, t) || 1, c = i.getUint32(Lt.FIELDS.NUMBER_OF_ARRAY_ELEMENTS, t) || 1, l = i.getUint32(Lt.FIELDS.NUMBER_OF_FACES, t), u = i.getUint32(Lt.FIELDS.NUMBER_OF_MIPMAP_LEVELS, t), h = i.getUint32(Lt.FIELDS.BYTES_OF_KEY_VALUE_DATA, t);
    if (o === 0 || a !== 1) throw new Error("Only 2D textures are supported");
    if (l !== 1) throw new Error("CubeTextures are not supported by KTXLoader yet!");
    if (c !== 1) throw new Error("WebGL does not support array textures");
    return {
      littleEndian: t,
      glType: e,
      glFormat: r,
      glInternalFormat: s,
      pixelWidth: n,
      pixelHeight: o,
      numberOfMipmapLevels: u,
      offset: Lt.FILE_HEADER_SIZE + h
    };
  }
  function $b(i) {
    for (let t = 0; t < Lt.FILE_IDENTIFIER.length; t++) if (i.getUint8(t) !== Lt.FILE_IDENTIFIER[t]) return false;
    return true;
  }
  const cR = {
    extension: {
      type: P.LoadParser,
      priority: ve.High,
      name: "loadKTX"
    },
    name: "loadKTX",
    test(i) {
      return Me(i, ".ktx");
    },
    async load(i, t, e) {
      const r = await en(), n = await (await fetch(i)).arrayBuffer(), o = Wb(n, r), a = new tn(o);
      return Ur(a, e, i);
    },
    unload(i) {
      Array.isArray(i) ? i.forEach((t) => t.destroy(true)) : i.destroy(true);
    }
  }, Yb = `(function () {
    'use strict';

    const converters = {
      rgb8unorm: {
        convertedFormat: "rgba8unorm",
        convertFunction: convertRGBtoRGBA
      },
      "rgb8unorm-srgb": {
        convertedFormat: "rgba8unorm-srgb",
        convertFunction: convertRGBtoRGBA
      }
    };
    function convertFormatIfRequired(textureOptions) {
      const format = textureOptions.format;
      if (converters[format]) {
        const convertFunction = converters[format].convertFunction;
        const levelBuffers = textureOptions.resource;
        for (let i = 0; i < levelBuffers.length; i++) {
          levelBuffers[i] = convertFunction(levelBuffers[i]);
        }
        textureOptions.format = converters[format].convertedFormat;
      }
    }
    function convertRGBtoRGBA(levelBuffer) {
      const pixelCount = levelBuffer.byteLength / 3;
      const levelBufferWithAlpha = new Uint32Array(pixelCount);
      for (let i = 0; i < pixelCount; ++i) {
        levelBufferWithAlpha[i] = levelBuffer[i * 3] + (levelBuffer[i * 3 + 1] << 8) + (levelBuffer[i * 3 + 2] << 16) + 4278190080;
      }
      return new Uint8Array(levelBufferWithAlpha.buffer);
    }

    function createLevelBuffersFromKTX(ktxTexture) {
      const levelBuffers = [];
      for (let i = 0; i < ktxTexture.numLevels; i++) {
        const imageData = ktxTexture.getImageData(i, 0, 0);
        const levelBuffer = new Uint8Array(imageData.byteLength);
        levelBuffer.set(imageData);
        levelBuffers.push(levelBuffer);
      }
      return levelBuffers;
    }

    const glFormatToGPUFormatMap = {
      6408: "rgba8unorm",
      32856: "bgra8unorm",
      //
      32857: "rgb10a2unorm",
      33189: "depth16unorm",
      33190: "depth24plus",
      33321: "r8unorm",
      33323: "rg8unorm",
      33325: "r16float",
      33326: "r32float",
      33327: "rg16float",
      33328: "rg32float",
      33329: "r8sint",
      33330: "r8uint",
      33331: "r16sint",
      33332: "r16uint",
      33333: "r32sint",
      33334: "r32uint",
      33335: "rg8sint",
      33336: "rg8uint",
      33337: "rg16sint",
      33338: "rg16uint",
      33339: "rg32sint",
      33340: "rg32uint",
      33778: "bc2-rgba-unorm",
      33779: "bc3-rgba-unorm",
      34836: "rgba32float",
      34842: "rgba16float",
      35056: "depth24plus-stencil8",
      35898: "rg11b10ufloat",
      35901: "rgb9e5ufloat",
      35907: "rgba8unorm-srgb",
      // bgra8unorm-srgb
      36012: "depth32float",
      36013: "depth32float-stencil8",
      36168: "stencil8",
      36208: "rgba32uint",
      36214: "rgba16uint",
      36220: "rgba8uint",
      36226: "rgba32sint",
      36232: "rgba16sint",
      36238: "rgba8sint",
      36492: "bc7-rgba-unorm",
      36756: "r8snorm",
      36757: "rg8snorm",
      36759: "rgba8snorm",
      37496: "etc2-rgba8unorm",
      37808: "astc-4x4-unorm"
    };
    function glFormatToGPUFormat(glInternalFormat) {
      const format = glFormatToGPUFormatMap[glInternalFormat];
      if (format) {
        return format;
      }
      throw new Error(\`Unsupported glInternalFormat: \${glInternalFormat}\`);
    }

    const vkFormatToGPUFormatMap = {
      23: "rgb8unorm",
      // VK_FORMAT_R8G8B8_UNORM
      37: "rgba8unorm",
      // VK_FORMAT_R8G8B8A8_UNORM
      43: "rgba8unorm-srgb"
      // VK_FORMAT_R8G8B8A8_SRGB
      // TODO add more!
    };
    function vkFormatToGPUFormat(vkFormat) {
      const format = vkFormatToGPUFormatMap[vkFormat];
      if (format) {
        return format;
      }
      throw new Error(\`Unsupported VkFormat: \${vkFormat}\`);
    }

    function getTextureFormatFromKTXTexture(ktxTexture) {
      if (ktxTexture.classId === 2) {
        return vkFormatToGPUFormat(ktxTexture.vkFormat);
      }
      return glFormatToGPUFormat(ktxTexture.glInternalformat);
    }

    const gpuFormatToBasisTranscoderFormatMap = {
      "bc3-rgba-unorm": "BC3_RGBA",
      "bc7-rgba-unorm": "BC7_M5_RGBA",
      "etc2-rgba8unorm": "ETC2_RGBA",
      "astc-4x4-unorm": "ASTC_4x4_RGBA",
      // Uncompressed
      rgba8unorm: "RGBA32",
      rg11b10ufloat: "R11F_G11F_B10F"
    };
    function gpuFormatToKTXBasisTranscoderFormat(transcoderFormat) {
      const format = gpuFormatToBasisTranscoderFormatMap[transcoderFormat];
      if (format) {
        return format;
      }
      throw new Error(\`Unsupported transcoderFormat: \${transcoderFormat}\`);
    }

    const settings = {
      jsUrl: "",
      wasmUrl: ""
    };
    let basisTranscoderFormat;
    let basisTranscodedTextureFormat;
    let ktxPromise;
    async function getKTX() {
      if (!ktxPromise) {
        const absoluteJsUrl = new URL(settings.jsUrl, location.origin).href;
        const absoluteWasmUrl = new URL(settings.wasmUrl, location.origin).href;
        importScripts(absoluteJsUrl);
        ktxPromise = new Promise((resolve) => {
          LIBKTX({
            locateFile: (_file) => absoluteWasmUrl
          }).then((libktx) => {
            resolve(libktx);
          });
        });
      }
      return ktxPromise;
    }
    async function fetchKTXTexture(url, ktx) {
      const ktx2Response = await fetch(url);
      if (ktx2Response.ok) {
        const ktx2ArrayBuffer = await ktx2Response.arrayBuffer();
        return new ktx.ktxTexture(new Uint8Array(ktx2ArrayBuffer));
      }
      throw new Error(\`Failed to load KTX(2) texture: \${url}\`);
    }
    const preferredTranscodedFormat = [
      "bc7-rgba-unorm",
      "astc-4x4-unorm",
      "etc2-rgba8unorm",
      "bc3-rgba-unorm",
      "rgba8unorm"
    ];
    async function load(url) {
      const ktx = await getKTX();
      const ktxTexture = await fetchKTXTexture(url, ktx);
      let format;
      if (ktxTexture.needsTranscoding) {
        format = basisTranscodedTextureFormat;
        const transcodeFormat = ktx.TranscodeTarget[basisTranscoderFormat];
        const result = ktxTexture.transcodeBasis(transcodeFormat, 0);
        if (result !== ktx.ErrorCode.SUCCESS) {
          throw new Error("Unable to transcode basis texture.");
        }
      } else {
        format = getTextureFormatFromKTXTexture(ktxTexture);
      }
      const levelBuffers = createLevelBuffersFromKTX(ktxTexture);
      const textureOptions = {
        width: ktxTexture.baseWidth,
        height: ktxTexture.baseHeight,
        format,
        mipLevelCount: ktxTexture.numLevels,
        resource: levelBuffers,
        alphaMode: "no-premultiply-alpha"
      };
      convertFormatIfRequired(textureOptions);
      return textureOptions;
    }
    async function init(jsUrl, wasmUrl, supportedTextures) {
      if (jsUrl)
        settings.jsUrl = jsUrl;
      if (wasmUrl)
        settings.wasmUrl = wasmUrl;
      basisTranscodedTextureFormat = preferredTranscodedFormat.filter((format) => supportedTextures.includes(format))[0];
      basisTranscoderFormat = gpuFormatToKTXBasisTranscoderFormat(basisTranscodedTextureFormat);
      await getKTX();
    }
    const messageHandlers = {
      init: async (data) => {
        const { jsUrl, wasmUrl, supportedTextures } = data;
        await init(jsUrl, wasmUrl, supportedTextures);
      },
      load: async (data) => {
        try {
          const textureOptions = await load(data.url);
          return {
            type: "load",
            url: data.url,
            success: true,
            textureOptions,
            transferables: textureOptions.resource?.map((arr) => arr.buffer)
          };
        } catch (e) {
          throw e;
        }
      }
    };
    self.onmessage = async (messageEvent) => {
      const message = messageEvent.data;
      const response = await messageHandlers[message.type]?.(message);
      if (response) {
        self.postMessage(response, response.transferables);
      }
    };

})();
`;
  let $r = null;
  class Jh {
    constructor() {
      $r || ($r = URL.createObjectURL(new Blob([
        Yb
      ], {
        type: "application/javascript"
      }))), this.worker = new Worker($r);
    }
  }
  Jh.revokeObjectURL = function() {
    $r && (URL.revokeObjectURL($r), $r = null);
  };
  const uu = {
    jsUrl: "https://files.pixijs.download/transcoders/ktx/libktx.js",
    wasmUrl: "https://files.pixijs.download/transcoders/ktx/libktx.wasm"
  };
  let hi;
  const Zh = {};
  function Kb(i) {
    return hi || (hi = new Jh().worker, hi.onmessage = (t) => {
      const { success: e, url: r, textureOptions: s } = t.data;
      e || console.warn("Failed to load KTX texture", r), Zh[r](s);
    }, hi.postMessage({
      type: "init",
      jsUrl: uu.jsUrl,
      wasmUrl: uu.wasmUrl,
      supportedTextures: i
    })), hi;
  }
  function Jb(i, t) {
    const e = Kb(t);
    return new Promise((r) => {
      Zh[i] = r, e.postMessage({
        type: "load",
        url: i
      });
    });
  }
  const uR = {
    extension: {
      type: P.LoadParser,
      priority: ve.High,
      name: "loadKTX2"
    },
    name: "loadKTX2",
    test(i) {
      return Me(i, ".ktx2");
    },
    async load(i, t, e) {
      const r = await en(), s = await Jb(i, r), n = new tn(s);
      return Ur(n, e, i);
    },
    async unload(i) {
      Array.isArray(i) ? i.forEach((t) => t.destroy(true)) : i.destroy(true);
    }
  };
  const Oo = [
    "basis",
    "bc7",
    "bc6h",
    "astc",
    "etc2",
    "bc5",
    "bc4",
    "bc3",
    "bc2",
    "bc1",
    "eac"
  ], lR = {
    extension: P.ResolveParser,
    test: (i) => Me(i, [
      ".ktx",
      ".ktx2",
      ".dds"
    ]),
    parse: (i) => {
      var _a2;
      let t;
      const e = i.split(".");
      if (e.length > 2) {
        const r = e[e.length - 2];
        Oo.includes(r) && (t = r);
      } else t = e[e.length - 1];
      return {
        resolution: parseFloat(((_a2 = Ir.RETINA_PREFIX.exec(i)) == null ? void 0 : _a2[1]) ?? "1"),
        format: t,
        src: i
      };
    }
  };
  let us;
  const hR = {
    extension: {
      type: P.DetectionParser,
      priority: 2
    },
    test: async () => !!(await Js() || Ks()),
    add: async (i) => {
      const t = await Xh();
      return us = Zb(t), [
        ...us,
        ...i
      ];
    },
    remove: async (i) => us ? i.filter((t) => !(t in us)) : i
  };
  function Zb(i) {
    const t = [
      "basis"
    ], e = {};
    return i.forEach((r) => {
      const s = r.split("-")[0];
      s && !e[s] && (e[s] = true, t.push(s));
    }), t.sort((r, s) => {
      const n = Oo.indexOf(r), o = Oo.indexOf(s);
      return n === -1 ? 1 : o === -1 ? -1 : n - o;
    }), t;
  }
  const Qb = new re(), No = class {
    cull(t, e, r = true) {
      this._cullRecursive(t, e, r);
    }
    _cullRecursive(t, e, r = true) {
      if (t.cullable && t.measurable && t.includeInBuild) {
        const s = t.cullArea ?? Xs(t, r, Qb);
        t.culled = s.x >= e.x + e.width || s.y >= e.y + e.height || s.x + s.width <= e.x || s.y + s.height <= e.y;
      } else t.culled = false;
      if (!(!t.cullableChildren || t.culled || !t.renderable || !t.measurable || !t.includeInBuild)) for (let s = 0; s < t.children.length; s++) this._cullRecursive(t.children[s], e, r);
    }
  };
  No.shared = new No();
  let tw = No;
  class ew {
    static init() {
      this._renderRef = this.render.bind(this), this.render = () => {
        tw.shared.cull(this.stage, this.renderer.screen), this.renderer.render({
          container: this.stage
        });
      };
    }
    static destroy() {
      this.render = this._renderRef;
    }
  }
  ew.extension = {
    priority: 10,
    type: P.Application,
    name: "culler"
  };
  var di = {}, Xe = {}, vr = {}, lu;
  function rn() {
    if (lu) return vr;
    lu = 1;
    function i(n, o, a) {
      if (a === void 0 && (a = Array.prototype), n && typeof a.find == "function") return a.find.call(n, o);
      for (var c = 0; c < n.length; c++) if (Object.prototype.hasOwnProperty.call(n, c)) {
        var l = n[c];
        if (o.call(void 0, l, c, n)) return l;
      }
    }
    function t(n, o) {
      return o === void 0 && (o = Object), o && typeof o.freeze == "function" ? o.freeze(n) : n;
    }
    function e(n, o) {
      if (n === null || typeof n != "object") throw new TypeError("target is not an object");
      for (var a in o) Object.prototype.hasOwnProperty.call(o, a) && (n[a] = o[a]);
      return n;
    }
    var r = t({
      HTML: "text/html",
      isHTML: function(n) {
        return n === r.HTML;
      },
      XML_APPLICATION: "application/xml",
      XML_TEXT: "text/xml",
      XML_XHTML_APPLICATION: "application/xhtml+xml",
      XML_SVG_IMAGE: "image/svg+xml"
    }), s = t({
      HTML: "http://www.w3.org/1999/xhtml",
      isHTML: function(n) {
        return n === s.HTML;
      },
      SVG: "http://www.w3.org/2000/svg",
      XML: "http://www.w3.org/XML/1998/namespace",
      XMLNS: "http://www.w3.org/2000/xmlns/"
    });
    return vr.assign = e, vr.find = i, vr.freeze = t, vr.MIME_TYPE = r, vr.NAMESPACE = s, vr;
  }
  var hu;
  function Qh() {
    if (hu) return Xe;
    hu = 1;
    var i = rn(), t = i.find, e = i.NAMESPACE;
    function r(b) {
      return b !== "";
    }
    function s(b) {
      return b ? b.split(/[\t\n\f\r ]+/).filter(r) : [];
    }
    function n(b, w) {
      return b.hasOwnProperty(w) || (b[w] = true), b;
    }
    function o(b) {
      if (!b) return [];
      var w = s(b);
      return Object.keys(w.reduce(n, {}));
    }
    function a(b) {
      return function(w) {
        return b && b.indexOf(w) !== -1;
      };
    }
    function c(b, w) {
      for (var T in b) Object.prototype.hasOwnProperty.call(b, T) && (w[T] = b[T]);
    }
    function l(b, w) {
      var T = b.prototype;
      if (!(T instanceof w)) {
        let k = function() {
        };
        k.prototype = w.prototype, k = new k(), c(T, k), b.prototype = T = k;
      }
      T.constructor != b && (typeof b != "function" && console.error("unknown Class:" + b), T.constructor = b);
    }
    var u = {}, h = u.ELEMENT_NODE = 1, d = u.ATTRIBUTE_NODE = 2, p = u.TEXT_NODE = 3, g = u.CDATA_SECTION_NODE = 4, y = u.ENTITY_REFERENCE_NODE = 5, m = u.ENTITY_NODE = 6, v = u.PROCESSING_INSTRUCTION_NODE = 7, S = u.COMMENT_NODE = 8, C = u.DOCUMENT_NODE = 9, G = u.DOCUMENT_TYPE_NODE = 10, H = u.DOCUMENT_FRAGMENT_NODE = 11, Y = u.NOTATION_NODE = 12, L = {}, W = {}, A = L.INDEX_SIZE_ERR = (W[1] = "Index size error", 1), I = L.DOMSTRING_SIZE_ERR = (W[2] = "DOMString size error", 2), z = L.HIERARCHY_REQUEST_ERR = (W[3] = "Hierarchy request error", 3), J = L.WRONG_DOCUMENT_ERR = (W[4] = "Wrong document", 4), j = L.INVALID_CHARACTER_ERR = (W[5] = "Invalid character", 5), X = L.NO_DATA_ALLOWED_ERR = (W[6] = "No data allowed", 6), Q = L.NO_MODIFICATION_ALLOWED_ERR = (W[7] = "No modification allowed", 7), x = L.NOT_FOUND_ERR = (W[8] = "Not found", 8), R = L.NOT_SUPPORTED_ERR = (W[9] = "Not supported", 9), E = L.INUSE_ATTRIBUTE_ERR = (W[10] = "Attribute in use", 10), B = L.INVALID_STATE_ERR = (W[11] = "Invalid state", 11), D = L.SYNTAX_ERR = (W[12] = "Syntax error", 12), N = L.INVALID_MODIFICATION_ERR = (W[13] = "Invalid modification", 13), O = L.NAMESPACE_ERR = (W[14] = "Invalid namespace", 14), q = L.INVALID_ACCESS_ERR = (W[15] = "Invalid access", 15);
    function V(b, w) {
      if (w instanceof Error) var T = w;
      else T = this, Error.call(this, W[b]), this.message = W[b], Error.captureStackTrace && Error.captureStackTrace(this, V);
      return T.code = b, w && (this.message = this.message + ": " + w), T;
    }
    V.prototype = Error.prototype, c(L, V);
    function $() {
    }
    $.prototype = {
      length: 0,
      item: function(b) {
        return b >= 0 && b < this.length ? this[b] : null;
      },
      toString: function(b, w) {
        for (var T = [], k = 0; k < this.length; k++) Gr(this[k], T, b, w);
        return T.join("");
      },
      filter: function(b) {
        return Array.prototype.filter.call(this, b);
      },
      indexOf: function(b) {
        return Array.prototype.indexOf.call(this, b);
      }
    };
    function ft(b, w) {
      this._node = b, this._refresh = w, pt(this);
    }
    function pt(b) {
      var w = b._node._inc || b._node.ownerDocument._inc;
      if (b._inc !== w) {
        var T = b._refresh(b._node);
        if (Ja(b, "length", T.length), !b.$$length || T.length < b.$$length) for (var k = T.length; k in b; k++) Object.prototype.hasOwnProperty.call(b, k) && delete b[k];
        c(T, b), b._inc = w;
      }
    }
    ft.prototype.item = function(b) {
      return pt(this), this[b] || null;
    }, l(ft, $);
    function it() {
    }
    function gt(b, w) {
      for (var T = b.length; T--; ) if (b[T] === w) return T;
    }
    function _t(b, w, T, k) {
      if (k ? w[gt(w, k)] = T : w[w.length++] = T, b) {
        T.ownerElement = b;
        var K = b.ownerDocument;
        K && (k && we(K, b, k), be(K, b, T));
      }
    }
    function se(b, w, T) {
      var k = gt(w, T);
      if (k >= 0) {
        for (var K = w.length - 1; k < K; ) w[k] = w[++k];
        if (w.length = K, b) {
          var ot = b.ownerDocument;
          ot && (we(ot, b, T), T.ownerElement = null);
        }
      } else throw new V(x, new Error(b.tagName + "@" + T));
    }
    it.prototype = {
      length: 0,
      item: $.prototype.item,
      getNamedItem: function(b) {
        for (var w = this.length; w--; ) {
          var T = this[w];
          if (T.nodeName == b) return T;
        }
      },
      setNamedItem: function(b) {
        var w = b.ownerElement;
        if (w && w != this._ownerElement) throw new V(E);
        var T = this.getNamedItem(b.nodeName);
        return _t(this._ownerElement, this, b, T), T;
      },
      setNamedItemNS: function(b) {
        var w = b.ownerElement, T;
        if (w && w != this._ownerElement) throw new V(E);
        return T = this.getNamedItemNS(b.namespaceURI, b.localName), _t(this._ownerElement, this, b, T), T;
      },
      removeNamedItem: function(b) {
        var w = this.getNamedItem(b);
        return se(this._ownerElement, this, w), w;
      },
      removeNamedItemNS: function(b, w) {
        var T = this.getNamedItemNS(b, w);
        return se(this._ownerElement, this, T), T;
      },
      getNamedItemNS: function(b, w) {
        for (var T = this.length; T--; ) {
          var k = this[T];
          if (k.localName == w && k.namespaceURI == b) return k;
        }
        return null;
      }
    };
    function te() {
    }
    te.prototype = {
      hasFeature: function(b, w) {
        return true;
      },
      createDocument: function(b, w, T) {
        var k = new tt();
        if (k.implementation = this, k.childNodes = new $(), k.doctype = T || null, T && k.appendChild(T), w) {
          var K = k.createElementNS(b, w);
          k.appendChild(K);
        }
        return k;
      },
      createDocumentType: function(b, w, T) {
        var k = new ji();
        return k.name = b, k.nodeName = b, k.publicId = w || "", k.systemId = T || "", k;
      }
    };
    function ht() {
    }
    ht.prototype = {
      firstChild: null,
      lastChild: null,
      previousSibling: null,
      nextSibling: null,
      attributes: null,
      parentNode: null,
      childNodes: null,
      ownerDocument: null,
      nodeValue: null,
      namespaceURI: null,
      prefix: null,
      localName: null,
      insertBefore: function(b, w) {
        return Hi(this, b, w);
      },
      replaceChild: function(b, w) {
        Hi(this, b, w, Wa), w && this.removeChild(w);
      },
      removeChild: function(b) {
        return sr(this, b);
      },
      appendChild: function(b) {
        return this.insertBefore(b, null);
      },
      hasChildNodes: function() {
        return this.firstChild != null;
      },
      cloneNode: function(b) {
        return En(this.ownerDocument || this, this, b);
      },
      normalize: function() {
        for (var b = this.firstChild; b; ) {
          var w = b.nextSibling;
          w && w.nodeType == p && b.nodeType == p ? (this.removeChild(w), b.appendData(w.data)) : (b.normalize(), b = w);
        }
      },
      isSupported: function(b, w) {
        return this.ownerDocument.implementation.hasFeature(b, w);
      },
      hasAttributes: function() {
        return this.attributes.length > 0;
      },
      lookupPrefix: function(b) {
        for (var w = this; w; ) {
          var T = w._nsMap;
          if (T) {
            for (var k in T) if (Object.prototype.hasOwnProperty.call(T, k) && T[k] === b) return k;
          }
          w = w.nodeType == d ? w.ownerDocument : w.parentNode;
        }
        return null;
      },
      lookupNamespaceURI: function(b) {
        for (var w = this; w; ) {
          var T = w._nsMap;
          if (T && Object.prototype.hasOwnProperty.call(T, b)) return T[b];
          w = w.nodeType == d ? w.ownerDocument : w.parentNode;
        }
        return null;
      },
      isDefaultNamespace: function(b) {
        var w = this.lookupPrefix(b);
        return w == null;
      }
    };
    function Ut(b) {
      return b == "<" && "&lt;" || b == ">" && "&gt;" || b == "&" && "&amp;" || b == '"' && "&quot;" || "&#" + b.charCodeAt() + ";";
    }
    c(u, ht), c(u, ht.prototype);
    function nt(b, w) {
      if (w(b)) return true;
      if (b = b.firstChild) do
        if (nt(b, w)) return true;
      while (b = b.nextSibling);
    }
    function tt() {
      this.ownerDocument = this;
    }
    function be(b, w, T) {
      b && b._inc++;
      var k = T.namespaceURI;
      k === e.XMLNS && (w._nsMap[T.prefix ? T.localName : ""] = T.value);
    }
    function we(b, w, T, k) {
      b && b._inc++;
      var K = T.namespaceURI;
      K === e.XMLNS && delete w._nsMap[T.prefix ? T.localName : ""];
    }
    function He(b, w, T) {
      if (b && b._inc) {
        b._inc++;
        var k = w.childNodes;
        if (T) k[k.length++] = T;
        else {
          for (var K = w.firstChild, ot = 0; K; ) k[ot++] = K, K = K.nextSibling;
          k.length = ot, delete k[k.length];
        }
      }
    }
    function sr(b, w) {
      var T = w.previousSibling, k = w.nextSibling;
      return T ? T.nextSibling = k : b.firstChild = k, k ? k.previousSibling = T : b.lastChild = T, w.parentNode = null, w.previousSibling = null, w.nextSibling = null, He(b.ownerDocument, b), w;
    }
    function Pt(b) {
      return b && (b.nodeType === ht.DOCUMENT_NODE || b.nodeType === ht.DOCUMENT_FRAGMENT_NODE || b.nodeType === ht.ELEMENT_NODE);
    }
    function ee(b) {
      return b && (De(b) || mn(b) || Ee(b) || b.nodeType === ht.DOCUMENT_FRAGMENT_NODE || b.nodeType === ht.COMMENT_NODE || b.nodeType === ht.PROCESSING_INSTRUCTION_NODE);
    }
    function Ee(b) {
      return b && b.nodeType === ht.DOCUMENT_TYPE_NODE;
    }
    function De(b) {
      return b && b.nodeType === ht.ELEMENT_NODE;
    }
    function mn(b) {
      return b && b.nodeType === ht.TEXT_NODE;
    }
    function za(b, w) {
      var T = b.childNodes || [];
      if (t(T, De) || Ee(w)) return false;
      var k = t(T, Ee);
      return !(w && k && T.indexOf(k) > T.indexOf(w));
    }
    function ja(b, w) {
      var T = b.childNodes || [];
      function k(ot) {
        return De(ot) && ot !== w;
      }
      if (t(T, k)) return false;
      var K = t(T, Ee);
      return !(w && K && T.indexOf(K) > T.indexOf(w));
    }
    function bp(b, w, T) {
      if (!Pt(b)) throw new V(z, "Unexpected parent node type " + b.nodeType);
      if (T && T.parentNode !== b) throw new V(x, "child not in parent");
      if (!ee(w) || Ee(w) && b.nodeType !== ht.DOCUMENT_NODE) throw new V(z, "Unexpected node type " + w.nodeType + " for parent node type " + b.nodeType);
    }
    function wp(b, w, T) {
      var k = b.childNodes || [], K = w.childNodes || [];
      if (w.nodeType === ht.DOCUMENT_FRAGMENT_NODE) {
        var ot = K.filter(De);
        if (ot.length > 1 || t(K, mn)) throw new V(z, "More than one element or text in fragment");
        if (ot.length === 1 && !za(b, T)) throw new V(z, "Element in fragment can not be inserted before doctype");
      }
      if (De(w) && !za(b, T)) throw new V(z, "Only one element can be added and only after doctype");
      if (Ee(w)) {
        if (t(k, Ee)) throw new V(z, "Only one doctype is allowed");
        var Bt = t(k, De);
        if (T && k.indexOf(Bt) < k.indexOf(T)) throw new V(z, "Doctype can only be inserted before an element");
        if (!T && Bt) throw new V(z, "Doctype can not be appended since element is present");
      }
    }
    function Wa(b, w, T) {
      var k = b.childNodes || [], K = w.childNodes || [];
      if (w.nodeType === ht.DOCUMENT_FRAGMENT_NODE) {
        var ot = K.filter(De);
        if (ot.length > 1 || t(K, mn)) throw new V(z, "More than one element or text in fragment");
        if (ot.length === 1 && !ja(b, T)) throw new V(z, "Element in fragment can not be inserted before doctype");
      }
      if (De(w) && !ja(b, T)) throw new V(z, "Only one element can be added and only after doctype");
      if (Ee(w)) {
        if (t(k, function(ze) {
          return Ee(ze) && ze !== T;
        })) throw new V(z, "Only one doctype is allowed");
        var Bt = t(k, De);
        if (T && k.indexOf(Bt) < k.indexOf(T)) throw new V(z, "Doctype can only be inserted before an element");
      }
    }
    function Hi(b, w, T, k) {
      bp(b, w, T), b.nodeType === ht.DOCUMENT_NODE && (k || wp)(b, w, T);
      var K = w.parentNode;
      if (K && K.removeChild(w), w.nodeType === H) {
        var ot = w.firstChild;
        if (ot == null) return w;
        var Bt = w.lastChild;
      } else ot = Bt = w;
      var ne = T ? T.previousSibling : b.lastChild;
      ot.previousSibling = ne, Bt.nextSibling = T, ne ? ne.nextSibling = ot : b.firstChild = ot, T == null ? b.lastChild = Bt : T.previousSibling = Bt;
      do
        ot.parentNode = b;
      while (ot !== Bt && (ot = ot.nextSibling));
      return He(b.ownerDocument || b, b), w.nodeType == H && (w.firstChild = w.lastChild = null), w;
    }
    function yp(b, w) {
      return w.parentNode && w.parentNode.removeChild(w), w.parentNode = b, w.previousSibling = b.lastChild, w.nextSibling = null, w.previousSibling ? w.previousSibling.nextSibling = w : b.firstChild = w, b.lastChild = w, He(b.ownerDocument, b, w), w;
    }
    tt.prototype = {
      nodeName: "#document",
      nodeType: C,
      doctype: null,
      documentElement: null,
      _inc: 1,
      insertBefore: function(b, w) {
        if (b.nodeType == H) {
          for (var T = b.firstChild; T; ) {
            var k = T.nextSibling;
            this.insertBefore(T, w), T = k;
          }
          return b;
        }
        return Hi(this, b, w), b.ownerDocument = this, this.documentElement === null && b.nodeType === h && (this.documentElement = b), b;
      },
      removeChild: function(b) {
        return this.documentElement == b && (this.documentElement = null), sr(this, b);
      },
      replaceChild: function(b, w) {
        Hi(this, b, w, Wa), b.ownerDocument = this, w && this.removeChild(w), De(b) && (this.documentElement = b);
      },
      importNode: function(b, w) {
        return Ka(this, b, w);
      },
      getElementById: function(b) {
        var w = null;
        return nt(this.documentElement, function(T) {
          if (T.nodeType == h && T.getAttribute("id") == b) return w = T, true;
        }), w;
      },
      getElementsByClassName: function(b) {
        var w = o(b);
        return new ft(this, function(T) {
          var k = [];
          return w.length > 0 && nt(T.documentElement, function(K) {
            if (K !== T && K.nodeType === h) {
              var ot = K.getAttribute("class");
              if (ot) {
                var Bt = b === ot;
                if (!Bt) {
                  var ne = o(ot);
                  Bt = w.every(a(ne));
                }
                Bt && k.push(K);
              }
            }
          }), k;
        });
      },
      createElement: function(b) {
        var w = new _r();
        w.ownerDocument = this, w.nodeName = b, w.tagName = b, w.localName = b, w.childNodes = new $();
        var T = w.attributes = new it();
        return T._ownerElement = w, w;
      },
      createDocumentFragment: function() {
        var b = new Wi();
        return b.ownerDocument = this, b.childNodes = new $(), b;
      },
      createTextNode: function(b) {
        var w = new bn();
        return w.ownerDocument = this, w.appendData(b), w;
      },
      createComment: function(b) {
        var w = new wn();
        return w.ownerDocument = this, w.appendData(b), w;
      },
      createCDATASection: function(b) {
        var w = new yn();
        return w.ownerDocument = this, w.appendData(b), w;
      },
      createProcessingInstruction: function(b, w) {
        var T = new vn();
        return T.ownerDocument = this, T.tagName = T.nodeName = T.target = b, T.nodeValue = T.data = w, T;
      },
      createAttribute: function(b) {
        var w = new zi();
        return w.ownerDocument = this, w.name = b, w.nodeName = b, w.localName = b, w.specified = true, w;
      },
      createEntityReference: function(b) {
        var w = new xn();
        return w.ownerDocument = this, w.nodeName = b, w;
      },
      createElementNS: function(b, w) {
        var T = new _r(), k = w.split(":"), K = T.attributes = new it();
        return T.childNodes = new $(), T.ownerDocument = this, T.nodeName = w, T.tagName = w, T.namespaceURI = b, k.length == 2 ? (T.prefix = k[0], T.localName = k[1]) : T.localName = w, K._ownerElement = T, T;
      },
      createAttributeNS: function(b, w) {
        var T = new zi(), k = w.split(":");
        return T.ownerDocument = this, T.nodeName = w, T.name = w, T.namespaceURI = b, T.specified = true, k.length == 2 ? (T.prefix = k[0], T.localName = k[1]) : T.localName = w, T;
      }
    }, l(tt, ht);
    function _r() {
      this._nsMap = {};
    }
    _r.prototype = {
      nodeType: h,
      hasAttribute: function(b) {
        return this.getAttributeNode(b) != null;
      },
      getAttribute: function(b) {
        var w = this.getAttributeNode(b);
        return w && w.value || "";
      },
      getAttributeNode: function(b) {
        return this.attributes.getNamedItem(b);
      },
      setAttribute: function(b, w) {
        var T = this.ownerDocument.createAttribute(b);
        T.value = T.nodeValue = "" + w, this.setAttributeNode(T);
      },
      removeAttribute: function(b) {
        var w = this.getAttributeNode(b);
        w && this.removeAttributeNode(w);
      },
      appendChild: function(b) {
        return b.nodeType === H ? this.insertBefore(b, null) : yp(this, b);
      },
      setAttributeNode: function(b) {
        return this.attributes.setNamedItem(b);
      },
      setAttributeNodeNS: function(b) {
        return this.attributes.setNamedItemNS(b);
      },
      removeAttributeNode: function(b) {
        return this.attributes.removeNamedItem(b.nodeName);
      },
      removeAttributeNS: function(b, w) {
        var T = this.getAttributeNodeNS(b, w);
        T && this.removeAttributeNode(T);
      },
      hasAttributeNS: function(b, w) {
        return this.getAttributeNodeNS(b, w) != null;
      },
      getAttributeNS: function(b, w) {
        var T = this.getAttributeNodeNS(b, w);
        return T && T.value || "";
      },
      setAttributeNS: function(b, w, T) {
        var k = this.ownerDocument.createAttributeNS(b, w);
        k.value = k.nodeValue = "" + T, this.setAttributeNode(k);
      },
      getAttributeNodeNS: function(b, w) {
        return this.attributes.getNamedItemNS(b, w);
      },
      getElementsByTagName: function(b) {
        return new ft(this, function(w) {
          var T = [];
          return nt(w, function(k) {
            k !== w && k.nodeType == h && (b === "*" || k.tagName == b) && T.push(k);
          }), T;
        });
      },
      getElementsByTagNameNS: function(b, w) {
        return new ft(this, function(T) {
          var k = [];
          return nt(T, function(K) {
            K !== T && K.nodeType === h && (b === "*" || K.namespaceURI === b) && (w === "*" || K.localName == w) && k.push(K);
          }), k;
        });
      }
    }, tt.prototype.getElementsByTagName = _r.prototype.getElementsByTagName, tt.prototype.getElementsByTagNameNS = _r.prototype.getElementsByTagNameNS, l(_r, ht);
    function zi() {
    }
    zi.prototype.nodeType = d, l(zi, ht);
    function si() {
    }
    si.prototype = {
      data: "",
      substringData: function(b, w) {
        return this.data.substring(b, b + w);
      },
      appendData: function(b) {
        b = this.data + b, this.nodeValue = this.data = b, this.length = b.length;
      },
      insertData: function(b, w) {
        this.replaceData(b, 0, w);
      },
      appendChild: function(b) {
        throw new Error(W[z]);
      },
      deleteData: function(b, w) {
        this.replaceData(b, w, "");
      },
      replaceData: function(b, w, T) {
        var k = this.data.substring(0, b), K = this.data.substring(b + w);
        T = k + T + K, this.nodeValue = this.data = T, this.length = T.length;
      }
    }, l(si, ht);
    function bn() {
    }
    bn.prototype = {
      nodeName: "#text",
      nodeType: p,
      splitText: function(b) {
        var w = this.data, T = w.substring(b);
        w = w.substring(0, b), this.data = this.nodeValue = w, this.length = w.length;
        var k = this.ownerDocument.createTextNode(T);
        return this.parentNode && this.parentNode.insertBefore(k, this.nextSibling), k;
      }
    }, l(bn, si);
    function wn() {
    }
    wn.prototype = {
      nodeName: "#comment",
      nodeType: S
    }, l(wn, si);
    function yn() {
    }
    yn.prototype = {
      nodeName: "#cdata-section",
      nodeType: g
    }, l(yn, si);
    function ji() {
    }
    ji.prototype.nodeType = G, l(ji, ht);
    function Va() {
    }
    Va.prototype.nodeType = Y, l(Va, ht);
    function Xa() {
    }
    Xa.prototype.nodeType = m, l(Xa, ht);
    function xn() {
    }
    xn.prototype.nodeType = y, l(xn, ht);
    function Wi() {
    }
    Wi.prototype.nodeName = "#document-fragment", Wi.prototype.nodeType = H, l(Wi, ht);
    function vn() {
    }
    vn.prototype.nodeType = v, l(vn, ht);
    function qa() {
    }
    qa.prototype.serializeToString = function(b, w, T) {
      return $a.call(b, w, T);
    }, ht.prototype.toString = $a;
    function $a(b, w) {
      var T = [], k = this.nodeType == 9 && this.documentElement || this, K = k.prefix, ot = k.namespaceURI;
      if (ot && K == null) {
        var K = k.lookupPrefix(ot);
        if (K == null) var Bt = [
          {
            namespace: ot,
            prefix: null
          }
        ];
      }
      return Gr(this, T, b, w, Bt), T.join("");
    }
    function Ya(b, w, T) {
      var k = b.prefix || "", K = b.namespaceURI;
      if (!K || k === "xml" && K === e.XML || K === e.XMLNS) return false;
      for (var ot = T.length; ot--; ) {
        var Bt = T[ot];
        if (Bt.prefix === k) return Bt.namespace !== K;
      }
      return true;
    }
    function Sn(b, w, T) {
      b.push(" ", w, '="', T.replace(/[<>&"\t\n\r]/g, Ut), '"');
    }
    function Gr(b, w, T, k, K) {
      if (K || (K = []), k) if (b = k(b), b) {
        if (typeof b == "string") {
          w.push(b);
          return;
        }
      } else return;
      switch (b.nodeType) {
        case h:
          var ot = b.attributes, Bt = ot.length, Jt = b.firstChild, ne = b.tagName;
          T = e.isHTML(b.namespaceURI) || T;
          var ze = ne;
          if (!T && !b.prefix && b.namespaceURI) {
            for (var nr, je = 0; je < ot.length; je++) if (ot.item(je).name === "xmlns") {
              nr = ot.item(je).value;
              break;
            }
            if (!nr) for (var gr = K.length - 1; gr >= 0; gr--) {
              var mr = K[gr];
              if (mr.prefix === "" && mr.namespace === b.namespaceURI) {
                nr = mr.namespace;
                break;
              }
            }
            if (nr !== b.namespaceURI) for (var gr = K.length - 1; gr >= 0; gr--) {
              var mr = K[gr];
              if (mr.namespace === b.namespaceURI) {
                mr.prefix && (ze = mr.prefix + ":" + ne);
                break;
              }
            }
          }
          w.push("<", ze);
          for (var br = 0; br < Bt; br++) {
            var Ie = ot.item(br);
            Ie.prefix == "xmlns" ? K.push({
              prefix: Ie.localName,
              namespace: Ie.value
            }) : Ie.nodeName == "xmlns" && K.push({
              prefix: "",
              namespace: Ie.value
            });
          }
          for (var br = 0; br < Bt; br++) {
            var Ie = ot.item(br);
            if (Ya(Ie, T, K)) {
              var wr = Ie.prefix || "", ni = Ie.namespaceURI;
              Sn(w, wr ? "xmlns:" + wr : "xmlns", ni), K.push({
                prefix: wr,
                namespace: ni
              });
            }
            Gr(Ie, w, T, k, K);
          }
          if (ne === ze && Ya(b, T, K)) {
            var wr = b.prefix || "", ni = b.namespaceURI;
            Sn(w, wr ? "xmlns:" + wr : "xmlns", ni), K.push({
              prefix: wr,
              namespace: ni
            });
          }
          if (Jt || T && !/^(?:meta|link|img|br|hr|input)$/i.test(ne)) {
            if (w.push(">"), T && /^script$/i.test(ne)) for (; Jt; ) Jt.data ? w.push(Jt.data) : Gr(Jt, w, T, k, K.slice()), Jt = Jt.nextSibling;
            else for (; Jt; ) Gr(Jt, w, T, k, K.slice()), Jt = Jt.nextSibling;
            w.push("</", ze, ">");
          } else w.push("/>");
          return;
        case C:
        case H:
          for (var Jt = b.firstChild; Jt; ) Gr(Jt, w, T, k, K.slice()), Jt = Jt.nextSibling;
          return;
        case d:
          return Sn(w, b.name, b.value);
        case p:
          return w.push(b.data.replace(/[<&>]/g, Ut));
        case g:
          return w.push("<![CDATA[", b.data, "]]>");
        case S:
          return w.push("<!--", b.data, "-->");
        case G:
          var Za = b.publicId, Or = b.systemId;
          if (w.push("<!DOCTYPE ", b.name), Za) w.push(" PUBLIC ", Za), Or && Or != "." && w.push(" ", Or), w.push(">");
          else if (Or && Or != ".") w.push(" SYSTEM ", Or, ">");
          else {
            var Qa = b.internalSubset;
            Qa && w.push(" [", Qa, "]"), w.push(">");
          }
          return;
        case v:
          return w.push("<?", b.target, " ", b.data, "?>");
        case y:
          return w.push("&", b.nodeName, ";");
        default:
          w.push("??", b.nodeName);
      }
    }
    function Ka(b, w, T) {
      var k;
      switch (w.nodeType) {
        case h:
          k = w.cloneNode(false), k.ownerDocument = b;
        case H:
          break;
        case d:
          T = true;
          break;
      }
      if (k || (k = w.cloneNode(false)), k.ownerDocument = b, k.parentNode = null, T) for (var K = w.firstChild; K; ) k.appendChild(Ka(b, K, T)), K = K.nextSibling;
      return k;
    }
    function En(b, w, T) {
      var k = new w.constructor();
      for (var K in w) if (Object.prototype.hasOwnProperty.call(w, K)) {
        var ot = w[K];
        typeof ot != "object" && ot != k[K] && (k[K] = ot);
      }
      switch (w.childNodes && (k.childNodes = new $()), k.ownerDocument = b, k.nodeType) {
        case h:
          var Bt = w.attributes, ne = k.attributes = new it(), ze = Bt.length;
          ne._ownerElement = k;
          for (var nr = 0; nr < ze; nr++) k.setAttributeNode(En(b, Bt.item(nr), true));
          break;
        case d:
          T = true;
      }
      if (T) for (var je = w.firstChild; je; ) k.appendChild(En(b, je, T)), je = je.nextSibling;
      return k;
    }
    function Ja(b, w, T) {
      b[w] = T;
    }
    try {
      if (Object.defineProperty) {
        let b = function(w) {
          switch (w.nodeType) {
            case h:
            case H:
              var T = [];
              for (w = w.firstChild; w; ) w.nodeType !== 7 && w.nodeType !== 8 && T.push(b(w)), w = w.nextSibling;
              return T.join("");
            default:
              return w.nodeValue;
          }
        };
        Object.defineProperty(ft.prototype, "length", {
          get: function() {
            return pt(this), this.$$length;
          }
        }), Object.defineProperty(ht.prototype, "textContent", {
          get: function() {
            return b(this);
          },
          set: function(w) {
            switch (this.nodeType) {
              case h:
              case H:
                for (; this.firstChild; ) this.removeChild(this.firstChild);
                (w || String(w)) && this.appendChild(this.ownerDocument.createTextNode(w));
                break;
              default:
                this.data = w, this.value = w, this.nodeValue = w;
            }
          }
        }), Ja = function(w, T, k) {
          w["$$" + T] = k;
        };
      }
    } catch {
    }
    return Xe.DocumentType = ji, Xe.DOMException = V, Xe.DOMImplementation = te, Xe.Element = _r, Xe.Node = ht, Xe.NodeList = $, Xe.XMLSerializer = qa, Xe;
  }
  var fi = {}, io = {}, du;
  function rw() {
    return du || (du = 1, function(i) {
      "use strict";
      var t = rn().freeze;
      i.XML_ENTITIES = t({
        amp: "&",
        apos: "'",
        gt: ">",
        lt: "<",
        quot: '"'
      }), i.HTML_ENTITIES = t({
        Aacute: "\xC1",
        aacute: "\xE1",
        Abreve: "\u0102",
        abreve: "\u0103",
        ac: "\u223E",
        acd: "\u223F",
        acE: "\u223E\u0333",
        Acirc: "\xC2",
        acirc: "\xE2",
        acute: "\xB4",
        Acy: "\u0410",
        acy: "\u0430",
        AElig: "\xC6",
        aelig: "\xE6",
        af: "\u2061",
        Afr: "\u{1D504}",
        afr: "\u{1D51E}",
        Agrave: "\xC0",
        agrave: "\xE0",
        alefsym: "\u2135",
        aleph: "\u2135",
        Alpha: "\u0391",
        alpha: "\u03B1",
        Amacr: "\u0100",
        amacr: "\u0101",
        amalg: "\u2A3F",
        AMP: "&",
        amp: "&",
        And: "\u2A53",
        and: "\u2227",
        andand: "\u2A55",
        andd: "\u2A5C",
        andslope: "\u2A58",
        andv: "\u2A5A",
        ang: "\u2220",
        ange: "\u29A4",
        angle: "\u2220",
        angmsd: "\u2221",
        angmsdaa: "\u29A8",
        angmsdab: "\u29A9",
        angmsdac: "\u29AA",
        angmsdad: "\u29AB",
        angmsdae: "\u29AC",
        angmsdaf: "\u29AD",
        angmsdag: "\u29AE",
        angmsdah: "\u29AF",
        angrt: "\u221F",
        angrtvb: "\u22BE",
        angrtvbd: "\u299D",
        angsph: "\u2222",
        angst: "\xC5",
        angzarr: "\u237C",
        Aogon: "\u0104",
        aogon: "\u0105",
        Aopf: "\u{1D538}",
        aopf: "\u{1D552}",
        ap: "\u2248",
        apacir: "\u2A6F",
        apE: "\u2A70",
        ape: "\u224A",
        apid: "\u224B",
        apos: "'",
        ApplyFunction: "\u2061",
        approx: "\u2248",
        approxeq: "\u224A",
        Aring: "\xC5",
        aring: "\xE5",
        Ascr: "\u{1D49C}",
        ascr: "\u{1D4B6}",
        Assign: "\u2254",
        ast: "*",
        asymp: "\u2248",
        asympeq: "\u224D",
        Atilde: "\xC3",
        atilde: "\xE3",
        Auml: "\xC4",
        auml: "\xE4",
        awconint: "\u2233",
        awint: "\u2A11",
        backcong: "\u224C",
        backepsilon: "\u03F6",
        backprime: "\u2035",
        backsim: "\u223D",
        backsimeq: "\u22CD",
        Backslash: "\u2216",
        Barv: "\u2AE7",
        barvee: "\u22BD",
        Barwed: "\u2306",
        barwed: "\u2305",
        barwedge: "\u2305",
        bbrk: "\u23B5",
        bbrktbrk: "\u23B6",
        bcong: "\u224C",
        Bcy: "\u0411",
        bcy: "\u0431",
        bdquo: "\u201E",
        becaus: "\u2235",
        Because: "\u2235",
        because: "\u2235",
        bemptyv: "\u29B0",
        bepsi: "\u03F6",
        bernou: "\u212C",
        Bernoullis: "\u212C",
        Beta: "\u0392",
        beta: "\u03B2",
        beth: "\u2136",
        between: "\u226C",
        Bfr: "\u{1D505}",
        bfr: "\u{1D51F}",
        bigcap: "\u22C2",
        bigcirc: "\u25EF",
        bigcup: "\u22C3",
        bigodot: "\u2A00",
        bigoplus: "\u2A01",
        bigotimes: "\u2A02",
        bigsqcup: "\u2A06",
        bigstar: "\u2605",
        bigtriangledown: "\u25BD",
        bigtriangleup: "\u25B3",
        biguplus: "\u2A04",
        bigvee: "\u22C1",
        bigwedge: "\u22C0",
        bkarow: "\u290D",
        blacklozenge: "\u29EB",
        blacksquare: "\u25AA",
        blacktriangle: "\u25B4",
        blacktriangledown: "\u25BE",
        blacktriangleleft: "\u25C2",
        blacktriangleright: "\u25B8",
        blank: "\u2423",
        blk12: "\u2592",
        blk14: "\u2591",
        blk34: "\u2593",
        block: "\u2588",
        bne: "=\u20E5",
        bnequiv: "\u2261\u20E5",
        bNot: "\u2AED",
        bnot: "\u2310",
        Bopf: "\u{1D539}",
        bopf: "\u{1D553}",
        bot: "\u22A5",
        bottom: "\u22A5",
        bowtie: "\u22C8",
        boxbox: "\u29C9",
        boxDL: "\u2557",
        boxDl: "\u2556",
        boxdL: "\u2555",
        boxdl: "\u2510",
        boxDR: "\u2554",
        boxDr: "\u2553",
        boxdR: "\u2552",
        boxdr: "\u250C",
        boxH: "\u2550",
        boxh: "\u2500",
        boxHD: "\u2566",
        boxHd: "\u2564",
        boxhD: "\u2565",
        boxhd: "\u252C",
        boxHU: "\u2569",
        boxHu: "\u2567",
        boxhU: "\u2568",
        boxhu: "\u2534",
        boxminus: "\u229F",
        boxplus: "\u229E",
        boxtimes: "\u22A0",
        boxUL: "\u255D",
        boxUl: "\u255C",
        boxuL: "\u255B",
        boxul: "\u2518",
        boxUR: "\u255A",
        boxUr: "\u2559",
        boxuR: "\u2558",
        boxur: "\u2514",
        boxV: "\u2551",
        boxv: "\u2502",
        boxVH: "\u256C",
        boxVh: "\u256B",
        boxvH: "\u256A",
        boxvh: "\u253C",
        boxVL: "\u2563",
        boxVl: "\u2562",
        boxvL: "\u2561",
        boxvl: "\u2524",
        boxVR: "\u2560",
        boxVr: "\u255F",
        boxvR: "\u255E",
        boxvr: "\u251C",
        bprime: "\u2035",
        Breve: "\u02D8",
        breve: "\u02D8",
        brvbar: "\xA6",
        Bscr: "\u212C",
        bscr: "\u{1D4B7}",
        bsemi: "\u204F",
        bsim: "\u223D",
        bsime: "\u22CD",
        bsol: "\\",
        bsolb: "\u29C5",
        bsolhsub: "\u27C8",
        bull: "\u2022",
        bullet: "\u2022",
        bump: "\u224E",
        bumpE: "\u2AAE",
        bumpe: "\u224F",
        Bumpeq: "\u224E",
        bumpeq: "\u224F",
        Cacute: "\u0106",
        cacute: "\u0107",
        Cap: "\u22D2",
        cap: "\u2229",
        capand: "\u2A44",
        capbrcup: "\u2A49",
        capcap: "\u2A4B",
        capcup: "\u2A47",
        capdot: "\u2A40",
        CapitalDifferentialD: "\u2145",
        caps: "\u2229\uFE00",
        caret: "\u2041",
        caron: "\u02C7",
        Cayleys: "\u212D",
        ccaps: "\u2A4D",
        Ccaron: "\u010C",
        ccaron: "\u010D",
        Ccedil: "\xC7",
        ccedil: "\xE7",
        Ccirc: "\u0108",
        ccirc: "\u0109",
        Cconint: "\u2230",
        ccups: "\u2A4C",
        ccupssm: "\u2A50",
        Cdot: "\u010A",
        cdot: "\u010B",
        cedil: "\xB8",
        Cedilla: "\xB8",
        cemptyv: "\u29B2",
        cent: "\xA2",
        CenterDot: "\xB7",
        centerdot: "\xB7",
        Cfr: "\u212D",
        cfr: "\u{1D520}",
        CHcy: "\u0427",
        chcy: "\u0447",
        check: "\u2713",
        checkmark: "\u2713",
        Chi: "\u03A7",
        chi: "\u03C7",
        cir: "\u25CB",
        circ: "\u02C6",
        circeq: "\u2257",
        circlearrowleft: "\u21BA",
        circlearrowright: "\u21BB",
        circledast: "\u229B",
        circledcirc: "\u229A",
        circleddash: "\u229D",
        CircleDot: "\u2299",
        circledR: "\xAE",
        circledS: "\u24C8",
        CircleMinus: "\u2296",
        CirclePlus: "\u2295",
        CircleTimes: "\u2297",
        cirE: "\u29C3",
        cire: "\u2257",
        cirfnint: "\u2A10",
        cirmid: "\u2AEF",
        cirscir: "\u29C2",
        ClockwiseContourIntegral: "\u2232",
        CloseCurlyDoubleQuote: "\u201D",
        CloseCurlyQuote: "\u2019",
        clubs: "\u2663",
        clubsuit: "\u2663",
        Colon: "\u2237",
        colon: ":",
        Colone: "\u2A74",
        colone: "\u2254",
        coloneq: "\u2254",
        comma: ",",
        commat: "@",
        comp: "\u2201",
        compfn: "\u2218",
        complement: "\u2201",
        complexes: "\u2102",
        cong: "\u2245",
        congdot: "\u2A6D",
        Congruent: "\u2261",
        Conint: "\u222F",
        conint: "\u222E",
        ContourIntegral: "\u222E",
        Copf: "\u2102",
        copf: "\u{1D554}",
        coprod: "\u2210",
        Coproduct: "\u2210",
        COPY: "\xA9",
        copy: "\xA9",
        copysr: "\u2117",
        CounterClockwiseContourIntegral: "\u2233",
        crarr: "\u21B5",
        Cross: "\u2A2F",
        cross: "\u2717",
        Cscr: "\u{1D49E}",
        cscr: "\u{1D4B8}",
        csub: "\u2ACF",
        csube: "\u2AD1",
        csup: "\u2AD0",
        csupe: "\u2AD2",
        ctdot: "\u22EF",
        cudarrl: "\u2938",
        cudarrr: "\u2935",
        cuepr: "\u22DE",
        cuesc: "\u22DF",
        cularr: "\u21B6",
        cularrp: "\u293D",
        Cup: "\u22D3",
        cup: "\u222A",
        cupbrcap: "\u2A48",
        CupCap: "\u224D",
        cupcap: "\u2A46",
        cupcup: "\u2A4A",
        cupdot: "\u228D",
        cupor: "\u2A45",
        cups: "\u222A\uFE00",
        curarr: "\u21B7",
        curarrm: "\u293C",
        curlyeqprec: "\u22DE",
        curlyeqsucc: "\u22DF",
        curlyvee: "\u22CE",
        curlywedge: "\u22CF",
        curren: "\xA4",
        curvearrowleft: "\u21B6",
        curvearrowright: "\u21B7",
        cuvee: "\u22CE",
        cuwed: "\u22CF",
        cwconint: "\u2232",
        cwint: "\u2231",
        cylcty: "\u232D",
        Dagger: "\u2021",
        dagger: "\u2020",
        daleth: "\u2138",
        Darr: "\u21A1",
        dArr: "\u21D3",
        darr: "\u2193",
        dash: "\u2010",
        Dashv: "\u2AE4",
        dashv: "\u22A3",
        dbkarow: "\u290F",
        dblac: "\u02DD",
        Dcaron: "\u010E",
        dcaron: "\u010F",
        Dcy: "\u0414",
        dcy: "\u0434",
        DD: "\u2145",
        dd: "\u2146",
        ddagger: "\u2021",
        ddarr: "\u21CA",
        DDotrahd: "\u2911",
        ddotseq: "\u2A77",
        deg: "\xB0",
        Del: "\u2207",
        Delta: "\u0394",
        delta: "\u03B4",
        demptyv: "\u29B1",
        dfisht: "\u297F",
        Dfr: "\u{1D507}",
        dfr: "\u{1D521}",
        dHar: "\u2965",
        dharl: "\u21C3",
        dharr: "\u21C2",
        DiacriticalAcute: "\xB4",
        DiacriticalDot: "\u02D9",
        DiacriticalDoubleAcute: "\u02DD",
        DiacriticalGrave: "`",
        DiacriticalTilde: "\u02DC",
        diam: "\u22C4",
        Diamond: "\u22C4",
        diamond: "\u22C4",
        diamondsuit: "\u2666",
        diams: "\u2666",
        die: "\xA8",
        DifferentialD: "\u2146",
        digamma: "\u03DD",
        disin: "\u22F2",
        div: "\xF7",
        divide: "\xF7",
        divideontimes: "\u22C7",
        divonx: "\u22C7",
        DJcy: "\u0402",
        djcy: "\u0452",
        dlcorn: "\u231E",
        dlcrop: "\u230D",
        dollar: "$",
        Dopf: "\u{1D53B}",
        dopf: "\u{1D555}",
        Dot: "\xA8",
        dot: "\u02D9",
        DotDot: "\u20DC",
        doteq: "\u2250",
        doteqdot: "\u2251",
        DotEqual: "\u2250",
        dotminus: "\u2238",
        dotplus: "\u2214",
        dotsquare: "\u22A1",
        doublebarwedge: "\u2306",
        DoubleContourIntegral: "\u222F",
        DoubleDot: "\xA8",
        DoubleDownArrow: "\u21D3",
        DoubleLeftArrow: "\u21D0",
        DoubleLeftRightArrow: "\u21D4",
        DoubleLeftTee: "\u2AE4",
        DoubleLongLeftArrow: "\u27F8",
        DoubleLongLeftRightArrow: "\u27FA",
        DoubleLongRightArrow: "\u27F9",
        DoubleRightArrow: "\u21D2",
        DoubleRightTee: "\u22A8",
        DoubleUpArrow: "\u21D1",
        DoubleUpDownArrow: "\u21D5",
        DoubleVerticalBar: "\u2225",
        DownArrow: "\u2193",
        Downarrow: "\u21D3",
        downarrow: "\u2193",
        DownArrowBar: "\u2913",
        DownArrowUpArrow: "\u21F5",
        DownBreve: "\u0311",
        downdownarrows: "\u21CA",
        downharpoonleft: "\u21C3",
        downharpoonright: "\u21C2",
        DownLeftRightVector: "\u2950",
        DownLeftTeeVector: "\u295E",
        DownLeftVector: "\u21BD",
        DownLeftVectorBar: "\u2956",
        DownRightTeeVector: "\u295F",
        DownRightVector: "\u21C1",
        DownRightVectorBar: "\u2957",
        DownTee: "\u22A4",
        DownTeeArrow: "\u21A7",
        drbkarow: "\u2910",
        drcorn: "\u231F",
        drcrop: "\u230C",
        Dscr: "\u{1D49F}",
        dscr: "\u{1D4B9}",
        DScy: "\u0405",
        dscy: "\u0455",
        dsol: "\u29F6",
        Dstrok: "\u0110",
        dstrok: "\u0111",
        dtdot: "\u22F1",
        dtri: "\u25BF",
        dtrif: "\u25BE",
        duarr: "\u21F5",
        duhar: "\u296F",
        dwangle: "\u29A6",
        DZcy: "\u040F",
        dzcy: "\u045F",
        dzigrarr: "\u27FF",
        Eacute: "\xC9",
        eacute: "\xE9",
        easter: "\u2A6E",
        Ecaron: "\u011A",
        ecaron: "\u011B",
        ecir: "\u2256",
        Ecirc: "\xCA",
        ecirc: "\xEA",
        ecolon: "\u2255",
        Ecy: "\u042D",
        ecy: "\u044D",
        eDDot: "\u2A77",
        Edot: "\u0116",
        eDot: "\u2251",
        edot: "\u0117",
        ee: "\u2147",
        efDot: "\u2252",
        Efr: "\u{1D508}",
        efr: "\u{1D522}",
        eg: "\u2A9A",
        Egrave: "\xC8",
        egrave: "\xE8",
        egs: "\u2A96",
        egsdot: "\u2A98",
        el: "\u2A99",
        Element: "\u2208",
        elinters: "\u23E7",
        ell: "\u2113",
        els: "\u2A95",
        elsdot: "\u2A97",
        Emacr: "\u0112",
        emacr: "\u0113",
        empty: "\u2205",
        emptyset: "\u2205",
        EmptySmallSquare: "\u25FB",
        emptyv: "\u2205",
        EmptyVerySmallSquare: "\u25AB",
        emsp: "\u2003",
        emsp13: "\u2004",
        emsp14: "\u2005",
        ENG: "\u014A",
        eng: "\u014B",
        ensp: "\u2002",
        Eogon: "\u0118",
        eogon: "\u0119",
        Eopf: "\u{1D53C}",
        eopf: "\u{1D556}",
        epar: "\u22D5",
        eparsl: "\u29E3",
        eplus: "\u2A71",
        epsi: "\u03B5",
        Epsilon: "\u0395",
        epsilon: "\u03B5",
        epsiv: "\u03F5",
        eqcirc: "\u2256",
        eqcolon: "\u2255",
        eqsim: "\u2242",
        eqslantgtr: "\u2A96",
        eqslantless: "\u2A95",
        Equal: "\u2A75",
        equals: "=",
        EqualTilde: "\u2242",
        equest: "\u225F",
        Equilibrium: "\u21CC",
        equiv: "\u2261",
        equivDD: "\u2A78",
        eqvparsl: "\u29E5",
        erarr: "\u2971",
        erDot: "\u2253",
        Escr: "\u2130",
        escr: "\u212F",
        esdot: "\u2250",
        Esim: "\u2A73",
        esim: "\u2242",
        Eta: "\u0397",
        eta: "\u03B7",
        ETH: "\xD0",
        eth: "\xF0",
        Euml: "\xCB",
        euml: "\xEB",
        euro: "\u20AC",
        excl: "!",
        exist: "\u2203",
        Exists: "\u2203",
        expectation: "\u2130",
        ExponentialE: "\u2147",
        exponentiale: "\u2147",
        fallingdotseq: "\u2252",
        Fcy: "\u0424",
        fcy: "\u0444",
        female: "\u2640",
        ffilig: "\uFB03",
        fflig: "\uFB00",
        ffllig: "\uFB04",
        Ffr: "\u{1D509}",
        ffr: "\u{1D523}",
        filig: "\uFB01",
        FilledSmallSquare: "\u25FC",
        FilledVerySmallSquare: "\u25AA",
        fjlig: "fj",
        flat: "\u266D",
        fllig: "\uFB02",
        fltns: "\u25B1",
        fnof: "\u0192",
        Fopf: "\u{1D53D}",
        fopf: "\u{1D557}",
        ForAll: "\u2200",
        forall: "\u2200",
        fork: "\u22D4",
        forkv: "\u2AD9",
        Fouriertrf: "\u2131",
        fpartint: "\u2A0D",
        frac12: "\xBD",
        frac13: "\u2153",
        frac14: "\xBC",
        frac15: "\u2155",
        frac16: "\u2159",
        frac18: "\u215B",
        frac23: "\u2154",
        frac25: "\u2156",
        frac34: "\xBE",
        frac35: "\u2157",
        frac38: "\u215C",
        frac45: "\u2158",
        frac56: "\u215A",
        frac58: "\u215D",
        frac78: "\u215E",
        frasl: "\u2044",
        frown: "\u2322",
        Fscr: "\u2131",
        fscr: "\u{1D4BB}",
        gacute: "\u01F5",
        Gamma: "\u0393",
        gamma: "\u03B3",
        Gammad: "\u03DC",
        gammad: "\u03DD",
        gap: "\u2A86",
        Gbreve: "\u011E",
        gbreve: "\u011F",
        Gcedil: "\u0122",
        Gcirc: "\u011C",
        gcirc: "\u011D",
        Gcy: "\u0413",
        gcy: "\u0433",
        Gdot: "\u0120",
        gdot: "\u0121",
        gE: "\u2267",
        ge: "\u2265",
        gEl: "\u2A8C",
        gel: "\u22DB",
        geq: "\u2265",
        geqq: "\u2267",
        geqslant: "\u2A7E",
        ges: "\u2A7E",
        gescc: "\u2AA9",
        gesdot: "\u2A80",
        gesdoto: "\u2A82",
        gesdotol: "\u2A84",
        gesl: "\u22DB\uFE00",
        gesles: "\u2A94",
        Gfr: "\u{1D50A}",
        gfr: "\u{1D524}",
        Gg: "\u22D9",
        gg: "\u226B",
        ggg: "\u22D9",
        gimel: "\u2137",
        GJcy: "\u0403",
        gjcy: "\u0453",
        gl: "\u2277",
        gla: "\u2AA5",
        glE: "\u2A92",
        glj: "\u2AA4",
        gnap: "\u2A8A",
        gnapprox: "\u2A8A",
        gnE: "\u2269",
        gne: "\u2A88",
        gneq: "\u2A88",
        gneqq: "\u2269",
        gnsim: "\u22E7",
        Gopf: "\u{1D53E}",
        gopf: "\u{1D558}",
        grave: "`",
        GreaterEqual: "\u2265",
        GreaterEqualLess: "\u22DB",
        GreaterFullEqual: "\u2267",
        GreaterGreater: "\u2AA2",
        GreaterLess: "\u2277",
        GreaterSlantEqual: "\u2A7E",
        GreaterTilde: "\u2273",
        Gscr: "\u{1D4A2}",
        gscr: "\u210A",
        gsim: "\u2273",
        gsime: "\u2A8E",
        gsiml: "\u2A90",
        Gt: "\u226B",
        GT: ">",
        gt: ">",
        gtcc: "\u2AA7",
        gtcir: "\u2A7A",
        gtdot: "\u22D7",
        gtlPar: "\u2995",
        gtquest: "\u2A7C",
        gtrapprox: "\u2A86",
        gtrarr: "\u2978",
        gtrdot: "\u22D7",
        gtreqless: "\u22DB",
        gtreqqless: "\u2A8C",
        gtrless: "\u2277",
        gtrsim: "\u2273",
        gvertneqq: "\u2269\uFE00",
        gvnE: "\u2269\uFE00",
        Hacek: "\u02C7",
        hairsp: "\u200A",
        half: "\xBD",
        hamilt: "\u210B",
        HARDcy: "\u042A",
        hardcy: "\u044A",
        hArr: "\u21D4",
        harr: "\u2194",
        harrcir: "\u2948",
        harrw: "\u21AD",
        Hat: "^",
        hbar: "\u210F",
        Hcirc: "\u0124",
        hcirc: "\u0125",
        hearts: "\u2665",
        heartsuit: "\u2665",
        hellip: "\u2026",
        hercon: "\u22B9",
        Hfr: "\u210C",
        hfr: "\u{1D525}",
        HilbertSpace: "\u210B",
        hksearow: "\u2925",
        hkswarow: "\u2926",
        hoarr: "\u21FF",
        homtht: "\u223B",
        hookleftarrow: "\u21A9",
        hookrightarrow: "\u21AA",
        Hopf: "\u210D",
        hopf: "\u{1D559}",
        horbar: "\u2015",
        HorizontalLine: "\u2500",
        Hscr: "\u210B",
        hscr: "\u{1D4BD}",
        hslash: "\u210F",
        Hstrok: "\u0126",
        hstrok: "\u0127",
        HumpDownHump: "\u224E",
        HumpEqual: "\u224F",
        hybull: "\u2043",
        hyphen: "\u2010",
        Iacute: "\xCD",
        iacute: "\xED",
        ic: "\u2063",
        Icirc: "\xCE",
        icirc: "\xEE",
        Icy: "\u0418",
        icy: "\u0438",
        Idot: "\u0130",
        IEcy: "\u0415",
        iecy: "\u0435",
        iexcl: "\xA1",
        iff: "\u21D4",
        Ifr: "\u2111",
        ifr: "\u{1D526}",
        Igrave: "\xCC",
        igrave: "\xEC",
        ii: "\u2148",
        iiiint: "\u2A0C",
        iiint: "\u222D",
        iinfin: "\u29DC",
        iiota: "\u2129",
        IJlig: "\u0132",
        ijlig: "\u0133",
        Im: "\u2111",
        Imacr: "\u012A",
        imacr: "\u012B",
        image: "\u2111",
        ImaginaryI: "\u2148",
        imagline: "\u2110",
        imagpart: "\u2111",
        imath: "\u0131",
        imof: "\u22B7",
        imped: "\u01B5",
        Implies: "\u21D2",
        in: "\u2208",
        incare: "\u2105",
        infin: "\u221E",
        infintie: "\u29DD",
        inodot: "\u0131",
        Int: "\u222C",
        int: "\u222B",
        intcal: "\u22BA",
        integers: "\u2124",
        Integral: "\u222B",
        intercal: "\u22BA",
        Intersection: "\u22C2",
        intlarhk: "\u2A17",
        intprod: "\u2A3C",
        InvisibleComma: "\u2063",
        InvisibleTimes: "\u2062",
        IOcy: "\u0401",
        iocy: "\u0451",
        Iogon: "\u012E",
        iogon: "\u012F",
        Iopf: "\u{1D540}",
        iopf: "\u{1D55A}",
        Iota: "\u0399",
        iota: "\u03B9",
        iprod: "\u2A3C",
        iquest: "\xBF",
        Iscr: "\u2110",
        iscr: "\u{1D4BE}",
        isin: "\u2208",
        isindot: "\u22F5",
        isinE: "\u22F9",
        isins: "\u22F4",
        isinsv: "\u22F3",
        isinv: "\u2208",
        it: "\u2062",
        Itilde: "\u0128",
        itilde: "\u0129",
        Iukcy: "\u0406",
        iukcy: "\u0456",
        Iuml: "\xCF",
        iuml: "\xEF",
        Jcirc: "\u0134",
        jcirc: "\u0135",
        Jcy: "\u0419",
        jcy: "\u0439",
        Jfr: "\u{1D50D}",
        jfr: "\u{1D527}",
        jmath: "\u0237",
        Jopf: "\u{1D541}",
        jopf: "\u{1D55B}",
        Jscr: "\u{1D4A5}",
        jscr: "\u{1D4BF}",
        Jsercy: "\u0408",
        jsercy: "\u0458",
        Jukcy: "\u0404",
        jukcy: "\u0454",
        Kappa: "\u039A",
        kappa: "\u03BA",
        kappav: "\u03F0",
        Kcedil: "\u0136",
        kcedil: "\u0137",
        Kcy: "\u041A",
        kcy: "\u043A",
        Kfr: "\u{1D50E}",
        kfr: "\u{1D528}",
        kgreen: "\u0138",
        KHcy: "\u0425",
        khcy: "\u0445",
        KJcy: "\u040C",
        kjcy: "\u045C",
        Kopf: "\u{1D542}",
        kopf: "\u{1D55C}",
        Kscr: "\u{1D4A6}",
        kscr: "\u{1D4C0}",
        lAarr: "\u21DA",
        Lacute: "\u0139",
        lacute: "\u013A",
        laemptyv: "\u29B4",
        lagran: "\u2112",
        Lambda: "\u039B",
        lambda: "\u03BB",
        Lang: "\u27EA",
        lang: "\u27E8",
        langd: "\u2991",
        langle: "\u27E8",
        lap: "\u2A85",
        Laplacetrf: "\u2112",
        laquo: "\xAB",
        Larr: "\u219E",
        lArr: "\u21D0",
        larr: "\u2190",
        larrb: "\u21E4",
        larrbfs: "\u291F",
        larrfs: "\u291D",
        larrhk: "\u21A9",
        larrlp: "\u21AB",
        larrpl: "\u2939",
        larrsim: "\u2973",
        larrtl: "\u21A2",
        lat: "\u2AAB",
        lAtail: "\u291B",
        latail: "\u2919",
        late: "\u2AAD",
        lates: "\u2AAD\uFE00",
        lBarr: "\u290E",
        lbarr: "\u290C",
        lbbrk: "\u2772",
        lbrace: "{",
        lbrack: "[",
        lbrke: "\u298B",
        lbrksld: "\u298F",
        lbrkslu: "\u298D",
        Lcaron: "\u013D",
        lcaron: "\u013E",
        Lcedil: "\u013B",
        lcedil: "\u013C",
        lceil: "\u2308",
        lcub: "{",
        Lcy: "\u041B",
        lcy: "\u043B",
        ldca: "\u2936",
        ldquo: "\u201C",
        ldquor: "\u201E",
        ldrdhar: "\u2967",
        ldrushar: "\u294B",
        ldsh: "\u21B2",
        lE: "\u2266",
        le: "\u2264",
        LeftAngleBracket: "\u27E8",
        LeftArrow: "\u2190",
        Leftarrow: "\u21D0",
        leftarrow: "\u2190",
        LeftArrowBar: "\u21E4",
        LeftArrowRightArrow: "\u21C6",
        leftarrowtail: "\u21A2",
        LeftCeiling: "\u2308",
        LeftDoubleBracket: "\u27E6",
        LeftDownTeeVector: "\u2961",
        LeftDownVector: "\u21C3",
        LeftDownVectorBar: "\u2959",
        LeftFloor: "\u230A",
        leftharpoondown: "\u21BD",
        leftharpoonup: "\u21BC",
        leftleftarrows: "\u21C7",
        LeftRightArrow: "\u2194",
        Leftrightarrow: "\u21D4",
        leftrightarrow: "\u2194",
        leftrightarrows: "\u21C6",
        leftrightharpoons: "\u21CB",
        leftrightsquigarrow: "\u21AD",
        LeftRightVector: "\u294E",
        LeftTee: "\u22A3",
        LeftTeeArrow: "\u21A4",
        LeftTeeVector: "\u295A",
        leftthreetimes: "\u22CB",
        LeftTriangle: "\u22B2",
        LeftTriangleBar: "\u29CF",
        LeftTriangleEqual: "\u22B4",
        LeftUpDownVector: "\u2951",
        LeftUpTeeVector: "\u2960",
        LeftUpVector: "\u21BF",
        LeftUpVectorBar: "\u2958",
        LeftVector: "\u21BC",
        LeftVectorBar: "\u2952",
        lEg: "\u2A8B",
        leg: "\u22DA",
        leq: "\u2264",
        leqq: "\u2266",
        leqslant: "\u2A7D",
        les: "\u2A7D",
        lescc: "\u2AA8",
        lesdot: "\u2A7F",
        lesdoto: "\u2A81",
        lesdotor: "\u2A83",
        lesg: "\u22DA\uFE00",
        lesges: "\u2A93",
        lessapprox: "\u2A85",
        lessdot: "\u22D6",
        lesseqgtr: "\u22DA",
        lesseqqgtr: "\u2A8B",
        LessEqualGreater: "\u22DA",
        LessFullEqual: "\u2266",
        LessGreater: "\u2276",
        lessgtr: "\u2276",
        LessLess: "\u2AA1",
        lesssim: "\u2272",
        LessSlantEqual: "\u2A7D",
        LessTilde: "\u2272",
        lfisht: "\u297C",
        lfloor: "\u230A",
        Lfr: "\u{1D50F}",
        lfr: "\u{1D529}",
        lg: "\u2276",
        lgE: "\u2A91",
        lHar: "\u2962",
        lhard: "\u21BD",
        lharu: "\u21BC",
        lharul: "\u296A",
        lhblk: "\u2584",
        LJcy: "\u0409",
        ljcy: "\u0459",
        Ll: "\u22D8",
        ll: "\u226A",
        llarr: "\u21C7",
        llcorner: "\u231E",
        Lleftarrow: "\u21DA",
        llhard: "\u296B",
        lltri: "\u25FA",
        Lmidot: "\u013F",
        lmidot: "\u0140",
        lmoust: "\u23B0",
        lmoustache: "\u23B0",
        lnap: "\u2A89",
        lnapprox: "\u2A89",
        lnE: "\u2268",
        lne: "\u2A87",
        lneq: "\u2A87",
        lneqq: "\u2268",
        lnsim: "\u22E6",
        loang: "\u27EC",
        loarr: "\u21FD",
        lobrk: "\u27E6",
        LongLeftArrow: "\u27F5",
        Longleftarrow: "\u27F8",
        longleftarrow: "\u27F5",
        LongLeftRightArrow: "\u27F7",
        Longleftrightarrow: "\u27FA",
        longleftrightarrow: "\u27F7",
        longmapsto: "\u27FC",
        LongRightArrow: "\u27F6",
        Longrightarrow: "\u27F9",
        longrightarrow: "\u27F6",
        looparrowleft: "\u21AB",
        looparrowright: "\u21AC",
        lopar: "\u2985",
        Lopf: "\u{1D543}",
        lopf: "\u{1D55D}",
        loplus: "\u2A2D",
        lotimes: "\u2A34",
        lowast: "\u2217",
        lowbar: "_",
        LowerLeftArrow: "\u2199",
        LowerRightArrow: "\u2198",
        loz: "\u25CA",
        lozenge: "\u25CA",
        lozf: "\u29EB",
        lpar: "(",
        lparlt: "\u2993",
        lrarr: "\u21C6",
        lrcorner: "\u231F",
        lrhar: "\u21CB",
        lrhard: "\u296D",
        lrm: "\u200E",
        lrtri: "\u22BF",
        lsaquo: "\u2039",
        Lscr: "\u2112",
        lscr: "\u{1D4C1}",
        Lsh: "\u21B0",
        lsh: "\u21B0",
        lsim: "\u2272",
        lsime: "\u2A8D",
        lsimg: "\u2A8F",
        lsqb: "[",
        lsquo: "\u2018",
        lsquor: "\u201A",
        Lstrok: "\u0141",
        lstrok: "\u0142",
        Lt: "\u226A",
        LT: "<",
        lt: "<",
        ltcc: "\u2AA6",
        ltcir: "\u2A79",
        ltdot: "\u22D6",
        lthree: "\u22CB",
        ltimes: "\u22C9",
        ltlarr: "\u2976",
        ltquest: "\u2A7B",
        ltri: "\u25C3",
        ltrie: "\u22B4",
        ltrif: "\u25C2",
        ltrPar: "\u2996",
        lurdshar: "\u294A",
        luruhar: "\u2966",
        lvertneqq: "\u2268\uFE00",
        lvnE: "\u2268\uFE00",
        macr: "\xAF",
        male: "\u2642",
        malt: "\u2720",
        maltese: "\u2720",
        Map: "\u2905",
        map: "\u21A6",
        mapsto: "\u21A6",
        mapstodown: "\u21A7",
        mapstoleft: "\u21A4",
        mapstoup: "\u21A5",
        marker: "\u25AE",
        mcomma: "\u2A29",
        Mcy: "\u041C",
        mcy: "\u043C",
        mdash: "\u2014",
        mDDot: "\u223A",
        measuredangle: "\u2221",
        MediumSpace: "\u205F",
        Mellintrf: "\u2133",
        Mfr: "\u{1D510}",
        mfr: "\u{1D52A}",
        mho: "\u2127",
        micro: "\xB5",
        mid: "\u2223",
        midast: "*",
        midcir: "\u2AF0",
        middot: "\xB7",
        minus: "\u2212",
        minusb: "\u229F",
        minusd: "\u2238",
        minusdu: "\u2A2A",
        MinusPlus: "\u2213",
        mlcp: "\u2ADB",
        mldr: "\u2026",
        mnplus: "\u2213",
        models: "\u22A7",
        Mopf: "\u{1D544}",
        mopf: "\u{1D55E}",
        mp: "\u2213",
        Mscr: "\u2133",
        mscr: "\u{1D4C2}",
        mstpos: "\u223E",
        Mu: "\u039C",
        mu: "\u03BC",
        multimap: "\u22B8",
        mumap: "\u22B8",
        nabla: "\u2207",
        Nacute: "\u0143",
        nacute: "\u0144",
        nang: "\u2220\u20D2",
        nap: "\u2249",
        napE: "\u2A70\u0338",
        napid: "\u224B\u0338",
        napos: "\u0149",
        napprox: "\u2249",
        natur: "\u266E",
        natural: "\u266E",
        naturals: "\u2115",
        nbsp: "\xA0",
        nbump: "\u224E\u0338",
        nbumpe: "\u224F\u0338",
        ncap: "\u2A43",
        Ncaron: "\u0147",
        ncaron: "\u0148",
        Ncedil: "\u0145",
        ncedil: "\u0146",
        ncong: "\u2247",
        ncongdot: "\u2A6D\u0338",
        ncup: "\u2A42",
        Ncy: "\u041D",
        ncy: "\u043D",
        ndash: "\u2013",
        ne: "\u2260",
        nearhk: "\u2924",
        neArr: "\u21D7",
        nearr: "\u2197",
        nearrow: "\u2197",
        nedot: "\u2250\u0338",
        NegativeMediumSpace: "\u200B",
        NegativeThickSpace: "\u200B",
        NegativeThinSpace: "\u200B",
        NegativeVeryThinSpace: "\u200B",
        nequiv: "\u2262",
        nesear: "\u2928",
        nesim: "\u2242\u0338",
        NestedGreaterGreater: "\u226B",
        NestedLessLess: "\u226A",
        NewLine: `
`,
        nexist: "\u2204",
        nexists: "\u2204",
        Nfr: "\u{1D511}",
        nfr: "\u{1D52B}",
        ngE: "\u2267\u0338",
        nge: "\u2271",
        ngeq: "\u2271",
        ngeqq: "\u2267\u0338",
        ngeqslant: "\u2A7E\u0338",
        nges: "\u2A7E\u0338",
        nGg: "\u22D9\u0338",
        ngsim: "\u2275",
        nGt: "\u226B\u20D2",
        ngt: "\u226F",
        ngtr: "\u226F",
        nGtv: "\u226B\u0338",
        nhArr: "\u21CE",
        nharr: "\u21AE",
        nhpar: "\u2AF2",
        ni: "\u220B",
        nis: "\u22FC",
        nisd: "\u22FA",
        niv: "\u220B",
        NJcy: "\u040A",
        njcy: "\u045A",
        nlArr: "\u21CD",
        nlarr: "\u219A",
        nldr: "\u2025",
        nlE: "\u2266\u0338",
        nle: "\u2270",
        nLeftarrow: "\u21CD",
        nleftarrow: "\u219A",
        nLeftrightarrow: "\u21CE",
        nleftrightarrow: "\u21AE",
        nleq: "\u2270",
        nleqq: "\u2266\u0338",
        nleqslant: "\u2A7D\u0338",
        nles: "\u2A7D\u0338",
        nless: "\u226E",
        nLl: "\u22D8\u0338",
        nlsim: "\u2274",
        nLt: "\u226A\u20D2",
        nlt: "\u226E",
        nltri: "\u22EA",
        nltrie: "\u22EC",
        nLtv: "\u226A\u0338",
        nmid: "\u2224",
        NoBreak: "\u2060",
        NonBreakingSpace: "\xA0",
        Nopf: "\u2115",
        nopf: "\u{1D55F}",
        Not: "\u2AEC",
        not: "\xAC",
        NotCongruent: "\u2262",
        NotCupCap: "\u226D",
        NotDoubleVerticalBar: "\u2226",
        NotElement: "\u2209",
        NotEqual: "\u2260",
        NotEqualTilde: "\u2242\u0338",
        NotExists: "\u2204",
        NotGreater: "\u226F",
        NotGreaterEqual: "\u2271",
        NotGreaterFullEqual: "\u2267\u0338",
        NotGreaterGreater: "\u226B\u0338",
        NotGreaterLess: "\u2279",
        NotGreaterSlantEqual: "\u2A7E\u0338",
        NotGreaterTilde: "\u2275",
        NotHumpDownHump: "\u224E\u0338",
        NotHumpEqual: "\u224F\u0338",
        notin: "\u2209",
        notindot: "\u22F5\u0338",
        notinE: "\u22F9\u0338",
        notinva: "\u2209",
        notinvb: "\u22F7",
        notinvc: "\u22F6",
        NotLeftTriangle: "\u22EA",
        NotLeftTriangleBar: "\u29CF\u0338",
        NotLeftTriangleEqual: "\u22EC",
        NotLess: "\u226E",
        NotLessEqual: "\u2270",
        NotLessGreater: "\u2278",
        NotLessLess: "\u226A\u0338",
        NotLessSlantEqual: "\u2A7D\u0338",
        NotLessTilde: "\u2274",
        NotNestedGreaterGreater: "\u2AA2\u0338",
        NotNestedLessLess: "\u2AA1\u0338",
        notni: "\u220C",
        notniva: "\u220C",
        notnivb: "\u22FE",
        notnivc: "\u22FD",
        NotPrecedes: "\u2280",
        NotPrecedesEqual: "\u2AAF\u0338",
        NotPrecedesSlantEqual: "\u22E0",
        NotReverseElement: "\u220C",
        NotRightTriangle: "\u22EB",
        NotRightTriangleBar: "\u29D0\u0338",
        NotRightTriangleEqual: "\u22ED",
        NotSquareSubset: "\u228F\u0338",
        NotSquareSubsetEqual: "\u22E2",
        NotSquareSuperset: "\u2290\u0338",
        NotSquareSupersetEqual: "\u22E3",
        NotSubset: "\u2282\u20D2",
        NotSubsetEqual: "\u2288",
        NotSucceeds: "\u2281",
        NotSucceedsEqual: "\u2AB0\u0338",
        NotSucceedsSlantEqual: "\u22E1",
        NotSucceedsTilde: "\u227F\u0338",
        NotSuperset: "\u2283\u20D2",
        NotSupersetEqual: "\u2289",
        NotTilde: "\u2241",
        NotTildeEqual: "\u2244",
        NotTildeFullEqual: "\u2247",
        NotTildeTilde: "\u2249",
        NotVerticalBar: "\u2224",
        npar: "\u2226",
        nparallel: "\u2226",
        nparsl: "\u2AFD\u20E5",
        npart: "\u2202\u0338",
        npolint: "\u2A14",
        npr: "\u2280",
        nprcue: "\u22E0",
        npre: "\u2AAF\u0338",
        nprec: "\u2280",
        npreceq: "\u2AAF\u0338",
        nrArr: "\u21CF",
        nrarr: "\u219B",
        nrarrc: "\u2933\u0338",
        nrarrw: "\u219D\u0338",
        nRightarrow: "\u21CF",
        nrightarrow: "\u219B",
        nrtri: "\u22EB",
        nrtrie: "\u22ED",
        nsc: "\u2281",
        nsccue: "\u22E1",
        nsce: "\u2AB0\u0338",
        Nscr: "\u{1D4A9}",
        nscr: "\u{1D4C3}",
        nshortmid: "\u2224",
        nshortparallel: "\u2226",
        nsim: "\u2241",
        nsime: "\u2244",
        nsimeq: "\u2244",
        nsmid: "\u2224",
        nspar: "\u2226",
        nsqsube: "\u22E2",
        nsqsupe: "\u22E3",
        nsub: "\u2284",
        nsubE: "\u2AC5\u0338",
        nsube: "\u2288",
        nsubset: "\u2282\u20D2",
        nsubseteq: "\u2288",
        nsubseteqq: "\u2AC5\u0338",
        nsucc: "\u2281",
        nsucceq: "\u2AB0\u0338",
        nsup: "\u2285",
        nsupE: "\u2AC6\u0338",
        nsupe: "\u2289",
        nsupset: "\u2283\u20D2",
        nsupseteq: "\u2289",
        nsupseteqq: "\u2AC6\u0338",
        ntgl: "\u2279",
        Ntilde: "\xD1",
        ntilde: "\xF1",
        ntlg: "\u2278",
        ntriangleleft: "\u22EA",
        ntrianglelefteq: "\u22EC",
        ntriangleright: "\u22EB",
        ntrianglerighteq: "\u22ED",
        Nu: "\u039D",
        nu: "\u03BD",
        num: "#",
        numero: "\u2116",
        numsp: "\u2007",
        nvap: "\u224D\u20D2",
        nVDash: "\u22AF",
        nVdash: "\u22AE",
        nvDash: "\u22AD",
        nvdash: "\u22AC",
        nvge: "\u2265\u20D2",
        nvgt: ">\u20D2",
        nvHarr: "\u2904",
        nvinfin: "\u29DE",
        nvlArr: "\u2902",
        nvle: "\u2264\u20D2",
        nvlt: "<\u20D2",
        nvltrie: "\u22B4\u20D2",
        nvrArr: "\u2903",
        nvrtrie: "\u22B5\u20D2",
        nvsim: "\u223C\u20D2",
        nwarhk: "\u2923",
        nwArr: "\u21D6",
        nwarr: "\u2196",
        nwarrow: "\u2196",
        nwnear: "\u2927",
        Oacute: "\xD3",
        oacute: "\xF3",
        oast: "\u229B",
        ocir: "\u229A",
        Ocirc: "\xD4",
        ocirc: "\xF4",
        Ocy: "\u041E",
        ocy: "\u043E",
        odash: "\u229D",
        Odblac: "\u0150",
        odblac: "\u0151",
        odiv: "\u2A38",
        odot: "\u2299",
        odsold: "\u29BC",
        OElig: "\u0152",
        oelig: "\u0153",
        ofcir: "\u29BF",
        Ofr: "\u{1D512}",
        ofr: "\u{1D52C}",
        ogon: "\u02DB",
        Ograve: "\xD2",
        ograve: "\xF2",
        ogt: "\u29C1",
        ohbar: "\u29B5",
        ohm: "\u03A9",
        oint: "\u222E",
        olarr: "\u21BA",
        olcir: "\u29BE",
        olcross: "\u29BB",
        oline: "\u203E",
        olt: "\u29C0",
        Omacr: "\u014C",
        omacr: "\u014D",
        Omega: "\u03A9",
        omega: "\u03C9",
        Omicron: "\u039F",
        omicron: "\u03BF",
        omid: "\u29B6",
        ominus: "\u2296",
        Oopf: "\u{1D546}",
        oopf: "\u{1D560}",
        opar: "\u29B7",
        OpenCurlyDoubleQuote: "\u201C",
        OpenCurlyQuote: "\u2018",
        operp: "\u29B9",
        oplus: "\u2295",
        Or: "\u2A54",
        or: "\u2228",
        orarr: "\u21BB",
        ord: "\u2A5D",
        order: "\u2134",
        orderof: "\u2134",
        ordf: "\xAA",
        ordm: "\xBA",
        origof: "\u22B6",
        oror: "\u2A56",
        orslope: "\u2A57",
        orv: "\u2A5B",
        oS: "\u24C8",
        Oscr: "\u{1D4AA}",
        oscr: "\u2134",
        Oslash: "\xD8",
        oslash: "\xF8",
        osol: "\u2298",
        Otilde: "\xD5",
        otilde: "\xF5",
        Otimes: "\u2A37",
        otimes: "\u2297",
        otimesas: "\u2A36",
        Ouml: "\xD6",
        ouml: "\xF6",
        ovbar: "\u233D",
        OverBar: "\u203E",
        OverBrace: "\u23DE",
        OverBracket: "\u23B4",
        OverParenthesis: "\u23DC",
        par: "\u2225",
        para: "\xB6",
        parallel: "\u2225",
        parsim: "\u2AF3",
        parsl: "\u2AFD",
        part: "\u2202",
        PartialD: "\u2202",
        Pcy: "\u041F",
        pcy: "\u043F",
        percnt: "%",
        period: ".",
        permil: "\u2030",
        perp: "\u22A5",
        pertenk: "\u2031",
        Pfr: "\u{1D513}",
        pfr: "\u{1D52D}",
        Phi: "\u03A6",
        phi: "\u03C6",
        phiv: "\u03D5",
        phmmat: "\u2133",
        phone: "\u260E",
        Pi: "\u03A0",
        pi: "\u03C0",
        pitchfork: "\u22D4",
        piv: "\u03D6",
        planck: "\u210F",
        planckh: "\u210E",
        plankv: "\u210F",
        plus: "+",
        plusacir: "\u2A23",
        plusb: "\u229E",
        pluscir: "\u2A22",
        plusdo: "\u2214",
        plusdu: "\u2A25",
        pluse: "\u2A72",
        PlusMinus: "\xB1",
        plusmn: "\xB1",
        plussim: "\u2A26",
        plustwo: "\u2A27",
        pm: "\xB1",
        Poincareplane: "\u210C",
        pointint: "\u2A15",
        Popf: "\u2119",
        popf: "\u{1D561}",
        pound: "\xA3",
        Pr: "\u2ABB",
        pr: "\u227A",
        prap: "\u2AB7",
        prcue: "\u227C",
        prE: "\u2AB3",
        pre: "\u2AAF",
        prec: "\u227A",
        precapprox: "\u2AB7",
        preccurlyeq: "\u227C",
        Precedes: "\u227A",
        PrecedesEqual: "\u2AAF",
        PrecedesSlantEqual: "\u227C",
        PrecedesTilde: "\u227E",
        preceq: "\u2AAF",
        precnapprox: "\u2AB9",
        precneqq: "\u2AB5",
        precnsim: "\u22E8",
        precsim: "\u227E",
        Prime: "\u2033",
        prime: "\u2032",
        primes: "\u2119",
        prnap: "\u2AB9",
        prnE: "\u2AB5",
        prnsim: "\u22E8",
        prod: "\u220F",
        Product: "\u220F",
        profalar: "\u232E",
        profline: "\u2312",
        profsurf: "\u2313",
        prop: "\u221D",
        Proportion: "\u2237",
        Proportional: "\u221D",
        propto: "\u221D",
        prsim: "\u227E",
        prurel: "\u22B0",
        Pscr: "\u{1D4AB}",
        pscr: "\u{1D4C5}",
        Psi: "\u03A8",
        psi: "\u03C8",
        puncsp: "\u2008",
        Qfr: "\u{1D514}",
        qfr: "\u{1D52E}",
        qint: "\u2A0C",
        Qopf: "\u211A",
        qopf: "\u{1D562}",
        qprime: "\u2057",
        Qscr: "\u{1D4AC}",
        qscr: "\u{1D4C6}",
        quaternions: "\u210D",
        quatint: "\u2A16",
        quest: "?",
        questeq: "\u225F",
        QUOT: '"',
        quot: '"',
        rAarr: "\u21DB",
        race: "\u223D\u0331",
        Racute: "\u0154",
        racute: "\u0155",
        radic: "\u221A",
        raemptyv: "\u29B3",
        Rang: "\u27EB",
        rang: "\u27E9",
        rangd: "\u2992",
        range: "\u29A5",
        rangle: "\u27E9",
        raquo: "\xBB",
        Rarr: "\u21A0",
        rArr: "\u21D2",
        rarr: "\u2192",
        rarrap: "\u2975",
        rarrb: "\u21E5",
        rarrbfs: "\u2920",
        rarrc: "\u2933",
        rarrfs: "\u291E",
        rarrhk: "\u21AA",
        rarrlp: "\u21AC",
        rarrpl: "\u2945",
        rarrsim: "\u2974",
        Rarrtl: "\u2916",
        rarrtl: "\u21A3",
        rarrw: "\u219D",
        rAtail: "\u291C",
        ratail: "\u291A",
        ratio: "\u2236",
        rationals: "\u211A",
        RBarr: "\u2910",
        rBarr: "\u290F",
        rbarr: "\u290D",
        rbbrk: "\u2773",
        rbrace: "}",
        rbrack: "]",
        rbrke: "\u298C",
        rbrksld: "\u298E",
        rbrkslu: "\u2990",
        Rcaron: "\u0158",
        rcaron: "\u0159",
        Rcedil: "\u0156",
        rcedil: "\u0157",
        rceil: "\u2309",
        rcub: "}",
        Rcy: "\u0420",
        rcy: "\u0440",
        rdca: "\u2937",
        rdldhar: "\u2969",
        rdquo: "\u201D",
        rdquor: "\u201D",
        rdsh: "\u21B3",
        Re: "\u211C",
        real: "\u211C",
        realine: "\u211B",
        realpart: "\u211C",
        reals: "\u211D",
        rect: "\u25AD",
        REG: "\xAE",
        reg: "\xAE",
        ReverseElement: "\u220B",
        ReverseEquilibrium: "\u21CB",
        ReverseUpEquilibrium: "\u296F",
        rfisht: "\u297D",
        rfloor: "\u230B",
        Rfr: "\u211C",
        rfr: "\u{1D52F}",
        rHar: "\u2964",
        rhard: "\u21C1",
        rharu: "\u21C0",
        rharul: "\u296C",
        Rho: "\u03A1",
        rho: "\u03C1",
        rhov: "\u03F1",
        RightAngleBracket: "\u27E9",
        RightArrow: "\u2192",
        Rightarrow: "\u21D2",
        rightarrow: "\u2192",
        RightArrowBar: "\u21E5",
        RightArrowLeftArrow: "\u21C4",
        rightarrowtail: "\u21A3",
        RightCeiling: "\u2309",
        RightDoubleBracket: "\u27E7",
        RightDownTeeVector: "\u295D",
        RightDownVector: "\u21C2",
        RightDownVectorBar: "\u2955",
        RightFloor: "\u230B",
        rightharpoondown: "\u21C1",
        rightharpoonup: "\u21C0",
        rightleftarrows: "\u21C4",
        rightleftharpoons: "\u21CC",
        rightrightarrows: "\u21C9",
        rightsquigarrow: "\u219D",
        RightTee: "\u22A2",
        RightTeeArrow: "\u21A6",
        RightTeeVector: "\u295B",
        rightthreetimes: "\u22CC",
        RightTriangle: "\u22B3",
        RightTriangleBar: "\u29D0",
        RightTriangleEqual: "\u22B5",
        RightUpDownVector: "\u294F",
        RightUpTeeVector: "\u295C",
        RightUpVector: "\u21BE",
        RightUpVectorBar: "\u2954",
        RightVector: "\u21C0",
        RightVectorBar: "\u2953",
        ring: "\u02DA",
        risingdotseq: "\u2253",
        rlarr: "\u21C4",
        rlhar: "\u21CC",
        rlm: "\u200F",
        rmoust: "\u23B1",
        rmoustache: "\u23B1",
        rnmid: "\u2AEE",
        roang: "\u27ED",
        roarr: "\u21FE",
        robrk: "\u27E7",
        ropar: "\u2986",
        Ropf: "\u211D",
        ropf: "\u{1D563}",
        roplus: "\u2A2E",
        rotimes: "\u2A35",
        RoundImplies: "\u2970",
        rpar: ")",
        rpargt: "\u2994",
        rppolint: "\u2A12",
        rrarr: "\u21C9",
        Rrightarrow: "\u21DB",
        rsaquo: "\u203A",
        Rscr: "\u211B",
        rscr: "\u{1D4C7}",
        Rsh: "\u21B1",
        rsh: "\u21B1",
        rsqb: "]",
        rsquo: "\u2019",
        rsquor: "\u2019",
        rthree: "\u22CC",
        rtimes: "\u22CA",
        rtri: "\u25B9",
        rtrie: "\u22B5",
        rtrif: "\u25B8",
        rtriltri: "\u29CE",
        RuleDelayed: "\u29F4",
        ruluhar: "\u2968",
        rx: "\u211E",
        Sacute: "\u015A",
        sacute: "\u015B",
        sbquo: "\u201A",
        Sc: "\u2ABC",
        sc: "\u227B",
        scap: "\u2AB8",
        Scaron: "\u0160",
        scaron: "\u0161",
        sccue: "\u227D",
        scE: "\u2AB4",
        sce: "\u2AB0",
        Scedil: "\u015E",
        scedil: "\u015F",
        Scirc: "\u015C",
        scirc: "\u015D",
        scnap: "\u2ABA",
        scnE: "\u2AB6",
        scnsim: "\u22E9",
        scpolint: "\u2A13",
        scsim: "\u227F",
        Scy: "\u0421",
        scy: "\u0441",
        sdot: "\u22C5",
        sdotb: "\u22A1",
        sdote: "\u2A66",
        searhk: "\u2925",
        seArr: "\u21D8",
        searr: "\u2198",
        searrow: "\u2198",
        sect: "\xA7",
        semi: ";",
        seswar: "\u2929",
        setminus: "\u2216",
        setmn: "\u2216",
        sext: "\u2736",
        Sfr: "\u{1D516}",
        sfr: "\u{1D530}",
        sfrown: "\u2322",
        sharp: "\u266F",
        SHCHcy: "\u0429",
        shchcy: "\u0449",
        SHcy: "\u0428",
        shcy: "\u0448",
        ShortDownArrow: "\u2193",
        ShortLeftArrow: "\u2190",
        shortmid: "\u2223",
        shortparallel: "\u2225",
        ShortRightArrow: "\u2192",
        ShortUpArrow: "\u2191",
        shy: "\xAD",
        Sigma: "\u03A3",
        sigma: "\u03C3",
        sigmaf: "\u03C2",
        sigmav: "\u03C2",
        sim: "\u223C",
        simdot: "\u2A6A",
        sime: "\u2243",
        simeq: "\u2243",
        simg: "\u2A9E",
        simgE: "\u2AA0",
        siml: "\u2A9D",
        simlE: "\u2A9F",
        simne: "\u2246",
        simplus: "\u2A24",
        simrarr: "\u2972",
        slarr: "\u2190",
        SmallCircle: "\u2218",
        smallsetminus: "\u2216",
        smashp: "\u2A33",
        smeparsl: "\u29E4",
        smid: "\u2223",
        smile: "\u2323",
        smt: "\u2AAA",
        smte: "\u2AAC",
        smtes: "\u2AAC\uFE00",
        SOFTcy: "\u042C",
        softcy: "\u044C",
        sol: "/",
        solb: "\u29C4",
        solbar: "\u233F",
        Sopf: "\u{1D54A}",
        sopf: "\u{1D564}",
        spades: "\u2660",
        spadesuit: "\u2660",
        spar: "\u2225",
        sqcap: "\u2293",
        sqcaps: "\u2293\uFE00",
        sqcup: "\u2294",
        sqcups: "\u2294\uFE00",
        Sqrt: "\u221A",
        sqsub: "\u228F",
        sqsube: "\u2291",
        sqsubset: "\u228F",
        sqsubseteq: "\u2291",
        sqsup: "\u2290",
        sqsupe: "\u2292",
        sqsupset: "\u2290",
        sqsupseteq: "\u2292",
        squ: "\u25A1",
        Square: "\u25A1",
        square: "\u25A1",
        SquareIntersection: "\u2293",
        SquareSubset: "\u228F",
        SquareSubsetEqual: "\u2291",
        SquareSuperset: "\u2290",
        SquareSupersetEqual: "\u2292",
        SquareUnion: "\u2294",
        squarf: "\u25AA",
        squf: "\u25AA",
        srarr: "\u2192",
        Sscr: "\u{1D4AE}",
        sscr: "\u{1D4C8}",
        ssetmn: "\u2216",
        ssmile: "\u2323",
        sstarf: "\u22C6",
        Star: "\u22C6",
        star: "\u2606",
        starf: "\u2605",
        straightepsilon: "\u03F5",
        straightphi: "\u03D5",
        strns: "\xAF",
        Sub: "\u22D0",
        sub: "\u2282",
        subdot: "\u2ABD",
        subE: "\u2AC5",
        sube: "\u2286",
        subedot: "\u2AC3",
        submult: "\u2AC1",
        subnE: "\u2ACB",
        subne: "\u228A",
        subplus: "\u2ABF",
        subrarr: "\u2979",
        Subset: "\u22D0",
        subset: "\u2282",
        subseteq: "\u2286",
        subseteqq: "\u2AC5",
        SubsetEqual: "\u2286",
        subsetneq: "\u228A",
        subsetneqq: "\u2ACB",
        subsim: "\u2AC7",
        subsub: "\u2AD5",
        subsup: "\u2AD3",
        succ: "\u227B",
        succapprox: "\u2AB8",
        succcurlyeq: "\u227D",
        Succeeds: "\u227B",
        SucceedsEqual: "\u2AB0",
        SucceedsSlantEqual: "\u227D",
        SucceedsTilde: "\u227F",
        succeq: "\u2AB0",
        succnapprox: "\u2ABA",
        succneqq: "\u2AB6",
        succnsim: "\u22E9",
        succsim: "\u227F",
        SuchThat: "\u220B",
        Sum: "\u2211",
        sum: "\u2211",
        sung: "\u266A",
        Sup: "\u22D1",
        sup: "\u2283",
        sup1: "\xB9",
        sup2: "\xB2",
        sup3: "\xB3",
        supdot: "\u2ABE",
        supdsub: "\u2AD8",
        supE: "\u2AC6",
        supe: "\u2287",
        supedot: "\u2AC4",
        Superset: "\u2283",
        SupersetEqual: "\u2287",
        suphsol: "\u27C9",
        suphsub: "\u2AD7",
        suplarr: "\u297B",
        supmult: "\u2AC2",
        supnE: "\u2ACC",
        supne: "\u228B",
        supplus: "\u2AC0",
        Supset: "\u22D1",
        supset: "\u2283",
        supseteq: "\u2287",
        supseteqq: "\u2AC6",
        supsetneq: "\u228B",
        supsetneqq: "\u2ACC",
        supsim: "\u2AC8",
        supsub: "\u2AD4",
        supsup: "\u2AD6",
        swarhk: "\u2926",
        swArr: "\u21D9",
        swarr: "\u2199",
        swarrow: "\u2199",
        swnwar: "\u292A",
        szlig: "\xDF",
        Tab: "	",
        target: "\u2316",
        Tau: "\u03A4",
        tau: "\u03C4",
        tbrk: "\u23B4",
        Tcaron: "\u0164",
        tcaron: "\u0165",
        Tcedil: "\u0162",
        tcedil: "\u0163",
        Tcy: "\u0422",
        tcy: "\u0442",
        tdot: "\u20DB",
        telrec: "\u2315",
        Tfr: "\u{1D517}",
        tfr: "\u{1D531}",
        there4: "\u2234",
        Therefore: "\u2234",
        therefore: "\u2234",
        Theta: "\u0398",
        theta: "\u03B8",
        thetasym: "\u03D1",
        thetav: "\u03D1",
        thickapprox: "\u2248",
        thicksim: "\u223C",
        ThickSpace: "\u205F\u200A",
        thinsp: "\u2009",
        ThinSpace: "\u2009",
        thkap: "\u2248",
        thksim: "\u223C",
        THORN: "\xDE",
        thorn: "\xFE",
        Tilde: "\u223C",
        tilde: "\u02DC",
        TildeEqual: "\u2243",
        TildeFullEqual: "\u2245",
        TildeTilde: "\u2248",
        times: "\xD7",
        timesb: "\u22A0",
        timesbar: "\u2A31",
        timesd: "\u2A30",
        tint: "\u222D",
        toea: "\u2928",
        top: "\u22A4",
        topbot: "\u2336",
        topcir: "\u2AF1",
        Topf: "\u{1D54B}",
        topf: "\u{1D565}",
        topfork: "\u2ADA",
        tosa: "\u2929",
        tprime: "\u2034",
        TRADE: "\u2122",
        trade: "\u2122",
        triangle: "\u25B5",
        triangledown: "\u25BF",
        triangleleft: "\u25C3",
        trianglelefteq: "\u22B4",
        triangleq: "\u225C",
        triangleright: "\u25B9",
        trianglerighteq: "\u22B5",
        tridot: "\u25EC",
        trie: "\u225C",
        triminus: "\u2A3A",
        TripleDot: "\u20DB",
        triplus: "\u2A39",
        trisb: "\u29CD",
        tritime: "\u2A3B",
        trpezium: "\u23E2",
        Tscr: "\u{1D4AF}",
        tscr: "\u{1D4C9}",
        TScy: "\u0426",
        tscy: "\u0446",
        TSHcy: "\u040B",
        tshcy: "\u045B",
        Tstrok: "\u0166",
        tstrok: "\u0167",
        twixt: "\u226C",
        twoheadleftarrow: "\u219E",
        twoheadrightarrow: "\u21A0",
        Uacute: "\xDA",
        uacute: "\xFA",
        Uarr: "\u219F",
        uArr: "\u21D1",
        uarr: "\u2191",
        Uarrocir: "\u2949",
        Ubrcy: "\u040E",
        ubrcy: "\u045E",
        Ubreve: "\u016C",
        ubreve: "\u016D",
        Ucirc: "\xDB",
        ucirc: "\xFB",
        Ucy: "\u0423",
        ucy: "\u0443",
        udarr: "\u21C5",
        Udblac: "\u0170",
        udblac: "\u0171",
        udhar: "\u296E",
        ufisht: "\u297E",
        Ufr: "\u{1D518}",
        ufr: "\u{1D532}",
        Ugrave: "\xD9",
        ugrave: "\xF9",
        uHar: "\u2963",
        uharl: "\u21BF",
        uharr: "\u21BE",
        uhblk: "\u2580",
        ulcorn: "\u231C",
        ulcorner: "\u231C",
        ulcrop: "\u230F",
        ultri: "\u25F8",
        Umacr: "\u016A",
        umacr: "\u016B",
        uml: "\xA8",
        UnderBar: "_",
        UnderBrace: "\u23DF",
        UnderBracket: "\u23B5",
        UnderParenthesis: "\u23DD",
        Union: "\u22C3",
        UnionPlus: "\u228E",
        Uogon: "\u0172",
        uogon: "\u0173",
        Uopf: "\u{1D54C}",
        uopf: "\u{1D566}",
        UpArrow: "\u2191",
        Uparrow: "\u21D1",
        uparrow: "\u2191",
        UpArrowBar: "\u2912",
        UpArrowDownArrow: "\u21C5",
        UpDownArrow: "\u2195",
        Updownarrow: "\u21D5",
        updownarrow: "\u2195",
        UpEquilibrium: "\u296E",
        upharpoonleft: "\u21BF",
        upharpoonright: "\u21BE",
        uplus: "\u228E",
        UpperLeftArrow: "\u2196",
        UpperRightArrow: "\u2197",
        Upsi: "\u03D2",
        upsi: "\u03C5",
        upsih: "\u03D2",
        Upsilon: "\u03A5",
        upsilon: "\u03C5",
        UpTee: "\u22A5",
        UpTeeArrow: "\u21A5",
        upuparrows: "\u21C8",
        urcorn: "\u231D",
        urcorner: "\u231D",
        urcrop: "\u230E",
        Uring: "\u016E",
        uring: "\u016F",
        urtri: "\u25F9",
        Uscr: "\u{1D4B0}",
        uscr: "\u{1D4CA}",
        utdot: "\u22F0",
        Utilde: "\u0168",
        utilde: "\u0169",
        utri: "\u25B5",
        utrif: "\u25B4",
        uuarr: "\u21C8",
        Uuml: "\xDC",
        uuml: "\xFC",
        uwangle: "\u29A7",
        vangrt: "\u299C",
        varepsilon: "\u03F5",
        varkappa: "\u03F0",
        varnothing: "\u2205",
        varphi: "\u03D5",
        varpi: "\u03D6",
        varpropto: "\u221D",
        vArr: "\u21D5",
        varr: "\u2195",
        varrho: "\u03F1",
        varsigma: "\u03C2",
        varsubsetneq: "\u228A\uFE00",
        varsubsetneqq: "\u2ACB\uFE00",
        varsupsetneq: "\u228B\uFE00",
        varsupsetneqq: "\u2ACC\uFE00",
        vartheta: "\u03D1",
        vartriangleleft: "\u22B2",
        vartriangleright: "\u22B3",
        Vbar: "\u2AEB",
        vBar: "\u2AE8",
        vBarv: "\u2AE9",
        Vcy: "\u0412",
        vcy: "\u0432",
        VDash: "\u22AB",
        Vdash: "\u22A9",
        vDash: "\u22A8",
        vdash: "\u22A2",
        Vdashl: "\u2AE6",
        Vee: "\u22C1",
        vee: "\u2228",
        veebar: "\u22BB",
        veeeq: "\u225A",
        vellip: "\u22EE",
        Verbar: "\u2016",
        verbar: "|",
        Vert: "\u2016",
        vert: "|",
        VerticalBar: "\u2223",
        VerticalLine: "|",
        VerticalSeparator: "\u2758",
        VerticalTilde: "\u2240",
        VeryThinSpace: "\u200A",
        Vfr: "\u{1D519}",
        vfr: "\u{1D533}",
        vltri: "\u22B2",
        vnsub: "\u2282\u20D2",
        vnsup: "\u2283\u20D2",
        Vopf: "\u{1D54D}",
        vopf: "\u{1D567}",
        vprop: "\u221D",
        vrtri: "\u22B3",
        Vscr: "\u{1D4B1}",
        vscr: "\u{1D4CB}",
        vsubnE: "\u2ACB\uFE00",
        vsubne: "\u228A\uFE00",
        vsupnE: "\u2ACC\uFE00",
        vsupne: "\u228B\uFE00",
        Vvdash: "\u22AA",
        vzigzag: "\u299A",
        Wcirc: "\u0174",
        wcirc: "\u0175",
        wedbar: "\u2A5F",
        Wedge: "\u22C0",
        wedge: "\u2227",
        wedgeq: "\u2259",
        weierp: "\u2118",
        Wfr: "\u{1D51A}",
        wfr: "\u{1D534}",
        Wopf: "\u{1D54E}",
        wopf: "\u{1D568}",
        wp: "\u2118",
        wr: "\u2240",
        wreath: "\u2240",
        Wscr: "\u{1D4B2}",
        wscr: "\u{1D4CC}",
        xcap: "\u22C2",
        xcirc: "\u25EF",
        xcup: "\u22C3",
        xdtri: "\u25BD",
        Xfr: "\u{1D51B}",
        xfr: "\u{1D535}",
        xhArr: "\u27FA",
        xharr: "\u27F7",
        Xi: "\u039E",
        xi: "\u03BE",
        xlArr: "\u27F8",
        xlarr: "\u27F5",
        xmap: "\u27FC",
        xnis: "\u22FB",
        xodot: "\u2A00",
        Xopf: "\u{1D54F}",
        xopf: "\u{1D569}",
        xoplus: "\u2A01",
        xotime: "\u2A02",
        xrArr: "\u27F9",
        xrarr: "\u27F6",
        Xscr: "\u{1D4B3}",
        xscr: "\u{1D4CD}",
        xsqcup: "\u2A06",
        xuplus: "\u2A04",
        xutri: "\u25B3",
        xvee: "\u22C1",
        xwedge: "\u22C0",
        Yacute: "\xDD",
        yacute: "\xFD",
        YAcy: "\u042F",
        yacy: "\u044F",
        Ycirc: "\u0176",
        ycirc: "\u0177",
        Ycy: "\u042B",
        ycy: "\u044B",
        yen: "\xA5",
        Yfr: "\u{1D51C}",
        yfr: "\u{1D536}",
        YIcy: "\u0407",
        yicy: "\u0457",
        Yopf: "\u{1D550}",
        yopf: "\u{1D56A}",
        Yscr: "\u{1D4B4}",
        yscr: "\u{1D4CE}",
        YUcy: "\u042E",
        yucy: "\u044E",
        Yuml: "\u0178",
        yuml: "\xFF",
        Zacute: "\u0179",
        zacute: "\u017A",
        Zcaron: "\u017D",
        zcaron: "\u017E",
        Zcy: "\u0417",
        zcy: "\u0437",
        Zdot: "\u017B",
        zdot: "\u017C",
        zeetrf: "\u2128",
        ZeroWidthSpace: "\u200B",
        Zeta: "\u0396",
        zeta: "\u03B6",
        Zfr: "\u2128",
        zfr: "\u{1D537}",
        ZHcy: "\u0416",
        zhcy: "\u0436",
        zigrarr: "\u21DD",
        Zopf: "\u2124",
        zopf: "\u{1D56B}",
        Zscr: "\u{1D4B5}",
        zscr: "\u{1D4CF}",
        zwj: "\u200D",
        zwnj: "\u200C"
      }), i.entityMap = i.HTML_ENTITIES;
    }(io)), io;
  }
  var ls = {}, fu;
  function iw() {
    if (fu) return ls;
    fu = 1;
    var i = rn().NAMESPACE, t = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, e = new RegExp("[\\-\\.0-9" + t.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]"), r = new RegExp("^" + t.source + e.source + "*(?::" + t.source + e.source + "*)?$"), s = 0, n = 1, o = 2, a = 3, c = 4, l = 5, u = 6, h = 7;
    function d(A, I) {
      this.message = A, this.locator = I, Error.captureStackTrace && Error.captureStackTrace(this, d);
    }
    d.prototype = new Error(), d.prototype.name = d.name;
    function p() {
    }
    p.prototype = {
      parse: function(A, I, z) {
        var J = this.domBuilder;
        J.startDocument(), G(I, I = {}), g(A, I, z, J, this.errorHandler), J.endDocument();
      }
    };
    function g(A, I, z, J, j) {
      function X(Pt) {
        if (Pt > 65535) {
          Pt -= 65536;
          var ee = 55296 + (Pt >> 10), Ee = 56320 + (Pt & 1023);
          return String.fromCharCode(ee, Ee);
        } else return String.fromCharCode(Pt);
      }
      function Q(Pt) {
        var ee = Pt.slice(1, -1);
        return Object.hasOwnProperty.call(z, ee) ? z[ee] : ee.charAt(0) === "#" ? X(parseInt(ee.substr(1).replace("x", "0x"))) : (j.error("entity not found:" + Pt), Pt);
      }
      function x(Pt) {
        if (Pt > V) {
          var ee = A.substring(V, Pt).replace(/&#?\w+;/g, Q);
          N && R(V), J.characters(ee, 0, Pt - V), V = Pt;
        }
      }
      function R(Pt, ee) {
        for (; Pt >= B && (ee = D.exec(A)); ) E = ee.index, B = E + ee[0].length, N.lineNumber++;
        N.columnNumber = Pt - E + 1;
      }
      for (var E = 0, B = 0, D = /.*(?:\r\n?|\n)|.*$/g, N = J.locator, O = [
        {
          currentNSMap: I
        }
      ], q = {}, V = 0; ; ) {
        try {
          var $ = A.indexOf("<", V);
          if ($ < 0) {
            if (!A.substr(V).match(/^\s*$/)) {
              var ft = J.doc, pt = ft.createTextNode(A.substr(V));
              ft.appendChild(pt), J.currentElement = pt;
            }
            return;
          }
          switch ($ > V && x($), A.charAt($ + 1)) {
            case "/":
              var tt = A.indexOf(">", $ + 3), it = A.substring($ + 2, tt).replace(/[ \t\n\r]+$/g, ""), gt = O.pop();
              tt < 0 ? (it = A.substring($ + 2).replace(/[\s<].*/, ""), j.error("end tag name: " + it + " is not complete:" + gt.tagName), tt = $ + 1 + it.length) : it.match(/\s</) && (it = it.replace(/[\s<].*/, ""), j.error("end tag name: " + it + " maybe not complete"), tt = $ + 1 + it.length);
              var _t = gt.localNSMap, se = gt.tagName == it, te = se || gt.tagName && gt.tagName.toLowerCase() == it.toLowerCase();
              if (te) {
                if (J.endElement(gt.uri, gt.localName, it), _t) for (var ht in _t) Object.prototype.hasOwnProperty.call(_t, ht) && J.endPrefixMapping(ht);
                se || j.fatalError("end tag name: " + it + " is not match the current start tagName:" + gt.tagName);
              } else O.push(gt);
              tt++;
              break;
            case "?":
              N && R($), tt = Y(A, $, J);
              break;
            case "!":
              N && R($), tt = H(A, $, J, j);
              break;
            default:
              N && R($);
              var Ut = new L(), nt = O[O.length - 1].currentNSMap, tt = m(A, $, Ut, nt, Q, j), be = Ut.length;
              if (!Ut.closed && C(A, tt, Ut.tagName, q) && (Ut.closed = true, z.nbsp || j.warning("unclosed xml attribute")), N && be) {
                for (var we = y(N, {}), He = 0; He < be; He++) {
                  var sr = Ut[He];
                  R(sr.offset), sr.locator = y(N, {});
                }
                J.locator = we, v(Ut, J, nt) && O.push(Ut), J.locator = N;
              } else v(Ut, J, nt) && O.push(Ut);
              i.isHTML(Ut.uri) && !Ut.closed ? tt = S(A, tt, Ut.tagName, Q, J) : tt++;
          }
        } catch (Pt) {
          if (Pt instanceof d) throw Pt;
          j.error("element parse error: " + Pt), tt = -1;
        }
        tt > V ? V = tt : x(Math.max($, V) + 1);
      }
    }
    function y(A, I) {
      return I.lineNumber = A.lineNumber, I.columnNumber = A.columnNumber, I;
    }
    function m(A, I, z, J, j, X) {
      function Q(O, q, V) {
        z.attributeNames.hasOwnProperty(O) && X.fatalError("Attribute " + O + " redefined"), z.addValue(O, q.replace(/[\t\n\r]/g, " ").replace(/&#?\w+;/g, j), V);
      }
      for (var x, R, E = ++I, B = s; ; ) {
        var D = A.charAt(E);
        switch (D) {
          case "=":
            if (B === n) x = A.slice(I, E), B = a;
            else if (B === o) B = a;
            else throw new Error("attribute equal must after attrName");
            break;
          case "'":
          case '"':
            if (B === a || B === n) if (B === n && (X.warning('attribute value must after "="'), x = A.slice(I, E)), I = E + 1, E = A.indexOf(D, I), E > 0) R = A.slice(I, E), Q(x, R, I - 1), B = l;
            else throw new Error("attribute value no end '" + D + "' match");
            else if (B == c) R = A.slice(I, E), Q(x, R, I), X.warning('attribute "' + x + '" missed start quot(' + D + ")!!"), I = E + 1, B = l;
            else throw new Error('attribute value must after "="');
            break;
          case "/":
            switch (B) {
              case s:
                z.setTagName(A.slice(I, E));
              case l:
              case u:
              case h:
                B = h, z.closed = true;
              case c:
              case n:
                break;
              case o:
                z.closed = true;
                break;
              default:
                throw new Error("attribute invalid close char('/')");
            }
            break;
          case "":
            return X.error("unexpected end of input"), B == s && z.setTagName(A.slice(I, E)), E;
          case ">":
            switch (B) {
              case s:
                z.setTagName(A.slice(I, E));
              case l:
              case u:
              case h:
                break;
              case c:
              case n:
                R = A.slice(I, E), R.slice(-1) === "/" && (z.closed = true, R = R.slice(0, -1));
              case o:
                B === o && (R = x), B == c ? (X.warning('attribute "' + R + '" missed quot(")!'), Q(x, R, I)) : ((!i.isHTML(J[""]) || !R.match(/^(?:disabled|checked|selected)$/i)) && X.warning('attribute "' + R + '" missed value!! "' + R + '" instead!!'), Q(R, R, I));
                break;
              case a:
                throw new Error("attribute value missed!!");
            }
            return E;
          case "\x80":
            D = " ";
          default:
            if (D <= " ") switch (B) {
              case s:
                z.setTagName(A.slice(I, E)), B = u;
                break;
              case n:
                x = A.slice(I, E), B = o;
                break;
              case c:
                var R = A.slice(I, E);
                X.warning('attribute "' + R + '" missed quot(")!!'), Q(x, R, I);
              case l:
                B = u;
                break;
            }
            else switch (B) {
              case o:
                var N = z.tagName;
                (!i.isHTML(J[""]) || !x.match(/^(?:disabled|checked|selected)$/i)) && X.warning('attribute "' + x + '" missed value!! "' + x + '" instead2!!'), Q(x, x, I), I = E, B = n;
                break;
              case l:
                X.warning('attribute space is required"' + x + '"!!');
              case u:
                B = n, I = E;
                break;
              case a:
                B = c, I = E;
                break;
              case h:
                throw new Error("elements closed character '/' and '>' must be connected to");
            }
        }
        E++;
      }
    }
    function v(A, I, z) {
      for (var J = A.tagName, j = null, D = A.length; D--; ) {
        var X = A[D], Q = X.qName, x = X.value, N = Q.indexOf(":");
        if (N > 0) var R = X.prefix = Q.slice(0, N), E = Q.slice(N + 1), B = R === "xmlns" && E;
        else E = Q, R = null, B = Q === "xmlns" && "";
        X.localName = E, B !== false && (j == null && (j = {}, G(z, z = {})), z[B] = j[B] = x, X.uri = i.XMLNS, I.startPrefixMapping(B, x));
      }
      for (var D = A.length; D--; ) {
        X = A[D];
        var R = X.prefix;
        R && (R === "xml" && (X.uri = i.XML), R !== "xmlns" && (X.uri = z[R || ""]));
      }
      var N = J.indexOf(":");
      N > 0 ? (R = A.prefix = J.slice(0, N), E = A.localName = J.slice(N + 1)) : (R = null, E = A.localName = J);
      var O = A.uri = z[R || ""];
      if (I.startElement(O, E, J, A), A.closed) {
        if (I.endElement(O, E, J), j) for (R in j) Object.prototype.hasOwnProperty.call(j, R) && I.endPrefixMapping(R);
      } else return A.currentNSMap = z, A.localNSMap = j, true;
    }
    function S(A, I, z, J, j) {
      if (/^(?:script|textarea)$/i.test(z)) {
        var X = A.indexOf("</" + z + ">", I), Q = A.substring(I + 1, X);
        if (/[&<]/.test(Q)) return /^script$/i.test(z) ? (j.characters(Q, 0, Q.length), X) : (Q = Q.replace(/&#?\w+;/g, J), j.characters(Q, 0, Q.length), X);
      }
      return I + 1;
    }
    function C(A, I, z, J) {
      var j = J[z];
      return j == null && (j = A.lastIndexOf("</" + z + ">"), j < I && (j = A.lastIndexOf("</" + z)), J[z] = j), j < I;
    }
    function G(A, I) {
      for (var z in A) Object.prototype.hasOwnProperty.call(A, z) && (I[z] = A[z]);
    }
    function H(A, I, z, J) {
      var j = A.charAt(I + 2);
      switch (j) {
        case "-":
          if (A.charAt(I + 3) === "-") {
            var X = A.indexOf("-->", I + 4);
            return X > I ? (z.comment(A, I + 4, X - I - 4), X + 3) : (J.error("Unclosed comment"), -1);
          } else return -1;
        default:
          if (A.substr(I + 3, 6) == "CDATA[") {
            var X = A.indexOf("]]>", I + 9);
            return z.startCDATA(), z.characters(A, I + 9, X - I - 9), z.endCDATA(), X + 3;
          }
          var Q = W(A, I), x = Q.length;
          if (x > 1 && /!doctype/i.test(Q[0][0])) {
            var R = Q[1][0], E = false, B = false;
            x > 3 && (/^public$/i.test(Q[2][0]) ? (E = Q[3][0], B = x > 4 && Q[4][0]) : /^system$/i.test(Q[2][0]) && (B = Q[3][0]));
            var D = Q[x - 1];
            return z.startDTD(R, E, B), z.endDTD(), D.index + D[0].length;
          }
      }
      return -1;
    }
    function Y(A, I, z) {
      var J = A.indexOf("?>", I);
      if (J) {
        var j = A.substring(I, J).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
        if (j) {
          var X = j[0].length;
          return z.processingInstruction(j[1], j[2]), J + 2;
        } else return -1;
      }
      return -1;
    }
    function L() {
      this.attributeNames = {};
    }
    L.prototype = {
      setTagName: function(A) {
        if (!r.test(A)) throw new Error("invalid tagName:" + A);
        this.tagName = A;
      },
      addValue: function(A, I, z) {
        if (!r.test(A)) throw new Error("invalid attribute:" + A);
        this.attributeNames[A] = this.length, this[this.length++] = {
          qName: A,
          value: I,
          offset: z
        };
      },
      length: 0,
      getLocalName: function(A) {
        return this[A].localName;
      },
      getLocator: function(A) {
        return this[A].locator;
      },
      getQName: function(A) {
        return this[A].qName;
      },
      getURI: function(A) {
        return this[A].uri;
      },
      getValue: function(A) {
        return this[A].value;
      }
    };
    function W(A, I) {
      var z, J = [], j = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
      for (j.lastIndex = I, j.exec(A); z = j.exec(A); ) if (J.push(z), z[1]) return J;
    }
    return ls.XMLReader = p, ls.ParseError = d, ls;
  }
  var pu;
  function sw() {
    if (pu) return fi;
    pu = 1;
    var i = rn(), t = Qh(), e = rw(), r = iw(), s = t.DOMImplementation, n = i.NAMESPACE, o = r.ParseError, a = r.XMLReader;
    function c(m) {
      return m.replace(/\r[\n\u0085]/g, `
`).replace(/[\r\u0085\u2028]/g, `
`);
    }
    function l(m) {
      this.options = m || {
        locator: {}
      };
    }
    l.prototype.parseFromString = function(m, v) {
      var S = this.options, C = new a(), G = S.domBuilder || new h(), H = S.errorHandler, Y = S.locator, L = S.xmlns || {}, W = /\/x?html?$/.test(v), A = W ? e.HTML_ENTITIES : e.XML_ENTITIES;
      Y && G.setDocumentLocator(Y), C.errorHandler = u(H, G, Y), C.domBuilder = S.domBuilder || G, W && (L[""] = n.HTML), L.xml = L.xml || n.XML;
      var I = S.normalizeLineEndings || c;
      return m && typeof m == "string" ? C.parse(I(m), L, A) : C.errorHandler.error("invalid doc source"), G.doc;
    };
    function u(m, v, S) {
      if (!m) {
        if (v instanceof h) return v;
        m = v;
      }
      var C = {}, G = m instanceof Function;
      S = S || {};
      function H(Y) {
        var L = m[Y];
        !L && G && (L = m.length == 2 ? function(W) {
          m(Y, W);
        } : m), C[Y] = L && function(W) {
          L("[xmldom " + Y + "]	" + W + p(S));
        } || function() {
        };
      }
      return H("warning"), H("error"), H("fatalError"), C;
    }
    function h() {
      this.cdata = false;
    }
    function d(m, v) {
      v.lineNumber = m.lineNumber, v.columnNumber = m.columnNumber;
    }
    h.prototype = {
      startDocument: function() {
        this.doc = new s().createDocument(null, null, null), this.locator && (this.doc.documentURI = this.locator.systemId);
      },
      startElement: function(m, v, S, C) {
        var G = this.doc, H = G.createElementNS(m, S || v), Y = C.length;
        y(this, H), this.currentElement = H, this.locator && d(this.locator, H);
        for (var L = 0; L < Y; L++) {
          var m = C.getURI(L), W = C.getValue(L), S = C.getQName(L), A = G.createAttributeNS(m, S);
          this.locator && d(C.getLocator(L), A), A.value = A.nodeValue = W, H.setAttributeNode(A);
        }
      },
      endElement: function(m, v, S) {
        var C = this.currentElement, G = C.tagName;
        this.currentElement = C.parentNode;
      },
      startPrefixMapping: function(m, v) {
      },
      endPrefixMapping: function(m) {
      },
      processingInstruction: function(m, v) {
        var S = this.doc.createProcessingInstruction(m, v);
        this.locator && d(this.locator, S), y(this, S);
      },
      ignorableWhitespace: function(m, v, S) {
      },
      characters: function(m, v, S) {
        if (m = g.apply(this, arguments), m) {
          if (this.cdata) var C = this.doc.createCDATASection(m);
          else var C = this.doc.createTextNode(m);
          this.currentElement ? this.currentElement.appendChild(C) : /^\s*$/.test(m) && this.doc.appendChild(C), this.locator && d(this.locator, C);
        }
      },
      skippedEntity: function(m) {
      },
      endDocument: function() {
        this.doc.normalize();
      },
      setDocumentLocator: function(m) {
        (this.locator = m) && (m.lineNumber = 0);
      },
      comment: function(m, v, S) {
        m = g.apply(this, arguments);
        var C = this.doc.createComment(m);
        this.locator && d(this.locator, C), y(this, C);
      },
      startCDATA: function() {
        this.cdata = true;
      },
      endCDATA: function() {
        this.cdata = false;
      },
      startDTD: function(m, v, S) {
        var C = this.doc.implementation;
        if (C && C.createDocumentType) {
          var G = C.createDocumentType(m, v, S);
          this.locator && d(this.locator, G), y(this, G), this.doc.doctype = G;
        }
      },
      warning: function(m) {
        console.warn("[xmldom warning]	" + m, p(this.locator));
      },
      error: function(m) {
        console.error("[xmldom error]	" + m, p(this.locator));
      },
      fatalError: function(m) {
        throw new o(m, this.locator);
      }
    };
    function p(m) {
      if (m) return `
@` + (m.systemId || "") + "#[line:" + m.lineNumber + ",col:" + m.columnNumber + "]";
    }
    function g(m, v, S) {
      return typeof m == "string" ? m.substr(v, S) : m.length >= v + S || v ? new java.lang.String(m, v, S) + "" : m;
    }
    "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function(m) {
      h.prototype[m] = function() {
        return null;
      };
    });
    function y(m, v) {
      m.currentElement ? m.currentElement.appendChild(v) : m.doc.appendChild(v);
    }
    return fi.__DOMHandler = h, fi.normalizeLineEndings = c, fi.DOMParser = l, fi;
  }
  var _u;
  function nw() {
    if (_u) return di;
    _u = 1;
    var i = Qh();
    return di.DOMImplementation = i.DOMImplementation, di.XMLSerializer = i.XMLSerializer, di.DOMParser = sw().DOMParser, di;
  }
  var fR = nw();
  class ow {
    constructor() {
      this.interactionFrequency = 10, this._deltaTime = 0, this._didMove = false, this._tickerAdded = false, this._pauseUpdate = true;
    }
    init(t) {
      this.removeTickerListener(), this.events = t, this.interactionFrequency = 10, this._deltaTime = 0, this._didMove = false, this._tickerAdded = false, this._pauseUpdate = true;
    }
    get pauseUpdate() {
      return this._pauseUpdate;
    }
    set pauseUpdate(t) {
      this._pauseUpdate = t;
    }
    addTickerListener() {
      this._tickerAdded || !this.domElement || (ae.system.add(this._tickerUpdate, this, dr.INTERACTION), this._tickerAdded = true);
    }
    removeTickerListener() {
      this._tickerAdded && (ae.system.remove(this._tickerUpdate, this), this._tickerAdded = false);
    }
    pointerMoved() {
      this._didMove = true;
    }
    _update() {
      if (!this.domElement || this._pauseUpdate) return;
      if (this._didMove) {
        this._didMove = false;
        return;
      }
      const t = this.events._rootPointerEvent;
      this.events.supportsTouchEvents && t.pointerType === "touch" || globalThis.document.dispatchEvent(new PointerEvent("pointermove", {
        clientX: t.clientX,
        clientY: t.clientY,
        pointerType: t.pointerType,
        pointerId: t.pointerId
      }));
    }
    _tickerUpdate(t) {
      this._deltaTime += t.deltaTime, !(this._deltaTime < this.interactionFrequency) && (this._deltaTime = 0, this._update());
    }
  }
  const ar = new ow();
  class Gs extends Ii {
    constructor() {
      super(...arguments), this.client = new At(), this.movement = new At(), this.offset = new At(), this.global = new At(), this.screen = new At();
    }
    get clientX() {
      return this.client.x;
    }
    get clientY() {
      return this.client.y;
    }
    get x() {
      return this.clientX;
    }
    get y() {
      return this.clientY;
    }
    get movementX() {
      return this.movement.x;
    }
    get movementY() {
      return this.movement.y;
    }
    get offsetX() {
      return this.offset.x;
    }
    get offsetY() {
      return this.offset.y;
    }
    get globalX() {
      return this.global.x;
    }
    get globalY() {
      return this.global.y;
    }
    get screenX() {
      return this.screen.x;
    }
    get screenY() {
      return this.screen.y;
    }
    getLocalPosition(t, e, r) {
      return t.worldTransform.applyInverse(r || this.global, e);
    }
    getModifierState(t) {
      return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(t);
    }
    initMouseEvent(t, e, r, s, n, o, a, c, l, u, h, d, p, g, y) {
      throw new Error("Method not implemented.");
    }
  }
  class Ce extends Gs {
    constructor() {
      super(...arguments), this.width = 0, this.height = 0, this.isPrimary = false;
    }
    getCoalescedEvents() {
      return this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove" ? [
        this
      ] : [];
    }
    getPredictedEvents() {
      throw new Error("getPredictedEvents is not supported!");
    }
  }
  class Qr extends Gs {
    constructor() {
      super(...arguments), this.DOM_DELTA_PIXEL = 0, this.DOM_DELTA_LINE = 1, this.DOM_DELTA_PAGE = 2;
    }
  }
  Qr.DOM_DELTA_PIXEL = 0;
  Qr.DOM_DELTA_LINE = 1;
  Qr.DOM_DELTA_PAGE = 2;
  const aw = 2048, cw = new At(), pi = new At();
  class uw {
    constructor(t) {
      this.dispatch = new me(), this.moveOnAll = false, this.enableGlobalMoveEvents = true, this.mappingState = {
        trackingData: {}
      }, this.eventPool = /* @__PURE__ */ new Map(), this._allInteractiveElements = [], this._hitElements = [], this._isPointerMoveEvent = false, this.rootTarget = t, this.hitPruneFn = this.hitPruneFn.bind(this), this.hitTestFn = this.hitTestFn.bind(this), this.mapPointerDown = this.mapPointerDown.bind(this), this.mapPointerMove = this.mapPointerMove.bind(this), this.mapPointerOut = this.mapPointerOut.bind(this), this.mapPointerOver = this.mapPointerOver.bind(this), this.mapPointerUp = this.mapPointerUp.bind(this), this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this), this.mapWheel = this.mapWheel.bind(this), this.mappingTable = {}, this.addEventMapping("pointerdown", this.mapPointerDown), this.addEventMapping("pointermove", this.mapPointerMove), this.addEventMapping("pointerout", this.mapPointerOut), this.addEventMapping("pointerleave", this.mapPointerOut), this.addEventMapping("pointerover", this.mapPointerOver), this.addEventMapping("pointerup", this.mapPointerUp), this.addEventMapping("pointerupoutside", this.mapPointerUpOutside), this.addEventMapping("wheel", this.mapWheel);
    }
    addEventMapping(t, e) {
      this.mappingTable[t] || (this.mappingTable[t] = []), this.mappingTable[t].push({
        fn: e,
        priority: 0
      }), this.mappingTable[t].sort((r, s) => r.priority - s.priority);
    }
    dispatchEvent(t, e) {
      t.propagationStopped = false, t.propagationImmediatelyStopped = false, this.propagate(t, e), this.dispatch.emit(e || t.type, t);
    }
    mapEvent(t) {
      if (!this.rootTarget) return;
      const e = this.mappingTable[t.type];
      if (e) for (let r = 0, s = e.length; r < s; r++) e[r].fn(t);
      else ut(`[EventBoundary]: Event mapping not defined for ${t.type}`);
    }
    hitTest(t, e) {
      ar.pauseUpdate = true;
      const s = this._isPointerMoveEvent && this.enableGlobalMoveEvents ? "hitTestMoveRecursive" : "hitTestRecursive", n = this[s](this.rootTarget, this.rootTarget.eventMode, cw.set(t, e), this.hitTestFn, this.hitPruneFn);
      return n && n[0];
    }
    propagate(t, e) {
      if (!t.target) return;
      const r = t.composedPath();
      t.eventPhase = t.CAPTURING_PHASE;
      for (let s = 0, n = r.length - 1; s < n; s++) if (t.currentTarget = r[s], this.notifyTarget(t, e), t.propagationStopped || t.propagationImmediatelyStopped) return;
      if (t.eventPhase = t.AT_TARGET, t.currentTarget = t.target, this.notifyTarget(t, e), !(t.propagationStopped || t.propagationImmediatelyStopped)) {
        t.eventPhase = t.BUBBLING_PHASE;
        for (let s = r.length - 2; s >= 0; s--) if (t.currentTarget = r[s], this.notifyTarget(t, e), t.propagationStopped || t.propagationImmediatelyStopped) return;
      }
    }
    all(t, e, r = this._allInteractiveElements) {
      if (r.length === 0) return;
      t.eventPhase = t.BUBBLING_PHASE;
      const s = Array.isArray(e) ? e : [
        e
      ];
      for (let n = r.length - 1; n >= 0; n--) s.forEach((o) => {
        t.currentTarget = r[n], this.notifyTarget(t, o);
      });
    }
    propagationPath(t) {
      const e = [
        t
      ];
      for (let r = 0; r < aw && t !== this.rootTarget && t.parent; r++) {
        if (!t.parent) throw new Error("Cannot find propagation path to disconnected target");
        e.push(t.parent), t = t.parent;
      }
      return e.reverse(), e;
    }
    hitTestMoveRecursive(t, e, r, s, n, o = false) {
      let a = false;
      if (this._interactivePrune(t)) return null;
      if ((t.eventMode === "dynamic" || e === "dynamic") && (ar.pauseUpdate = false), t.interactiveChildren && t.children) {
        const u = t.children;
        for (let h = u.length - 1; h >= 0; h--) {
          const d = u[h], p = this.hitTestMoveRecursive(d, this._isInteractive(e) ? e : d.eventMode, r, s, n, o || n(t, r));
          if (p) {
            if (p.length > 0 && !p[p.length - 1].parent) continue;
            const g = t.isInteractive();
            (p.length > 0 || g) && (g && this._allInteractiveElements.push(t), p.push(t)), this._hitElements.length === 0 && (this._hitElements = p), a = true;
          }
        }
      }
      const c = this._isInteractive(e), l = t.isInteractive();
      return l && l && this._allInteractiveElements.push(t), o || this._hitElements.length > 0 ? null : a ? this._hitElements : c && !n(t, r) && s(t, r) ? l ? [
        t
      ] : [] : null;
    }
    hitTestRecursive(t, e, r, s, n) {
      if (this._interactivePrune(t) || n(t, r)) return null;
      if ((t.eventMode === "dynamic" || e === "dynamic") && (ar.pauseUpdate = false), t.interactiveChildren && t.children) {
        const c = t.children, l = r;
        for (let u = c.length - 1; u >= 0; u--) {
          const h = c[u], d = this.hitTestRecursive(h, this._isInteractive(e) ? e : h.eventMode, l, s, n);
          if (d) {
            if (d.length > 0 && !d[d.length - 1].parent) continue;
            const p = t.isInteractive();
            return (d.length > 0 || p) && d.push(t), d;
          }
        }
      }
      const o = this._isInteractive(e), a = t.isInteractive();
      return o && s(t, r) ? a ? [
        t
      ] : [] : null;
    }
    _isInteractive(t) {
      return t === "static" || t === "dynamic";
    }
    _interactivePrune(t) {
      return !t || !t.visible || !t.renderable || !t.includeInBuild || !t.measurable || t.eventMode === "none" || t.eventMode === "passive" && !t.interactiveChildren;
    }
    hitPruneFn(t, e) {
      if (t.hitArea && (t.worldTransform.applyInverse(e, pi), !t.hitArea.contains(pi.x, pi.y))) return true;
      if (t.effects && t.effects.length) for (let r = 0; r < t.effects.length; r++) {
        const s = t.effects[r];
        if (s.containsPoint && !s.containsPoint(e, this.hitTestFn)) return true;
      }
      return false;
    }
    hitTestFn(t, e) {
      return t.hitArea ? true : (t == null ? void 0 : t.containsPoint) ? (t.worldTransform.applyInverse(e, pi), t.containsPoint(pi)) : false;
    }
    notifyTarget(t, e) {
      var _a2, _b2;
      if (!t.currentTarget.isInteractive()) return;
      e = e ?? t.type;
      const r = `on${e}`;
      (_b2 = (_a2 = t.currentTarget)[r]) == null ? void 0 : _b2.call(_a2, t);
      const s = t.eventPhase === t.CAPTURING_PHASE || t.eventPhase === t.AT_TARGET ? `${e}capture` : e;
      this._notifyListeners(t, s), t.eventPhase === t.AT_TARGET && this._notifyListeners(t, e);
    }
    mapPointerDown(t) {
      if (!(t instanceof Ce)) {
        ut("EventBoundary cannot map a non-pointer event as a pointer event");
        return;
      }
      const e = this.createPointerEvent(t);
      if (this.dispatchEvent(e, "pointerdown"), e.pointerType === "touch") this.dispatchEvent(e, "touchstart");
      else if (e.pointerType === "mouse" || e.pointerType === "pen") {
        const s = e.button === 2;
        this.dispatchEvent(e, s ? "rightdown" : "mousedown");
      }
      const r = this.trackingData(t.pointerId);
      r.pressTargetsByButton[t.button] = e.composedPath(), this.freeEvent(e);
    }
    mapPointerMove(t) {
      var _a2, _b2;
      if (!(t instanceof Ce)) {
        ut("EventBoundary cannot map a non-pointer event as a pointer event");
        return;
      }
      this._allInteractiveElements.length = 0, this._hitElements.length = 0, this._isPointerMoveEvent = true;
      const e = this.createPointerEvent(t);
      this._isPointerMoveEvent = false;
      const r = e.pointerType === "mouse" || e.pointerType === "pen", s = this.trackingData(t.pointerId), n = this.findMountedTarget(s.overTargets);
      if (((_a2 = s.overTargets) == null ? void 0 : _a2.length) > 0 && n !== e.target) {
        const c = t.type === "mousemove" ? "mouseout" : "pointerout", l = this.createPointerEvent(t, c, n);
        if (this.dispatchEvent(l, "pointerout"), r && this.dispatchEvent(l, "mouseout"), !e.composedPath().includes(n)) {
          const u = this.createPointerEvent(t, "pointerleave", n);
          for (u.eventPhase = u.AT_TARGET; u.target && !e.composedPath().includes(u.target); ) u.currentTarget = u.target, this.notifyTarget(u), r && this.notifyTarget(u, "mouseleave"), u.target = u.target.parent;
          this.freeEvent(u);
        }
        this.freeEvent(l);
      }
      if (n !== e.target) {
        const c = t.type === "mousemove" ? "mouseover" : "pointerover", l = this.clonePointerEvent(e, c);
        this.dispatchEvent(l, "pointerover"), r && this.dispatchEvent(l, "mouseover");
        let u = n == null ? void 0 : n.parent;
        for (; u && u !== this.rootTarget.parent && u !== e.target; ) u = u.parent;
        if (!u || u === this.rootTarget.parent) {
          const d = this.clonePointerEvent(e, "pointerenter");
          for (d.eventPhase = d.AT_TARGET; d.target && d.target !== n && d.target !== this.rootTarget.parent; ) d.currentTarget = d.target, this.notifyTarget(d), r && this.notifyTarget(d, "mouseenter"), d.target = d.target.parent;
          this.freeEvent(d);
        }
        this.freeEvent(l);
      }
      const o = [], a = this.enableGlobalMoveEvents ?? true;
      this.moveOnAll ? o.push("pointermove") : this.dispatchEvent(e, "pointermove"), a && o.push("globalpointermove"), e.pointerType === "touch" && (this.moveOnAll ? o.splice(1, 0, "touchmove") : this.dispatchEvent(e, "touchmove"), a && o.push("globaltouchmove")), r && (this.moveOnAll ? o.splice(1, 0, "mousemove") : this.dispatchEvent(e, "mousemove"), a && o.push("globalmousemove"), this.cursor = (_b2 = e.target) == null ? void 0 : _b2.cursor), o.length > 0 && this.all(e, o), this._allInteractiveElements.length = 0, this._hitElements.length = 0, s.overTargets = e.composedPath(), this.freeEvent(e);
    }
    mapPointerOver(t) {
      var _a2;
      if (!(t instanceof Ce)) {
        ut("EventBoundary cannot map a non-pointer event as a pointer event");
        return;
      }
      const e = this.trackingData(t.pointerId), r = this.createPointerEvent(t), s = r.pointerType === "mouse" || r.pointerType === "pen";
      this.dispatchEvent(r, "pointerover"), s && this.dispatchEvent(r, "mouseover"), r.pointerType === "mouse" && (this.cursor = (_a2 = r.target) == null ? void 0 : _a2.cursor);
      const n = this.clonePointerEvent(r, "pointerenter");
      for (n.eventPhase = n.AT_TARGET; n.target && n.target !== this.rootTarget.parent; ) n.currentTarget = n.target, this.notifyTarget(n), s && this.notifyTarget(n, "mouseenter"), n.target = n.target.parent;
      e.overTargets = r.composedPath(), this.freeEvent(r), this.freeEvent(n);
    }
    mapPointerOut(t) {
      if (!(t instanceof Ce)) {
        ut("EventBoundary cannot map a non-pointer event as a pointer event");
        return;
      }
      const e = this.trackingData(t.pointerId);
      if (e.overTargets) {
        const r = t.pointerType === "mouse" || t.pointerType === "pen", s = this.findMountedTarget(e.overTargets), n = this.createPointerEvent(t, "pointerout", s);
        this.dispatchEvent(n), r && this.dispatchEvent(n, "mouseout");
        const o = this.createPointerEvent(t, "pointerleave", s);
        for (o.eventPhase = o.AT_TARGET; o.target && o.target !== this.rootTarget.parent; ) o.currentTarget = o.target, this.notifyTarget(o), r && this.notifyTarget(o, "mouseleave"), o.target = o.target.parent;
        e.overTargets = null, this.freeEvent(n), this.freeEvent(o);
      }
      this.cursor = null;
    }
    mapPointerUp(t) {
      if (!(t instanceof Ce)) {
        ut("EventBoundary cannot map a non-pointer event as a pointer event");
        return;
      }
      const e = performance.now(), r = this.createPointerEvent(t);
      if (this.dispatchEvent(r, "pointerup"), r.pointerType === "touch") this.dispatchEvent(r, "touchend");
      else if (r.pointerType === "mouse" || r.pointerType === "pen") {
        const a = r.button === 2;
        this.dispatchEvent(r, a ? "rightup" : "mouseup");
      }
      const s = this.trackingData(t.pointerId), n = this.findMountedTarget(s.pressTargetsByButton[t.button]);
      let o = n;
      if (n && !r.composedPath().includes(n)) {
        let a = n;
        for (; a && !r.composedPath().includes(a); ) {
          if (r.currentTarget = a, this.notifyTarget(r, "pointerupoutside"), r.pointerType === "touch") this.notifyTarget(r, "touchendoutside");
          else if (r.pointerType === "mouse" || r.pointerType === "pen") {
            const c = r.button === 2;
            this.notifyTarget(r, c ? "rightupoutside" : "mouseupoutside");
          }
          a = a.parent;
        }
        delete s.pressTargetsByButton[t.button], o = a;
      }
      if (o) {
        const a = this.clonePointerEvent(r, "click");
        a.target = o, a.path = null, s.clicksByButton[t.button] || (s.clicksByButton[t.button] = {
          clickCount: 0,
          target: a.target,
          timeStamp: e
        });
        const c = s.clicksByButton[t.button];
        if (c.target === a.target && e - c.timeStamp < 200 ? ++c.clickCount : c.clickCount = 1, c.target = a.target, c.timeStamp = e, a.detail = c.clickCount, a.pointerType === "mouse") {
          const l = a.button === 2;
          this.dispatchEvent(a, l ? "rightclick" : "click");
        } else a.pointerType === "touch" && this.dispatchEvent(a, "tap");
        this.dispatchEvent(a, "pointertap"), this.freeEvent(a);
      }
      this.freeEvent(r);
    }
    mapPointerUpOutside(t) {
      if (!(t instanceof Ce)) {
        ut("EventBoundary cannot map a non-pointer event as a pointer event");
        return;
      }
      const e = this.trackingData(t.pointerId), r = this.findMountedTarget(e.pressTargetsByButton[t.button]), s = this.createPointerEvent(t);
      if (r) {
        let n = r;
        for (; n; ) s.currentTarget = n, this.notifyTarget(s, "pointerupoutside"), s.pointerType === "touch" ? this.notifyTarget(s, "touchendoutside") : (s.pointerType === "mouse" || s.pointerType === "pen") && this.notifyTarget(s, s.button === 2 ? "rightupoutside" : "mouseupoutside"), n = n.parent;
        delete e.pressTargetsByButton[t.button];
      }
      this.freeEvent(s);
    }
    mapWheel(t) {
      if (!(t instanceof Qr)) {
        ut("EventBoundary cannot map a non-wheel event as a wheel event");
        return;
      }
      const e = this.createWheelEvent(t);
      this.dispatchEvent(e), this.freeEvent(e);
    }
    findMountedTarget(t) {
      if (!t) return null;
      let e = t[0];
      for (let r = 1; r < t.length && t[r].parent === e; r++) e = t[r];
      return e;
    }
    createPointerEvent(t, e, r) {
      const s = this.allocateEvent(Ce);
      return this.copyPointerData(t, s), this.copyMouseData(t, s), this.copyData(t, s), s.nativeEvent = t.nativeEvent, s.originalEvent = t, s.target = r ?? this.hitTest(s.global.x, s.global.y) ?? this._hitElements[0], typeof e == "string" && (s.type = e), s;
    }
    createWheelEvent(t) {
      const e = this.allocateEvent(Qr);
      return this.copyWheelData(t, e), this.copyMouseData(t, e), this.copyData(t, e), e.nativeEvent = t.nativeEvent, e.originalEvent = t, e.target = this.hitTest(e.global.x, e.global.y), e;
    }
    clonePointerEvent(t, e) {
      const r = this.allocateEvent(Ce);
      return r.nativeEvent = t.nativeEvent, r.originalEvent = t.originalEvent, this.copyPointerData(t, r), this.copyMouseData(t, r), this.copyData(t, r), r.target = t.target, r.path = t.composedPath().slice(), r.type = e ?? r.type, r;
    }
    copyWheelData(t, e) {
      e.deltaMode = t.deltaMode, e.deltaX = t.deltaX, e.deltaY = t.deltaY, e.deltaZ = t.deltaZ;
    }
    copyPointerData(t, e) {
      t instanceof Ce && e instanceof Ce && (e.pointerId = t.pointerId, e.width = t.width, e.height = t.height, e.isPrimary = t.isPrimary, e.pointerType = t.pointerType, e.pressure = t.pressure, e.tangentialPressure = t.tangentialPressure, e.tiltX = t.tiltX, e.tiltY = t.tiltY, e.twist = t.twist);
    }
    copyMouseData(t, e) {
      t instanceof Gs && e instanceof Gs && (e.altKey = t.altKey, e.button = t.button, e.buttons = t.buttons, e.client.copyFrom(t.client), e.ctrlKey = t.ctrlKey, e.metaKey = t.metaKey, e.movement.copyFrom(t.movement), e.screen.copyFrom(t.screen), e.shiftKey = t.shiftKey, e.global.copyFrom(t.global));
    }
    copyData(t, e) {
      e.isTrusted = t.isTrusted, e.srcElement = t.srcElement, e.timeStamp = performance.now(), e.type = t.type, e.detail = t.detail, e.view = t.view, e.which = t.which, e.layer.copyFrom(t.layer), e.page.copyFrom(t.page);
    }
    trackingData(t) {
      return this.mappingState.trackingData[t] || (this.mappingState.trackingData[t] = {
        pressTargetsByButton: {},
        clicksByButton: {},
        overTarget: null
      }), this.mappingState.trackingData[t];
    }
    allocateEvent(t) {
      this.eventPool.has(t) || this.eventPool.set(t, []);
      const e = this.eventPool.get(t).pop() || new t(this);
      return e.eventPhase = e.NONE, e.currentTarget = null, e.path = null, e.target = null, e;
    }
    freeEvent(t) {
      if (t.manager !== this) throw new Error("It is illegal to free an event not managed by this EventBoundary!");
      const e = t.constructor;
      this.eventPool.has(e) || this.eventPool.set(e, []), this.eventPool.get(e).push(t);
    }
    _notifyListeners(t, e) {
      const r = t.currentTarget._events[e];
      if (r) if ("fn" in r) r.once && t.currentTarget.removeListener(e, r.fn, void 0, true), r.fn.call(r.context, t);
      else for (let s = 0, n = r.length; s < n && !t.propagationImmediatelyStopped; s++) r[s].once && t.currentTarget.removeListener(e, r[s].fn, void 0, true), r[s].fn.call(r[s].context, t);
    }
  }
  const lw = 1, hw = {
    touchstart: "pointerdown",
    touchend: "pointerup",
    touchendoutside: "pointerupoutside",
    touchmove: "pointermove",
    touchcancel: "pointercancel"
  }, pa = class Lo {
    constructor(t) {
      this.supportsTouchEvents = "ontouchstart" in globalThis, this.supportsPointerEvents = !!globalThis.PointerEvent, this.domElement = null, this.resolution = 1, this.renderer = t, this.rootBoundary = new uw(null), ar.init(this), this.autoPreventDefault = true, this._eventsAdded = false, this._rootPointerEvent = new Ce(null), this._rootWheelEvent = new Qr(null), this.cursorStyles = {
        default: "inherit",
        pointer: "pointer"
      }, this.features = new Proxy({
        ...Lo.defaultEventFeatures
      }, {
        set: (e, r, s) => (r === "globalMove" && (this.rootBoundary.enableGlobalMoveEvents = s), e[r] = s, true)
      }), this._onPointerDown = this._onPointerDown.bind(this), this._onPointerMove = this._onPointerMove.bind(this), this._onPointerUp = this._onPointerUp.bind(this), this._onPointerOverOut = this._onPointerOverOut.bind(this), this.onWheel = this.onWheel.bind(this);
    }
    static get defaultEventMode() {
      return this._defaultEventMode;
    }
    init(t) {
      const { canvas: e, resolution: r } = this.renderer;
      this.setTargetElement(e), this.resolution = r, Lo._defaultEventMode = t.eventMode ?? "passive", Object.assign(this.features, t.eventFeatures ?? {}), this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove;
    }
    resolutionChange(t) {
      this.resolution = t;
    }
    destroy() {
      this.setTargetElement(null), this.renderer = null, this._currentCursor = null;
    }
    setCursor(t) {
      t = t || "default";
      let e = true;
      if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas && (e = false), this._currentCursor === t) return;
      this._currentCursor = t;
      const r = this.cursorStyles[t];
      if (r) switch (typeof r) {
        case "string":
          e && (this.domElement.style.cursor = r);
          break;
        case "function":
          r(t);
          break;
        case "object":
          e && Object.assign(this.domElement.style, r);
          break;
      }
      else e && typeof t == "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, t) && (this.domElement.style.cursor = t);
    }
    get pointer() {
      return this._rootPointerEvent;
    }
    _onPointerDown(t) {
      if (!this.features.click) return;
      this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
      const e = this._normalizeToPointerData(t);
      this.autoPreventDefault && e[0].isNormalized && (t.cancelable || !("cancelable" in t)) && t.preventDefault();
      for (let r = 0, s = e.length; r < s; r++) {
        const n = e[r], o = this._bootstrapEvent(this._rootPointerEvent, n);
        this.rootBoundary.mapEvent(o);
      }
      this.setCursor(this.rootBoundary.cursor);
    }
    _onPointerMove(t) {
      if (!this.features.move) return;
      this.rootBoundary.rootTarget = this.renderer.lastObjectRendered, ar.pointerMoved();
      const e = this._normalizeToPointerData(t);
      for (let r = 0, s = e.length; r < s; r++) {
        const n = this._bootstrapEvent(this._rootPointerEvent, e[r]);
        this.rootBoundary.mapEvent(n);
      }
      this.setCursor(this.rootBoundary.cursor);
    }
    _onPointerUp(t) {
      if (!this.features.click) return;
      this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
      let e = t.target;
      t.composedPath && t.composedPath().length > 0 && (e = t.composedPath()[0]);
      const r = e !== this.domElement ? "outside" : "", s = this._normalizeToPointerData(t);
      for (let n = 0, o = s.length; n < o; n++) {
        const a = this._bootstrapEvent(this._rootPointerEvent, s[n]);
        a.type += r, this.rootBoundary.mapEvent(a);
      }
      this.setCursor(this.rootBoundary.cursor);
    }
    _onPointerOverOut(t) {
      if (!this.features.click) return;
      this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
      const e = this._normalizeToPointerData(t);
      for (let r = 0, s = e.length; r < s; r++) {
        const n = this._bootstrapEvent(this._rootPointerEvent, e[r]);
        this.rootBoundary.mapEvent(n);
      }
      this.setCursor(this.rootBoundary.cursor);
    }
    onWheel(t) {
      if (!this.features.wheel) return;
      const e = this.normalizeWheelEvent(t);
      this.rootBoundary.rootTarget = this.renderer.lastObjectRendered, this.rootBoundary.mapEvent(e);
    }
    setTargetElement(t) {
      this._removeEvents(), this.domElement = t, ar.domElement = t, this._addEvents();
    }
    _addEvents() {
      if (this._eventsAdded || !this.domElement) return;
      ar.addTickerListener();
      const t = this.domElement.style;
      t && (globalThis.navigator.msPointerEnabled ? (t.msContentZooming = "none", t.msTouchAction = "none") : this.supportsPointerEvents && (t.touchAction = "none")), this.supportsPointerEvents ? (globalThis.document.addEventListener("pointermove", this._onPointerMove, true), this.domElement.addEventListener("pointerdown", this._onPointerDown, true), this.domElement.addEventListener("pointerleave", this._onPointerOverOut, true), this.domElement.addEventListener("pointerover", this._onPointerOverOut, true), globalThis.addEventListener("pointerup", this._onPointerUp, true)) : (globalThis.document.addEventListener("mousemove", this._onPointerMove, true), this.domElement.addEventListener("mousedown", this._onPointerDown, true), this.domElement.addEventListener("mouseout", this._onPointerOverOut, true), this.domElement.addEventListener("mouseover", this._onPointerOverOut, true), globalThis.addEventListener("mouseup", this._onPointerUp, true), this.supportsTouchEvents && (this.domElement.addEventListener("touchstart", this._onPointerDown, true), this.domElement.addEventListener("touchend", this._onPointerUp, true), this.domElement.addEventListener("touchmove", this._onPointerMove, true))), this.domElement.addEventListener("wheel", this.onWheel, {
        passive: true,
        capture: true
      }), this._eventsAdded = true;
    }
    _removeEvents() {
      if (!this._eventsAdded || !this.domElement) return;
      ar.removeTickerListener();
      const t = this.domElement.style;
      t && (globalThis.navigator.msPointerEnabled ? (t.msContentZooming = "", t.msTouchAction = "") : this.supportsPointerEvents && (t.touchAction = "")), this.supportsPointerEvents ? (globalThis.document.removeEventListener("pointermove", this._onPointerMove, true), this.domElement.removeEventListener("pointerdown", this._onPointerDown, true), this.domElement.removeEventListener("pointerleave", this._onPointerOverOut, true), this.domElement.removeEventListener("pointerover", this._onPointerOverOut, true), globalThis.removeEventListener("pointerup", this._onPointerUp, true)) : (globalThis.document.removeEventListener("mousemove", this._onPointerMove, true), this.domElement.removeEventListener("mousedown", this._onPointerDown, true), this.domElement.removeEventListener("mouseout", this._onPointerOverOut, true), this.domElement.removeEventListener("mouseover", this._onPointerOverOut, true), globalThis.removeEventListener("mouseup", this._onPointerUp, true), this.supportsTouchEvents && (this.domElement.removeEventListener("touchstart", this._onPointerDown, true), this.domElement.removeEventListener("touchend", this._onPointerUp, true), this.domElement.removeEventListener("touchmove", this._onPointerMove, true))), this.domElement.removeEventListener("wheel", this.onWheel, true), this.domElement = null, this._eventsAdded = false;
    }
    mapPositionToPoint(t, e, r) {
      const s = this.domElement.isConnected ? this.domElement.getBoundingClientRect() : {
        x: 0,
        y: 0,
        width: this.domElement.width,
        height: this.domElement.height,
        left: 0,
        top: 0
      }, n = 1 / this.resolution;
      t.x = (e - s.left) * (this.domElement.width / s.width) * n, t.y = (r - s.top) * (this.domElement.height / s.height) * n;
    }
    _normalizeToPointerData(t) {
      const e = [];
      if (this.supportsTouchEvents && t instanceof TouchEvent) for (let r = 0, s = t.changedTouches.length; r < s; r++) {
        const n = t.changedTouches[r];
        typeof n.button > "u" && (n.button = 0), typeof n.buttons > "u" && (n.buttons = 1), typeof n.isPrimary > "u" && (n.isPrimary = t.touches.length === 1 && t.type === "touchstart"), typeof n.width > "u" && (n.width = n.radiusX || 1), typeof n.height > "u" && (n.height = n.radiusY || 1), typeof n.tiltX > "u" && (n.tiltX = 0), typeof n.tiltY > "u" && (n.tiltY = 0), typeof n.pointerType > "u" && (n.pointerType = "touch"), typeof n.pointerId > "u" && (n.pointerId = n.identifier || 0), typeof n.pressure > "u" && (n.pressure = n.force || 0.5), typeof n.twist > "u" && (n.twist = 0), typeof n.tangentialPressure > "u" && (n.tangentialPressure = 0), typeof n.layerX > "u" && (n.layerX = n.offsetX = n.clientX), typeof n.layerY > "u" && (n.layerY = n.offsetY = n.clientY), n.isNormalized = true, n.type = t.type, e.push(n);
      }
      else if (!globalThis.MouseEvent || t instanceof MouseEvent && (!this.supportsPointerEvents || !(t instanceof globalThis.PointerEvent))) {
        const r = t;
        typeof r.isPrimary > "u" && (r.isPrimary = true), typeof r.width > "u" && (r.width = 1), typeof r.height > "u" && (r.height = 1), typeof r.tiltX > "u" && (r.tiltX = 0), typeof r.tiltY > "u" && (r.tiltY = 0), typeof r.pointerType > "u" && (r.pointerType = "mouse"), typeof r.pointerId > "u" && (r.pointerId = lw), typeof r.pressure > "u" && (r.pressure = 0.5), typeof r.twist > "u" && (r.twist = 0), typeof r.tangentialPressure > "u" && (r.tangentialPressure = 0), r.isNormalized = true, e.push(r);
      } else e.push(t);
      return e;
    }
    normalizeWheelEvent(t) {
      const e = this._rootWheelEvent;
      return this._transferMouseData(e, t), e.deltaX = t.deltaX, e.deltaY = t.deltaY, e.deltaZ = t.deltaZ, e.deltaMode = t.deltaMode, this.mapPositionToPoint(e.screen, t.clientX, t.clientY), e.global.copyFrom(e.screen), e.offset.copyFrom(e.screen), e.nativeEvent = t, e.type = t.type, e;
    }
    _bootstrapEvent(t, e) {
      return t.originalEvent = null, t.nativeEvent = e, t.pointerId = e.pointerId, t.width = e.width, t.height = e.height, t.isPrimary = e.isPrimary, t.pointerType = e.pointerType, t.pressure = e.pressure, t.tangentialPressure = e.tangentialPressure, t.tiltX = e.tiltX, t.tiltY = e.tiltY, t.twist = e.twist, this._transferMouseData(t, e), this.mapPositionToPoint(t.screen, e.clientX, e.clientY), t.global.copyFrom(t.screen), t.offset.copyFrom(t.screen), t.isTrusted = e.isTrusted, t.type === "pointerleave" && (t.type = "pointerout"), t.type.startsWith("mouse") && (t.type = t.type.replace("mouse", "pointer")), t.type.startsWith("touch") && (t.type = hw[t.type] || t.type), t;
    }
    _transferMouseData(t, e) {
      t.isTrusted = e.isTrusted, t.srcElement = e.srcElement, t.timeStamp = performance.now(), t.type = e.type, t.altKey = e.altKey, t.button = e.button, t.buttons = e.buttons, t.client.x = e.clientX, t.client.y = e.clientY, t.ctrlKey = e.ctrlKey, t.metaKey = e.metaKey, t.movement.x = e.movementX, t.movement.y = e.movementY, t.page.x = e.pageX, t.page.y = e.pageY, t.relatedTarget = null, t.shiftKey = e.shiftKey;
    }
  };
  pa.extension = {
    name: "events",
    type: [
      P.WebGLSystem,
      P.CanvasSystem,
      P.WebGPUSystem
    ],
    priority: -1
  };
  pa.defaultEventFeatures = {
    move: true,
    globalMove: true,
    click: true,
    wheel: true
  };
  dw = pa;
  pR = {
    onclick: null,
    onmousedown: null,
    onmouseenter: null,
    onmouseleave: null,
    onmousemove: null,
    onglobalmousemove: null,
    onmouseout: null,
    onmouseover: null,
    onmouseup: null,
    onmouseupoutside: null,
    onpointercancel: null,
    onpointerdown: null,
    onpointerenter: null,
    onpointerleave: null,
    onpointermove: null,
    onglobalpointermove: null,
    onpointerout: null,
    onpointerover: null,
    onpointertap: null,
    onpointerup: null,
    onpointerupoutside: null,
    onrightclick: null,
    onrightdown: null,
    onrightup: null,
    onrightupoutside: null,
    ontap: null,
    ontouchcancel: null,
    ontouchend: null,
    ontouchendoutside: null,
    ontouchmove: null,
    onglobaltouchmove: null,
    ontouchstart: null,
    onwheel: null,
    get interactive() {
      return this.eventMode === "dynamic" || this.eventMode === "static";
    },
    set interactive(i) {
      this.eventMode = i ? "static" : "passive";
    },
    _internalEventMode: void 0,
    get eventMode() {
      return this._internalEventMode ?? dw.defaultEventMode;
    },
    set eventMode(i) {
      this._internalEventMode = i;
    },
    isInteractive() {
      return this.eventMode === "static" || this.eventMode === "dynamic";
    },
    interactiveChildren: true,
    hitArea: null,
    addEventListener(i, t, e) {
      const r = typeof e == "boolean" && e || typeof e == "object" && e.capture, s = typeof e == "object" ? e.signal : void 0, n = typeof e == "object" ? e.once === true : false, o = typeof t == "function" ? void 0 : t;
      i = r ? `${i}capture` : i;
      const a = typeof t == "function" ? t : t.handleEvent, c = this;
      s && s.addEventListener("abort", () => {
        c.off(i, a, o);
      }), n ? c.once(i, a, o) : c.on(i, a, o);
    },
    removeEventListener(i, t, e) {
      const r = typeof e == "boolean" && e || typeof e == "object" && e.capture, s = typeof t == "function" ? void 0 : t;
      i = r ? `${i}capture` : i, t = typeof t == "function" ? t : t.handleEvent, this.off(i, t, s);
    },
    dispatchEvent(i) {
      if (!(i instanceof Ii)) throw new Error("Container cannot propagate events outside of the Federated Events API");
      return i.defaultPrevented = false, i.path = null, i.target = this, i.manager.dispatchEvent(i), !i.defaultPrevented;
    }
  };
  var td = `in vec2 aPosition;
out vec2 vTextureCoord;

uniform vec4 uInputSize;
uniform vec4 uOutputFrame;
uniform vec4 uOutputTexture;

vec4 filterVertexPosition( void )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
    
    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aPosition * (uOutputFrame.zw * uInputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`, fw = `
in vec2 vTextureCoord;

out vec4 finalColor;

uniform float uAlpha;
uniform sampler2D uTexture;

void main()
{
    finalColor =  texture(uTexture, vTextureCoord) * uAlpha;
}
`, gu = `struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

struct AlphaUniforms {
  uAlpha:f32,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler : sampler;

@group(1) @binding(0) var<uniform> alphaUniforms : AlphaUniforms;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>
  };

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  
}

fn getSize() -> vec2<f32>
{
  return gfu.uGlobalFrame.zw;
}
  
@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>, 
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition)
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {
 
    var sample = textureSample(uTexture, uSampler, uv);
    
    return sample * alphaUniforms.uAlpha;
}`;
  const pw = class ed extends ri {
    constructor(t) {
      t = {
        ...ed.defaultOptions,
        ...t
      };
      const e = Ne.from({
        vertex: {
          source: gu,
          entryPoint: "mainVertex"
        },
        fragment: {
          source: gu,
          entryPoint: "mainFragment"
        }
      }), r = ir.from({
        vertex: td,
        fragment: fw,
        name: "alpha-filter"
      }), { alpha: s, ...n } = t, o = new Qt({
        uAlpha: {
          value: s,
          type: "f32"
        }
      });
      super({
        ...n,
        gpuProgram: e,
        glProgram: r,
        resources: {
          alphaUniforms: o
        }
      });
    }
    get alpha() {
      return this.resources.alphaUniforms.uniforms.uAlpha;
    }
    set alpha(t) {
      this.resources.alphaUniforms.uniforms.uAlpha = t;
    }
  };
  pw.defaultOptions = {
    alpha: 1
  };
  let _w = 0;
  class gw {
    constructor(t) {
      this._poolKeyHash = /* @__PURE__ */ Object.create(null), this._texturePool = {}, this.textureOptions = t || {}, this.enableFullScreen = false;
    }
    createTexture(t, e, r) {
      const s = new Ht({
        ...this.textureOptions,
        width: t,
        height: e,
        resolution: 1,
        antialias: r,
        autoGarbageCollect: true
      });
      return new Z({
        source: s,
        label: `texturePool_${_w++}`
      });
    }
    getOptimalTexture(t, e, r = 1, s) {
      let n = Math.ceil(t * r - 1e-6), o = Math.ceil(e * r - 1e-6);
      n = Yr(n), o = Yr(o);
      const a = (n << 17) + (o << 1) + (s ? 1 : 0);
      this._texturePool[a] || (this._texturePool[a] = []);
      let c = this._texturePool[a].pop();
      return c || (c = this.createTexture(n, o, s)), c.source._resolution = r, c.source.width = n / r, c.source.height = o / r, c.source.pixelWidth = n, c.source.pixelHeight = o, c.frame.x = 0, c.frame.y = 0, c.frame.width = t, c.frame.height = e, c.updateUvs(), this._poolKeyHash[c.uid] = a, c;
    }
    getSameSizeTexture(t, e = false) {
      const r = t.source;
      return this.getOptimalTexture(t.width, t.height, r._resolution, e);
    }
    returnTexture(t) {
      const e = this._poolKeyHash[t.uid];
      this._texturePool[e].push(t);
    }
    clear(t) {
      if (t = t !== false, t) for (const e in this._texturePool) {
        const r = this._texturePool[e];
        if (r) for (let s = 0; s < r.length; s++) r[s].destroy(true);
      }
      this._texturePool = {};
    }
  }
  const Zt = new gw(), rd = {
    5: [
      0.153388,
      0.221461,
      0.250301
    ],
    7: [
      0.071303,
      0.131514,
      0.189879,
      0.214607
    ],
    9: [
      0.028532,
      0.067234,
      0.124009,
      0.179044,
      0.20236
    ],
    11: [
      93e-4,
      0.028002,
      0.065984,
      0.121703,
      0.175713,
      0.198596
    ],
    13: [
      2406e-6,
      9255e-6,
      0.027867,
      0.065666,
      0.121117,
      0.174868,
      0.197641
    ],
    15: [
      489e-6,
      2403e-6,
      9246e-6,
      0.02784,
      0.065602,
      0.120999,
      0.174697,
      0.197448
    ]
  }, mw = [
    "in vec2 vBlurTexCoords[%size%];",
    "uniform sampler2D uTexture;",
    "out vec4 finalColor;",
    "void main(void)",
    "{",
    "    finalColor = vec4(0.0);",
    "    %blur%",
    "}"
  ].join(`
`);
  function bw(i) {
    const t = rd[i], e = t.length;
    let r = mw, s = "";
    const n = "finalColor += texture(uTexture, vBlurTexCoords[%index%]) * %value%;";
    let o;
    for (let a = 0; a < i; a++) {
      let c = n.replace("%index%", a.toString());
      o = a, a >= e && (o = i - a - 1), c = c.replace("%value%", t[o].toString()), s += c, s += `
`;
    }
    return r = r.replace("%blur%", s), r = r.replace("%size%", i.toString()), r;
  }
  const ww = `
    in vec2 aPosition;

    uniform float uStrength;

    out vec2 vBlurTexCoords[%size%];

    uniform vec4 uInputSize;
    uniform vec4 uOutputFrame;
    uniform vec4 uOutputTexture;

    vec4 filterVertexPosition( void )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
    
    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

    vec2 filterTextureCoord( void )
    {
        return aPosition * (uOutputFrame.zw * uInputSize.zw);
    }

    void main(void)
    {
        gl_Position = filterVertexPosition();

        float pixelStrength = uInputSize.%dimension% * uStrength;

        vec2 textureCoord = filterTextureCoord();
        %blur%
    }`;
  function yw(i, t) {
    const e = Math.ceil(i / 2);
    let r = ww, s = "", n;
    t ? n = "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * pixelStrength, 0.0);" : n = "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * pixelStrength);";
    for (let o = 0; o < i; o++) {
      let a = n.replace("%index%", o.toString());
      a = a.replace("%sampleIndex%", `${o - (e - 1)}.0`), s += a, s += `
`;
    }
    return r = r.replace("%blur%", s), r = r.replace("%size%", i.toString()), r = r.replace("%dimension%", t ? "z" : "w"), r;
  }
  function xw(i, t) {
    const e = yw(t, i), r = bw(t);
    return ir.from({
      vertex: e,
      fragment: r,
      name: `blur-${i ? "horizontal" : "vertical"}-pass-filter`
    });
  }
  var vw = `

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

struct BlurUniforms {
  uStrength:f32,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler : sampler;

@group(1) @binding(0) var<uniform> blurUniforms : BlurUniforms;


struct VSOutput {
    @builtin(position) position: vec4<f32>,
    %blur-struct%
  };

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  
}

fn getSize() -> vec2<f32>
{
  return gfu.uGlobalFrame.zw;
}


@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>, 
) -> VSOutput {

  let filteredCord = filterTextureCoord(aPosition);

  let strength = gfu.uInputSize.w * blurUniforms.uStrength;

  return VSOutput(
   filterVertexPosition(aPosition),
    %blur-vertex-out%
  );
}

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  %blur-fragment-in%
) -> @location(0) vec4<f32> {

    var   finalColor = vec4(0.0);

    %blur-sampling%

    return finalColor;
}`;
  function Sw(i, t) {
    const e = rd[t], r = e.length, s = [], n = [], o = [];
    for (let h = 0; h < t; h++) {
      s[h] = `@location(${h}) offset${h}: vec2<f32>,`, i ? n[h] = `filteredCord + vec2(${h - r + 1} * strength, 0.0),` : n[h] = `filteredCord + vec2(0.0, ${h - r + 1} * strength),`;
      const d = h < r ? h : t - h - 1, p = e[d].toString();
      o[h] = `finalColor += textureSample(uTexture, uSampler, offset${h}) * ${p};`;
    }
    const a = s.join(`
`), c = n.join(`
`), l = o.join(`
`), u = vw.replace("%blur-struct%", a).replace("%blur-vertex-out%", c).replace("%blur-fragment-in%", a).replace("%blur-sampling%", l);
    return Ne.from({
      vertex: {
        source: u,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: u,
        entryPoint: "mainFragment"
      }
    });
  }
  const id = class sd extends ri {
    constructor(t) {
      t = {
        ...sd.defaultOptions,
        ...t
      };
      const e = xw(t.horizontal, t.kernelSize), r = Sw(t.horizontal, t.kernelSize);
      super({
        glProgram: e,
        gpuProgram: r,
        resources: {
          blurUniforms: {
            uStrength: {
              value: 0,
              type: "f32"
            }
          }
        },
        ...t
      }), this.horizontal = t.horizontal, this._quality = 0, this.quality = t.quality, this.blur = t.strength, this._uniforms = this.resources.blurUniforms.uniforms;
    }
    apply(t, e, r, s) {
      if (this._uniforms.uStrength = this.strength / this.passes, this.passes === 1) t.applyFilter(this, e, r, s);
      else {
        const n = Zt.getSameSizeTexture(e);
        let o = e, a = n;
        this._state.blend = false;
        for (let c = 0; c < this.passes - 1; c++) {
          t.applyFilter(this, o, a, t.renderer.type === ge.WEBGPU);
          const l = a;
          a = o, o = l;
        }
        this._state.blend = true, t.applyFilter(this, o, r, s), Zt.returnTexture(n);
      }
    }
    get blur() {
      return this.strength;
    }
    set blur(t) {
      this.padding = 1 + Math.abs(t) * 2, this.strength = t;
    }
    get quality() {
      return this._quality;
    }
    set quality(t) {
      this._quality = t, this.passes = t;
    }
  };
  id.defaultOptions = {
    strength: 8,
    quality: 4,
    kernelSize: 5
  };
  let so = id;
  class Ew extends ri {
    constructor(...t) {
      let e = t[0] ?? {};
      typeof e == "number" && (lt(dt, "BlurFilter constructor params are now options object. See params: { strength, quality, resolution, kernelSize }"), e = {
        strength: e
      }, t[1] !== void 0 && (e.quality = t[1]), t[2] !== void 0 && (e.resolution = t[2] || "inherit"), t[3] !== void 0 && (e.kernelSize = t[3])), e = {
        ...so.defaultOptions,
        ...e
      };
      const { strength: r, quality: s, ...n } = e;
      super({
        ...n,
        compatibleRenderers: ge.BOTH,
        resources: {}
      }), this._repeatEdgePixels = false, this.blurXFilter = new so({
        horizontal: false,
        ...e
      }), this.blurYFilter = new so({
        horizontal: true,
        ...e
      }), this.quality = s, this.blur = r, this.repeatEdgePixels = false;
    }
    apply(t, e, r, s) {
      const n = Math.abs(this.blurXFilter.strength), o = Math.abs(this.blurYFilter.strength);
      if (n && o) {
        const a = Zt.getSameSizeTexture(e);
        this.blurXFilter.blendMode = "normal", this.blurXFilter.apply(t, e, a, true), this.blurYFilter.blendMode = this.blendMode, this.blurYFilter.apply(t, a, r, s), Zt.returnTexture(a);
      } else o ? (this.blurYFilter.blendMode = this.blendMode, this.blurYFilter.apply(t, e, r, s)) : (this.blurXFilter.blendMode = this.blendMode, this.blurXFilter.apply(t, e, r, s));
    }
    updatePadding() {
      this._repeatEdgePixels ? this.padding = 0 : this.padding = Math.max(Math.abs(this.blurXFilter.blur), Math.abs(this.blurYFilter.blur)) * 2;
    }
    get blur() {
      return this.blurXFilter.blur;
    }
    set blur(t) {
      this.blurXFilter.blur = this.blurYFilter.blur = t, this.updatePadding();
    }
    get quality() {
      return this.blurXFilter.quality;
    }
    set quality(t) {
      this.blurXFilter.quality = this.blurYFilter.quality = t;
    }
    get blurX() {
      return this.blurXFilter.blur;
    }
    set blurX(t) {
      this.blurXFilter.blur = t, this.updatePadding();
    }
    get blurY() {
      return this.blurYFilter.blur;
    }
    set blurY(t) {
      this.blurYFilter.blur = t, this.updatePadding();
    }
    get repeatEdgePixels() {
      return this._repeatEdgePixels;
    }
    set repeatEdgePixels(t) {
      this._repeatEdgePixels = t, this.updatePadding();
    }
  }
  Ew.defaultOptions = {
    strength: 8,
    quality: 4,
    kernelSize: 5
  };
  var Tw = `
in vec2 vTextureCoord;
in vec4 vColor;

out vec4 finalColor;

uniform float uNoise;
uniform float uSeed;
uniform sampler2D uTexture;

float rand(vec2 co)
{
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

void main()
{
    vec4 color = texture(uTexture, vTextureCoord);
    float randomValue = rand(gl_FragCoord.xy * uSeed);
    float diff = (randomValue - 0.5) *  uNoise;

    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (color.a > 0.0) {
        color.rgb /= color.a;
    }

    color.r += diff;
    color.g += diff;
    color.b += diff;

    // Premultiply alpha again.
    color.rgb *= color.a;

    finalColor = color;
}
`, mu = `

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

struct NoiseUniforms {
  uNoise:f32,
  uSeed:f32,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler : sampler;

@group(1) @binding(0) var<uniform> noiseUniforms : NoiseUniforms;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>
  };

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  
}

fn getSize() -> vec2<f32>
{
  return gfu.uGlobalFrame.zw;
}
  
@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>, 
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition)
  );
}

fn rand(co:vec2<f32>) -> f32
{
  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}



@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {

    var pixelPosition =  globalTextureCoord(position.xy);// / (getSize());//-  gfu.uOutputFrame.xy);
  
    
    var sample = textureSample(uTexture, uSampler, uv);
    var randomValue =  rand(pixelPosition.xy * noiseUniforms.uSeed);
    var diff = (randomValue - 0.5) * noiseUniforms.uNoise;
  
    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (sample.a > 0.0) {
      sample.r /= sample.a;
      sample.g /= sample.a;
      sample.b /= sample.a;
    }

    sample.r += diff;
    sample.g += diff;
    sample.b += diff;

    // Premultiply alpha again.
    sample.r *= sample.a;
    sample.g *= sample.a;
    sample.b *= sample.a;
    
    return sample;
}`;
  const Cw = class nd extends ri {
    constructor(t = {}) {
      t = {
        ...nd.defaultOptions,
        ...t
      };
      const e = Ne.from({
        vertex: {
          source: mu,
          entryPoint: "mainVertex"
        },
        fragment: {
          source: mu,
          entryPoint: "mainFragment"
        }
      }), r = ir.from({
        vertex: td,
        fragment: Tw,
        name: "noise-filter"
      }), { noise: s, seed: n, ...o } = t;
      super({
        ...o,
        gpuProgram: e,
        glProgram: r,
        resources: {
          noiseUniforms: new Qt({
            uNoise: {
              value: 1,
              type: "f32"
            },
            uSeed: {
              value: 1,
              type: "f32"
            }
          })
        }
      }), this.noise = s, this.seed = n ?? Math.random();
    }
    get noise() {
      return this.resources.noiseUniforms.uniforms.uNoise;
    }
    set noise(t) {
      this.resources.noiseUniforms.uniforms.uNoise = t;
    }
    get seed() {
      return this.resources.noiseUniforms.uniforms.uSeed;
    }
    set seed(t) {
      this.resources.noiseUniforms.uniforms.uSeed = t;
    }
  };
  Cw.defaultOptions = {
    noise: 0.5
  };
  Aw = class {
    constructor(t) {
      this._renderer = t;
    }
    push(t, e, r) {
      this._renderer.renderPipes.batch.break(r), r.add({
        renderPipeId: "filter",
        canBundle: false,
        action: "pushFilter",
        container: e,
        filterEffect: t
      });
    }
    pop(t, e, r) {
      this._renderer.renderPipes.batch.break(r), r.add({
        renderPipeId: "filter",
        action: "popFilter",
        canBundle: false
      });
    }
    execute(t) {
      t.action === "pushFilter" ? this._renderer.filter.push(t) : t.action === "popFilter" && this._renderer.filter.pop();
    }
    destroy() {
      this._renderer = null;
    }
  };
  Aw.extension = {
    type: [
      P.WebGLPipes,
      P.WebGPUPipes,
      P.CanvasPipes
    ],
    name: "filter"
  };
  const Rw = new st();
  function Pw(i, t) {
    return t.clear(), od(i, t), t.isValid || t.set(0, 0, 0, 0), i.renderGroup ? t.applyMatrix(i.renderGroup.localTransform) : t.applyMatrix(i.parentRenderGroup.worldTransform), t;
  }
  function od(i, t) {
    if (i.localDisplayStatus !== 7 || !i.measurable) return;
    const e = !!i.effects.length;
    let r = t;
    if ((i.renderGroup || e) && (r = Je.get().clear()), i.boundsArea) t.addRect(i.boundsArea, i.worldTransform);
    else {
      if (i.renderPipeId) {
        const n = i.bounds;
        r.addFrame(n.minX, n.minY, n.maxX, n.maxY, i.groupTransform);
      }
      const s = i.children;
      for (let n = 0; n < s.length; n++) od(s[n], r);
    }
    if (e) {
      let s = false;
      for (let n = 0; n < i.effects.length; n++) i.effects[n].addBounds && (s || (s = true, r.applyMatrix(i.parentRenderGroup.worldTransform)), i.effects[n].addBounds(r, true));
      s && (r.applyMatrix(i.parentRenderGroup.worldTransform.copyTo(Rw).invert()), t.addBounds(r, i.relativeGroupTransform)), t.addBounds(r), Je.return(r);
    } else i.renderGroup && (t.addBounds(r, i.relativeGroupTransform), Je.return(r));
  }
  function Bw(i, t) {
    t.clear();
    const e = t.matrix;
    for (let r = 0; r < i.length; r++) {
      const s = i[r];
      s.globalDisplayStatus < 7 || (t.matrix = s.worldTransform, s.addBounds(t));
    }
    return t.matrix = e, t;
  }
  const Mw = new Fi({
    attributes: {
      aPosition: {
        buffer: new Float32Array([
          0,
          0,
          1,
          0,
          1,
          1,
          0,
          1
        ]),
        location: 0,
        format: "float32x2",
        stride: 2 * 4,
        offset: 0
      }
    },
    indexBuffer: new Uint32Array([
      0,
      1,
      2,
      0,
      2,
      3
    ])
  });
  Dw = class {
    constructor(t) {
      this._filterStackIndex = 0, this._filterStack = [], this._filterGlobalUniforms = new Qt({
        uInputSize: {
          value: new Float32Array(4),
          type: "vec4<f32>"
        },
        uInputPixel: {
          value: new Float32Array(4),
          type: "vec4<f32>"
        },
        uInputClamp: {
          value: new Float32Array(4),
          type: "vec4<f32>"
        },
        uOutputFrame: {
          value: new Float32Array(4),
          type: "vec4<f32>"
        },
        uGlobalFrame: {
          value: new Float32Array(4),
          type: "vec4<f32>"
        },
        uOutputTexture: {
          value: new Float32Array(4),
          type: "vec4<f32>"
        }
      }), this._globalFilterBindGroup = new Ze({}), this.renderer = t;
    }
    get activeBackTexture() {
      var _a2;
      return (_a2 = this._activeFilterData) == null ? void 0 : _a2.backTexture;
    }
    push(t) {
      var _a2;
      const e = this.renderer, r = t.filterEffect.filters;
      this._filterStack[this._filterStackIndex] || (this._filterStack[this._filterStackIndex] = this._getFilterData());
      const s = this._filterStack[this._filterStackIndex];
      if (this._filterStackIndex++, r.length === 0) {
        s.skip = true;
        return;
      }
      const n = s.bounds;
      t.renderables ? Bw(t.renderables, n) : t.filterEffect.filterArea ? (n.clear(), n.addRect(t.filterEffect.filterArea), n.applyMatrix(t.container.worldTransform)) : Pw(t.container, n);
      const o = e.renderTarget.renderTarget.colorTexture.source;
      let a = 1 / 0, c = 0, l = true, u = false, h = false;
      for (let p = 0; p < r.length; p++) {
        const g = r[p];
        if (a = Math.min(a, g.resolution === "inherit" ? o._resolution : g.resolution), c += g.padding, g.antialias === "off" ? l = false : g.antialias === "inherit" && l && (l = o.antialias), !!!(g.compatibleRenderers & e.type)) {
          h = false;
          break;
        }
        if (g.blendRequired && !(((_a2 = e.backBuffer) == null ? void 0 : _a2.useBackBuffer) ?? true)) {
          ut("Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options."), h = false;
          break;
        }
        h = g.enabled || h, u = u || g.blendRequired;
      }
      if (!h) {
        s.skip = true;
        return;
      }
      const d = e.renderTarget.rootViewPort;
      if (n.scale(a).fitBounds(0, d.width, 0, d.height).scale(1 / a).pad(c).ceil(), !n.isPositive) {
        s.skip = true;
        return;
      }
      s.skip = false, s.bounds = n, s.blendRequired = u, s.container = t.container, s.filterEffect = t.filterEffect, s.previousRenderSurface = e.renderTarget.renderSurface, s.inputTexture = Zt.getOptimalTexture(n.width, n.height, a, l), e.renderTarget.bind(s.inputTexture, true), e.globalUniforms.push({
        offset: n
      });
    }
    pop() {
      const t = this.renderer;
      this._filterStackIndex--;
      const e = this._filterStack[this._filterStackIndex];
      if (e.skip) return;
      this._activeFilterData = e;
      const r = e.inputTexture, s = e.bounds;
      let n = Z.EMPTY;
      if (t.renderTarget.finishRenderPass(), e.blendRequired) {
        const a = this._filterStackIndex > 0 ? this._filterStack[this._filterStackIndex - 1].bounds : null, c = t.renderTarget.getRenderTarget(e.previousRenderSurface);
        n = this.getBackTexture(c, s, a);
      }
      e.backTexture = n;
      const o = e.filterEffect.filters;
      if (this._globalFilterBindGroup.setResource(r.source.style, 2), this._globalFilterBindGroup.setResource(n.source, 3), t.globalUniforms.pop(), o.length === 1) o[0].apply(this, r, e.previousRenderSurface, false), Zt.returnTexture(r);
      else {
        let a = e.inputTexture, c = Zt.getOptimalTexture(s.width, s.height, a.source._resolution, false), l = 0;
        for (l = 0; l < o.length - 1; ++l) {
          o[l].apply(this, a, c, true);
          const h = a;
          a = c, c = h;
        }
        o[l].apply(this, a, e.previousRenderSurface, false), Zt.returnTexture(a), Zt.returnTexture(c);
      }
      e.blendRequired && Zt.returnTexture(n);
    }
    getBackTexture(t, e, r) {
      const s = t.colorTexture.source._resolution, n = Zt.getOptimalTexture(e.width, e.height, s, false);
      let o = e.minX, a = e.minY;
      r && (o -= r.minX, a -= r.minY), o = Math.floor(o * s), a = Math.floor(a * s);
      const c = Math.ceil(e.width * s), l = Math.ceil(e.height * s);
      return this.renderer.renderTarget.copyToTexture(t, n, {
        x: o,
        y: a
      }, {
        width: c,
        height: l
      }, {
        x: 0,
        y: 0
      }), n;
    }
    applyFilter(t, e, r, s) {
      const n = this.renderer, o = this._filterStack[this._filterStackIndex], a = o.bounds, c = At.shared, u = o.previousRenderSurface === r;
      let h = this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution, d = this._filterStackIndex - 1;
      for (; d > 0 && this._filterStack[d].skip; ) --d;
      d > 0 && (h = this._filterStack[d].inputTexture.source._resolution);
      const p = this._filterGlobalUniforms, g = p.uniforms, y = g.uOutputFrame, m = g.uInputSize, v = g.uInputPixel, S = g.uInputClamp, C = g.uGlobalFrame, G = g.uOutputTexture;
      if (u) {
        let L = this._filterStackIndex;
        for (; L > 0; ) {
          L--;
          const W = this._filterStack[this._filterStackIndex - 1];
          if (!W.skip) {
            c.x = W.bounds.minX, c.y = W.bounds.minY;
            break;
          }
        }
        y[0] = a.minX - c.x, y[1] = a.minY - c.y;
      } else y[0] = 0, y[1] = 0;
      y[2] = e.frame.width, y[3] = e.frame.height, m[0] = e.source.width, m[1] = e.source.height, m[2] = 1 / m[0], m[3] = 1 / m[1], v[0] = e.source.pixelWidth, v[1] = e.source.pixelHeight, v[2] = 1 / v[0], v[3] = 1 / v[1], S[0] = 0.5 * v[2], S[1] = 0.5 * v[3], S[2] = e.frame.width * m[2] - 0.5 * v[2], S[3] = e.frame.height * m[3] - 0.5 * v[3];
      const H = this.renderer.renderTarget.rootRenderTarget.colorTexture;
      C[0] = c.x * h, C[1] = c.y * h, C[2] = H.source.width * h, C[3] = H.source.height * h;
      const Y = this.renderer.renderTarget.getRenderTarget(r);
      if (n.renderTarget.bind(r, !!s), r instanceof Z ? (G[0] = r.frame.width, G[1] = r.frame.height) : (G[0] = Y.width, G[1] = Y.height), G[2] = Y.isRoot ? -1 : 1, p.update(), n.renderPipes.uniformBatch) {
        const L = n.renderPipes.uniformBatch.getUboResource(p);
        this._globalFilterBindGroup.setResource(L, 0);
      } else this._globalFilterBindGroup.setResource(p, 0);
      this._globalFilterBindGroup.setResource(e.source, 1), this._globalFilterBindGroup.setResource(e.source.style, 2), t.groups[0] = this._globalFilterBindGroup, n.encoder.draw({
        geometry: Mw,
        shader: t,
        state: t._state,
        topology: "triangle-list"
      }), n.type === ge.WEBGL && n.renderTarget.finishRenderPass();
    }
    _getFilterData() {
      return {
        skip: false,
        inputTexture: null,
        bounds: new re(),
        container: null,
        filterEffect: null,
        blendRequired: false,
        previousRenderSurface: null
      };
    }
    calculateSpriteMatrix(t, e) {
      const r = this._activeFilterData, s = t.set(r.inputTexture._source.width, 0, 0, r.inputTexture._source.height, r.bounds.minX, r.bounds.minY), n = e.worldTransform.copyTo(st.shared);
      return n.invert(), s.prepend(n), s.scale(1 / e.texture.frame.width, 1 / e.texture.frame.height), s.translate(e.anchor.x, e.anchor.y), s;
    }
  };
  Dw.extension = {
    type: [
      P.WebGLSystem,
      P.WebGPUSystem
    ],
    name: "filter"
  };
  var Iw = `in vec2 vMaskCoord;
in vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform sampler2D uMaskTexture;

uniform float uAlpha;
uniform vec4 uMaskClamp;

out vec4 finalColor;

void main(void)
{
    float clip = step(3.5,
        step(uMaskClamp.x, vMaskCoord.x) +
        step(uMaskClamp.y, vMaskCoord.y) +
        step(vMaskCoord.x, uMaskClamp.z) +
        step(vMaskCoord.y, uMaskClamp.w));

    // TODO look into why this is needed
    float npmAlpha = uAlpha; 
    vec4 original = texture(uTexture, vTextureCoord);
    vec4 masky = texture(uMaskTexture, vMaskCoord);
    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);

    original *= (alphaMul * masky.r * uAlpha * clip);

    finalColor = original;
}
`, Fw = `in vec2 aPosition;

out vec2 vTextureCoord;
out vec2 vMaskCoord;


uniform vec4 uInputSize;
uniform vec4 uOutputFrame;
uniform vec4 uOutputTexture;
uniform mat3 uFilterMatrix;

vec4 filterVertexPosition(  vec2 aPosition )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
       
    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

vec2 filterTextureCoord(  vec2 aPosition )
{
    return aPosition * (uOutputFrame.zw * uInputSize.zw);
}

vec2 getFilterCoord( vec2 aPosition )
{
    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;
}   

void main(void)
{
    gl_Position = filterVertexPosition(aPosition);
    vTextureCoord = filterTextureCoord(aPosition);
    vMaskCoord = getFilterCoord(aPosition);
}
`, bu = `struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,  
};

struct MaskUniforms {
  uFilterMatrix:mat3x3<f32>,
  uMaskClamp:vec4<f32>,
  uAlpha:f32,
};


@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler : sampler;

@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;
@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>,
    @location(1) filterUv : vec2<f32>,
  };

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  
}

fn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>
{
  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;
}

fn getSize() -> vec2<f32>
{

  
  return gfu.uGlobalFrame.zw;
}
  
@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>, 
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition),
   getFilterCoord(aPosition)
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @location(1) filterUv: vec2<f32>,
  @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {

    var maskClamp = filterUniforms.uMaskClamp;

     var clip = step(3.5,
        step(maskClamp.x, filterUv.x) +
        step(maskClamp.y, filterUv.y) +
        step(filterUv.x, maskClamp.z) +
        step(filterUv.y, maskClamp.w));

    var mask = textureSample(uMaskTexture, uSampler, filterUv);
    var source = textureSample(uTexture, uSampler, uv);
    
    var npmAlpha = 0.0;

    var alphaMul = 1.0 - npmAlpha * (1.0 - mask.a);

    var a = (alphaMul * mask.r) * clip;

    return vec4(source.rgb, source.a) * a;
}`;
  class Uw extends ri {
    constructor(t) {
      const { sprite: e, ...r } = t, s = new kl(e.texture), n = new Qt({
        uFilterMatrix: {
          value: new st(),
          type: "mat3x3<f32>"
        },
        uMaskClamp: {
          value: s.uClampFrame,
          type: "vec4<f32>"
        },
        uAlpha: {
          value: 1,
          type: "f32"
        }
      }), o = Ne.from({
        vertex: {
          source: bu,
          entryPoint: "mainVertex"
        },
        fragment: {
          source: bu,
          entryPoint: "mainFragment"
        }
      }), a = ir.from({
        vertex: Fw,
        fragment: Iw,
        name: "mask-filter"
      });
      super({
        ...r,
        gpuProgram: o,
        glProgram: a,
        resources: {
          filterUniforms: n,
          uMaskTexture: e.texture.source
        }
      }), this.sprite = e, this._textureMatrix = s;
    }
    apply(t, e, r, s) {
      this._textureMatrix.texture = this.sprite.texture, t.calculateSpriteMatrix(this.resources.filterUniforms.uniforms.uFilterMatrix, this.sprite).prepend(this._textureMatrix.mapCoord), this.resources.uMaskTexture = this.sprite.texture.source, t.applyFilter(this, e, r, s);
    }
  }
  function wu(i, t, e, r, s, n, o, a) {
    const c = o - e, l = a - r, u = s - e, h = n - r, d = i - e, p = t - r, g = c * c + l * l, y = c * u + l * h, m = c * d + l * p, v = u * u + h * h, S = u * d + h * p, C = 1 / (g * v - y * y), G = (v * m - y * S) * C, H = (g * S - y * m) * C;
    return G >= 0 && H >= 0 && G + H < 1;
  }
  const ad = class cd {
    constructor(t) {
      this._tick = () => {
        this.timeout = setTimeout(this._processQueue, 0);
      }, this._processQueue = () => {
        const { queue: e } = this;
        let r = 0;
        for (; e.length && r < cd.uploadsPerFrame; ) {
          const s = e.shift();
          this.uploadQueueItem(s), r++;
        }
        e.length ? ae.system.addOnce(this._tick, this, dr.UTILITY) : this._resolve();
      }, this.renderer = t, this.queue = [], this.resolves = [];
    }
    getQueue() {
      return [
        ...this.queue
      ];
    }
    add(t) {
      const e = Array.isArray(t) ? t : [
        t
      ];
      for (const r of e) r instanceof Dt ? this._addContainer(r) : this.resolveQueueItem(r, this.queue);
      return this;
    }
    _addContainer(t) {
      this.resolveQueueItem(t, this.queue);
      for (const e of t.children) this._addContainer(e);
    }
    upload(t) {
      return t && this.add(t), new Promise((e) => {
        this.queue.length ? (this.resolves.push(e), this.dedupeQueue(), ae.system.addOnce(this._tick, this, dr.UTILITY)) : e();
      });
    }
    dedupeQueue() {
      const t = /* @__PURE__ */ Object.create(null);
      let e = 0;
      for (let r = 0; r < this.queue.length; r++) {
        const s = this.queue[r];
        t[s.uid] || (t[s.uid] = true, this.queue[e++] = s);
      }
      this.queue.length = e;
    }
    _resolve() {
      const { resolves: t } = this, e = t.slice(0);
      t.length = 0;
      for (const r of e) r();
    }
  };
  ad.uploadsPerFrame = 4;
  let kw = ad;
  class $e extends Dt {
    constructor(t) {
      t instanceof oe && (t = {
        context: t
      });
      const { context: e, roundPixels: r, ...s } = t || {};
      super({
        label: "Graphics",
        ...s
      }), this.canBundle = true, this.renderPipeId = "graphics", this._roundPixels = 0, e ? this._context = e : this._context = this._ownedContext = new oe(), this._context.on("update", this.onViewUpdate, this), this.allowChildren = false, this.roundPixels = r ?? false;
    }
    set context(t) {
      t !== this._context && (this._context.off("update", this.onViewUpdate, this), this._context = t, this._context.on("update", this.onViewUpdate, this), this.onViewUpdate());
    }
    get context() {
      return this._context;
    }
    get bounds() {
      return this._context.bounds;
    }
    addBounds(t) {
      t.addBounds(this._context.bounds);
    }
    containsPoint(t) {
      return this._context.containsPoint(t);
    }
    get roundPixels() {
      return !!this._roundPixels;
    }
    set roundPixels(t) {
      this._roundPixels = t ? 1 : 0;
    }
    onViewUpdate() {
      if (this._didChangeId += 4096, this._didGraphicsUpdate = true, this.didViewUpdate) return;
      this.didViewUpdate = true;
      const t = this.renderGroup || this.parentRenderGroup;
      t && t.onChildViewUpdate(this);
    }
    destroy(t) {
      this._ownedContext && !t ? this._ownedContext.destroy(t) : (t === true || (t == null ? void 0 : t.context) === true) && this._context.destroy(t), this._ownedContext = null, this._context = null, super.destroy(t);
    }
    _callContextMethod(t, e) {
      return this.context[t](...e), this;
    }
    setFillStyle(...t) {
      return this._callContextMethod("setFillStyle", t);
    }
    setStrokeStyle(...t) {
      return this._callContextMethod("setStrokeStyle", t);
    }
    fill(...t) {
      return this._callContextMethod("fill", t);
    }
    stroke(...t) {
      return this._callContextMethod("stroke", t);
    }
    texture(...t) {
      return this._callContextMethod("texture", t);
    }
    beginPath() {
      return this._callContextMethod("beginPath", []);
    }
    cut() {
      return this._callContextMethod("cut", []);
    }
    arc(...t) {
      return this._callContextMethod("arc", t);
    }
    arcTo(...t) {
      return this._callContextMethod("arcTo", t);
    }
    arcToSvg(...t) {
      return this._callContextMethod("arcToSvg", t);
    }
    bezierCurveTo(...t) {
      return this._callContextMethod("bezierCurveTo", t);
    }
    closePath() {
      return this._callContextMethod("closePath", []);
    }
    ellipse(...t) {
      return this._callContextMethod("ellipse", t);
    }
    circle(...t) {
      return this._callContextMethod("circle", t);
    }
    path(...t) {
      return this._callContextMethod("path", t);
    }
    lineTo(...t) {
      return this._callContextMethod("lineTo", t);
    }
    moveTo(...t) {
      return this._callContextMethod("moveTo", t);
    }
    quadraticCurveTo(...t) {
      return this._callContextMethod("quadraticCurveTo", t);
    }
    rect(...t) {
      return this._callContextMethod("rect", t);
    }
    roundRect(...t) {
      return this._callContextMethod("roundRect", t);
    }
    poly(...t) {
      return this._callContextMethod("poly", t);
    }
    regularPoly(...t) {
      return this._callContextMethod("regularPoly", t);
    }
    roundPoly(...t) {
      return this._callContextMethod("roundPoly", t);
    }
    roundShape(...t) {
      return this._callContextMethod("roundShape", t);
    }
    filletRect(...t) {
      return this._callContextMethod("filletRect", t);
    }
    chamferRect(...t) {
      return this._callContextMethod("chamferRect", t);
    }
    star(...t) {
      return this._callContextMethod("star", t);
    }
    svg(...t) {
      return this._callContextMethod("svg", t);
    }
    restore(...t) {
      return this._callContextMethod("restore", t);
    }
    save() {
      return this._callContextMethod("save", []);
    }
    getTransform() {
      return this.context.getTransform();
    }
    resetTransform() {
      return this._callContextMethod("resetTransform", []);
    }
    rotateTransform(...t) {
      return this._callContextMethod("rotate", t);
    }
    scaleTransform(...t) {
      return this._callContextMethod("scale", t);
    }
    setTransform(...t) {
      return this._callContextMethod("setTransform", t);
    }
    transform(...t) {
      return this._callContextMethod("transform", t);
    }
    translateTransform(...t) {
      return this._callContextMethod("translate", t);
    }
    clear() {
      return this._callContextMethod("clear", []);
    }
    get fillStyle() {
      return this._context.fillStyle;
    }
    set fillStyle(t) {
      this._context.fillStyle = t;
    }
    get strokeStyle() {
      return this._context.strokeStyle;
    }
    set strokeStyle(t) {
      this._context.strokeStyle = t;
    }
    clone(t = false) {
      return t ? new $e(this._context.clone()) : (this._ownedContext = null, new $e(this._context));
    }
    lineStyle(t, e, r) {
      lt(dt, "Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.");
      const s = {};
      return t && (s.width = t), e && (s.color = e), r && (s.alpha = r), this.context.strokeStyle = s, this;
    }
    beginFill(t, e) {
      lt(dt, "Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");
      const r = {};
      return t && (r.color = t), e && (r.alpha = e), this.context.fillStyle = r, this;
    }
    endFill() {
      lt(dt, "Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style."), this.context.fill();
      const t = this.context.strokeStyle;
      return (t.width !== oe.defaultStrokeStyle.width || t.color !== oe.defaultStrokeStyle.color || t.alpha !== oe.defaultStrokeStyle.alpha) && this.context.stroke(), this;
    }
    drawCircle(...t) {
      return lt(dt, "Graphics#drawCircle has been renamed to Graphics#circle"), this._callContextMethod("circle", t);
    }
    drawEllipse(...t) {
      return lt(dt, "Graphics#drawEllipse has been renamed to Graphics#ellipse"), this._callContextMethod("ellipse", t);
    }
    drawPolygon(...t) {
      return lt(dt, "Graphics#drawPolygon has been renamed to Graphics#poly"), this._callContextMethod("poly", t);
    }
    drawRect(...t) {
      return lt(dt, "Graphics#drawRect has been renamed to Graphics#rect"), this._callContextMethod("rect", t);
    }
    drawRoundedRect(...t) {
      return lt(dt, "Graphics#drawRoundedRect has been renamed to Graphics#roundRect"), this._callContextMethod("roundRect", t);
    }
    drawStar(...t) {
      return lt(dt, "Graphics#drawStar has been renamed to Graphics#star"), this._callContextMethod("star", t);
    }
  }
  const ud = class ld extends Fi {
    constructor(...t) {
      let e = t[0] ?? {};
      e instanceof Float32Array && (lt(dt, "use new MeshGeometry({ positions, uvs, indices }) instead"), e = {
        positions: e,
        uvs: t[1],
        indices: t[2]
      }), e = {
        ...ld.defaultOptions,
        ...e
      };
      const r = e.positions || new Float32Array([
        0,
        0,
        1,
        0,
        1,
        1,
        0,
        1
      ]), s = e.uvs || new Float32Array([
        0,
        0,
        1,
        0,
        1,
        1,
        0,
        1
      ]), n = e.indices || new Uint32Array([
        0,
        1,
        2,
        0,
        2,
        3
      ]), o = e.shrinkBuffersToFit, a = new Pe({
        data: r,
        label: "attribute-mesh-positions",
        shrinkToFit: o,
        usage: yt.VERTEX | yt.COPY_DST
      }), c = new Pe({
        data: s,
        label: "attribute-mesh-uvs",
        shrinkToFit: o,
        usage: yt.VERTEX | yt.COPY_DST
      }), l = new Pe({
        data: n,
        label: "index-mesh-buffer",
        shrinkToFit: o,
        usage: yt.INDEX | yt.COPY_DST
      });
      super({
        attributes: {
          aPosition: {
            buffer: a,
            format: "float32x2",
            stride: 2 * 4,
            offset: 0
          },
          aUV: {
            buffer: c,
            format: "float32x2",
            stride: 2 * 4,
            offset: 0
          }
        },
        indexBuffer: l,
        topology: e.topology
      }), this.batchMode = "auto";
    }
    get positions() {
      return this.attributes.aPosition.buffer.data;
    }
    set positions(t) {
      this.attributes.aPosition.buffer.data = t;
    }
    get uvs() {
      return this.attributes.aUV.buffer.data;
    }
    set uvs(t) {
      this.attributes.aUV.buffer.data = t;
    }
    get indices() {
      return this.indexBuffer.data;
    }
    set indices(t) {
      this.indexBuffer.data = t;
    }
  };
  ud.defaultOptions = {
    topology: "triangle-list",
    shrinkBuffersToFit: false
  };
  let Ui = ud;
  class hd extends Dt {
    constructor(...t) {
      let e = t[0];
      e instanceof Fi && (lt(dt, "Mesh: use new Mesh({ geometry, shader }) instead"), e = {
        geometry: e,
        shader: t[1]
      }, t[3] && (lt(dt, "Mesh: drawMode argument has been removed, use geometry.topology instead"), e.geometry.topology = t[3]));
      const { geometry: r, shader: s, texture: n, roundPixels: o, state: a, ...c } = e;
      super({
        label: "Mesh",
        ...c
      }), this.renderPipeId = "mesh", this.canBundle = true, this._shader = null, this._roundPixels = 0, this.allowChildren = false, this.shader = s ?? null, this.texture = n ?? (s == null ? void 0 : s.texture) ?? Z.WHITE, this.state = a ?? Le.for2d(), this._geometry = r, this._geometry.on("update", this.onViewUpdate, this), this.roundPixels = o ?? false;
    }
    get roundPixels() {
      return !!this._roundPixels;
    }
    set roundPixels(t) {
      this._roundPixels = t ? 1 : 0;
    }
    get material() {
      return lt(dt, "mesh.material property has been removed, use mesh.shader instead"), this._shader;
    }
    set shader(t) {
      this._shader !== t && (this._shader = t, this.onViewUpdate());
    }
    get shader() {
      return this._shader;
    }
    set geometry(t) {
      var _a2;
      this._geometry !== t && ((_a2 = this._geometry) == null ? void 0 : _a2.off("update", this.onViewUpdate, this), t.on("update", this.onViewUpdate, this), this._geometry = t, this.onViewUpdate());
    }
    get geometry() {
      return this._geometry;
    }
    set texture(t) {
      t || (t = Z.EMPTY);
      const e = this._texture;
      e !== t && (e && e.dynamic && e.off("update", this.onViewUpdate, this), t.dynamic && t.on("update", this.onViewUpdate, this), this.shader && (this.shader.texture = t), this._texture = t, this.onViewUpdate());
    }
    get texture() {
      return this._texture;
    }
    get batched() {
      return this._shader ? false : this._geometry instanceof Ui ? this._geometry.batchMode === "auto" ? this._geometry.positions.length / 2 <= 100 : this._geometry.batchMode === "batch" : false;
    }
    get bounds() {
      return this._geometry.bounds;
    }
    addBounds(t) {
      t.addBounds(this.geometry.bounds);
    }
    containsPoint(t) {
      const { x: e, y: r } = t;
      if (!this.bounds.containsPoint(e, r)) return false;
      const s = this.geometry.getBuffer("aPosition").data, n = this.geometry.topology === "triangle-strip" ? 3 : 1;
      if (this.geometry.getIndex()) {
        const o = this.geometry.getIndex().data, a = o.length;
        for (let c = 0; c + 2 < a; c += n) {
          const l = o[c] * 2, u = o[c + 1] * 2, h = o[c + 2] * 2;
          if (wu(e, r, s[l], s[l + 1], s[u], s[u + 1], s[h], s[h + 1])) return true;
        }
      } else {
        const o = s.length / 2;
        for (let a = 0; a + 2 < o; a += n) {
          const c = a * 2, l = (a + 1) * 2, u = (a + 2) * 2;
          if (wu(e, r, s[c], s[c + 1], s[l], s[l + 1], s[u], s[u + 1])) return true;
        }
      }
      return false;
    }
    onViewUpdate() {
      if (this._didChangeId += 4096, this.didViewUpdate) return;
      this.didViewUpdate = true;
      const t = this.renderGroup || this.parentRenderGroup;
      t && t.onChildViewUpdate(this);
    }
    destroy(t) {
      var _a2;
      if (super.destroy(t), typeof t == "boolean" ? t : t == null ? void 0 : t.texture) {
        const r = typeof t == "boolean" ? t : t == null ? void 0 : t.textureSource;
        this._texture.destroy(r);
      }
      (_a2 = this._geometry) == null ? void 0 : _a2.off("update", this.onViewUpdate, this), this._texture = null, this._geometry = null, this._shader = null;
    }
  }
  class Os extends hr {
    constructor(t, e = true) {
      super(t[0] instanceof Z ? t[0] : t[0].texture), this._textures = null, this._durations = null, this._autoUpdate = e, this._isConnectedToTicker = false, this.animationSpeed = 1, this.loop = true, this.updateAnchor = false, this.onComplete = null, this.onFrameChange = null, this.onLoop = null, this._currentTime = 0, this._playing = false, this._previousFrame = null, this.textures = t;
    }
    stop() {
      this._playing && (this._playing = false, this._autoUpdate && this._isConnectedToTicker && (ae.shared.remove(this.update, this), this._isConnectedToTicker = false));
    }
    play() {
      this._playing || (this._playing = true, this._autoUpdate && !this._isConnectedToTicker && (ae.shared.add(this.update, this, dr.HIGH), this._isConnectedToTicker = true));
    }
    gotoAndStop(t) {
      this.stop(), this.currentFrame = t;
    }
    gotoAndPlay(t) {
      this.currentFrame = t, this.play();
    }
    update(t) {
      if (!this._playing) return;
      const e = t.deltaTime, r = this.animationSpeed * e, s = this.currentFrame;
      if (this._durations !== null) {
        let n = this._currentTime % 1 * this._durations[this.currentFrame];
        for (n += r / 60 * 1e3; n < 0; ) this._currentTime--, n += this._durations[this.currentFrame];
        const o = Math.sign(this.animationSpeed * e);
        for (this._currentTime = Math.floor(this._currentTime); n >= this._durations[this.currentFrame]; ) n -= this._durations[this.currentFrame] * o, this._currentTime += o;
        this._currentTime += n / this._durations[this.currentFrame];
      } else this._currentTime += r;
      this._currentTime < 0 && !this.loop ? (this.gotoAndStop(0), this.onComplete && this.onComplete()) : this._currentTime >= this._textures.length && !this.loop ? (this.gotoAndStop(this._textures.length - 1), this.onComplete && this.onComplete()) : s !== this.currentFrame && (this.loop && this.onLoop && (this.animationSpeed > 0 && this.currentFrame < s || this.animationSpeed < 0 && this.currentFrame > s) && this.onLoop(), this._updateTexture());
    }
    _updateTexture() {
      const t = this.currentFrame;
      this._previousFrame !== t && (this._previousFrame = t, this.texture = this._textures[t], this.updateAnchor && this.anchor.copyFrom(this.texture.defaultAnchor), this.onFrameChange && this.onFrameChange(this.currentFrame));
    }
    destroy() {
      this.stop(), super.destroy(), this.onComplete = null, this.onFrameChange = null, this.onLoop = null;
    }
    static fromFrames(t) {
      const e = [];
      for (let r = 0; r < t.length; ++r) e.push(Z.from(t[r]));
      return new Os(e);
    }
    static fromImages(t) {
      const e = [];
      for (let r = 0; r < t.length; ++r) e.push(Z.from(t[r]));
      return new Os(e);
    }
    get totalFrames() {
      return this._textures.length;
    }
    get textures() {
      return this._textures;
    }
    set textures(t) {
      if (t[0] instanceof Z) this._textures = t, this._durations = null;
      else {
        this._textures = [], this._durations = [];
        for (let e = 0; e < t.length; e++) this._textures.push(t[e].texture), this._durations.push(t[e].time);
      }
      this._previousFrame = null, this.gotoAndStop(0), this._updateTexture();
    }
    get currentFrame() {
      let t = Math.floor(this._currentTime) % this._textures.length;
      return t < 0 && (t += this._textures.length), t;
    }
    set currentFrame(t) {
      if (t < 0 || t > this.totalFrames - 1) throw new Error(`[AnimatedSprite]: Invalid frame index value ${t}, expected to be between 0 and totalFrames ${this.totalFrames}.`);
      const e = this.currentFrame;
      this._currentTime = t, e !== this.currentFrame && this._updateTexture();
    }
    get playing() {
      return this._playing;
    }
    get autoUpdate() {
      return this._autoUpdate;
    }
    set autoUpdate(t) {
      t !== this._autoUpdate && (this._autoUpdate = t, !this._autoUpdate && this._isConnectedToTicker ? (ae.shared.remove(this.update, this), this._isConnectedToTicker = false) : this._autoUpdate && !this._isConnectedToTicker && this._playing && (ae.shared.add(this.update, this), this._isConnectedToTicker = true));
    }
  }
  class Gw {
    constructor({ matrix: t, observer: e } = {}) {
      this.dirty = true, this._matrix = t ?? new st(), this.observer = e, this.position = new Xt(this, 0, 0), this.scale = new Xt(this, 1, 1), this.pivot = new Xt(this, 0, 0), this.skew = new Xt(this, 0, 0), this._rotation = 0, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1;
    }
    get matrix() {
      const t = this._matrix;
      return this.dirty && (t.a = this._cx * this.scale.x, t.b = this._sx * this.scale.x, t.c = this._cy * this.scale.y, t.d = this._sy * this.scale.y, t.tx = this.position.x - (this.pivot.x * t.a + this.pivot.y * t.c), t.ty = this.position.y - (this.pivot.x * t.b + this.pivot.y * t.d), this.dirty = false), t;
    }
    _onUpdate(t) {
      var _a2;
      this.dirty = true, t === this.skew && this.updateSkew(), (_a2 = this.observer) == null ? void 0 : _a2._onUpdate(this);
    }
    updateSkew() {
      this._cx = Math.cos(this._rotation + this.skew.y), this._sx = Math.sin(this._rotation + this.skew.y), this._cy = -Math.sin(this._rotation - this.skew.x), this._sy = Math.cos(this._rotation - this.skew.x), this.dirty = true;
    }
    toString() {
      return `[pixi.js/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`;
    }
    setFromMatrix(t) {
      t.decompose(this), this.dirty = true;
    }
    get rotation() {
      return this._rotation;
    }
    set rotation(t) {
      this._rotation !== t && (this._rotation = t, this._onUpdate(this.skew));
    }
  }
  const dd = class Ss extends Dt {
    constructor(...t) {
      let e = t[0] || {};
      e instanceof Z && (e = {
        texture: e
      }), t.length > 1 && (lt(dt, "use new TilingSprite({ texture, width:100, height:100 }) instead"), e.width = t[1], e.height = t[2]), e = {
        ...Ss.defaultOptions,
        ...e
      };
      const { texture: r, anchor: s, tilePosition: n, tileScale: o, tileRotation: a, width: c, height: l, applyAnchorToTexture: u, roundPixels: h, ...d } = e ?? {};
      super({
        label: "TilingSprite",
        ...d
      }), this.renderPipeId = "tilingSprite", this.canBundle = true, this.batched = true, this._roundPixels = 0, this._bounds = {
        minX: 0,
        maxX: 1,
        minY: 0,
        maxY: 0
      }, this._boundsDirty = true, this.allowChildren = false, this._anchor = new Xt({
        _onUpdate: () => {
          this.onViewUpdate();
        }
      }), this._applyAnchorToTexture = u, this.texture = r, this._width = c ?? r.width, this._height = l ?? r.height, this._tileTransform = new Gw({
        observer: {
          _onUpdate: () => this.onViewUpdate()
        }
      }), s && (this.anchor = s), this.tilePosition = n, this.tileScale = o, this.tileRotation = a, this.roundPixels = h ?? false;
    }
    static from(t, e = {}) {
      return typeof t == "string" ? new Ss({
        texture: Ct.get(t),
        ...e
      }) : new Ss({
        texture: t,
        ...e
      });
    }
    get clampMargin() {
      return this._texture.textureMatrix.clampMargin;
    }
    set clampMargin(t) {
      this._texture.textureMatrix.clampMargin = t;
    }
    get anchor() {
      return this._anchor;
    }
    set anchor(t) {
      typeof t == "number" ? this._anchor.set(t) : this._anchor.copyFrom(t);
    }
    get tilePosition() {
      return this._tileTransform.position;
    }
    set tilePosition(t) {
      this._tileTransform.position.copyFrom(t);
    }
    get tileScale() {
      return this._tileTransform.scale;
    }
    set tileScale(t) {
      typeof t == "number" ? this._tileTransform.scale.set(t) : this._tileTransform.scale.copyFrom(t);
    }
    set tileRotation(t) {
      this._tileTransform.rotation = t;
    }
    get tileRotation() {
      return this._tileTransform.rotation;
    }
    get tileTransform() {
      return this._tileTransform;
    }
    get roundPixels() {
      return !!this._roundPixels;
    }
    set roundPixels(t) {
      this._roundPixels = t ? 1 : 0;
    }
    get bounds() {
      return this._boundsDirty && (this._updateBounds(), this._boundsDirty = false), this._bounds;
    }
    set texture(t) {
      t || (t = Z.EMPTY);
      const e = this._texture;
      e !== t && (e && e.dynamic && e.off("update", this.onViewUpdate, this), t.dynamic && t.on("update", this.onViewUpdate, this), this._texture = t, this.onViewUpdate());
    }
    get texture() {
      return this._texture;
    }
    set width(t) {
      this._width = t, this.onViewUpdate();
    }
    get width() {
      return this._width;
    }
    set height(t) {
      this._height = t, this.onViewUpdate();
    }
    get height() {
      return this._height;
    }
    _updateBounds() {
      const t = this._bounds, e = this._anchor, r = this._width, s = this._height;
      t.maxX = -e._x * r, t.minX = t.maxX + r, t.maxY = -e._y * s, t.minY = t.maxY + s;
    }
    addBounds(t) {
      const e = this.bounds;
      t.addFrame(e.minX, e.minY, e.maxX, e.maxY);
    }
    containsPoint(t) {
      const e = this._width, r = this._height, s = -e * this._anchor._x;
      let n = 0;
      return t.x >= s && t.x <= s + e && (n = -r * this._anchor._y, t.y >= n && t.y <= n + r);
    }
    onViewUpdate() {
      if (this._boundsDirty = true, this._didTilingSpriteUpdate = true, this._didChangeId += 4096, this.didViewUpdate) return;
      this.didViewUpdate = true;
      const t = this.renderGroup || this.parentRenderGroup;
      t && t.onChildViewUpdate(this);
    }
    destroy(t = false) {
      if (super.destroy(t), this._anchor = null, this._tileTransform = null, this._bounds = null, typeof t == "boolean" ? t : t == null ? void 0 : t.texture) {
        const r = typeof t == "boolean" ? t : t == null ? void 0 : t.textureSource;
        this._texture.destroy(r);
      }
      this._texture = null;
    }
  };
  dd.defaultOptions = {
    texture: Z.EMPTY,
    anchor: {
      x: 0,
      y: 0
    },
    tilePosition: {
      x: 0,
      y: 0
    },
    tileScale: {
      x: 1,
      y: 1
    },
    tileRotation: 0,
    applyAnchorToTexture: false
  };
  let Ow = dd;
  class _a extends Dt {
    constructor(t, e) {
      const { text: r, resolution: s, style: n, anchor: o, width: a, height: c, roundPixels: l, ...u } = t;
      super({
        ...u
      }), this.batched = true, this._resolution = null, this._autoResolution = true, this._didTextUpdate = true, this._roundPixels = 0, this._bounds = new re(), this._boundsDirty = true, this._styleClass = e, this.text = r ?? "", this.style = n, this.resolution = s ?? null, this.allowChildren = false, this._anchor = new Xt({
        _onUpdate: () => {
          this.onViewUpdate();
        }
      }), o && (this.anchor = o), this.roundPixels = l ?? false, a !== void 0 && (this.width = a), c !== void 0 && (this.height = c);
    }
    get anchor() {
      return this._anchor;
    }
    set anchor(t) {
      typeof t == "number" ? this._anchor.set(t) : this._anchor.copyFrom(t);
    }
    get roundPixels() {
      return !!this._roundPixels;
    }
    set roundPixels(t) {
      this._roundPixels = t ? 1 : 0;
    }
    set text(t) {
      t = t.toString(), this._text !== t && (this._text = t, this.onViewUpdate());
    }
    get text() {
      return this._text;
    }
    set resolution(t) {
      this._autoResolution = t === null, this._resolution = t, this.onViewUpdate();
    }
    get resolution() {
      return this._resolution;
    }
    get style() {
      return this._style;
    }
    set style(t) {
      var _a2;
      t = t || {}, (_a2 = this._style) == null ? void 0 : _a2.off("update", this.onViewUpdate, this), t instanceof this._styleClass ? this._style = t : this._style = new this._styleClass(t), this._style.on("update", this.onViewUpdate, this), this.onViewUpdate();
    }
    get bounds() {
      return this._boundsDirty && (this._updateBounds(), this._boundsDirty = false), this._bounds;
    }
    get width() {
      return Math.abs(this.scale.x) * this.bounds.width;
    }
    set width(t) {
      this._setWidth(t, this.bounds.width);
    }
    get height() {
      return Math.abs(this.scale.y) * this.bounds.height;
    }
    set height(t) {
      this._setHeight(t, this.bounds.height);
    }
    getSize(t) {
      return t || (t = {}), t.width = Math.abs(this.scale.x) * this.bounds.width, t.height = Math.abs(this.scale.y) * this.bounds.height, t;
    }
    setSize(t, e) {
      let r, s;
      typeof t != "object" ? (r = t, s = e ?? t) : (r = t.width, s = t.height ?? t.width), r !== void 0 && this._setWidth(r, this.bounds.width), s !== void 0 && this._setHeight(s, this.bounds.height);
    }
    addBounds(t) {
      const e = this.bounds;
      t.addFrame(e.minX, e.minY, e.maxX, e.maxY);
    }
    containsPoint(t) {
      const e = this.bounds.width, r = this.bounds.height, s = -e * this.anchor.x;
      let n = 0;
      return t.x >= s && t.x <= s + e && (n = -r * this.anchor.y, t.y >= n && t.y <= n + r);
    }
    onViewUpdate() {
      if (this._didChangeId += 4096, this._boundsDirty = true, this.didViewUpdate) return;
      this.didViewUpdate = true, this._didTextUpdate = true;
      const t = this.renderGroup || this.parentRenderGroup;
      t && t.onChildViewUpdate(this);
    }
    _getKey() {
      return `${this.text}:${this._style.styleKey}:${this._resolution}`;
    }
    destroy(t = false) {
      super.destroy(t), this.owner = null, this._bounds = null, this._anchor = null, (typeof t == "boolean" ? t : t == null ? void 0 : t.style) && this._style.destroy(t), this._style = null, this._text = null;
    }
  }
  function ga(i, t) {
    let e = i[0] ?? {};
    return (typeof e == "string" || i[1]) && (lt(dt, `use new ${t}({ text: "hi!", style }) instead`), e = {
      text: e,
      style: i[1]
    }), e;
  }
  class fd extends _a {
    constructor(...t) {
      const e = ga(t, "Text");
      super(e, Oe), this.renderPipeId = "text";
    }
    _updateBounds() {
      const t = this._bounds, e = this._anchor, r = Ge.measureText(this._text, this._style), { width: s, height: n } = r;
      t.minX = -e._x * s, t.maxX = t.minX + s, t.minY = -e._y * n, t.maxY = t.minY + n;
    }
  }
  class Nw extends kw {
    resolveQueueItem(t, e) {
      return t instanceof Dt ? this.resolveContainerQueueItem(t, e) : t instanceof Ht || t instanceof Z ? e.push(t.source) : t instanceof oe && e.push(t), null;
    }
    resolveContainerQueueItem(t, e) {
      t instanceof hr || t instanceof Ow || t instanceof hd ? e.push(t.texture.source) : t instanceof fd ? e.push(t) : t instanceof $e ? e.push(t.context) : t instanceof Os && t.textures.forEach((r) => {
        r.source ? e.push(r.source) : e.push(r.texture.source);
      });
    }
    resolveGraphicsContextQueueItem(t) {
      this.renderer.graphicsContext.getContextRenderData(t);
      const { instructions: e } = t;
      for (const r of e) if (r.action === "texture") {
        const { image: s } = r.data;
        return s.source;
      } else if (r.action === "fill") {
        const { texture: s } = r.data.style;
        return s.source;
      }
      return null;
    }
  }
  class Lw extends _a {
    constructor(...t) {
      var e;
      const r = ga(t, "BitmapText");
      r.style ?? (r.style = r.style || {}), (e = r.style).fill ?? (e.fill = 16777215), super(r, Oe), this.renderPipeId = "bitmapText";
    }
    _updateBounds() {
      const t = this._bounds, e = this._anchor, r = ks.measureText(this.text, this._style), s = r.scale, n = r.offsetY * s;
      let o = r.width * s, a = r.height * s;
      const c = this._style._stroke;
      c && (o += c.width, a += c.width), t.minX = -e._x * o, t.maxX = t.minX + o, t.minY = -e._y * (a + n), t.maxY = t.minY + a;
    }
  }
  function Hw(i) {
    const t = i._stroke, e = i._fill, s = [
      `div { ${[
        `color: ${Tt.shared.setValue(e.color).toHex()}`,
        `font-size: ${i.fontSize}px`,
        `font-family: ${i.fontFamily}`,
        `font-weight: ${i.fontWeight}`,
        `font-style: ${i.fontStyle}`,
        `font-variant: ${i.fontVariant}`,
        `letter-spacing: ${i.letterSpacing}px`,
        `text-align: ${i.align}`,
        `padding: ${i.padding}px`,
        `white-space: ${i.whiteSpace === "pre" && i.wordWrap ? "pre-wrap" : i.whiteSpace}`,
        ...i.lineHeight ? [
          `line-height: ${i.lineHeight}px`
        ] : [],
        ...i.wordWrap ? [
          `word-wrap: ${i.breakWords ? "break-all" : "break-word"}`,
          `max-width: ${i.wordWrapWidth}px`
        ] : [],
        ...t ? [
          _d(t)
        ] : [],
        ...i.dropShadow ? [
          pd(i.dropShadow)
        ] : [],
        ...i.cssOverrides
      ].join(";")} }`
    ];
    return zw(i.tagStyles, s), s.join(" ");
  }
  function pd(i) {
    const t = Tt.shared.setValue(i.color).setAlpha(i.alpha).toHexa(), e = Math.round(Math.cos(i.angle) * i.distance), r = Math.round(Math.sin(i.angle) * i.distance), s = `${e}px ${r}px`;
    return i.blur > 0 ? `text-shadow: ${s} ${i.blur}px ${t}` : `text-shadow: ${s} ${t}`;
  }
  function _d(i) {
    return [
      `-webkit-text-stroke-width: ${i.width}px`,
      `-webkit-text-stroke-color: ${Tt.shared.setValue(i.color).toHex()}`,
      `text-stroke-width: ${i.width}px`,
      `text-stroke-color: ${Tt.shared.setValue(i.color).toHex()}`,
      "paint-order: stroke"
    ].join(";");
  }
  const yu = {
    fontSize: "font-size: {{VALUE}}px",
    fontFamily: "font-family: {{VALUE}}",
    fontWeight: "font-weight: {{VALUE}}",
    fontStyle: "font-style: {{VALUE}}",
    fontVariant: "font-variant: {{VALUE}}",
    letterSpacing: "letter-spacing: {{VALUE}}px",
    align: "text-align: {{VALUE}}",
    padding: "padding: {{VALUE}}px",
    whiteSpace: "white-space: {{VALUE}}",
    lineHeight: "line-height: {{VALUE}}px",
    wordWrapWidth: "max-width: {{VALUE}}px"
  }, xu = {
    fill: (i) => `color: ${Tt.shared.setValue(i).toHex()}`,
    breakWords: (i) => `word-wrap: ${i ? "break-all" : "break-word"}`,
    stroke: _d,
    dropShadow: pd
  };
  function zw(i, t) {
    for (const e in i) {
      const r = i[e], s = [];
      for (const n in r) xu[n] ? s.push(xu[n](r[n])) : yu[n] && s.push(yu[n].replace("{{VALUE}}", r[n]));
      t.push(`${e} { ${s.join(";")} }`);
    }
  }
  class sn extends Oe {
    constructor(t = {}) {
      super(t), this._cssOverrides = [], this.cssOverrides ?? (this.cssOverrides = t.cssOverrides), this.tagStyles = t.tagStyles ?? {};
    }
    set cssOverrides(t) {
      this._cssOverrides = t instanceof Array ? t : [
        t
      ], this.update();
    }
    get cssOverrides() {
      return this._cssOverrides;
    }
    _generateKey() {
      return this._styleKey = Fh(this) + this._cssOverrides.join("-"), this._styleKey;
    }
    update() {
      this._cssStyle = null, super.update();
    }
    clone() {
      return new sn({
        align: this.align,
        breakWords: this.breakWords,
        dropShadow: this.dropShadow ? {
          ...this.dropShadow
        } : null,
        fill: this._fill,
        fontFamily: this.fontFamily,
        fontSize: this.fontSize,
        fontStyle: this.fontStyle,
        fontVariant: this.fontVariant,
        fontWeight: this.fontWeight,
        letterSpacing: this.letterSpacing,
        lineHeight: this.lineHeight,
        padding: this.padding,
        stroke: this._stroke,
        whiteSpace: this.whiteSpace,
        wordWrap: this.wordWrap,
        wordWrapWidth: this.wordWrapWidth,
        cssOverrides: this.cssOverrides
      });
    }
    get cssStyle() {
      return this._cssStyle || (this._cssStyle = Hw(this)), this._cssStyle;
    }
    addOverride(...t) {
      const e = t.filter((r) => !this.cssOverrides.includes(r));
      e.length > 0 && (this.cssOverrides.push(...e), this.update());
    }
    removeOverride(...t) {
      const e = t.filter((r) => this.cssOverrides.includes(r));
      e.length > 0 && (this.cssOverrides = this.cssOverrides.filter((r) => !e.includes(r)), this.update());
    }
    set fill(t) {
      typeof t != "string" && typeof t != "number" && ut("[HTMLTextStyle] only color fill is not supported by HTMLText"), super.fill = t;
    }
    set stroke(t) {
      t && typeof t != "string" && typeof t != "number" && ut("[HTMLTextStyle] only color stroke is not supported by HTMLText"), super.stroke = t;
    }
  }
  const vu = "http://www.w3.org/2000/svg", Su = "http://www.w3.org/1999/xhtml";
  class gd {
    constructor() {
      this.svgRoot = document.createElementNS(vu, "svg"), this.foreignObject = document.createElementNS(vu, "foreignObject"), this.domElement = document.createElementNS(Su, "div"), this.styleElement = document.createElementNS(Su, "style"), this.image = new Image();
      const { foreignObject: t, svgRoot: e, styleElement: r, domElement: s } = this;
      t.setAttribute("width", "10000"), t.setAttribute("height", "10000"), t.style.overflow = "hidden", e.appendChild(t), t.appendChild(r), t.appendChild(s);
    }
  }
  let Eu;
  function md(i, t, e, r) {
    r = r || Eu || (Eu = new gd());
    const { domElement: s, styleElement: n, svgRoot: o } = r;
    s.innerHTML = `<style>${t.cssStyle};</style><div style='padding:0'>${i}</div>`, s.setAttribute("style", "transform-origin: top left; display: inline-block"), e && (n.textContent = e), document.body.appendChild(o);
    const a = s.getBoundingClientRect();
    o.remove();
    const c = Ge.measureFont(t.fontStyle).descent, l = t.padding * 2;
    return {
      width: a.width - l,
      height: a.height + c - l
    };
  }
  class jw extends _a {
    constructor(...t) {
      const e = ga(t, "HtmlText");
      super(e, sn), this.renderPipeId = "htmlText";
    }
    _updateBounds() {
      const t = this._bounds, e = this._anchor, r = md(this.text, this._style), { width: s, height: n } = r;
      t.minX = -e._x * s, t.maxX = t.minX + s, t.minY = -e._y * n, t.maxY = t.minY + n;
    }
  }
  class Ww extends Nw {
    uploadQueueItem(t) {
      t instanceof Ht ? this.uploadTextureSource(t) : t instanceof fd ? this.uploadText(t) : t instanceof jw ? this.uploadHTMLText(t) : t instanceof Lw ? this.uploadBitmapText(t) : t instanceof oe && this.uploadGraphicsContext(t);
    }
    uploadTextureSource(t) {
      this.renderer.texture.initSource(t);
    }
    uploadText(t) {
      this.renderer.renderPipes.text.initGpuText(t);
    }
    uploadBitmapText(t) {
      this.renderer.renderPipes.bitmapText.initGpuText(t);
    }
    uploadHTMLText(t) {
      this.renderer.renderPipes.htmlText.initGpuText(t);
    }
    uploadGraphicsContext(t) {
      this.renderer.graphicsContext.getContextRenderData(t);
      const { instructions: e } = t;
      for (const r of e) if (r.action === "texture") {
        const { image: s } = r.data;
        this.uploadTextureSource(s.source);
      } else if (r.action === "fill") {
        const { texture: s } = r.data.style;
        this.uploadTextureSource(s.source);
      }
      return null;
    }
  }
  class Vw extends Ww {
    destroy() {
      clearTimeout(this.timeout), this.renderer = null, this.queue = null, this.resolves = null;
    }
  }
  Vw.extension = {
    type: [
      P.WebGLSystem,
      P.WebGPUSystem
    ],
    name: "prepare"
  };
  function Tu(i, t, e) {
    if (i) for (const r in i) {
      const s = r.toLocaleLowerCase(), n = t[s];
      if (n) {
        let o = i[r];
        r === "header" && (o = o.replace(/@in\s+[^;]+;\s*/g, "").replace(/@out\s+[^;]+;\s*/g, "")), e && n.push(`//----${e}----//`), n.push(o);
      } else ut(`${r} placement hook does not exist in shader`);
    }
  }
  const Xw = /\{\{(.*?)\}\}/g;
  function Cu(i) {
    var _a2;
    const t = {};
    return (((_a2 = i.match(Xw)) == null ? void 0 : _a2.map((r) => r.replace(/[{()}]/g, ""))) ?? []).forEach((r) => {
      t[r] = [];
    }), t;
  }
  function Au(i, t) {
    let e;
    const r = /@in\s+([^;]+);/g;
    for (; (e = r.exec(i)) !== null; ) t.push(e[1]);
  }
  function Ru(i, t, e = false) {
    const r = [];
    Au(t, r), i.forEach((a) => {
      a.header && Au(a.header, r);
    });
    const s = r;
    e && s.sort();
    const n = s.map((a, c) => `       @location(${c}) ${a},`).join(`
`);
    let o = t.replace(/@in\s+[^;]+;\s*/g, "");
    return o = o.replace("{{in}}", `
${n}
`), o;
  }
  function Pu(i, t) {
    let e;
    const r = /@out\s+([^;]+);/g;
    for (; (e = r.exec(i)) !== null; ) t.push(e[1]);
  }
  function qw(i) {
    const e = /\b(\w+)\s*:/g.exec(i);
    return e ? e[1] : "";
  }
  function $w(i) {
    const t = /@.*?\s+/g;
    return i.replace(t, "");
  }
  function Yw(i, t) {
    const e = [];
    Pu(t, e), i.forEach((c) => {
      c.header && Pu(c.header, e);
    });
    let r = 0;
    const s = e.sort().map((c) => c.indexOf("builtin") > -1 ? c : `@location(${r++}) ${c}`).join(`,
`), n = e.sort().map((c) => `       var ${$w(c)};`).join(`
`), o = `return VSOutput(
                ${e.sort().map((c) => ` ${qw(c)}`).join(`,
`)});`;
    let a = t.replace(/@out\s+[^;]+;\s*/g, "");
    return a = a.replace("{{struct}}", `
${s}
`), a = a.replace("{{start}}", `
${n}
`), a = a.replace("{{return}}", `
${o}
`), a;
  }
  function Bu(i, t) {
    let e = i;
    for (const r in t) {
      const s = t[r];
      s.join(`
`).length ? e = e.replace(`{{${r}}}`, `//-----${r} START-----//
${s.join(`
`)}
//----${r} FINISH----//`) : e = e.replace(`{{${r}}}`, "");
    }
    return e;
  }
  const ur = /* @__PURE__ */ Object.create(null), no = /* @__PURE__ */ new Map();
  let Kw = 0;
  function Jw({ template: i, bits: t }) {
    const e = bd(i, t);
    if (ur[e]) return ur[e];
    const { vertex: r, fragment: s } = Qw(i, t);
    return ur[e] = wd(r, s, t), ur[e];
  }
  function Zw({ template: i, bits: t }) {
    const e = bd(i, t);
    return ur[e] || (ur[e] = wd(i.vertex, i.fragment, t)), ur[e];
  }
  function Qw(i, t) {
    const e = t.map((o) => o.vertex).filter((o) => !!o), r = t.map((o) => o.fragment).filter((o) => !!o);
    let s = Ru(e, i.vertex, true);
    s = Yw(e, s);
    const n = Ru(r, i.fragment, true);
    return {
      vertex: s,
      fragment: n
    };
  }
  function bd(i, t) {
    return t.map((e) => (no.has(e) || no.set(e, Kw++), no.get(e))).sort((e, r) => e - r).join("-") + i.vertex + i.fragment;
  }
  function wd(i, t, e) {
    const r = Cu(i), s = Cu(t);
    return e.forEach((n) => {
      Tu(n.vertex, r, n.name), Tu(n.fragment, s, n.name);
    }), {
      vertex: Bu(i, r),
      fragment: Bu(t, s)
    };
  }
  const ty = `
    @in aPosition: vec2<f32>;
    @in aUV: vec2<f32>;

    @out @builtin(position) vPosition: vec4<f32>;
    @out vUV : vec2<f32>;
    @out vColor : vec4<f32>;

    {{header}}

    struct VSOutput {
        {{struct}}
    };

    @vertex
    fn main( {{in}} ) -> VSOutput {

        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;
        var modelMatrix = mat3x3<f32>(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        var position = aPosition;
        var uv = aUV;

        {{start}}
        
        vColor = vec4<f32>(1., 1., 1., 1.);

        {{main}}

        vUV = uv;

        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;

        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);
       
        vColor *= globalUniforms.uWorldColorAlpha;

        {{end}}

        {{return}}
    };
`, ey = `
    @in vUV : vec2<f32>;
    @in vColor : vec4<f32>;
   
    {{header}}

    @fragment
    fn main(
        {{in}}
      ) -> @location(0) vec4<f32> {
        
        {{start}}

        var outColor:vec4<f32>;
      
        {{main}}
        
        return outColor * vColor;
      };
`, ry = `
    in vec2 aPosition;
    in vec2 aUV;

    out vec4 vColor;
    out vec2 vUV;

    {{header}}

    void main(void){

        mat3 worldTransformMatrix = uWorldTransformMatrix;
        mat3 modelMatrix = mat3(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        vec2 position = aPosition;
        vec2 uv = aUV;
        
        {{start}}
        
        vColor = vec4(1.);
        
        {{main}}
        
        vUV = uv;
        
        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;

        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);

        vColor *= uWorldColorAlpha;

        {{end}}
    }
`, iy = `
   
    in vec4 vColor;
    in vec2 vUV;

    out vec4 finalColor;

    {{header}}

    void main(void) {
        
        {{start}}

        vec4 outColor;
      
        {{main}}
        
        finalColor = outColor * vColor;
    }
`, sy = {
    name: "global-uniforms-bit",
    vertex: {
      header: `
        struct GlobalUniforms {
            uProjectionMatrix:mat3x3<f32>,
            uWorldTransformMatrix:mat3x3<f32>,
            uWorldColorAlpha: vec4<f32>,
            uResolution: vec2<f32>,
        }

        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;
        `
    }
  };
  const ny = {
    name: "global-uniforms-bit",
    vertex: {
      header: `
          uniform mat3 uProjectionMatrix;
          uniform mat3 uWorldTransformMatrix;
          uniform vec4 uWorldColorAlpha;
          uniform vec2 uResolution;
        `
    }
  };
  function ki({ bits: i, name: t }) {
    const e = Jw({
      template: {
        fragment: ey,
        vertex: ty
      },
      bits: [
        sy,
        ...i
      ]
    });
    return Ne.from({
      name: t,
      vertex: {
        source: e.vertex,
        entryPoint: "main"
      },
      fragment: {
        source: e.fragment,
        entryPoint: "main"
      }
    });
  }
  function Gi({ bits: i, name: t }) {
    return new ir({
      name: t,
      ...Zw({
        template: {
          vertex: ry,
          fragment: iy
        },
        bits: [
          ny,
          ...i
        ]
      })
    });
  }
  const ma = {
    name: "color-bit",
    vertex: {
      header: `
            @in aColor: vec4<f32>;
        `,
      main: `
            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);
        `
    }
  }, ba = {
    name: "color-bit",
    vertex: {
      header: `
            in vec4 aColor;
        `,
      main: `
            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);
        `
    }
  }, oo = {};
  function oy(i) {
    const t = [];
    if (i === 1) t.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;"), t.push("@group(1) @binding(1) var textureSampler1: sampler;");
    else {
      let e = 0;
      for (let r = 0; r < i; r++) t.push(`@group(1) @binding(${e++}) var textureSource${r + 1}: texture_2d<f32>;`), t.push(`@group(1) @binding(${e++}) var textureSampler${r + 1}: sampler;`);
    }
    return t.join(`
`);
  }
  function ay(i) {
    const t = [];
    if (i === 1) t.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);");
    else {
      t.push("switch vTextureId {");
      for (let e = 0; e < i; e++) e === i - 1 ? t.push("  default:{") : t.push(`  case ${e}:{`), t.push(`      outColor = textureSampleGrad(textureSource${e + 1}, textureSampler${e + 1}, vUV, uvDx, uvDy);`), t.push("      break;}");
      t.push("}");
    }
    return t.join(`
`);
  }
  function wa(i) {
    return oo[i] || (oo[i] = {
      name: "texture-batch-bit",
      vertex: {
        header: `
                @in aTextureIdAndRound: vec2<u32>;
                @out @interpolate(flat) vTextureId : u32;
            `,
        main: `
                vTextureId = aTextureIdAndRound.y;
            `,
        end: `
                if(aTextureIdAndRound.x == 1)
                {
                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
                }
            `
      },
      fragment: {
        header: `
                @in @interpolate(flat) vTextureId: u32;

                ${oy(i)}
            `,
        main: `
                var uvDx = dpdx(vUV);
                var uvDy = dpdy(vUV);

                ${ay(i)}
            `
      }
    }), oo[i];
  }
  const ao = {};
  function cy(i) {
    const t = [];
    for (let e = 0; e < i; e++) e > 0 && t.push("else"), e < i - 1 && t.push(`if(vTextureId < ${e}.5)`), t.push("{"), t.push(`	outColor = texture(uTextures[${e}], vUV);`), t.push("}");
    return t.join(`
`);
  }
  function ya(i) {
    return ao[i] || (ao[i] = {
      name: "texture-batch-bit",
      vertex: {
        header: `
                in vec2 aTextureIdAndRound;
                out float vTextureId;

            `,
        main: `
                vTextureId = aTextureIdAndRound.y;
            `,
        end: `
                if(aTextureIdAndRound.x == 1.)
                {
                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
                }
            `
      },
      fragment: {
        header: `
                in float vTextureId;

                uniform sampler2D uTextures[${i}];

            `,
        main: `

                ${cy(i)}
            `
      }
    }), ao[i];
  }
  const Oi = {
    name: "round-pixels-bit",
    vertex: {
      header: `
            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> 
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
    }
  }, Ni = {
    name: "round-pixels-bit",
    vertex: {
      header: `   
            vec2 roundPixels(vec2 position, vec2 targetSize)
            {       
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
    }
  }, Mu = {};
  function xa(i) {
    let t = Mu[i];
    if (t) return t;
    const e = new Int32Array(i);
    for (let r = 0; r < i; r++) e[r] = r;
    return t = Mu[i] = new Qt({
      uTextures: {
        value: e,
        type: "i32",
        size: i
      }
    }, {
      isStatic: true
    }), t;
  }
  class yd {
    constructor() {
      this._didUpload = false, this._tempState = Le.for2d();
    }
    init(t) {
      const e = Fr(), r = Gi({
        name: "batch",
        bits: [
          ba,
          ya(e),
          Ni
        ]
      });
      this._shader = new Se({
        glProgram: r,
        resources: {
          batchSamplers: xa(e)
        }
      }), t.renderer.runners.contextChange.add(this);
    }
    contextChange() {
      this._didUpload = false;
    }
    start(t, e) {
      const r = t.renderer;
      r.shader.bind(this._shader, this._didUpload), r.shader.updateUniformGroup(r.globalUniforms.uniformGroup), r.geometry.bind(e, this._shader.glProgram);
    }
    execute(t, e) {
      const r = t.renderer;
      this._didUpload = true, this._tempState.blendMode = e.blendMode, r.state.set(this._tempState);
      const s = e.textures.textures;
      for (let n = 0; n < e.textures.count; n++) r.texture.bind(s[n], n);
      r.geometry.draw("triangle-list", e.size, e.start);
    }
    destroy() {
      this._shader.destroy(true), this._shader = null;
    }
  }
  yd.extension = {
    type: [
      P.WebGLPipesAdaptor
    ],
    name: "batch"
  };
  const hs = Le.for2d();
  class xd {
    init() {
      const t = ki({
        name: "batch",
        bits: [
          ma,
          wa(Fr()),
          Oi
        ]
      });
      this._shader = new Se({
        gpuProgram: t,
        groups: {}
      });
    }
    start(t, e) {
      const r = t.renderer, s = r.encoder, n = this._shader.gpuProgram;
      this._geometry = e, s.setGeometry(e), hs.blendMode = "normal", r.pipeline.getPipeline(e, n, hs);
      const o = r.globalUniforms.bindGroup;
      s.resetBindGroup(1), s.setBindGroup(0, o, n);
    }
    execute(t, e) {
      const r = this._shader.gpuProgram, s = t.renderer, n = s.encoder;
      if (!e.bindGroup) {
        const c = e.textures;
        e.bindGroup = aa(c.textures, c.count);
      }
      hs.blendMode = e.blendMode;
      const o = s.bindGroup.getBindGroup(e.bindGroup, r, 1), a = s.pipeline.getPipeline(this._geometry, r, hs);
      e.bindGroup._touch(s.textureGC.count), n.setPipeline(a), n.renderPassEncoder.setBindGroup(1, o), n.renderPassEncoder.drawIndexed(e.size, 1, e.start);
    }
    destroy() {
      this._shader.destroy(true), this._shader = null;
    }
  }
  xd.extension = {
    type: [
      P.WebGPUPipesAdaptor
    ],
    name: "batch"
  };
  class vd {
    constructor(t, e) {
      this.state = Le.for2d(), this._batches = /* @__PURE__ */ Object.create(null), this._geometries = /* @__PURE__ */ Object.create(null), this.renderer = t, this._adaptor = e, this._adaptor.init(this);
    }
    buildStart(t) {
      if (!this._batches[t.uid]) {
        const e = new Th();
        this._batches[t.uid] = e, this._geometries[e.uid] = new Ah();
      }
      this._activeBatch = this._batches[t.uid], this._activeGeometry = this._geometries[this._activeBatch.uid], this._activeBatch.begin();
    }
    addToBatch(t) {
      this._activeBatch.add(t);
    }
    break(t) {
      this._activeBatch.break(t);
    }
    buildEnd(t) {
      const e = this._activeBatch, r = this._activeGeometry;
      e.finish(t), r.indexBuffer.setDataWithSize(e.indexBuffer, e.indexSize, true), r.buffers[0].setDataWithSize(e.attributeBuffer.float32View, e.attributeSize, false);
    }
    upload(t) {
      const e = this._batches[t.uid], r = this._geometries[e.uid];
      e.dirty && (e.dirty = false, r.buffers[0].update(e.attributeSize * 4));
    }
    execute(t) {
      if (t.action === "startBatch") {
        const e = t.batcher, r = this._geometries[e.uid];
        this._adaptor.start(this, r);
      }
      this._adaptor.execute(this, t);
    }
    destroy() {
      this.state = null, this.renderer = null, this._adaptor.destroy(), this._adaptor = null;
      for (const t in this._batches) this._batches[t].destroy();
      this._batches = null;
      for (const t in this._geometries) this._geometries[t].destroy();
      this._geometries = null;
    }
  }
  vd.extension = {
    type: [
      P.WebGLPipes,
      P.WebGPUPipes,
      P.CanvasPipes
    ],
    name: "batch"
  };
  const Ei = {
    name: "local-uniform-bit",
    vertex: {
      header: `

            struct LocalUniforms {
                uTransformMatrix:mat3x3<f32>,
                uColor:vec4<f32>,
                uRound:f32,
            }

            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `,
      main: `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `,
      end: `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `
    }
  }, uy = {
    ...Ei,
    vertex: {
      ...Ei.vertex,
      header: Ei.vertex.header.replace("group(1)", "group(2)")
    }
  }, va = {
    name: "local-uniform-bit",
    vertex: {
      header: `

            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `,
      main: `
            vColor *= uColor;
            modelMatrix = uTransformMatrix;
        `,
      end: `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `
    }
  }, ly = {
    name: "texture-bit",
    vertex: {
      header: `

        struct TextureUniforms {
            uTextureMatrix:mat3x3<f32>,
        }

        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;
        `,
      main: `
            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;
        `
    },
    fragment: {
      header: `
            @group(2) @binding(0) var uTexture: texture_2d<f32>;
            @group(2) @binding(1) var uSampler: sampler;

         
        `,
      main: `
            outColor = textureSample(uTexture, uSampler, vUV);
        `
    }
  }, hy = {
    name: "texture-bit",
    vertex: {
      header: `
            uniform mat3 uTextureMatrix;
        `,
      main: `
            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;
        `
    },
    fragment: {
      header: `
        uniform sampler2D uTexture;

         
        `,
      main: `
            outColor = texture(uTexture, vUV);
        `
    }
  };
  function dy(i, t) {
    const e = i.root, r = i.instructionSet;
    r.reset(), t.batch.buildStart(r), t.blendMode.buildStart(), t.colorMask.buildStart(), e.sortableChildren && e.sortChildren(), Sd(e, r, t, true), t.batch.buildEnd(r), t.blendMode.buildEnd(r);
  }
  function nn(i, t, e) {
    i.globalDisplayStatus < 7 || !i.includeInBuild || (i.sortableChildren && i.sortChildren(), i.isSimple ? fy(i, t, e) : Sd(i, t, e, false));
  }
  function fy(i, t, e) {
    if (i.renderPipeId && (e.blendMode.setBlendMode(i, i.groupBlendMode, t), i.didViewUpdate = false, e[i.renderPipeId].addRenderable(i, t)), !i.renderGroup) {
      const r = i.children, s = r.length;
      for (let n = 0; n < s; n++) nn(r[n], t, e);
    }
  }
  function Sd(i, t, e, r) {
    if (!r && i.renderGroup) e.renderGroup.addRenderGroup(i.renderGroup, t);
    else {
      for (let o = 0; o < i.effects.length; o++) {
        const a = i.effects[o];
        e[a.pipe].push(a, i, t);
      }
      const s = i.renderPipeId;
      s && (e.blendMode.setBlendMode(i, i.groupBlendMode, t), i.didViewUpdate = false, e[s].addRenderable(i, t));
      const n = i.children;
      if (n.length) for (let o = 0; o < n.length; o++) nn(n[o], t, e);
      for (let o = i.effects.length - 1; o >= 0; o--) {
        const a = i.effects[o];
        e[a.pipe].pop(a, i, t);
      }
    }
  }
  const py = new re();
  class _y extends Rs {
    constructor() {
      super(), this.filters = [
        new Uw({
          sprite: new hr(Z.EMPTY),
          resolution: "inherit",
          antialias: "inherit"
        })
      ];
    }
    get sprite() {
      return this.filters[0].sprite;
    }
    set sprite(t) {
      this.filters[0].sprite = t;
    }
  }
  class Ed {
    constructor(t) {
      this._activeMaskStage = [], this._renderer = t;
    }
    push(t, e, r) {
      const s = this._renderer;
      if (s.renderPipes.batch.break(r), r.add({
        renderPipeId: "alphaMask",
        action: "pushMaskBegin",
        mask: t,
        canBundle: false,
        maskedContainer: e
      }), t.renderMaskToTexture) {
        const n = t.mask;
        n.includeInBuild = true, nn(n, r, s.renderPipes), n.includeInBuild = false;
      }
      s.renderPipes.batch.break(r), r.add({
        renderPipeId: "alphaMask",
        action: "pushMaskEnd",
        mask: t,
        maskedContainer: e,
        canBundle: false
      });
    }
    pop(t, e, r) {
      this._renderer.renderPipes.batch.break(r), r.add({
        renderPipeId: "alphaMask",
        action: "popMaskEnd",
        mask: t,
        canBundle: false
      });
    }
    execute(t) {
      const e = this._renderer, r = t.mask.renderMaskToTexture;
      if (t.action === "pushMaskBegin") {
        const s = vt.get(_y);
        if (r) {
          t.mask.mask.measurable = true;
          const n = Xs(t.mask.mask, true, py);
          t.mask.mask.measurable = false, n.ceil();
          const o = e.renderTarget.renderTarget.colorTexture.source, a = Zt.getOptimalTexture(n.width, n.height, o._resolution, o.antialias);
          e.renderTarget.push(a, true), e.globalUniforms.push({
            offset: n,
            worldColor: 4294967295
          });
          const c = s.sprite;
          c.texture = a, c.worldTransform.tx = n.minX, c.worldTransform.ty = n.minY, this._activeMaskStage.push({
            filterEffect: s,
            maskedContainer: t.maskedContainer,
            filterTexture: a
          });
        } else s.sprite = t.mask.mask, this._activeMaskStage.push({
          filterEffect: s,
          maskedContainer: t.maskedContainer
        });
      } else if (t.action === "pushMaskEnd") {
        const s = this._activeMaskStage[this._activeMaskStage.length - 1];
        r && (e.type === ge.WEBGL && e.renderTarget.finishRenderPass(), e.renderTarget.pop(), e.globalUniforms.pop()), e.filter.push({
          renderPipeId: "filter",
          action: "pushFilter",
          container: s.maskedContainer,
          filterEffect: s.filterEffect,
          canBundle: false
        });
      } else if (t.action === "popMaskEnd") {
        e.filter.pop();
        const s = this._activeMaskStage.pop();
        r && Zt.returnTexture(s.filterTexture), vt.return(s.filterEffect);
      }
    }
    destroy() {
      this._renderer = null, this._activeMaskStage = null;
    }
  }
  Ed.extension = {
    type: [
      P.WebGLPipes,
      P.WebGPUPipes,
      P.CanvasPipes
    ],
    name: "alphaMask"
  };
  class Td {
    constructor(t) {
      this._colorStack = [], this._colorStackIndex = 0, this._currentColor = 0, this._renderer = t;
    }
    buildStart() {
      this._colorStack[0] = 15, this._colorStackIndex = 1, this._currentColor = 15;
    }
    push(t, e, r) {
      this._renderer.renderPipes.batch.break(r);
      const n = this._colorStack;
      n[this._colorStackIndex] = n[this._colorStackIndex - 1] & t.mask;
      const o = this._colorStack[this._colorStackIndex];
      o !== this._currentColor && (this._currentColor = o, r.add({
        renderPipeId: "colorMask",
        colorMask: o,
        canBundle: false
      })), this._colorStackIndex++;
    }
    pop(t, e, r) {
      this._renderer.renderPipes.batch.break(r);
      const n = this._colorStack;
      this._colorStackIndex--;
      const o = n[this._colorStackIndex - 1];
      o !== this._currentColor && (this._currentColor = o, r.add({
        renderPipeId: "colorMask",
        colorMask: o,
        canBundle: false
      }));
    }
    execute(t) {
      this._renderer.colorMask.setMask(t.colorMask);
    }
    destroy() {
      this._colorStack = null;
    }
  }
  Td.extension = {
    type: [
      P.WebGLPipes,
      P.WebGPUPipes,
      P.CanvasPipes
    ],
    name: "colorMask"
  };
  class Cd {
    constructor(t) {
      this._maskStackHash = {}, this._maskHash = /* @__PURE__ */ new WeakMap(), this._renderer = t;
    }
    push(t, e, r) {
      var s;
      const n = t, o = this._renderer;
      o.renderPipes.batch.break(r), o.renderPipes.blendMode.setBlendMode(n.mask, "none", r), r.add({
        renderPipeId: "stencilMask",
        action: "pushMaskBegin",
        mask: t,
        canBundle: false
      });
      const a = n.mask;
      a.includeInBuild = true, this._maskHash.has(n) || this._maskHash.set(n, {
        instructionsStart: 0,
        instructionsLength: 0
      });
      const c = this._maskHash.get(n);
      c.instructionsStart = r.instructionSize, nn(a, r, o.renderPipes), a.includeInBuild = false, o.renderPipes.batch.break(r), r.add({
        renderPipeId: "stencilMask",
        action: "pushMaskEnd",
        mask: t,
        canBundle: false
      });
      const l = r.instructionSize - c.instructionsStart - 1;
      c.instructionsLength = l;
      const u = o.renderTarget.renderTarget.uid;
      (s = this._maskStackHash)[u] ?? (s[u] = 0);
    }
    pop(t, e, r) {
      const s = t, n = this._renderer;
      n.renderPipes.batch.break(r), n.renderPipes.blendMode.setBlendMode(s.mask, "none", r), r.add({
        renderPipeId: "stencilMask",
        action: "popMaskBegin",
        canBundle: false
      });
      const o = this._maskHash.get(t);
      for (let a = 0; a < o.instructionsLength; a++) r.instructions[r.instructionSize++] = r.instructions[o.instructionsStart++];
      r.add({
        renderPipeId: "stencilMask",
        action: "popMaskEnd",
        canBundle: false
      });
    }
    execute(t) {
      var e;
      const r = this._renderer, s = r.renderTarget.renderTarget.uid;
      let n = (e = this._maskStackHash)[s] ?? (e[s] = 0);
      t.action === "pushMaskBegin" ? (r.renderTarget.ensureDepthStencil(), r.stencil.setStencilMode(Kt.RENDERING_MASK_ADD, n), n++, r.colorMask.setMask(0)) : t.action === "pushMaskEnd" ? (r.stencil.setStencilMode(Kt.MASK_ACTIVE, n), r.colorMask.setMask(15)) : t.action === "popMaskBegin" ? (r.colorMask.setMask(0), n !== 0 ? r.stencil.setStencilMode(Kt.RENDERING_MASK_REMOVE, n) : (r.renderTarget.clear(null, pe.STENCIL), r.stencil.setStencilMode(Kt.DISABLED, n)), n--) : t.action === "popMaskEnd" && (r.stencil.setStencilMode(Kt.MASK_ACTIVE, n), r.colorMask.setMask(15)), this._maskStackHash[s] = n;
    }
    destroy() {
      this._renderer = null, this._maskStackHash = null, this._maskHash = null;
    }
  }
  Cd.extension = {
    type: [
      P.WebGLPipes,
      P.WebGPUPipes,
      P.CanvasPipes
    ],
    name: "stencilMask"
  };
  var Es = ((i) => (i[i.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", i[i.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", i[i.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER", i))(Es || {});
  class gy {
    constructor(t, e) {
      this.buffer = t || null, this.updateID = -1, this.byteLength = -1, this.type = e;
    }
  }
  class Ad {
    constructor(t) {
      this._gpuBuffers = /* @__PURE__ */ Object.create(null), this._boundBufferBases = /* @__PURE__ */ Object.create(null), this._renderer = t;
    }
    destroy() {
      this._renderer = null, this._gl = null, this._gpuBuffers = null, this._boundBufferBases = null;
    }
    contextChange() {
      this._gpuBuffers = /* @__PURE__ */ Object.create(null), this._gl = this._renderer.gl;
    }
    getGlBuffer(t) {
      return this._gpuBuffers[t.uid] || this.createGLBuffer(t);
    }
    bind(t) {
      const { _gl: e } = this, r = this.getGlBuffer(t);
      e.bindBuffer(r.type, r.buffer);
    }
    bindBufferBase(t, e) {
      const { _gl: r } = this;
      if (this._boundBufferBases[e] !== t) {
        const s = this.getGlBuffer(t);
        this._boundBufferBases[e] = t, r.bindBufferBase(r.UNIFORM_BUFFER, e, s.buffer);
      }
    }
    bindBufferRange(t, e, r) {
      const { _gl: s } = this;
      r = r || 0;
      const n = this.getGlBuffer(t);
      s.bindBufferRange(s.UNIFORM_BUFFER, e || 0, n.buffer, r * 256, 256);
    }
    updateBuffer(t) {
      const { _gl: e } = this, r = this.getGlBuffer(t);
      if (t._updateID === r.updateID) return r;
      r.updateID = t._updateID, e.bindBuffer(r.type, r.buffer);
      const s = t.data;
      if (r.byteLength >= t.data.byteLength) e.bufferSubData(r.type, 0, s, 0, t._updateSize / s.BYTES_PER_ELEMENT);
      else {
        const n = t.descriptor.usage & yt.STATIC ? e.STATIC_DRAW : e.DYNAMIC_DRAW;
        r.byteLength = s.byteLength, e.bufferData(r.type, s, n);
      }
      return r;
    }
    destroyAll() {
      const t = this._gl;
      for (const e in this._gpuBuffers) t.deleteBuffer(this._gpuBuffers[e].buffer);
      this._gpuBuffers = /* @__PURE__ */ Object.create(null);
    }
    onBufferDestroy(t, e) {
      const r = this._gpuBuffers[t.uid], s = this._gl;
      e || s.deleteBuffer(r.buffer), this._gpuBuffers[t.uid] = null;
    }
    createGLBuffer(t) {
      const { _gl: e } = this;
      let r = Es.ARRAY_BUFFER;
      t.descriptor.usage & yt.INDEX ? r = Es.ELEMENT_ARRAY_BUFFER : t.descriptor.usage & yt.UNIFORM && (r = Es.UNIFORM_BUFFER);
      const s = new gy(e.createBuffer(), r);
      return this._gpuBuffers[t.uid] = s, t.on("destroy", this.onBufferDestroy, this), s;
    }
  }
  Ad.extension = {
    type: [
      P.WebGLSystem
    ],
    name: "buffer"
  };
  const Sa = class Rd {
    constructor(t) {
      this.supports = {
        uint32Indices: true,
        uniformBufferObject: true,
        vertexArrayObject: true,
        srgbTextures: true,
        nonPowOf2wrapping: true,
        msaa: true,
        nonPowOf2mipmaps: true
      }, this._renderer = t, this.extensions = /* @__PURE__ */ Object.create(null), this.handleContextLost = this.handleContextLost.bind(this), this.handleContextRestored = this.handleContextRestored.bind(this);
    }
    get isLost() {
      return !this.gl || this.gl.isContextLost();
    }
    contextChange(t) {
      this.gl = t, this._renderer.gl = t;
    }
    init(t) {
      if (t = {
        ...Rd.defaultOptions,
        ...t
      }, t.context) this.initFromContext(t.context);
      else {
        const e = this._renderer.background.alpha < 1, r = t.premultipliedAlpha ?? true, s = t.antialias && !this._renderer.backBuffer.useBackBuffer;
        this.createContext(t.preferWebGLVersion, {
          alpha: e,
          premultipliedAlpha: r,
          antialias: s,
          stencil: true,
          preserveDrawingBuffer: t.preserveDrawingBuffer,
          powerPreference: t.powerPreference ?? "default"
        });
      }
    }
    initFromContext(t) {
      this.gl = t, this.webGLVersion = t instanceof St.get().getWebGLRenderingContext() ? 1 : 2, this.getExtensions(), this.validateContext(t), this._renderer.runners.contextChange.emit(t);
      const e = this._renderer.view.canvas;
      e.addEventListener("webglcontextlost", this.handleContextLost, false), e.addEventListener("webglcontextrestored", this.handleContextRestored, false);
    }
    createContext(t, e) {
      let r;
      const s = this._renderer.view.canvas;
      if (t === 2 && (r = s.getContext("webgl2", e)), !r && (r = s.getContext("webgl", e), !r)) throw new Error("This browser does not support WebGL. Try using the canvas renderer");
      this.gl = r, this.initFromContext(this.gl);
    }
    getExtensions() {
      const { gl: t } = this, e = {
        anisotropicFiltering: t.getExtension("EXT_texture_filter_anisotropic"),
        floatTextureLinear: t.getExtension("OES_texture_float_linear"),
        s3tc: t.getExtension("WEBGL_compressed_texture_s3tc"),
        s3tc_sRGB: t.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
        etc: t.getExtension("WEBGL_compressed_texture_etc"),
        etc1: t.getExtension("WEBGL_compressed_texture_etc1"),
        pvrtc: t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
        atc: t.getExtension("WEBGL_compressed_texture_atc"),
        astc: t.getExtension("WEBGL_compressed_texture_astc"),
        bptc: t.getExtension("EXT_texture_compression_bptc"),
        rgtc: t.getExtension("EXT_texture_compression_rgtc"),
        loseContext: t.getExtension("WEBGL_lose_context")
      };
      if (this.webGLVersion === 1) this.extensions = {
        ...e,
        drawBuffers: t.getExtension("WEBGL_draw_buffers"),
        depthTexture: t.getExtension("WEBGL_depth_texture"),
        vertexArrayObject: t.getExtension("OES_vertex_array_object") || t.getExtension("MOZ_OES_vertex_array_object") || t.getExtension("WEBKIT_OES_vertex_array_object"),
        uint32ElementIndex: t.getExtension("OES_element_index_uint"),
        floatTexture: t.getExtension("OES_texture_float"),
        floatTextureLinear: t.getExtension("OES_texture_float_linear"),
        textureHalfFloat: t.getExtension("OES_texture_half_float"),
        textureHalfFloatLinear: t.getExtension("OES_texture_half_float_linear"),
        vertexAttribDivisorANGLE: t.getExtension("ANGLE_instanced_arrays"),
        srgb: t.getExtension("EXT_sRGB")
      };
      else {
        this.extensions = {
          ...e,
          colorBufferFloat: t.getExtension("EXT_color_buffer_float")
        };
        const r = t.getExtension("WEBGL_provoking_vertex");
        r && r.provokingVertexWEBGL(r.FIRST_VERTEX_CONVENTION_WEBGL);
      }
    }
    handleContextLost(t) {
      t.preventDefault(), this._contextLossForced && (this._contextLossForced = false, setTimeout(() => {
        var _a2;
        this.gl.isContextLost() && ((_a2 = this.extensions.loseContext) == null ? void 0 : _a2.restoreContext());
      }, 0));
    }
    handleContextRestored() {
      this._renderer.runners.contextChange.emit(this.gl);
    }
    destroy() {
      var _a2;
      const t = this._renderer.view.canvas;
      this._renderer = null, t.removeEventListener("webglcontextlost", this.handleContextLost), t.removeEventListener("webglcontextrestored", this.handleContextRestored), this.gl.useProgram(null), (_a2 = this.extensions.loseContext) == null ? void 0 : _a2.loseContext();
    }
    forceContextLoss() {
      var _a2;
      (_a2 = this.extensions.loseContext) == null ? void 0 : _a2.loseContext(), this._contextLossForced = true;
    }
    validateContext(t) {
      const e = t.getContextAttributes();
      e && !e.stencil && ut("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
      const r = this.supports, s = this.webGLVersion === 2, n = this.extensions;
      r.uint32Indices = s || !!n.uint32ElementIndex, r.uniformBufferObject = s, r.vertexArrayObject = s || !!n.vertexArrayObject, r.srgbTextures = s || !!n.srgb, r.nonPowOf2wrapping = s, r.nonPowOf2mipmaps = s, r.msaa = s, r.uint32Indices || ut("Provided WebGL context does not support 32 index buffer, large scenes may not render correctly");
    }
  };
  Sa.extension = {
    type: [
      P.WebGLSystem
    ],
    name: "context"
  };
  Sa.defaultOptions = {
    context: null,
    premultipliedAlpha: true,
    preserveDrawingBuffer: false,
    powerPreference: void 0,
    preferWebGLVersion: 2
  };
  let my = Sa;
  function Pd(i, t) {
    for (const e in i.attributes) {
      const r = i.attributes[e], s = t[e];
      s ? (r.location ?? (r.location = s.location), r.format ?? (r.format = s.format), r.offset ?? (r.offset = s.offset), r.instance ?? (r.instance = s.instance)) : ut(`Attribute ${e} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`);
    }
    by(i);
  }
  function by(i) {
    const { buffers: t, attributes: e } = i, r = {}, s = {};
    for (const n in t) {
      const o = t[n];
      r[o.uid] = 0, s[o.uid] = 0;
    }
    for (const n in e) {
      const o = e[n];
      r[o.buffer.uid] += Ai(o.format).stride;
    }
    for (const n in e) {
      const o = e[n];
      o.stride ?? (o.stride = r[o.buffer.uid]), o.start ?? (o.start = s[o.buffer.uid]), s[o.buffer.uid] += Ai(o.format).stride;
    }
  }
  var Ho = ((i) => (i[i.RGBA = 6408] = "RGBA", i[i.RGB = 6407] = "RGB", i[i.RG = 33319] = "RG", i[i.RED = 6403] = "RED", i[i.RGBA_INTEGER = 36249] = "RGBA_INTEGER", i[i.RGB_INTEGER = 36248] = "RGB_INTEGER", i[i.RG_INTEGER = 33320] = "RG_INTEGER", i[i.RED_INTEGER = 36244] = "RED_INTEGER", i[i.ALPHA = 6406] = "ALPHA", i[i.LUMINANCE = 6409] = "LUMINANCE", i[i.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", i[i.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", i[i.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL", i))(Ho || {}), Bd = ((i) => (i[i.TEXTURE_2D = 3553] = "TEXTURE_2D", i[i.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", i[i.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", i[i.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", i[i.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", i[i.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", i[i.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", i[i.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", i[i.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z", i))(Bd || {});
  var wt = ((i) => (i[i.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", i[i.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", i[i.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", i[i.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", i[i.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", i[i.UNSIGNED_INT = 5125] = "UNSIGNED_INT", i[i.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", i[i.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", i[i.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", i[i.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", i[i.BYTE = 5120] = "BYTE", i[i.SHORT = 5122] = "SHORT", i[i.INT = 5124] = "INT", i[i.FLOAT = 5126] = "FLOAT", i[i.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", i[i.HALF_FLOAT = 36193] = "HALF_FLOAT", i))(wt || {});
  const Du = {
    uint8x2: wt.UNSIGNED_BYTE,
    uint8x4: wt.UNSIGNED_BYTE,
    sint8x2: wt.BYTE,
    sint8x4: wt.BYTE,
    unorm8x2: wt.UNSIGNED_BYTE,
    unorm8x4: wt.UNSIGNED_BYTE,
    snorm8x2: wt.BYTE,
    snorm8x4: wt.BYTE,
    uint16x2: wt.UNSIGNED_SHORT,
    uint16x4: wt.UNSIGNED_SHORT,
    sint16x2: wt.SHORT,
    sint16x4: wt.SHORT,
    unorm16x2: wt.UNSIGNED_SHORT,
    unorm16x4: wt.UNSIGNED_SHORT,
    snorm16x2: wt.SHORT,
    snorm16x4: wt.SHORT,
    float16x2: wt.HALF_FLOAT,
    float16x4: wt.HALF_FLOAT,
    float32: wt.FLOAT,
    float32x2: wt.FLOAT,
    float32x3: wt.FLOAT,
    float32x4: wt.FLOAT,
    uint32: wt.UNSIGNED_INT,
    uint32x2: wt.UNSIGNED_INT,
    uint32x3: wt.UNSIGNED_INT,
    uint32x4: wt.UNSIGNED_INT,
    sint32: wt.INT,
    sint32x2: wt.INT,
    sint32x3: wt.INT,
    sint32x4: wt.INT
  };
  function wy(i) {
    return Du[i] ?? Du.float32;
  }
  const yy = {
    "point-list": 0,
    "line-list": 1,
    "line-strip": 3,
    "triangle-list": 4,
    "triangle-strip": 5
  };
  class Md {
    constructor(t) {
      this._geometryVaoHash = /* @__PURE__ */ Object.create(null), this._renderer = t, this._activeGeometry = null, this._activeVao = null, this.hasVao = true, this.hasInstance = true;
    }
    contextChange() {
      const t = this.gl = this._renderer.gl;
      if (!this._renderer.context.supports.vertexArrayObject) throw new Error("[PixiJS] Vertex Array Objects are not supported on this device");
      const e = this._renderer.context.extensions.vertexArrayObject;
      e && (t.createVertexArray = () => e.createVertexArrayOES(), t.bindVertexArray = (s) => e.bindVertexArrayOES(s), t.deleteVertexArray = (s) => e.deleteVertexArrayOES(s));
      const r = this._renderer.context.extensions.vertexAttribDivisorANGLE;
      r && (t.drawArraysInstanced = (s, n, o, a) => {
        r.drawArraysInstancedANGLE(s, n, o, a);
      }, t.drawElementsInstanced = (s, n, o, a, c) => {
        r.drawElementsInstancedANGLE(s, n, o, a, c);
      }, t.vertexAttribDivisor = (s, n) => r.vertexAttribDivisorANGLE(s, n)), this._activeGeometry = null, this._activeVao = null, this._geometryVaoHash = /* @__PURE__ */ Object.create(null);
    }
    bind(t, e) {
      const r = this.gl;
      this._activeGeometry = t;
      const s = this.getVao(t, e);
      this._activeVao !== s && (this._activeVao = s, r.bindVertexArray(s)), this.updateBuffers();
    }
    reset() {
      this.unbind();
    }
    updateBuffers() {
      const t = this._activeGeometry, e = this._renderer.buffer;
      for (let r = 0; r < t.buffers.length; r++) {
        const s = t.buffers[r];
        e.updateBuffer(s);
      }
    }
    checkCompatibility(t, e) {
      const r = t.attributes, s = e._attributeData;
      for (const n in s) if (!r[n]) throw new Error(`shader and geometry incompatible, geometry missing the "${n}" attribute`);
    }
    getSignature(t, e) {
      const r = t.attributes, s = e._attributeData, n = [
        "g",
        t.uid
      ];
      for (const o in r) s[o] && n.push(o, s[o].location);
      return n.join("-");
    }
    getVao(t, e) {
      var _a2;
      return ((_a2 = this._geometryVaoHash[t.uid]) == null ? void 0 : _a2[e._key]) || this.initGeometryVao(t, e);
    }
    initGeometryVao(t, e, r = true) {
      const s = this._renderer.gl, n = this._renderer.buffer;
      this._renderer.shader._getProgramData(e), this.checkCompatibility(t, e);
      const o = this.getSignature(t, e);
      this._geometryVaoHash[t.uid] || (this._geometryVaoHash[t.uid] = /* @__PURE__ */ Object.create(null), t.on("destroy", this.onGeometryDestroy, this));
      const a = this._geometryVaoHash[t.uid];
      let c = a[o];
      if (c) return a[e._key] = c, c;
      Pd(t, e._attributeData);
      const l = t.buffers;
      c = s.createVertexArray(), s.bindVertexArray(c);
      for (let u = 0; u < l.length; u++) {
        const h = l[u];
        n.bind(h);
      }
      return this.activateVao(t, e), a[e._key] = c, a[o] = c, s.bindVertexArray(null), c;
    }
    onGeometryDestroy(t, e) {
      const r = this._geometryVaoHash[t.uid], s = this.gl;
      if (r) {
        if (e) for (const n in r) this._activeVao !== r[n] && this.unbind(), s.deleteVertexArray(r[n]);
        this._geometryVaoHash[t.uid] = null;
      }
    }
    destroyAll(t = false) {
      const e = this.gl;
      for (const r in this._geometryVaoHash) {
        if (t) for (const s in this._geometryVaoHash[r]) {
          const n = this._geometryVaoHash[r];
          this._activeVao !== n && this.unbind(), e.deleteVertexArray(n[s]);
        }
        this._geometryVaoHash[r] = null;
      }
    }
    activateVao(t, e) {
      var _a2;
      const r = this._renderer.gl, s = this._renderer.buffer, n = t.attributes;
      t.indexBuffer && s.bind(t.indexBuffer);
      let o = null;
      for (const a in n) {
        const c = n[a], l = c.buffer, u = s.getGlBuffer(l), h = e._attributeData[a];
        if (h) {
          o !== u && (s.bind(l), o = u);
          const d = c.location;
          r.enableVertexAttribArray(d);
          const p = Ai(c.format), g = wy(c.format);
          if (((_a2 = h.format) == null ? void 0 : _a2.substring(1, 4)) === "int" ? r.vertexAttribIPointer(d, p.size, g, c.stride, c.offset) : r.vertexAttribPointer(d, p.size, g, p.normalised, c.stride, c.offset), c.instance) if (this.hasInstance) {
            const y = c.divisor ?? 1;
            r.vertexAttribDivisor(d, y);
          } else throw new Error("geometry error, GPU Instancing is not supported on this device");
        }
      }
    }
    draw(t, e, r, s) {
      const { gl: n } = this._renderer, o = this._activeGeometry, a = yy[o.topology || t];
      if (s || (s = o.instanceCount), o.indexBuffer) {
        const c = o.indexBuffer.data.BYTES_PER_ELEMENT, l = c === 2 ? n.UNSIGNED_SHORT : n.UNSIGNED_INT;
        s > 1 ? n.drawElementsInstanced(a, e || o.indexBuffer.data.length, l, (r || 0) * c, s) : n.drawElements(a, e || o.indexBuffer.data.length, l, (r || 0) * c);
      } else s > 1 ? n.drawArraysInstanced(a, r || 0, e || o.getSize(), s) : n.drawArrays(a, r || 0, e || o.getSize());
      return this;
    }
    unbind() {
      this.gl.bindVertexArray(null), this._activeVao = null, this._activeGeometry = null;
    }
    destroy() {
      this._renderer = null, this.gl = null, this._activeVao = null, this._activeGeometry = null;
    }
  }
  Md.extension = {
    type: [
      P.WebGLSystem
    ],
    name: "geometry"
  };
  const xy = new Fi({
    attributes: {
      aPosition: [
        -1,
        -1,
        3,
        -1,
        -1,
        3
      ]
    }
  }), Ea = class Dd {
    constructor(t) {
      this.useBackBuffer = false, this._useBackBufferThisRender = false, this._renderer = t;
    }
    init(t = {}) {
      const { useBackBuffer: e, antialias: r } = {
        ...Dd.defaultOptions,
        ...t
      };
      this.useBackBuffer = e, this._antialias = r, this._renderer.context.supports.msaa || (ut("antialiasing, is not supported on when using the back buffer"), this._antialias = false), this._state = Le.for2d();
      const s = new ir({
        vertex: `
                attribute vec2 aPosition;
                out vec2 vUv;

                void main() {
                    gl_Position = vec4(aPosition, 0.0, 1.0);

                    vUv = (aPosition + 1.0) / 2.0;

                    // flip dem UVs
                    vUv.y = 1.0 - vUv.y;
                }`,
        fragment: `
                in vec2 vUv;
                out vec4 finalColor;

                uniform sampler2D uTexture;

                void main() {
                    finalColor = texture(uTexture, vUv);
                }`,
        name: "big-triangle"
      });
      this._bigTriangleShader = new Se({
        glProgram: s,
        resources: {
          uTexture: Z.WHITE.source
        }
      });
    }
    renderStart(t) {
      const e = this._renderer.renderTarget.getRenderTarget(t.target);
      if (this._useBackBufferThisRender = this.useBackBuffer && !!e.isRoot, this._useBackBufferThisRender) {
        const r = this._renderer.renderTarget.getRenderTarget(t.target);
        this._targetTexture = r.colorTexture, t.target = this._getBackBufferTexture(r.colorTexture);
      }
    }
    renderEnd() {
      this._presentBackBuffer();
    }
    _presentBackBuffer() {
      const t = this._renderer;
      t.renderTarget.finishRenderPass(), this._useBackBufferThisRender && (t.renderTarget.bind(this._targetTexture, false), this._bigTriangleShader.resources.uTexture = this._backBufferTexture.source, t.encoder.draw({
        geometry: xy,
        shader: this._bigTriangleShader,
        state: this._state
      }));
    }
    _getBackBufferTexture(t) {
      return this._backBufferTexture = this._backBufferTexture || new Z({
        source: new Ht({
          width: t.width,
          height: t.height,
          resolution: t._resolution,
          antialias: this._antialias
        })
      }), this._backBufferTexture.source.resize(t.width, t.height, t._resolution), this._backBufferTexture;
    }
    destroy() {
      this._backBufferTexture && (this._backBufferTexture.destroy(), this._backBufferTexture = null);
    }
  };
  Ea.extension = {
    type: [
      P.WebGLSystem
    ],
    name: "backBuffer",
    priority: 1
  };
  Ea.defaultOptions = {
    useBackBuffer: false
  };
  let vy = Ea;
  class Id {
    constructor(t) {
      this._colorMaskCache = 15, this._renderer = t;
    }
    setMask(t) {
      this._colorMaskCache !== t && (this._colorMaskCache = t, this._renderer.gl.colorMask(!!(t & 8), !!(t & 4), !!(t & 2), !!(t & 1)));
    }
  }
  Id.extension = {
    type: [
      P.WebGLSystem
    ],
    name: "colorMask"
  };
  class Fd {
    constructor(t) {
      this.commandFinished = Promise.resolve(), this._renderer = t;
    }
    setGeometry(t, e) {
      this._renderer.geometry.bind(t, e.glProgram);
    }
    finishRenderPass() {
    }
    draw(t) {
      const e = this._renderer, { geometry: r, shader: s, state: n, skipSync: o, topology: a, size: c, start: l, instanceCount: u } = t;
      e.shader.bind(s, o), e.geometry.bind(r, e.shader._activeProgram), n && e.state.set(n), e.geometry.draw(a, c, l, u ?? r.instanceCount);
    }
    destroy() {
      this._renderer = null;
    }
  }
  Fd.extension = {
    type: [
      P.WebGLSystem
    ],
    name: "encoder"
  };
  class Sy {
    constructor() {
      this.width = -1, this.height = -1, this.msaa = false, this.msaaRenderBuffer = [];
    }
  }
  const kr = [];
  kr[Kt.NONE] = void 0;
  kr[Kt.DISABLED] = {
    stencilWriteMask: 0,
    stencilReadMask: 0
  };
  kr[Kt.RENDERING_MASK_ADD] = {
    stencilFront: {
      compare: "equal",
      passOp: "increment-clamp"
    },
    stencilBack: {
      compare: "equal",
      passOp: "increment-clamp"
    }
  };
  kr[Kt.RENDERING_MASK_REMOVE] = {
    stencilFront: {
      compare: "equal",
      passOp: "decrement-clamp"
    },
    stencilBack: {
      compare: "equal",
      passOp: "decrement-clamp"
    }
  };
  kr[Kt.MASK_ACTIVE] = {
    stencilWriteMask: 0,
    stencilFront: {
      compare: "equal",
      passOp: "keep"
    },
    stencilBack: {
      compare: "equal",
      passOp: "keep"
    }
  };
  class Ud {
    constructor(t) {
      this._stencilCache = {
        enabled: false,
        stencilReference: 0,
        stencilMode: Kt.NONE
      }, this._renderTargetStencilState = /* @__PURE__ */ Object.create(null), t.renderTarget.onRenderTargetChange.add(this);
    }
    contextChange(t) {
      this._gl = t, this._comparisonFuncMapping = {
        always: t.ALWAYS,
        never: t.NEVER,
        equal: t.EQUAL,
        "not-equal": t.NOTEQUAL,
        less: t.LESS,
        "less-equal": t.LEQUAL,
        greater: t.GREATER,
        "greater-equal": t.GEQUAL
      }, this._stencilOpsMapping = {
        keep: t.KEEP,
        zero: t.ZERO,
        replace: t.REPLACE,
        invert: t.INVERT,
        "increment-clamp": t.INCR,
        "decrement-clamp": t.DECR,
        "increment-wrap": t.INCR_WRAP,
        "decrement-wrap": t.DECR_WRAP
      }, this._stencilCache.enabled = false, this._stencilCache.stencilMode = Kt.NONE, this._stencilCache.stencilReference = 0;
    }
    onRenderTargetChange(t) {
      if (this._activeRenderTarget === t) return;
      this._activeRenderTarget = t;
      let e = this._renderTargetStencilState[t.uid];
      e || (e = this._renderTargetStencilState[t.uid] = {
        stencilMode: Kt.DISABLED,
        stencilReference: 0
      }), this.setStencilMode(e.stencilMode, e.stencilReference);
    }
    setStencilMode(t, e) {
      const r = this._renderTargetStencilState[this._activeRenderTarget.uid], s = this._gl, n = kr[t], o = this._stencilCache;
      if (r.stencilMode = t, r.stencilReference = e, t === Kt.DISABLED) {
        this._stencilCache.enabled && (this._stencilCache.enabled = false, s.disable(s.STENCIL_TEST));
        return;
      }
      this._stencilCache.enabled || (this._stencilCache.enabled = true, s.enable(s.STENCIL_TEST)), (t !== o.stencilMode || o.stencilReference !== e) && (o.stencilMode = t, o.stencilReference = e, s.stencilFunc(this._comparisonFuncMapping[n.stencilBack.compare], e, 255), s.stencilOp(s.KEEP, s.KEEP, this._stencilOpsMapping[n.stencilBack.passOp]));
    }
  }
  Ud.extension = {
    type: [
      P.WebGLSystem
    ],
    name: "stencil"
  };
  class kd {
    constructor(t) {
      this._syncFunctionHash = /* @__PURE__ */ Object.create(null), this._adaptor = t, this._systemCheck();
    }
    _systemCheck() {
      if (!hh()) throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");
    }
    ensureUniformGroup(t) {
      const e = this.getUniformGroupData(t);
      t.buffer || (t.buffer = new Pe({
        data: new Float32Array(e.layout.size / 4),
        usage: yt.UNIFORM | yt.COPY_DST
      }));
    }
    getUniformGroupData(t) {
      return this._syncFunctionHash[t._signature] || this._initUniformGroup(t);
    }
    _initUniformGroup(t) {
      const e = t._signature;
      let r = this._syncFunctionHash[e];
      if (!r) {
        const s = Object.keys(t.uniformStructures).map((a) => t.uniformStructures[a]), n = this._adaptor.createUboElements(s), o = this._generateUboSync(n.uboElements);
        r = this._syncFunctionHash[e] = {
          layout: n,
          syncFunction: o
        };
      }
      return this._syncFunctionHash[e];
    }
    _generateUboSync(t) {
      return this._adaptor.generateUboSync(t);
    }
    syncUniformGroup(t, e, r) {
      const s = this.getUniformGroupData(t);
      return t.buffer || (t.buffer = new Pe({
        data: new Float32Array(s.layout.size / 4),
        usage: yt.UNIFORM | yt.COPY_DST
      })), e || (e = t.buffer.data), r || (r = 0), s.syncFunction(t.uniforms, e, r), true;
    }
    updateUniformGroup(t) {
      if (t.isStatic && !t._dirtyId) return false;
      t._dirtyId = 0;
      const e = this.syncUniformGroup(t);
      return t.buffer.update(), e;
    }
    destroy() {
      this._syncFunctionHash = null;
    }
  }
  const Gd = {
    f32: 4,
    "vec2<f32>": 8,
    "vec3<f32>": 12,
    "vec4<f32>": 16,
    "mat2x2<f32>": 16 * 2,
    "mat3x3<f32>": 16 * 3,
    "mat4x4<f32>": 16 * 4
  };
  function Ey(i) {
    const t = i.map((n) => ({
      data: n,
      offset: 0,
      size: 0
    }));
    let e = 0, r = 0, s = 0;
    for (let n = 0; n < t.length; n++) {
      const o = t[n];
      if (e = Gd[o.data.type], !e) throw new Error(`Unknown type ${o.data.type}`);
      if (o.data.size > 1 && (e = Math.max(e, 16) * o.data.size), o.size = e, r % e !== 0 && r < 16) {
        const a = r % e % 16;
        r += a, s += a;
      }
      r + e > 16 ? (s = Math.ceil(s / 16) * 16, o.offset = s, s += e, r = e) : (o.offset = s, r += e, s += e);
    }
    return s = Math.ceil(s / 16) * 16, {
      uboElements: t,
      size: s
    };
  }
  const Br = [
    {
      type: "mat3x3<f32>",
      test: (i) => i.value.a !== void 0,
      ubo: `
            var matrix = uv[name].toArray(true);
            data[offset] = matrix[0];
            data[offset + 1] = matrix[1];
            data[offset + 2] = matrix[2];
            data[offset + 4] = matrix[3];
            data[offset + 5] = matrix[4];
            data[offset + 6] = matrix[5];
            data[offset + 8] = matrix[6];
            data[offset + 9] = matrix[7];
            data[offset + 10] = matrix[8];
        `,
      uniform: `
            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));
        `
    },
    {
      type: "vec4<f32>",
      test: (i) => i.type === "vec4<f32>" && i.size === 1 && i.value.width !== void 0,
      ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
            data[offset + 2] = v.width;
            data[offset + 3] = v.height;
        `,
      uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {
                cv[0] = v.x;
                cv[1] = v.y;
                cv[2] = v.width;
                cv[3] = v.height;
                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);
            }
        `
    },
    {
      type: "vec2<f32>",
      test: (i) => i.type === "vec2<f32>" && i.size === 1 && i.value.x !== void 0,
      ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
        `,
      uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y) {
                cv[0] = v.x;
                cv[1] = v.y;
                gl.uniform2f(ud[name].location, v.x, v.y);
            }
        `
    },
    {
      type: "vec4<f32>",
      test: (i) => i.type === "vec4<f32>" && i.size === 1 && i.value.red !== void 0,
      ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
            data[offset + 3] = v.alpha;
        `,
      uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                cv[3] = v.alpha;
                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);
            }
        `
    },
    {
      type: "vec3<f32>",
      test: (i) => i.type === "vec3<f32>" && i.size === 1 && i.value.red !== void 0,
      ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
        `,
      uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);
            }
        `
    }
  ];
  function Od(i, t, e, r) {
    const s = [
      `
        var v = null;
        var v2 = null;
        var t = 0;
        var index = 0;
        var name = null;
        var arrayOffset = null;
    `
    ];
    let n = 0;
    for (let a = 0; a < i.length; a++) {
      const c = i[a], l = c.data.name;
      let u = false, h = 0;
      for (let d = 0; d < Br.length; d++) if (Br[d].test(c.data)) {
        h = c.offset / 4, s.push(`name = "${l}";`, `offset += ${h - n};`, Br[d][t] || Br[d].ubo), u = true;
        break;
      }
      if (!u) if (c.data.size > 1) h = c.offset / 4, s.push(e(c, h - n));
      else {
        const d = r[c.data.type];
        h = c.offset / 4, s.push(`
                    v = uv.${l};
                    offset += ${h - n};
                    ${d};
                `);
      }
      n = h;
    }
    const o = s.join(`
`);
    return new Function("uv", "data", "offset", o);
  }
  function zr(i, t) {
    return `
        for (let i = 0; i < ${i * t}; i++) {
            data[offset + (((i / ${i})|0) * 4) + (i % ${i})] = v[i];
        }
    `;
  }
  const Nd = {
    f32: `
        data[offset] = v;`,
    i32: `
        data[offset] = v;`,
    "vec2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];`,
    "vec3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];`,
    "vec4<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];`,
    "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 4] = v[2];
        data[offset + 5] = v[3];`,
    "mat3x3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];
        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];`,
    "mat4x4<f32>": `
        for (let i = 0; i < 16; i++) {
            data[offset + i] = v[i];
        }`,
    "mat3x2<f32>": zr(3, 2),
    "mat4x2<f32>": zr(4, 2),
    "mat2x3<f32>": zr(2, 3),
    "mat4x3<f32>": zr(4, 3),
    "mat2x4<f32>": zr(2, 4),
    "mat3x4<f32>": zr(3, 4)
  }, Ty = {
    ...Nd,
    "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];
    `
  };
  function Cy(i, t) {
    const e = Math.max(Gd[i.data.type] / 16, 1), r = i.data.value.length / i.data.size, s = (4 - r % 4) % 4;
    return `
        v = uv.${i.data.name};
        offset += ${t};

        arrayOffset = offset;

        t = 0;

        for(var i=0; i < ${i.data.size * e}; i++)
        {
            for(var j = 0; j < ${r}; j++)
            {
                data[arrayOffset++] = v[t++];
            }
            ${s !== 0 ? `arrayOffset += ${s};` : ""}
        }
    `;
  }
  function Ay(i) {
    return Od(i, "uboStd40", Cy, Nd);
  }
  class Ld extends kd {
    constructor() {
      super({
        createUboElements: Ey,
        generateUboSync: Ay
      });
    }
  }
  Ld.extension = {
    type: [
      P.WebGLSystem
    ],
    name: "ubo"
  };
  class Ry {
    constructor() {
      this._clearColorCache = [
        0,
        0,
        0,
        0
      ], this._viewPortCache = new Et();
    }
    init(t, e) {
      this._renderer = t, this._renderTargetSystem = e, t.runners.contextChange.add(this);
    }
    contextChange() {
      this._clearColorCache = [
        0,
        0,
        0,
        0
      ], this._viewPortCache = new Et();
    }
    copyToTexture(t, e, r, s, n) {
      const o = this._renderTargetSystem, a = this._renderer, c = o.getGpuRenderTarget(t), l = a.gl;
      return this.finishRenderPass(t), l.bindFramebuffer(l.FRAMEBUFFER, c.resolveTargetFramebuffer), a.texture.bind(e, 0), l.copyTexSubImage2D(l.TEXTURE_2D, 0, n.x, n.y, r.x, r.y, s.width, s.height), e;
    }
    startRenderPass(t, e = true, r, s) {
      const n = this._renderTargetSystem, o = t.colorTexture, a = n.getGpuRenderTarget(t);
      let c = s.y;
      t.isRoot && (c = o.pixelHeight - s.height), t.colorTextures.forEach((h) => {
        this._renderer.texture.unbind(h);
      });
      const l = this._renderer.gl;
      l.bindFramebuffer(l.FRAMEBUFFER, a.framebuffer);
      const u = this._viewPortCache;
      (u.x !== s.x || u.y !== c || u.width !== s.width || u.height !== s.height) && (u.x = s.x, u.y = c, u.width = s.width, u.height = s.height, l.viewport(s.x, c, s.width, s.height)), !a.depthStencilRenderBuffer && (t.stencil || t.depth) && this._initStencil(a), this.clear(t, e, r);
    }
    finishRenderPass(t) {
      const r = this._renderTargetSystem.getGpuRenderTarget(t);
      if (!r.msaa) return;
      const s = this._renderer.gl;
      s.bindFramebuffer(s.FRAMEBUFFER, r.resolveTargetFramebuffer), s.bindFramebuffer(s.READ_FRAMEBUFFER, r.framebuffer), s.blitFramebuffer(0, 0, r.width, r.height, 0, 0, r.width, r.height, s.COLOR_BUFFER_BIT, s.NEAREST), s.bindFramebuffer(s.FRAMEBUFFER, r.framebuffer);
    }
    initGpuRenderTarget(t) {
      const e = this._renderer, r = e.gl, s = new Sy();
      return t.colorTexture.resource === e.gl.canvas ? (s.framebuffer = null, s) : (this._initColor(t, s), r.bindFramebuffer(r.FRAMEBUFFER, null), s);
    }
    destroyGpuRenderTarget(t) {
      const e = this._renderer.gl;
      t.framebuffer && (e.deleteFramebuffer(t.framebuffer), t.framebuffer = null), t.resolveTargetFramebuffer && (e.deleteFramebuffer(t.resolveTargetFramebuffer), t.resolveTargetFramebuffer = null), t.depthStencilRenderBuffer && (e.deleteRenderbuffer(t.depthStencilRenderBuffer), t.depthStencilRenderBuffer = null), t.msaaRenderBuffer.forEach((r) => {
        e.deleteRenderbuffer(r);
      }), t.msaaRenderBuffer = null;
    }
    clear(t, e, r) {
      if (!e) return;
      const s = this._renderTargetSystem;
      typeof e == "boolean" && (e = e ? pe.ALL : pe.NONE);
      const n = this._renderer.gl;
      if (e & pe.COLOR) {
        r ?? (r = s.defaultClearColor);
        const o = this._clearColorCache, a = r;
        (o[0] !== a[0] || o[1] !== a[1] || o[2] !== a[2] || o[3] !== a[3]) && (o[0] = a[0], o[1] = a[1], o[2] = a[2], o[3] = a[3], n.clearColor(a[0], a[1], a[2], a[3]));
      }
      n.clear(e);
    }
    resizeGpuRenderTarget(t) {
      if (t.isRoot) return;
      const r = this._renderTargetSystem.getGpuRenderTarget(t);
      this._resizeColor(t, r), (t.stencil || t.depth) && this._resizeStencil(r);
    }
    _initColor(t, e) {
      const r = this._renderer, s = r.gl, n = s.createFramebuffer();
      if (e.resolveTargetFramebuffer = n, s.bindFramebuffer(s.FRAMEBUFFER, n), e.width = t.colorTexture.source.pixelWidth, e.height = t.colorTexture.source.pixelHeight, t.colorTextures.forEach((o, a) => {
        const c = o.source;
        c.antialias && (r.context.supports.msaa ? e.msaa = true : ut("[RenderTexture] Antialiasing on textures is not supported in WebGL1")), r.texture.bindSource(c, 0);
        const u = r.texture.getGlSource(c).texture;
        s.framebufferTexture2D(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + a, 3553, u, 0);
      }), e.msaa) {
        const o = s.createFramebuffer();
        e.framebuffer = o, s.bindFramebuffer(s.FRAMEBUFFER, o), t.colorTextures.forEach((a, c) => {
          const l = s.createRenderbuffer();
          e.msaaRenderBuffer[c] = l;
        });
      } else e.framebuffer = n;
      this._resizeColor(t, e);
    }
    _resizeColor(t, e) {
      const r = t.colorTexture.source;
      if (e.width = r.pixelWidth, e.height = r.pixelHeight, t.colorTextures.forEach((s, n) => {
        n !== 0 && s.source.resize(r.width, r.height, r._resolution);
      }), e.msaa) {
        const s = this._renderer, n = s.gl, o = e.framebuffer;
        n.bindFramebuffer(n.FRAMEBUFFER, o), t.colorTextures.forEach((a, c) => {
          const l = a.source;
          s.texture.bindSource(l, 0);
          const h = s.texture.getGlSource(l).internalFormat, d = e.msaaRenderBuffer[c];
          n.bindRenderbuffer(n.RENDERBUFFER, d), n.renderbufferStorageMultisample(n.RENDERBUFFER, 4, h, l.pixelWidth, l.pixelHeight), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + c, n.RENDERBUFFER, d);
        });
      }
    }
    _initStencil(t) {
      if (t.framebuffer === null) return;
      const e = this._renderer.gl, r = e.createRenderbuffer();
      t.depthStencilRenderBuffer = r, e.bindRenderbuffer(e.RENDERBUFFER, r), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.RENDERBUFFER, r), this._resizeStencil(t);
    }
    _resizeStencil(t) {
      const e = this._renderer.gl;
      e.bindRenderbuffer(e.RENDERBUFFER, t.depthStencilRenderBuffer), t.msaa ? e.renderbufferStorageMultisample(e.RENDERBUFFER, 4, e.DEPTH24_STENCIL8, t.width, t.height) : e.renderbufferStorage(e.RENDERBUFFER, this._renderer.context.webGLVersion === 2 ? e.DEPTH24_STENCIL8 : e.DEPTH_STENCIL, t.width, t.height);
    }
  }
  function Py(i, t, e, r, s, n) {
    const o = n ? 1 : -1;
    return i.identity(), i.a = 1 / r * 2, i.d = o * (1 / s * 2), i.tx = -1 - t * i.a, i.ty = -o - e * i.d, i;
  }
  const _i = /* @__PURE__ */ new Map();
  function Hd(i, t) {
    if (!_i.has(i)) {
      const e = new Z({
        source: new Jr({
          resource: i,
          ...t
        })
      }), r = () => {
        _i.get(i) === e && _i.delete(i);
      };
      e.once("destroy", r), e.source.once("destroy", r), _i.set(i, e);
    }
    return _i.get(i);
  }
  function By(i) {
    const t = i.colorTexture.source.resource;
    return globalThis.HTMLCanvasElement && t instanceof HTMLCanvasElement && document.body.contains(t);
  }
  const zd = class jd {
    constructor(t = {}) {
      if (this.uid = Ot("renderTarget"), this.colorTextures = [], this.dirtyId = 0, this.isRoot = false, this._size = new Float32Array(2), this._managedColorTextures = false, t = {
        ...jd.defaultOptions,
        ...t
      }, this.stencil = t.stencil, this.depth = t.depth, this.isRoot = t.isRoot, typeof t.colorTextures == "number") {
        this._managedColorTextures = true;
        for (let e = 0; e < t.colorTextures; e++) this.colorTextures.push(new Ht({
          width: t.width,
          height: t.height,
          resolution: t.resolution,
          antialias: t.antialias
        }));
      } else {
        this.colorTextures = [
          ...t.colorTextures.map((r) => r.source)
        ];
        const e = this.colorTexture.source;
        this.resize(e.width, e.height, e._resolution);
      }
      this.colorTexture.source.on("resize", this.onSourceResize, this), (t.depthStencilTexture || this.stencil) && (t.depthStencilTexture instanceof Z || t.depthStencilTexture instanceof Ht ? this.depthStencilTexture = t.depthStencilTexture.source : this.ensureDepthStencilTexture());
    }
    get size() {
      const t = this._size;
      return t[0] = this.pixelWidth, t[1] = this.pixelHeight, t;
    }
    get width() {
      return this.colorTexture.source.width;
    }
    get height() {
      return this.colorTexture.source.height;
    }
    get pixelWidth() {
      return this.colorTexture.source.pixelWidth;
    }
    get pixelHeight() {
      return this.colorTexture.source.pixelHeight;
    }
    get resolution() {
      return this.colorTexture.source._resolution;
    }
    get colorTexture() {
      return this.colorTextures[0];
    }
    onSourceResize(t) {
      this.resize(t.width, t.height, t._resolution, true);
    }
    ensureDepthStencilTexture() {
      this.depthStencilTexture || (this.depthStencilTexture = new Ht({
        width: this.width,
        height: this.height,
        resolution: this.resolution,
        format: "depth24plus-stencil8",
        autoGenerateMipmaps: false,
        antialias: false,
        mipLevelCount: 1
      }));
    }
    resize(t, e, r = this.resolution, s = false) {
      this.dirtyId++, this.colorTextures.forEach((n, o) => {
        s && o === 0 || n.source.resize(t, e, r);
      }), this.depthStencilTexture && this.depthStencilTexture.source.resize(t, e, r);
    }
    destroy() {
      this.colorTexture.source.off("resize", this.onSourceResize, this), this._managedColorTextures && this.colorTextures.forEach((t) => {
        t.destroy();
      }), this.depthStencilTexture && (this.depthStencilTexture.destroy(), delete this.depthStencilTexture);
    }
  };
  zd.defaultOptions = {
    width: 0,
    height: 0,
    resolution: 1,
    colorTextures: 1,
    stencil: false,
    depth: false,
    antialias: false,
    isRoot: false
  };
  let zo = zd;
  class Wd {
    constructor(t) {
      this.rootViewPort = new Et(), this.viewport = new Et(), this.onRenderTargetChange = new dh("onRenderTargetChange"), this.projectionMatrix = new st(), this.defaultClearColor = [
        0,
        0,
        0,
        0
      ], this._renderSurfaceToRenderTargetHash = /* @__PURE__ */ new Map(), this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null), this._renderTargetStack = [], this._renderer = t;
    }
    finishRenderPass() {
      this.adaptor.finishRenderPass(this.renderTarget);
    }
    renderStart({ target: t, clear: e, clearColor: r, frame: s }) {
      this._renderTargetStack.length = 0, this.push(t, e, r, s), this.rootViewPort.copyFrom(this.viewport), this.rootRenderTarget = this.renderTarget, this.renderingToScreen = By(this.rootRenderTarget);
    }
    bind(t, e = true, r, s) {
      const n = this.getRenderTarget(t), o = this.renderTarget !== n;
      this.renderTarget = n, this.renderSurface = t;
      const a = this.getGpuRenderTarget(n);
      (n.pixelWidth !== a.width || n.pixelHeight !== a.height) && (this.adaptor.resizeGpuRenderTarget(n), a.width = n.pixelWidth, a.height = n.pixelHeight);
      const c = n.colorTexture, l = this.viewport, u = c.pixelWidth, h = c.pixelHeight;
      if (!s && t instanceof Z && (s = t.frame), s) {
        const d = c._resolution;
        l.x = s.x * d + 0.5 | 0, l.y = s.y * d + 0.5 | 0, l.width = s.width * d + 0.5 | 0, l.height = s.height * d + 0.5 | 0;
      } else l.x = 0, l.y = 0, l.width = u, l.height = h;
      return Py(this.projectionMatrix, 0, 0, l.width / c.resolution, l.height / c.resolution, !n.isRoot), this.adaptor.startRenderPass(n, e, r, l), o && this.onRenderTargetChange.emit(n), n;
    }
    clear(t, e = pe.ALL, r) {
      e && (t && (t = this.getRenderTarget(t)), this.adaptor.clear(t || this.renderTarget, e, r, this.viewport));
    }
    contextChange() {
      this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);
    }
    push(t, e = pe.ALL, r, s) {
      const n = this.bind(t, e, r, s);
      return this._renderTargetStack.push({
        renderTarget: n,
        frame: s
      }), n;
    }
    pop() {
      this._renderTargetStack.pop();
      const t = this._renderTargetStack[this._renderTargetStack.length - 1];
      this.bind(t.renderTarget, false, null, t.frame);
    }
    getRenderTarget(t) {
      return t.isTexture && (t = t.source), this._renderSurfaceToRenderTargetHash.get(t) ?? this._initRenderTarget(t);
    }
    copyToTexture(t, e, r, s, n) {
      r.x < 0 && (s.width += r.x, n.x -= r.x, r.x = 0), r.y < 0 && (s.height += r.y, n.y -= r.y, r.y = 0);
      const { pixelWidth: o, pixelHeight: a } = t;
      return s.width = Math.min(s.width, o - r.x), s.height = Math.min(s.height, a - r.y), this.adaptor.copyToTexture(t, e, r, s, n);
    }
    ensureDepthStencil() {
      this.renderTarget.stencil || (this.renderTarget.stencil = true, this.adaptor.startRenderPass(this.renderTarget, false, null, this.viewport));
    }
    destroy() {
      this._renderer = null, this._renderSurfaceToRenderTargetHash.forEach((t, e) => {
        t !== e && t.destroy();
      }), this._renderSurfaceToRenderTargetHash.clear(), this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);
    }
    _initRenderTarget(t) {
      let e = null;
      return Jr.test(t) && (t = Hd(t).source), t instanceof zo ? e = t : t instanceof Ht && (e = new zo({
        colorTextures: [
          t
        ]
      }), Jr.test(t.source.resource) && (e.isRoot = true), t.once("destroy", () => {
        e.destroy();
        const r = this._gpuRenderTargetHash[e.uid];
        r && (this._gpuRenderTargetHash[e.uid] = null, this.adaptor.destroyGpuRenderTarget(r));
      })), this._renderSurfaceToRenderTargetHash.set(t, e), e;
    }
    getGpuRenderTarget(t) {
      return this._gpuRenderTargetHash[t.uid] || (this._gpuRenderTargetHash[t.uid] = this.adaptor.initGpuRenderTarget(t));
    }
  }
  class Vd extends Wd {
    constructor(t) {
      super(t), this.adaptor = new Ry(), this.adaptor.init(t, this);
    }
  }
  Vd.extension = {
    type: [
      P.WebGLSystem
    ],
    name: "renderTarget"
  };
  class Ta extends me {
    constructor({ buffer: t, offset: e, size: r }) {
      super(), this.uid = Ot("buffer"), this._resourceType = "bufferResource", this._touched = 0, this._resourceId = Ot("resource"), this._bufferResource = true, this.destroyed = false, this.buffer = t, this.offset = e | 0, this.size = r, this.buffer.on("change", this.onBufferChange, this);
    }
    onBufferChange() {
      this._resourceId = Ot("resource"), this.emit("change", this);
    }
    destroy(t = false) {
      this.destroyed = true, t && this.buffer.destroy(), this.emit("change", this), this.buffer = null;
    }
  }
  function My(i, t) {
    const e = [], r = [
      `
        var g = s.groups;
        var sS = r.shader;
        var p = s.glProgram;
        var ugS = r.uniformGroup;
        var resources;
    `
    ];
    let s = false, n = 0, o = 0;
    const a = t._getProgramData(i.glProgram);
    for (const l in i.groups) {
      const u = i.groups[l];
      e.push(`
            resources = g[${l}].resources;
        `);
      for (const h in u.resources) {
        const d = u.resources[h];
        if (d instanceof Qt) d.ubo ? e.push(`
                        sS.bindUniformBlock(
                            resources[${h}],
                            sS._uniformBindMap[${l}[${h}],
                            ${n++}
                        );
                    `) : e.push(`
                        ugS.updateUniformGroup(resources[${h}], p, sD);
                    `);
        else if (d instanceof Ta) e.push(`
                    sS.bindUniformBlock(
                        resources[${h}],
                        sS._uniformBindMap[${l}[${h}],
                        ${n++}
                    );
                `);
        else if (d instanceof Ht) {
          const p = i._uniformBindMap[l][h], g = a.uniformData[p];
          g && (s || (s = true, r.push(`
                        var tS = r.texture;
                        `)), t._gl.uniform1i(g.location, o), e.push(`
                        tS.bind(resources[${h}], ${o});
                    `), o++);
        }
      }
    }
    const c = [
      ...r,
      ...e
    ].join(`
`);
    return new Function("r", "s", "sD", c);
  }
  class Dy {
    constructor(t, e) {
      this.program = t, this.uniformData = e, this.uniformGroups = {}, this.uniformDirtyGroups = {}, this.uniformBlockBindings = {};
    }
    destroy() {
      this.uniformData = null, this.uniformGroups = null, this.uniformDirtyGroups = null, this.uniformBlockBindings = null, this.program = null;
    }
  }
  function Iu(i, t, e) {
    const r = i.createShader(t);
    return i.shaderSource(r, e), i.compileShader(r), r;
  }
  function co(i) {
    const t = new Array(i);
    for (let e = 0; e < t.length; e++) t[e] = false;
    return t;
  }
  function Xd(i, t) {
    switch (i) {
      case "float":
        return 0;
      case "vec2":
        return new Float32Array(2 * t);
      case "vec3":
        return new Float32Array(3 * t);
      case "vec4":
        return new Float32Array(4 * t);
      case "int":
      case "uint":
      case "sampler2D":
      case "sampler2DArray":
        return 0;
      case "ivec2":
        return new Int32Array(2 * t);
      case "ivec3":
        return new Int32Array(3 * t);
      case "ivec4":
        return new Int32Array(4 * t);
      case "uvec2":
        return new Uint32Array(2 * t);
      case "uvec3":
        return new Uint32Array(3 * t);
      case "uvec4":
        return new Uint32Array(4 * t);
      case "bool":
        return false;
      case "bvec2":
        return co(2 * t);
      case "bvec3":
        return co(3 * t);
      case "bvec4":
        return co(4 * t);
      case "mat2":
        return new Float32Array([
          1,
          0,
          0,
          1
        ]);
      case "mat3":
        return new Float32Array([
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1
        ]);
      case "mat4":
        return new Float32Array([
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1
        ]);
    }
    return null;
  }
  let ds = null;
  const Fu = {
    FLOAT: "float",
    FLOAT_VEC2: "vec2",
    FLOAT_VEC3: "vec3",
    FLOAT_VEC4: "vec4",
    INT: "int",
    INT_VEC2: "ivec2",
    INT_VEC3: "ivec3",
    INT_VEC4: "ivec4",
    UNSIGNED_INT: "uint",
    UNSIGNED_INT_VEC2: "uvec2",
    UNSIGNED_INT_VEC3: "uvec3",
    UNSIGNED_INT_VEC4: "uvec4",
    BOOL: "bool",
    BOOL_VEC2: "bvec2",
    BOOL_VEC3: "bvec3",
    BOOL_VEC4: "bvec4",
    FLOAT_MAT2: "mat2",
    FLOAT_MAT3: "mat3",
    FLOAT_MAT4: "mat4",
    SAMPLER_2D: "sampler2D",
    INT_SAMPLER_2D: "sampler2D",
    UNSIGNED_INT_SAMPLER_2D: "sampler2D",
    SAMPLER_CUBE: "samplerCube",
    INT_SAMPLER_CUBE: "samplerCube",
    UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
    SAMPLER_2D_ARRAY: "sampler2DArray",
    INT_SAMPLER_2D_ARRAY: "sampler2DArray",
    UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
  }, Iy = {
    float: "float32",
    vec2: "float32x2",
    vec3: "float32x3",
    vec4: "float32x4",
    int: "sint32",
    ivec2: "sint32x2",
    ivec3: "sint32x3",
    ivec4: "sint32x4",
    uint: "uint32",
    uvec2: "uint32x2",
    uvec3: "uint32x3",
    uvec4: "uint32x4",
    bool: "uint32",
    bvec2: "uint32x2",
    bvec3: "uint32x3",
    bvec4: "uint32x4"
  };
  function qd(i, t) {
    if (!ds) {
      const e = Object.keys(Fu);
      ds = {};
      for (let r = 0; r < e.length; ++r) {
        const s = e[r];
        ds[i[s]] = Fu[s];
      }
    }
    return ds[t];
  }
  function Fy(i, t) {
    const e = qd(i, t);
    return Iy[e] || "float32";
  }
  function Uy(i, t, e = false) {
    const r = {}, s = t.getProgramParameter(i, t.ACTIVE_ATTRIBUTES);
    for (let o = 0; o < s; o++) {
      const a = t.getActiveAttrib(i, o);
      if (a.name.startsWith("gl_")) continue;
      const c = Fy(t, a.type);
      r[a.name] = {
        location: 0,
        format: c,
        stride: Ai(c).stride,
        offset: 0,
        instance: false,
        start: 0
      };
    }
    const n = Object.keys(r);
    if (e) {
      n.sort((o, a) => o > a ? 1 : -1);
      for (let o = 0; o < n.length; o++) r[n[o]].location = o, t.bindAttribLocation(i, o, n[o]);
      t.linkProgram(i);
    } else for (let o = 0; o < n.length; o++) r[n[o]].location = t.getAttribLocation(i, n[o]);
    return r;
  }
  function ky(i, t) {
    if (!t.ACTIVE_UNIFORM_BLOCKS) return {};
    const e = {}, r = t.getProgramParameter(i, t.ACTIVE_UNIFORM_BLOCKS);
    for (let s = 0; s < r; s++) {
      const n = t.getActiveUniformBlockName(i, s), o = t.getUniformBlockIndex(i, n), a = t.getActiveUniformBlockParameter(i, s, t.UNIFORM_BLOCK_DATA_SIZE);
      e[n] = {
        name: n,
        index: o,
        size: a
      };
    }
    return e;
  }
  function Gy(i, t) {
    const e = {}, r = t.getProgramParameter(i, t.ACTIVE_UNIFORMS);
    for (let s = 0; s < r; s++) {
      const n = t.getActiveUniform(i, s), o = n.name.replace(/\[.*?\]$/, ""), a = !!n.name.match(/\[.*?\]$/), c = qd(t, n.type);
      e[o] = {
        name: o,
        index: s,
        type: c,
        size: n.size,
        isArray: a,
        value: Xd(c, n.size)
      };
    }
    return e;
  }
  function Uu(i, t) {
    const e = i.getShaderSource(t).split(`
`).map((l, u) => `${u}: ${l}`), r = i.getShaderInfoLog(t), s = r.split(`
`), n = {}, o = s.map((l) => parseFloat(l.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))).filter((l) => l && !n[l] ? (n[l] = true, true) : false), a = [
      ""
    ];
    o.forEach((l) => {
      e[l - 1] = `%c${e[l - 1]}%c`, a.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
    });
    const c = e.join(`
`);
    a[0] = c, console.error(r), console.groupCollapsed("click to view full shader code"), console.warn(...a), console.groupEnd();
  }
  function Oy(i, t, e, r) {
    i.getProgramParameter(t, i.LINK_STATUS) || (i.getShaderParameter(e, i.COMPILE_STATUS) || Uu(i, e), i.getShaderParameter(r, i.COMPILE_STATUS) || Uu(i, r), console.error("PixiJS Error: Could not initialize shader."), i.getProgramInfoLog(t) !== "" && console.warn("PixiJS Warning: gl.getProgramInfoLog()", i.getProgramInfoLog(t)));
  }
  function Ny(i, t) {
    const e = Iu(i, i.VERTEX_SHADER, t.vertex), r = Iu(i, i.FRAGMENT_SHADER, t.fragment), s = i.createProgram();
    i.attachShader(s, e), i.attachShader(s, r);
    const n = t.transformFeedbackVaryings;
    n && (typeof i.transformFeedbackVaryings != "function" ? ut("TransformFeedback is not supported but TransformFeedbackVaryings are given.") : i.transformFeedbackVaryings(s, n.names, n.bufferMode === "separate" ? i.SEPARATE_ATTRIBS : i.INTERLEAVED_ATTRIBS)), i.linkProgram(s), i.getProgramParameter(s, i.LINK_STATUS) || Oy(i, s, e, r), t._attributeData = Uy(s, i, !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(t.vertex)), t._uniformData = Gy(s, i), t._uniformBlockData = ky(s, i), i.deleteShader(e), i.deleteShader(r);
    const o = {};
    for (const c in t._uniformData) {
      const l = t._uniformData[c];
      o[c] = {
        location: i.getUniformLocation(s, c),
        value: Xd(l.type, l.size)
      };
    }
    return new Dy(s, o);
  }
  const fs = {
    textureCount: 0,
    blockIndex: 0
  };
  class $d {
    constructor(t) {
      this._activeProgram = null, this._programDataHash = /* @__PURE__ */ Object.create(null), this._nextIndex = 0, this._boundUniformsIdsToIndexHash = /* @__PURE__ */ Object.create(null), this._boundIndexToUniformsHash = /* @__PURE__ */ Object.create(null), this._shaderSyncFunctions = /* @__PURE__ */ Object.create(null), this._renderer = t;
    }
    contextChange(t) {
      this._gl = t, this._maxBindings = t.MAX_UNIFORM_BUFFER_BINDINGS ? t.getParameter(t.MAX_UNIFORM_BUFFER_BINDINGS) : 0, this._programDataHash = /* @__PURE__ */ Object.create(null), this._boundUniformsIdsToIndexHash = /* @__PURE__ */ Object.create(null), this._boundIndexToUniformsHash = /* @__PURE__ */ Object.create(null), this._shaderSyncFunctions = /* @__PURE__ */ Object.create(null), this._activeProgram = null;
    }
    bind(t, e) {
      if (this._setProgram(t.glProgram), e) return;
      fs.textureCount = 0, fs.blockIndex = 0;
      let r = this._shaderSyncFunctions[t.glProgram._key];
      r || (r = this._shaderSyncFunctions[t.glProgram._key] = this._generateShaderSync(t, this)), r(this._renderer, t, fs);
    }
    updateUniformGroup(t) {
      this._renderer.uniformGroup.updateUniformGroup(t, this._activeProgram, fs);
    }
    bindUniformBlock(t, e, r = 0) {
      const s = this._renderer.buffer, n = this._getProgramData(this._activeProgram), o = t._bufferResource;
      o && this._renderer.ubo.updateUniformGroup(t), s.updateBuffer(t.buffer);
      let a = this._boundUniformsIdsToIndexHash[t.uid];
      if (a === void 0) {
        const u = this._nextIndex++ % this._maxBindings, h = this._boundIndexToUniformsHash[u];
        h && (this._boundUniformsIdsToIndexHash[h.uid] = void 0), a = this._boundUniformsIdsToIndexHash[t.uid] = u, this._boundIndexToUniformsHash[u] = t, o ? s.bindBufferRange(t.buffer, u, t.offset) : s.bindBufferBase(t.buffer, u);
      }
      const c = this._gl, l = this._activeProgram._uniformBlockData[e].index;
      n.uniformBlockBindings[r] !== a && (n.uniformBlockBindings[r] = a, c.uniformBlockBinding(n.program, l, a));
    }
    _setProgram(t) {
      if (this._activeProgram === t) return;
      this._activeProgram = t;
      const e = this._getProgramData(t);
      this._gl.useProgram(e.program);
    }
    _getProgramData(t) {
      return this._programDataHash[t._key] || this._createProgramData(t);
    }
    _createProgramData(t) {
      const e = t._key;
      return this._programDataHash[e] = Ny(this._gl, t), this._programDataHash[e];
    }
    destroy() {
      for (const t of Object.keys(this._programDataHash)) this._programDataHash[t].destroy(), this._programDataHash[t] = null;
      this._programDataHash = null, this._boundUniformsIdsToIndexHash = null;
    }
    _generateShaderSync(t, e) {
      return My(t, e);
    }
  }
  $d.extension = {
    type: [
      P.WebGLSystem
    ],
    name: "shader"
  };
  const Ly = {
    f32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1f(location, v);
        }`,
    "vec2<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2f(location, v[0], v[1]);
        }`,
    "vec3<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3f(location, v[0], v[1], v[2]);
        }`,
    "vec4<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4f(location, v[0], v[1], v[2], v[3]);
        }`,
    i32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,
    "vec2<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,
    "vec3<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,
    "vec4<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,
    u32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1ui(location, v);
        }`,
    "vec2<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2ui(location, v[0], v[1]);
        }`,
    "vec3<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3ui(location, v[0], v[1], v[2]);
        }`,
    "vec4<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
        }`,
    bool: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,
    "vec2<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,
    "vec3<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,
    "vec4<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,
    "mat2x2<f32>": "gl.uniformMatrix2fv(location, false, v);",
    "mat3x3<f32>": "gl.uniformMatrix3fv(location, false, v);",
    "mat4x4<f32>": "gl.uniformMatrix4fv(location, false, v);"
  }, Hy = {
    f32: "gl.uniform1fv(location, v);",
    "vec2<f32>": "gl.uniform2fv(location, v);",
    "vec3<f32>": "gl.uniform3fv(location, v);",
    "vec4<f32>": "gl.uniform4fv(location, v);",
    "mat2x2<f32>": "gl.uniformMatrix2fv(location, false, v);",
    "mat3x3<f32>": "gl.uniformMatrix3fv(location, false, v);",
    "mat4x4<f32>": "gl.uniformMatrix4fv(location, false, v);",
    i32: "gl.uniform1iv(location, v);",
    "vec2<i32>": "gl.uniform2iv(location, v);",
    "vec3<i32>": "gl.uniform3iv(location, v);",
    "vec4<i32>": "gl.uniform4iv(location, v);",
    u32: "gl.uniform1iv(location, v);",
    "vec2<u32>": "gl.uniform2iv(location, v);",
    "vec3<u32>": "gl.uniform3iv(location, v);",
    "vec4<u32>": "gl.uniform4iv(location, v);",
    bool: "gl.uniform1iv(location, v);",
    "vec2<bool>": "gl.uniform2iv(location, v);",
    "vec3<bool>": "gl.uniform3iv(location, v);",
    "vec4<bool>": "gl.uniform4iv(location, v);"
  };
  function zy(i, t) {
    const e = [
      `
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
        var name = null;
    `
    ];
    for (const r in i.uniforms) {
      if (!t[r]) {
        i.uniforms[r] instanceof Qt ? i.uniforms[r].ubo ? e.push(`
                        renderer.shader.bindUniformBlock(uv.${r}, "${r}");
                    `) : e.push(`
                        renderer.shader.updateUniformGroup(uv.${r});
                    `) : i.uniforms[r] instanceof Ta && e.push(`
                        renderer.shader.bindBufferResource(uv.${r}, "${r}");
                    `);
        continue;
      }
      const s = i.uniformStructures[r];
      let n = false;
      for (let o = 0; o < Br.length; o++) {
        const a = Br[o];
        if (s.type === a.type && a.test(s)) {
          e.push(`name = "${r}";`, Br[o].uniform), n = true;
          break;
        }
      }
      if (!n) {
        const a = (s.size === 1 ? Ly : Hy)[s.type].replace("location", `ud["${r}"].location`);
        e.push(`
            cu = ud["${r}"];
            cv = cu.value;
            v = uv["${r}"];
            ${a};`);
      }
    }
    return new Function("ud", "uv", "renderer", "syncData", e.join(`
`));
  }
  class Yd {
    constructor(t) {
      this._cache = {}, this._uniformGroupSyncHash = {}, this._renderer = t, this.gl = null, this._cache = {};
    }
    contextChange(t) {
      this.gl = t;
    }
    updateUniformGroup(t, e, r) {
      const s = this._renderer.shader._getProgramData(e);
      (!t.isStatic || t._dirtyId !== s.uniformDirtyGroups[t.uid]) && (s.uniformDirtyGroups[t.uid] = t._dirtyId, this._getUniformSyncFunction(t, e)(s.uniformData, t.uniforms, this._renderer, r));
    }
    _getUniformSyncFunction(t, e) {
      var _a2;
      return ((_a2 = this._uniformGroupSyncHash[t._signature]) == null ? void 0 : _a2[e._key]) || this._createUniformSyncFunction(t, e);
    }
    _createUniformSyncFunction(t, e) {
      const r = this._uniformGroupSyncHash[t._signature] || (this._uniformGroupSyncHash[t._signature] = {}), s = this._getSignature(t, e._uniformData, "u");
      return this._cache[s] || (this._cache[s] = this._generateUniformsSync(t, e._uniformData)), r[e._key] = this._cache[s], r[e._key];
    }
    _generateUniformsSync(t, e) {
      return zy(t, e);
    }
    _getSignature(t, e, r) {
      const s = t.uniforms, n = [
        `${r}-`
      ];
      for (const o in s) n.push(o), e[o] && n.push(e[o].type);
      return n.join("-");
    }
    destroy() {
      this._renderer = null, this._cache = null;
    }
  }
  Yd.extension = {
    type: [
      P.WebGLSystem
    ],
    name: "uniformGroup"
  };
  function jy(i) {
    const t = {};
    return t.normal = [
      i.ONE,
      i.ONE_MINUS_SRC_ALPHA
    ], t.add = [
      i.ONE,
      i.ONE
    ], t.multiply = [
      i.DST_COLOR,
      i.ONE_MINUS_SRC_ALPHA,
      i.ONE,
      i.ONE_MINUS_SRC_ALPHA
    ], t.screen = [
      i.ONE,
      i.ONE_MINUS_SRC_COLOR,
      i.ONE,
      i.ONE_MINUS_SRC_ALPHA
    ], t.none = [
      0,
      0
    ], t["normal-npm"] = [
      i.SRC_ALPHA,
      i.ONE_MINUS_SRC_ALPHA,
      i.ONE,
      i.ONE_MINUS_SRC_ALPHA
    ], t["add-npm"] = [
      i.SRC_ALPHA,
      i.ONE,
      i.ONE,
      i.ONE
    ], t["screen-npm"] = [
      i.SRC_ALPHA,
      i.ONE_MINUS_SRC_COLOR,
      i.ONE,
      i.ONE_MINUS_SRC_ALPHA
    ], t.erase = [
      i.ZERO,
      i.ONE_MINUS_SRC_ALPHA
    ], t;
  }
  const Wy = 0, Vy = 1, Xy = 2, qy = 3, $y = 4, Yy = 5, Kd = class jo {
    constructor() {
      this.gl = null, this.stateId = 0, this.polygonOffset = 0, this.blendMode = "none", this._blendEq = false, this.map = [], this.map[Wy] = this.setBlend, this.map[Vy] = this.setOffset, this.map[Xy] = this.setCullFace, this.map[qy] = this.setDepthTest, this.map[$y] = this.setFrontFace, this.map[Yy] = this.setDepthMask, this.checks = [], this.defaultState = Le.for2d();
    }
    contextChange(t) {
      this.gl = t, this.blendModesMap = jy(t), this.reset();
    }
    set(t) {
      if (t = t || this.defaultState, this.stateId !== t.data) {
        let e = this.stateId ^ t.data, r = 0;
        for (; e; ) e & 1 && this.map[r].call(this, !!(t.data & 1 << r)), e = e >> 1, r++;
        this.stateId = t.data;
      }
      for (let e = 0; e < this.checks.length; e++) this.checks[e](this, t);
    }
    forceState(t) {
      t = t || this.defaultState;
      for (let e = 0; e < this.map.length; e++) this.map[e].call(this, !!(t.data & 1 << e));
      for (let e = 0; e < this.checks.length; e++) this.checks[e](this, t);
      this.stateId = t.data;
    }
    setBlend(t) {
      this._updateCheck(jo._checkBlendMode, t), this.gl[t ? "enable" : "disable"](this.gl.BLEND);
    }
    setOffset(t) {
      this._updateCheck(jo._checkPolygonOffset, t), this.gl[t ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
    }
    setDepthTest(t) {
      this.gl[t ? "enable" : "disable"](this.gl.DEPTH_TEST);
    }
    setDepthMask(t) {
      this.gl.depthMask(t);
    }
    setCullFace(t) {
      this.gl[t ? "enable" : "disable"](this.gl.CULL_FACE);
    }
    setFrontFace(t) {
      this.gl.frontFace(this.gl[t ? "CW" : "CCW"]);
    }
    setBlendMode(t) {
      if (this.blendModesMap[t] || (t = "normal"), t === this.blendMode) return;
      this.blendMode = t;
      const e = this.blendModesMap[t], r = this.gl;
      e.length === 2 ? r.blendFunc(e[0], e[1]) : r.blendFuncSeparate(e[0], e[1], e[2], e[3]), e.length === 6 ? (this._blendEq = true, r.blendEquationSeparate(e[4], e[5])) : this._blendEq && (this._blendEq = false, r.blendEquationSeparate(r.FUNC_ADD, r.FUNC_ADD));
    }
    setPolygonOffset(t, e) {
      this.gl.polygonOffset(t, e);
    }
    reset() {
      this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false), this.forceState(this.defaultState), this._blendEq = true, this.blendMode = "", this.setBlendMode("normal");
    }
    _updateCheck(t, e) {
      const r = this.checks.indexOf(t);
      e && r === -1 ? this.checks.push(t) : !e && r !== -1 && this.checks.splice(r, 1);
    }
    static _checkBlendMode(t, e) {
      t.setBlendMode(e.blendMode);
    }
    static _checkPolygonOffset(t, e) {
      t.setPolygonOffset(1, e.polygonOffset);
    }
    destroy() {
      this.gl = null, this.checks.length = 0;
    }
  };
  Kd.extension = {
    type: [
      P.WebGLSystem
    ],
    name: "state"
  };
  let Ky = Kd;
  class Jy {
    constructor(t) {
      this.target = Bd.TEXTURE_2D, this.texture = t, this.width = -1, this.height = -1, this.type = wt.UNSIGNED_BYTE, this.internalFormat = Ho.RGBA, this.format = Ho.RGBA, this.samplerType = 0;
    }
  }
  const Zy = {
    id: "buffer",
    upload(i, t, e) {
      t.width === i.width || t.height === i.height ? e.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, i.width, i.height, t.format, t.type, i.resource) : e.texImage2D(t.target, 0, t.internalFormat, i.width, i.height, 0, t.format, t.type, i.resource), t.width = i.width, t.height = i.height;
    }
  }, Qy = {
    "bc1-rgba-unorm": true,
    "bc1-rgba-unorm-srgb": true,
    "bc2-rgba-unorm": true,
    "bc2-rgba-unorm-srgb": true,
    "bc3-rgba-unorm": true,
    "bc3-rgba-unorm-srgb": true,
    "bc4-r-unorm": true,
    "bc4-r-snorm": true,
    "bc5-rg-unorm": true,
    "bc5-rg-snorm": true,
    "bc6h-rgb-ufloat": true,
    "bc6h-rgb-float": true,
    "bc7-rgba-unorm": true,
    "bc7-rgba-unorm-srgb": true,
    "etc2-rgb8unorm": true,
    "etc2-rgb8unorm-srgb": true,
    "etc2-rgb8a1unorm": true,
    "etc2-rgb8a1unorm-srgb": true,
    "etc2-rgba8unorm": true,
    "etc2-rgba8unorm-srgb": true,
    "eac-r11unorm": true,
    "eac-r11snorm": true,
    "eac-rg11unorm": true,
    "eac-rg11snorm": true,
    "astc-4x4-unorm": true,
    "astc-4x4-unorm-srgb": true,
    "astc-5x4-unorm": true,
    "astc-5x4-unorm-srgb": true,
    "astc-5x5-unorm": true,
    "astc-5x5-unorm-srgb": true,
    "astc-6x5-unorm": true,
    "astc-6x5-unorm-srgb": true,
    "astc-6x6-unorm": true,
    "astc-6x6-unorm-srgb": true,
    "astc-8x5-unorm": true,
    "astc-8x5-unorm-srgb": true,
    "astc-8x6-unorm": true,
    "astc-8x6-unorm-srgb": true,
    "astc-8x8-unorm": true,
    "astc-8x8-unorm-srgb": true,
    "astc-10x5-unorm": true,
    "astc-10x5-unorm-srgb": true,
    "astc-10x6-unorm": true,
    "astc-10x6-unorm-srgb": true,
    "astc-10x8-unorm": true,
    "astc-10x8-unorm-srgb": true,
    "astc-10x10-unorm": true,
    "astc-10x10-unorm-srgb": true,
    "astc-12x10-unorm": true,
    "astc-12x10-unorm-srgb": true,
    "astc-12x12-unorm": true,
    "astc-12x12-unorm-srgb": true
  }, t0 = {
    id: "compressed",
    upload(i, t, e) {
      e.pixelStorei(e.UNPACK_ALIGNMENT, 4);
      let r = i.pixelWidth, s = i.pixelHeight;
      const n = !!Qy[i.format];
      for (let o = 0; o < i.resource.length; o++) {
        const a = i.resource[o];
        n ? e.compressedTexImage2D(e.TEXTURE_2D, o, t.internalFormat, r, s, 0, a) : e.texImage2D(e.TEXTURE_2D, o, t.internalFormat, r, s, 0, t.format, t.type, a), r = Math.max(r >> 1, 1), s = Math.max(s >> 1, 1);
      }
    }
  }, Jd = {
    id: "image",
    upload(i, t, e, r) {
      const s = i.alphaMode === "premultiply-alpha-on-upload";
      e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, s);
      const n = t.width, o = t.height, a = i.pixelWidth, c = i.pixelHeight, l = i.resourceWidth, u = i.resourceHeight;
      l < a || u < c ? ((n !== a || o !== c) && e.texImage2D(t.target, 0, t.internalFormat, a, c, 0, t.format, t.type, null), r === 2 ? e.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, l, u, t.format, t.type, i.resource) : e.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, t.format, t.type, i.resource)) : n === a || o === c ? e.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, t.format, t.type, i.resource) : r === 2 ? e.texImage2D(t.target, 0, t.internalFormat, a, c, 0, t.format, t.type, i.resource) : e.texImage2D(t.target, 0, t.internalFormat, t.format, t.type, i.resource), t.width = a, t.height = c;
    }
  }, e0 = {
    id: "video",
    upload(i, t, e, r) {
      if (!i.isValid) {
        e.texImage2D(t.target, 0, t.internalFormat, 1, 1, 0, t.format, t.type, null);
        return;
      }
      Jd.upload(i, t, e, r);
    }
  }, ku = {
    linear: 9729,
    nearest: 9728
  }, r0 = {
    linear: {
      linear: 9987,
      nearest: 9985
    },
    nearest: {
      linear: 9986,
      nearest: 9984
    }
  }, uo = {
    "clamp-to-edge": 33071,
    repeat: 10497,
    "mirror-repeat": 33648
  }, i0 = {
    never: 512,
    less: 513,
    equal: 514,
    "less-equal": 515,
    greater: 516,
    "not-equal": 517,
    "greater-equal": 518,
    always: 519
  };
  function Gu(i, t, e, r, s, n, o, a) {
    const c = n;
    if (!a || i.addressModeU !== "repeat" || i.addressModeV !== "repeat" || i.addressModeW !== "repeat") {
      const l = uo[o ? "clamp-to-edge" : i.addressModeU], u = uo[o ? "clamp-to-edge" : i.addressModeV], h = uo[o ? "clamp-to-edge" : i.addressModeW];
      t[s](c, t.TEXTURE_WRAP_S, l), t[s](c, t.TEXTURE_WRAP_T, u), t.TEXTURE_WRAP_R && t[s](c, t.TEXTURE_WRAP_R, h);
    }
    if ((!a || i.magFilter !== "linear") && t[s](c, t.TEXTURE_MAG_FILTER, ku[i.magFilter]), e) {
      if (!a || i.mipmapFilter !== "linear") {
        const l = r0[i.minFilter][i.mipmapFilter];
        t[s](c, t.TEXTURE_MIN_FILTER, l);
      }
    } else t[s](c, t.TEXTURE_MIN_FILTER, ku[i.minFilter]);
    if (r && i.maxAnisotropy > 1) {
      const l = Math.min(i.maxAnisotropy, t.getParameter(r.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
      t[s](c, r.TEXTURE_MAX_ANISOTROPY_EXT, l);
    }
    i.compare && t[s](c, t.TEXTURE_COMPARE_FUNC, i0[i.compare]);
  }
  function s0(i) {
    return {
      r8unorm: i.RED,
      r8snorm: i.RED,
      r8uint: i.RED,
      r8sint: i.RED,
      r16uint: i.RED,
      r16sint: i.RED,
      r16float: i.RED,
      rg8unorm: i.RG,
      rg8snorm: i.RG,
      rg8uint: i.RG,
      rg8sint: i.RG,
      r32uint: i.RED,
      r32sint: i.RED,
      r32float: i.RED,
      rg16uint: i.RG,
      rg16sint: i.RG,
      rg16float: i.RG,
      rgba8unorm: i.RGBA,
      "rgba8unorm-srgb": i.RGBA,
      rgba8snorm: i.RGBA,
      rgba8uint: i.RGBA,
      rgba8sint: i.RGBA,
      bgra8unorm: i.RGBA,
      "bgra8unorm-srgb": i.RGBA,
      rgb9e5ufloat: i.RGB,
      rgb10a2unorm: i.RGBA,
      rg11b10ufloat: i.RGB,
      rg32uint: i.RG,
      rg32sint: i.RG,
      rg32float: i.RG,
      rgba16uint: i.RGBA,
      rgba16sint: i.RGBA,
      rgba16float: i.RGBA,
      rgba32uint: i.RGBA,
      rgba32sint: i.RGBA,
      rgba32float: i.RGBA,
      stencil8: i.STENCIL_INDEX8,
      depth16unorm: i.DEPTH_COMPONENT,
      depth24plus: i.DEPTH_COMPONENT,
      "depth24plus-stencil8": i.DEPTH_STENCIL,
      depth32float: i.DEPTH_COMPONENT,
      "depth32float-stencil8": i.DEPTH_STENCIL
    };
  }
  function n0(i, t) {
    let e = {}, r = i.RGBA;
    return i instanceof St.get().getWebGLRenderingContext() ? t.srgb && (e = {
      "rgba8unorm-srgb": t.srgb.SRGB8_ALPHA8_EXT,
      "bgra8unorm-srgb": t.srgb.SRGB8_ALPHA8_EXT
    }) : (e = {
      "rgba8unorm-srgb": i.SRGB8_ALPHA8,
      "bgra8unorm-srgb": i.SRGB8_ALPHA8
    }, r = i.RGBA8), {
      r8unorm: i.R8,
      r8snorm: i.R8_SNORM,
      r8uint: i.R8UI,
      r8sint: i.R8I,
      r16uint: i.R16UI,
      r16sint: i.R16I,
      r16float: i.R16F,
      rg8unorm: i.RG8,
      rg8snorm: i.RG8_SNORM,
      rg8uint: i.RG8UI,
      rg8sint: i.RG8I,
      r32uint: i.R32UI,
      r32sint: i.R32I,
      r32float: i.R32F,
      rg16uint: i.RG16UI,
      rg16sint: i.RG16I,
      rg16float: i.RG16F,
      rgba8unorm: i.RGBA,
      ...e,
      rgba8snorm: i.RGBA8_SNORM,
      rgba8uint: i.RGBA8UI,
      rgba8sint: i.RGBA8I,
      bgra8unorm: r,
      rgb9e5ufloat: i.RGB9_E5,
      rgb10a2unorm: i.RGB10_A2,
      rg11b10ufloat: i.R11F_G11F_B10F,
      rg32uint: i.RG32UI,
      rg32sint: i.RG32I,
      rg32float: i.RG32F,
      rgba16uint: i.RGBA16UI,
      rgba16sint: i.RGBA16I,
      rgba16float: i.RGBA16F,
      rgba32uint: i.RGBA32UI,
      rgba32sint: i.RGBA32I,
      rgba32float: i.RGBA32F,
      stencil8: i.STENCIL_INDEX8,
      depth16unorm: i.DEPTH_COMPONENT16,
      depth24plus: i.DEPTH_COMPONENT24,
      "depth24plus-stencil8": i.DEPTH24_STENCIL8,
      depth32float: i.DEPTH_COMPONENT32F,
      "depth32float-stencil8": i.DEPTH32F_STENCIL8,
      ...t.s3tc ? {
        "bc1-rgba-unorm": t.s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT,
        "bc2-rgba-unorm": t.s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT,
        "bc3-rgba-unorm": t.s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT
      } : {},
      ...t.s3tc_sRGB ? {
        "bc1-rgba-unorm-srgb": t.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
        "bc2-rgba-unorm-srgb": t.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
        "bc3-rgba-unorm-srgb": t.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
      } : {},
      ...t.rgtc ? {
        "bc4-r-unorm": t.rgtc.COMPRESSED_RED_RGTC1_EXT,
        "bc4-r-snorm": t.rgtc.COMPRESSED_SIGNED_RED_RGTC1_EXT,
        "bc5-rg-unorm": t.rgtc.COMPRESSED_RED_GREEN_RGTC2_EXT,
        "bc5-rg-snorm": t.rgtc.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
      } : {},
      ...t.bptc ? {
        "bc6h-rgb-float": t.bptc.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT,
        "bc6h-rgb-ufloat": t.bptc.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT,
        "bc7-rgba-unorm": t.bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT,
        "bc7-rgba-unorm-srgb": t.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
      } : {},
      ...t.etc ? {
        "etc2-rgb8unorm": t.etc.COMPRESSED_RGB8_ETC2,
        "etc2-rgb8unorm-srgb": t.etc.COMPRESSED_SRGB8_ETC2,
        "etc2-rgb8a1unorm": t.etc.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,
        "etc2-rgb8a1unorm-srgb": t.etc.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,
        "etc2-rgba8unorm": t.etc.COMPRESSED_RGBA8_ETC2_EAC,
        "etc2-rgba8unorm-srgb": t.etc.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,
        "eac-r11unorm": t.etc.COMPRESSED_R11_EAC,
        "eac-rg11unorm": t.etc.COMPRESSED_SIGNED_RG11_EAC
      } : {},
      ...t.astc ? {
        "astc-4x4-unorm": t.astc.COMPRESSED_RGBA_ASTC_4x4_KHR,
        "astc-4x4-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,
        "astc-5x4-unorm": t.astc.COMPRESSED_RGBA_ASTC_5x4_KHR,
        "astc-5x4-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR,
        "astc-5x5-unorm": t.astc.COMPRESSED_RGBA_ASTC_5x5_KHR,
        "astc-5x5-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,
        "astc-6x5-unorm": t.astc.COMPRESSED_RGBA_ASTC_6x5_KHR,
        "astc-6x5-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,
        "astc-6x6-unorm": t.astc.COMPRESSED_RGBA_ASTC_6x6_KHR,
        "astc-6x6-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,
        "astc-8x5-unorm": t.astc.COMPRESSED_RGBA_ASTC_8x5_KHR,
        "astc-8x5-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,
        "astc-8x6-unorm": t.astc.COMPRESSED_RGBA_ASTC_8x6_KHR,
        "astc-8x6-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,
        "astc-8x8-unorm": t.astc.COMPRESSED_RGBA_ASTC_8x8_KHR,
        "astc-8x8-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,
        "astc-10x5-unorm": t.astc.COMPRESSED_RGBA_ASTC_10x5_KHR,
        "astc-10x5-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,
        "astc-10x6-unorm": t.astc.COMPRESSED_RGBA_ASTC_10x6_KHR,
        "astc-10x6-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,
        "astc-10x8-unorm": t.astc.COMPRESSED_RGBA_ASTC_10x8_KHR,
        "astc-10x8-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,
        "astc-10x10-unorm": t.astc.COMPRESSED_RGBA_ASTC_10x10_KHR,
        "astc-10x10-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,
        "astc-12x10-unorm": t.astc.COMPRESSED_RGBA_ASTC_12x10_KHR,
        "astc-12x10-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,
        "astc-12x12-unorm": t.astc.COMPRESSED_RGBA_ASTC_12x12_KHR,
        "astc-12x12-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
      } : {}
    };
  }
  function o0(i) {
    return {
      r8unorm: i.UNSIGNED_BYTE,
      r8snorm: i.BYTE,
      r8uint: i.UNSIGNED_BYTE,
      r8sint: i.BYTE,
      r16uint: i.UNSIGNED_SHORT,
      r16sint: i.SHORT,
      r16float: i.HALF_FLOAT,
      rg8unorm: i.UNSIGNED_BYTE,
      rg8snorm: i.BYTE,
      rg8uint: i.UNSIGNED_BYTE,
      rg8sint: i.BYTE,
      r32uint: i.UNSIGNED_INT,
      r32sint: i.INT,
      r32float: i.FLOAT,
      rg16uint: i.UNSIGNED_SHORT,
      rg16sint: i.SHORT,
      rg16float: i.HALF_FLOAT,
      rgba8unorm: i.UNSIGNED_BYTE,
      "rgba8unorm-srgb": i.UNSIGNED_BYTE,
      rgba8snorm: i.BYTE,
      rgba8uint: i.UNSIGNED_BYTE,
      rgba8sint: i.BYTE,
      bgra8unorm: i.UNSIGNED_BYTE,
      "bgra8unorm-srgb": i.UNSIGNED_BYTE,
      rgb9e5ufloat: i.UNSIGNED_INT_5_9_9_9_REV,
      rgb10a2unorm: i.UNSIGNED_INT_2_10_10_10_REV,
      rg11b10ufloat: i.UNSIGNED_INT_10F_11F_11F_REV,
      rg32uint: i.UNSIGNED_INT,
      rg32sint: i.INT,
      rg32float: i.FLOAT,
      rgba16uint: i.UNSIGNED_SHORT,
      rgba16sint: i.SHORT,
      rgba16float: i.HALF_FLOAT,
      rgba32uint: i.UNSIGNED_INT,
      rgba32sint: i.INT,
      rgba32float: i.FLOAT,
      stencil8: i.UNSIGNED_BYTE,
      depth16unorm: i.UNSIGNED_SHORT,
      depth24plus: i.UNSIGNED_INT,
      "depth24plus-stencil8": i.UNSIGNED_INT_24_8,
      depth32float: i.FLOAT,
      "depth32float-stencil8": i.FLOAT_32_UNSIGNED_INT_24_8_REV
    };
  }
  const a0 = 4;
  class Zd {
    constructor(t) {
      this.managedTextures = [], this._glTextures = /* @__PURE__ */ Object.create(null), this._glSamplers = /* @__PURE__ */ Object.create(null), this._boundTextures = [], this._activeTextureLocation = -1, this._boundSamplers = /* @__PURE__ */ Object.create(null), this._uploads = {
        image: Jd,
        buffer: Zy,
        video: e0,
        compressed: t0
      }, this._useSeparateSamplers = false, this._renderer = t;
    }
    contextChange(t) {
      this._gl = t, this._mapFormatToInternalFormat || (this._mapFormatToInternalFormat = n0(t, this._renderer.context.extensions), this._mapFormatToType = o0(t), this._mapFormatToFormat = s0(t)), this._glTextures = /* @__PURE__ */ Object.create(null), this._glSamplers = /* @__PURE__ */ Object.create(null), this._boundSamplers = /* @__PURE__ */ Object.create(null);
      for (let e = 0; e < 16; e++) this.bind(Z.EMPTY, e);
    }
    initSource(t) {
      this.bind(t);
    }
    bind(t, e = 0) {
      const r = t.source;
      t ? (this.bindSource(r, e), this._useSeparateSamplers && this._bindSampler(r.style, e)) : (this.bindSource(null, e), this._useSeparateSamplers && this._bindSampler(null, e));
    }
    bindSource(t, e = 0) {
      const r = this._gl;
      if (t._touched = this._renderer.textureGC.count, this._boundTextures[e] !== t) {
        this._boundTextures[e] = t, this._activateLocation(e), t = t || Z.EMPTY.source;
        const s = this.getGlSource(t);
        r.bindTexture(s.target, s.texture);
      }
    }
    _bindSampler(t, e = 0) {
      const r = this._gl;
      if (!t) {
        this._boundSamplers[e] = null, r.bindSampler(e, null);
        return;
      }
      const s = this._getGlSampler(t);
      this._boundSamplers[e] !== s && (this._boundSamplers[e] = s, r.bindSampler(e, s));
    }
    unbind(t) {
      const e = t.source, r = this._boundTextures, s = this._gl;
      for (let n = 0; n < r.length; n++) if (r[n] === e) {
        this._activateLocation(n);
        const o = this.getGlSource(e);
        s.bindTexture(o.target, null), r[n] = null;
      }
    }
    _activateLocation(t) {
      this._activeTextureLocation !== t && (this._activeTextureLocation = t, this._gl.activeTexture(this._gl.TEXTURE0 + t));
    }
    _initSource(t) {
      const e = this._gl, r = new Jy(e.createTexture());
      if (r.type = this._mapFormatToType[t.format], r.internalFormat = this._mapFormatToInternalFormat[t.format], r.format = this._mapFormatToFormat[t.format], t.autoGenerateMipmaps && (this._renderer.context.supports.nonPowOf2mipmaps || t.isPowerOfTwo)) {
        const s = Math.max(t.width, t.height);
        t.mipLevelCount = Math.floor(Math.log2(s)) + 1;
      }
      return this._glTextures[t.uid] = r, this.managedTextures.includes(t) || (t.on("update", this.onSourceUpdate, this), t.on("resize", this.onSourceUpdate, this), t.on("styleChange", this.onStyleChange, this), t.on("destroy", this.onSourceDestroy, this), t.on("unload", this.onSourceUnload, this), t.on("updateMipmaps", this.onUpdateMipmaps, this), this.managedTextures.push(t)), this.onSourceUpdate(t), this.updateStyle(t, false), r;
    }
    onStyleChange(t) {
      this.updateStyle(t, false);
    }
    updateStyle(t, e) {
      const r = this._gl, s = this.getGlSource(t);
      r.bindTexture(r.TEXTURE_2D, s.texture), this._boundTextures[this._activeTextureLocation] = t, Gu(t.style, r, t.mipLevelCount > 1, this._renderer.context.extensions.anisotropicFiltering, "texParameteri", r.TEXTURE_2D, !this._renderer.context.supports.nonPowOf2wrapping && !t.isPowerOfTwo, e);
    }
    onSourceUnload(t) {
      const e = this._glTextures[t.uid];
      e && (this.unbind(t), this._glTextures[t.uid] = null, this._gl.deleteTexture(e.texture));
    }
    onSourceUpdate(t) {
      const e = this._gl, r = this.getGlSource(t);
      e.bindTexture(e.TEXTURE_2D, r.texture), this._boundTextures[this._activeTextureLocation] = t, this._uploads[t.uploadMethodId] ? this._uploads[t.uploadMethodId].upload(t, r, e, this._renderer.context.webGLVersion) : e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, t.pixelWidth, t.pixelHeight, 0, e.RGBA, e.UNSIGNED_BYTE, null), t.autoGenerateMipmaps && t.mipLevelCount > 1 && this.onUpdateMipmaps(t, false);
    }
    onUpdateMipmaps(t, e = true) {
      e && this.bindSource(t, 0);
      const r = this.getGlSource(t);
      this._gl.generateMipmap(r.target);
    }
    onSourceDestroy(t) {
      t.off("destroy", this.onSourceDestroy, this), t.off("update", this.onSourceUpdate, this), t.off("resize", this.onSourceUpdate, this), t.off("unload", this.onSourceUnload, this), t.off("styleChange", this.onStyleChange, this), t.off("updateMipmaps", this.onUpdateMipmaps, this), this.managedTextures.splice(this.managedTextures.indexOf(t), 1), this.onSourceUnload(t);
    }
    _initSampler(t) {
      const e = this._gl, r = this._gl.createSampler();
      return this._glSamplers[t._resourceId] = r, Gu(t, e, this._boundTextures[this._activeTextureLocation].mipLevelCount > 1, this._renderer.context.extensions.anisotropicFiltering, "samplerParameteri", r, false, true), this._glSamplers[t._resourceId];
    }
    _getGlSampler(t) {
      return this._glSamplers[t._resourceId] || this._initSampler(t);
    }
    getGlSource(t) {
      return this._glTextures[t.uid] || this._initSource(t);
    }
    generateCanvas(t) {
      const { pixels: e, width: r, height: s } = this.getPixels(t), n = St.get().createCanvas();
      n.width = r, n.height = s;
      const o = n.getContext("2d");
      if (o) {
        const a = o.createImageData(r, s);
        a.data.set(e), o.putImageData(a, 0, 0);
      }
      return n;
    }
    getPixels(t) {
      const e = t.source.resolution, r = t.frame, s = Math.max(Math.round(r.width * e), 1), n = Math.max(Math.round(r.height * e), 1), o = new Uint8Array(a0 * s * n), a = this._renderer, c = a.renderTarget.getRenderTarget(t), l = a.renderTarget.getGpuRenderTarget(c), u = a.gl;
      return u.bindFramebuffer(u.FRAMEBUFFER, l.resolveTargetFramebuffer), u.readPixels(Math.round(r.x * e), Math.round(r.y * e), s, n, u.RGBA, u.UNSIGNED_BYTE, o), {
        pixels: new Uint8ClampedArray(o.buffer),
        width: s,
        height: n
      };
    }
    destroy() {
      this.managedTextures.slice().forEach((t) => this.onSourceDestroy(t)), this.managedTextures = null, this._renderer = null;
    }
  }
  Zd.extension = {
    type: [
      P.WebGLSystem
    ],
    name: "texture"
  };
  class Qd {
    init() {
      const t = new Qt({
        uColor: {
          value: new Float32Array([
            1,
            1,
            1,
            1
          ]),
          type: "vec4<f32>"
        },
        uTransformMatrix: {
          value: new st(),
          type: "mat3x3<f32>"
        },
        uRound: {
          value: 0,
          type: "f32"
        }
      }), e = Fr(), r = Gi({
        name: "graphics",
        bits: [
          ba,
          ya(e),
          va,
          Ni
        ]
      });
      this.shader = new Se({
        glProgram: r,
        resources: {
          localUniforms: t,
          batchSamplers: xa(e)
        }
      });
    }
    execute(t, e) {
      const r = e.context, s = r.customShader || this.shader, n = t.renderer, o = n.graphicsContext, { geometry: a, instructions: c } = o.getContextRenderData(r);
      s.groups[0] = n.globalUniforms.bindGroup, n.state.set(t.state), n.shader.bind(s), n.geometry.bind(a, s.glProgram);
      const l = c.instructions;
      for (let u = 0; u < c.instructionSize; u++) {
        const h = l[u];
        if (h.size) {
          for (let d = 0; d < h.textures.count; d++) n.texture.bind(h.textures.textures[d], d);
          n.geometry.draw("triangle-list", h.size, h.start);
        }
      }
    }
    destroy() {
      this.shader.destroy(true), this.shader = null;
    }
  }
  Qd.extension = {
    type: [
      P.WebGLPipesAdaptor
    ],
    name: "graphics"
  };
  class tf {
    init() {
      const t = Gi({
        name: "mesh",
        bits: [
          va,
          hy,
          Ni
        ]
      });
      this._shader = new Se({
        glProgram: t,
        resources: {
          uTexture: Z.EMPTY.source,
          textureUniforms: {
            uTextureMatrix: {
              type: "mat3x3<f32>",
              value: new st()
            }
          }
        }
      });
    }
    execute(t, e) {
      const r = t.renderer;
      let s = e._shader;
      if (s) {
        if (!s.glProgram) {
          ut("Mesh shader has no glProgram", e.shader);
          return;
        }
      } else {
        s = this._shader;
        const n = e.texture, o = n.source;
        s.resources.uTexture = o, s.resources.uSampler = o.style, s.resources.textureUniforms.uniforms.uTextureMatrix = n.textureMatrix.mapCoord;
      }
      s.groups[100] = r.globalUniforms.bindGroup, s.groups[101] = t.localUniformsBindGroup, r.encoder.draw({
        geometry: e._geometry,
        shader: s,
        state: e.state
      });
    }
    destroy() {
      this._shader.destroy(true), this._shader = null;
    }
  }
  tf.extension = {
    type: [
      P.WebGLPipesAdaptor
    ],
    name: "mesh"
  };
  class ef {
    constructor(t) {
      this._renderer = t;
    }
    addRenderable(t, e) {
      this._renderer.renderPipes.batch.break(e), e.add(t);
    }
    execute(t) {
      t.isRenderable && t.render(this._renderer);
    }
    destroy() {
      this._renderer = null;
    }
  }
  ef.extension = {
    type: [
      P.WebGLPipes,
      P.WebGPUPipes,
      P.CanvasPipes
    ],
    name: "customRender"
  };
  function rf(i, t) {
    const e = i.instructionSet, r = e.instructions;
    for (let s = 0; s < e.instructionSize; s++) {
      const n = r[s];
      t[n.renderPipeId].execute(n);
    }
  }
  class sf {
    constructor(t) {
      this._renderer = t;
    }
    addRenderGroup(t, e) {
      this._renderer.renderPipes.batch.break(e), e.add(t);
    }
    execute(t) {
      t.isRenderable && (this._renderer.globalUniforms.push({
        worldTransformMatrix: t.worldTransform,
        worldColor: t.worldColorAlpha
      }), rf(t, this._renderer.renderPipes), this._renderer.globalUniforms.pop());
    }
    destroy() {
      this._renderer = null;
    }
  }
  sf.extension = {
    type: [
      P.WebGLPipes,
      P.WebGPUPipes,
      P.CanvasPipes
    ],
    name: "renderGroup"
  };
  function Ca(i, t) {
    t || (t = 0);
    for (let e = t; e < i.length && i[e]; e++) i[e] = null;
  }
  function nf(i, t = []) {
    t.push(i);
    for (let e = 0; e < i.renderGroupChildren.length; e++) nf(i.renderGroupChildren[e], t);
    return t;
  }
  function c0(i, t, e) {
    const r = i >> 16 & 255, s = i >> 8 & 255, n = i & 255, o = t >> 16 & 255, a = t >> 8 & 255, c = t & 255, l = r + (o - r) * e, u = s + (a - s) * e, h = n + (c - n) * e;
    return (l << 16) + (u << 8) + h;
  }
  const lo = 16777215;
  function of(i, t) {
    return i === lo || t === lo ? i + t - lo : c0(i, t, 0.5);
  }
  const u0 = new Dt(), Ou = xi | Bs | ea;
  function af(i, t = false) {
    l0(i);
    const e = i.childrenToUpdate, r = i.updateTick++;
    for (const s in e) {
      const n = Number(s), o = e[s], a = o.list, c = o.index;
      for (let l = 0; l < c; l++) {
        const u = a[l];
        u.parentRenderGroup === i && u.relativeRenderGroupDepth === n && cf(u, r, 0);
      }
      Ca(a, c), o.index = 0;
    }
    if (t) for (let s = 0; s < i.renderGroupChildren.length; s++) af(i.renderGroupChildren[s], t);
  }
  function l0(i) {
    const t = i.root;
    let e;
    if (i.renderGroupParent) {
      const r = i.renderGroupParent;
      i.worldTransform.appendFrom(t.relativeGroupTransform, r.worldTransform), i.worldColor = of(t.groupColor, r.worldColor), e = t.groupAlpha * r.worldAlpha;
    } else i.worldTransform.copyFrom(t.localTransform), i.worldColor = t.localColor, e = t.localAlpha;
    e = e < 0 ? 0 : e > 1 ? 1 : e, i.worldAlpha = e, i.worldColorAlpha = i.worldColor + ((e * 255 | 0) << 24);
  }
  function cf(i, t, e) {
    if (t === i.updateTick) return;
    i.updateTick = t, i.didChange = false;
    const r = i.localTransform;
    i.updateLocalTransform();
    const s = i.parent;
    if (s && !s.renderGroup ? (e = e | i._updateFlags, i.relativeGroupTransform.appendFrom(r, s.relativeGroupTransform), e & Ou && Nu(i, s, e)) : (e = i._updateFlags, i.relativeGroupTransform.copyFrom(r), e & Ou && Nu(i, u0, e)), !i.renderGroup) {
      const n = i.children, o = n.length;
      for (let c = 0; c < o; c++) cf(n[c], t, e);
      const a = i.parentRenderGroup;
      i.renderPipeId && !a.structureDidChange && a.updateRenderable(i);
    }
  }
  function Nu(i, t, e) {
    if (e & Bs) {
      i.groupColor = of(i.localColor, t.groupColor);
      let r = i.localAlpha * t.groupAlpha;
      r = r < 0 ? 0 : r > 1 ? 1 : r, i.groupAlpha = r, i.groupColorAlpha = i.groupColor + ((r * 255 | 0) << 24);
    }
    e & ea && (i.groupBlendMode = i.localBlendMode === "inherit" ? t.groupBlendMode : i.localBlendMode), e & xi && (i.globalDisplayStatus = i.localDisplayStatus & t.globalDisplayStatus), i._updateFlags = 0;
  }
  function h0(i, t) {
    const { list: e, index: r } = i.childrenRenderablesToUpdate;
    let s = false;
    for (let n = 0; n < r; n++) {
      const o = e[n];
      if (s = t[o.renderPipeId].validateRenderable(o), s) break;
    }
    return i.structureDidChange = s, s;
  }
  const d0 = new st();
  class uf {
    constructor(t) {
      this._renderer = t;
    }
    render({ container: t, transform: e }) {
      t.isRenderGroup = true;
      const r = t.parent, s = t.renderGroup.renderGroupParent;
      t.parent = null, t.renderGroup.renderGroupParent = null;
      const n = this._renderer, o = nf(t.renderGroup, []);
      let a = d0;
      e && (a = a.copyFrom(t.renderGroup.localTransform), t.renderGroup.localTransform.copyFrom(e));
      const c = n.renderPipes;
      for (let l = 0; l < o.length; l++) {
        const u = o[l];
        u.runOnRender(), u.instructionSet.renderPipes = c, u.structureDidChange ? Ca(u.childrenRenderablesToUpdate.list, 0) : h0(u, c), af(u), u.structureDidChange ? (u.structureDidChange = false, dy(u, c)) : f0(u), u.childrenRenderablesToUpdate.index = 0, n.renderPipes.batch.upload(u.instructionSet);
      }
      n.globalUniforms.start({
        worldTransformMatrix: e ? t.renderGroup.localTransform : t.renderGroup.worldTransform,
        worldColor: t.renderGroup.worldColorAlpha
      }), rf(t.renderGroup, c), c.uniformBatch && c.uniformBatch.renderEnd(), e && t.renderGroup.localTransform.copyFrom(a), t.parent = r, t.renderGroup.renderGroupParent = s;
    }
    destroy() {
      this._renderer = null;
    }
  }
  uf.extension = {
    type: [
      P.WebGLSystem,
      P.WebGPUSystem,
      P.CanvasSystem
    ],
    name: "renderGroup"
  };
  function f0(i) {
    const { list: t, index: e } = i.childrenRenderablesToUpdate;
    for (let r = 0; r < e; r++) {
      const s = t[r];
      s.didViewUpdate && i.updateRenderable(s);
    }
    Ca(t, e);
  }
  class Aa {
    constructor() {
      this.vertexSize = 4, this.indexSize = 6, this.location = 0, this.batcher = null, this.batch = null, this.roundPixels = 0;
    }
    get blendMode() {
      return this.renderable.groupBlendMode;
    }
    packAttributes(t, e, r, s) {
      const n = this.renderable, o = this.texture, a = n.groupTransform, c = a.a, l = a.b, u = a.c, h = a.d, d = a.tx, p = a.ty, g = this.bounds, y = g.maxX, m = g.minX, v = g.maxY, S = g.minY, C = o.uvs, G = n.groupColorAlpha, H = s << 16 | this.roundPixels & 65535;
      t[r + 0] = c * m + u * S + d, t[r + 1] = h * S + l * m + p, t[r + 2] = C.x0, t[r + 3] = C.y0, e[r + 4] = G, e[r + 5] = H, t[r + 6] = c * y + u * S + d, t[r + 7] = h * S + l * y + p, t[r + 8] = C.x1, t[r + 9] = C.y1, e[r + 10] = G, e[r + 11] = H, t[r + 12] = c * y + u * v + d, t[r + 13] = h * v + l * y + p, t[r + 14] = C.x2, t[r + 15] = C.y2, e[r + 16] = G, e[r + 17] = H, t[r + 18] = c * m + u * v + d, t[r + 19] = h * v + l * m + p, t[r + 20] = C.x3, t[r + 21] = C.y3, e[r + 22] = G, e[r + 23] = H;
    }
    packIndex(t, e, r) {
      t[e] = r + 0, t[e + 1] = r + 1, t[e + 2] = r + 2, t[e + 3] = r + 0, t[e + 4] = r + 2, t[e + 5] = r + 3;
    }
    reset() {
      this.renderable = null, this.texture = null, this.batcher = null, this.batch = null, this.bounds = null;
    }
  }
  class lf {
    constructor(t) {
      this._gpuSpriteHash = /* @__PURE__ */ Object.create(null), this._renderer = t;
    }
    addRenderable(t, e) {
      const r = this._getGpuSprite(t);
      t._didSpriteUpdate && this._updateBatchableSprite(t, r), this._renderer.renderPipes.batch.addToBatch(r);
    }
    updateRenderable(t) {
      const e = this._gpuSpriteHash[t.uid];
      t._didSpriteUpdate && this._updateBatchableSprite(t, e), e.batcher.updateElement(e);
    }
    validateRenderable(t) {
      const e = t._texture, r = this._getGpuSprite(t);
      return r.texture._source !== e._source ? !r.batcher.checkAndUpdateTexture(r, e) : false;
    }
    destroyRenderable(t) {
      const e = this._gpuSpriteHash[t.uid];
      vt.return(e), this._gpuSpriteHash[t.uid] = null;
    }
    _updateBatchableSprite(t, e) {
      t._didSpriteUpdate = false, e.bounds = t.bounds, e.texture = t._texture;
    }
    _getGpuSprite(t) {
      return this._gpuSpriteHash[t.uid] || this._initGPUSprite(t);
    }
    _initGPUSprite(t) {
      const e = vt.get(Aa);
      return e.renderable = t, e.texture = t._texture, e.bounds = t.bounds, e.roundPixels = this._renderer._roundPixels | t._roundPixels, this._gpuSpriteHash[t.uid] = e, t._didSpriteUpdate = false, t.on("destroyed", () => {
        this.destroyRenderable(t);
      }), e;
    }
    destroy() {
      for (const t in this._gpuSpriteHash) vt.return(this._gpuSpriteHash[t]);
      this._gpuSpriteHash = null, this._renderer = null;
    }
  }
  lf.extension = {
    type: [
      P.WebGLPipes,
      P.WebGPUPipes,
      P.CanvasPipes
    ],
    name: "sprite"
  };
  const Ra = class hf {
    constructor() {
      this.clearBeforeRender = true, this._backgroundColor = new Tt(0), this.color = this._backgroundColor, this.alpha = 1;
    }
    init(t) {
      t = {
        ...hf.defaultOptions,
        ...t
      }, this.clearBeforeRender = t.clearBeforeRender, this.color = t.background || t.backgroundColor || this._backgroundColor, this.alpha = t.backgroundAlpha, this._backgroundColor.setAlpha(t.backgroundAlpha);
    }
    get color() {
      return this._backgroundColor;
    }
    set color(t) {
      this._backgroundColor.setValue(t);
    }
    get alpha() {
      return this._backgroundColor.alpha;
    }
    set alpha(t) {
      this._backgroundColor.setAlpha(t);
    }
    get colorRgba() {
      return this._backgroundColor.toArray();
    }
    destroy() {
    }
  };
  Ra.extension = {
    type: [
      P.WebGLSystem,
      P.WebGPUSystem,
      P.CanvasSystem
    ],
    name: "background",
    priority: 0
  };
  Ra.defaultOptions = {
    backgroundAlpha: 1,
    backgroundColor: 0,
    clearBeforeRender: true
  };
  let p0 = Ra;
  const Ti = {};
  Mt.handle(P.BlendMode, (i) => {
    if (!i.name) throw new Error("BlendMode extension must have a name property");
    Ti[i.name] = i.ref;
  }, (i) => {
    delete Ti[i.name];
  });
  class df {
    constructor(t) {
      this._isAdvanced = false, this._filterHash = /* @__PURE__ */ Object.create(null), this._renderer = t;
    }
    setBlendMode(t, e, r) {
      if (this._activeBlendMode === e) {
        this._isAdvanced && this._renderableList.push(t);
        return;
      }
      this._activeBlendMode = e, this._isAdvanced && this._endAdvancedBlendMode(r), this._isAdvanced = !!Ti[e], this._isAdvanced && (this._beginAdvancedBlendMode(r), this._renderableList.push(t));
    }
    _beginAdvancedBlendMode(t) {
      this._renderer.renderPipes.batch.break(t);
      const e = this._activeBlendMode;
      if (!Ti[e]) {
        ut(`Unable to assign BlendMode: '${e}'. You may want to include: import 'pixi.js/advanced-blend-modes'`);
        return;
      }
      let r = this._filterHash[e];
      r || (r = this._filterHash[e] = new Rs(), r.filters = [
        new Ti[e]()
      ]);
      const s = {
        renderPipeId: "filter",
        action: "pushFilter",
        renderables: [],
        filterEffect: r,
        canBundle: false
      };
      this._renderableList = s.renderables, t.add(s);
    }
    _endAdvancedBlendMode(t) {
      this._renderableList = null, this._renderer.renderPipes.batch.break(t), t.add({
        renderPipeId: "filter",
        action: "popFilter",
        canBundle: false
      });
    }
    buildStart() {
      this._isAdvanced = false;
    }
    buildEnd(t) {
      this._isAdvanced && this._endAdvancedBlendMode(t);
    }
    destroy() {
      this._renderer = null, this._renderableList = null;
      for (const t in this._filterHash) this._filterHash[t].destroy();
      this._filterHash = null;
    }
  }
  df.extension = {
    type: [
      P.WebGLPipes,
      P.WebGPUPipes,
      P.CanvasPipes
    ],
    name: "blendMode"
  };
  const ho = {
    png: "image/png",
    jpg: "image/jpeg",
    webp: "image/webp"
  }, Pa = class ff {
    constructor(t) {
      this._renderer = t;
    }
    _normalizeOptions(t, e = {}) {
      return t instanceof Dt || t instanceof Z ? {
        target: t,
        ...e
      } : {
        ...e,
        ...t
      };
    }
    async image(t) {
      const e = new Image();
      return e.src = await this.base64(t), e;
    }
    async base64(t) {
      t = this._normalizeOptions(t, ff.defaultImageOptions);
      const { format: e, quality: r } = t, s = this.canvas(t);
      if (s.toBlob !== void 0) return new Promise((n, o) => {
        s.toBlob((a) => {
          if (!a) {
            o(new Error("ICanvas.toBlob failed!"));
            return;
          }
          const c = new FileReader();
          c.onload = () => n(c.result), c.onerror = o, c.readAsDataURL(a);
        }, ho[e], r);
      });
      if (s.toDataURL !== void 0) return s.toDataURL(ho[e], r);
      if (s.convertToBlob !== void 0) {
        const n = await s.convertToBlob({
          type: ho[e],
          quality: r
        });
        return new Promise((o, a) => {
          const c = new FileReader();
          c.onload = () => o(c.result), c.onerror = a, c.readAsDataURL(n);
        });
      }
      throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented");
    }
    canvas(t) {
      t = this._normalizeOptions(t);
      const e = t.target, r = this._renderer;
      if (e instanceof Z) return r.texture.generateCanvas(e);
      const s = r.textureGenerator.generateTexture(t), n = r.texture.generateCanvas(s);
      return s.destroy(), n;
    }
    pixels(t) {
      t = this._normalizeOptions(t);
      const e = t.target, r = this._renderer, s = e instanceof Z ? e : r.textureGenerator.generateTexture(t), n = r.texture.getPixels(s);
      return e instanceof Dt && s.destroy(), n;
    }
    texture(t) {
      return t = this._normalizeOptions(t), t.target instanceof Z ? t.target : this._renderer.textureGenerator.generateTexture(t);
    }
    download(t) {
      t = this._normalizeOptions(t);
      const e = this.canvas(t), r = document.createElement("a");
      r.download = t.filename ?? "image.png", r.href = e.toDataURL("image/png"), document.body.appendChild(r), r.click(), document.body.removeChild(r);
    }
    log(t) {
      const e = t.width ?? 200;
      t = this._normalizeOptions(t);
      const r = this.canvas(t), s = r.toDataURL();
      console.log(`[Pixi Texture] ${r.width}px ${r.height}px`);
      const n = [
        "font-size: 1px;",
        `padding: ${e}px 300px;`,
        `background: url(${s}) no-repeat;`,
        "background-size: contain;"
      ].join(" ");
      console.log("%c ", n);
    }
    destroy() {
      this._renderer = null;
    }
  };
  Pa.extension = {
    type: [
      P.WebGLSystem,
      P.WebGPUSystem
    ],
    name: "extract"
  };
  Pa.defaultImageOptions = {
    format: "png",
    quality: 1
  };
  let _0 = Pa;
  class g0 extends Z {
    static create(t) {
      return new Z({
        source: new Ht(t)
      });
    }
    resize(t, e, r) {
      return this.source.resize(t, e, r), this;
    }
  }
  const m0 = new Et(), b0 = new re(), w0 = [
    0,
    0,
    0,
    0
  ];
  class pf {
    constructor(t) {
      this._renderer = t;
    }
    generateTexture(t) {
      var _a2;
      t instanceof Dt && (t = {
        target: t,
        frame: void 0,
        textureSourceOptions: {},
        resolution: void 0
      });
      const e = t.resolution || this._renderer.resolution, r = t.antialias || this._renderer.view.antialias, s = t.target;
      let n = t.clearColor;
      n ? n = Array.isArray(n) && n.length === 4 ? n : Tt.shared.setValue(n).toArray() : n = w0;
      const o = ((_a2 = t.frame) == null ? void 0 : _a2.copyTo(m0)) || ta(s, b0).rectangle;
      o.width = Math.max(o.width, 1 / e) | 0, o.height = Math.max(o.height, 1 / e) | 0;
      const a = g0.create({
        ...t.textureSourceOptions,
        width: o.width,
        height: o.height,
        resolution: e,
        antialias: r
      }), c = st.shared.translate(-o.x, -o.y);
      return this._renderer.render({
        container: s,
        transform: c,
        target: a,
        clearColor: n
      }), a.source.updateMipmaps(), a;
    }
    destroy() {
      this._renderer = null;
    }
  }
  pf.extension = {
    type: [
      P.WebGLSystem,
      P.WebGPUSystem
    ],
    name: "textureGenerator"
  };
  function on(i, t, e) {
    const r = (i >> 24 & 255) / 255;
    t[e++] = (i & 255) / 255 * r, t[e++] = (i >> 8 & 255) / 255 * r, t[e++] = (i >> 16 & 255) / 255 * r, t[e++] = r;
  }
  class _f {
    constructor(t) {
      this._stackIndex = 0, this._globalUniformDataStack = [], this._uniformsPool = [], this._activeUniforms = [], this._bindGroupPool = [], this._activeBindGroups = [], this._renderer = t;
    }
    reset() {
      this._stackIndex = 0;
      for (let t = 0; t < this._activeUniforms.length; t++) this._uniformsPool.push(this._activeUniforms[t]);
      for (let t = 0; t < this._activeBindGroups.length; t++) this._bindGroupPool.push(this._activeBindGroups[t]);
      this._activeUniforms.length = 0, this._activeBindGroups.length = 0;
    }
    start(t) {
      this.reset(), this.push(t);
    }
    bind({ size: t, projectionMatrix: e, worldTransformMatrix: r, worldColor: s, offset: n }) {
      const o = this._renderer.renderTarget.renderTarget, a = this._stackIndex ? this._globalUniformDataStack[this._stackIndex - 1] : {
        projectionData: o,
        worldTransformMatrix: new st(),
        worldColor: 4294967295,
        offset: new At()
      }, c = {
        projectionMatrix: e || this._renderer.renderTarget.projectionMatrix,
        resolution: t || o.size,
        worldTransformMatrix: r || a.worldTransformMatrix,
        worldColor: s || a.worldColor,
        offset: n || a.offset,
        bindGroup: null
      }, l = this._uniformsPool.pop() || this._createUniforms();
      this._activeUniforms.push(l);
      const u = l.uniforms;
      u.uProjectionMatrix = c.projectionMatrix, u.uResolution = c.resolution, u.uWorldTransformMatrix.copyFrom(c.worldTransformMatrix), u.uWorldTransformMatrix.tx -= c.offset.x, u.uWorldTransformMatrix.ty -= c.offset.y, on(c.worldColor, u.uWorldColorAlpha, 0), l.update();
      let h;
      this._renderer.renderPipes.uniformBatch ? h = this._renderer.renderPipes.uniformBatch.getUniformBindGroup(l, false) : (h = this._bindGroupPool.pop() || new Ze(), this._activeBindGroups.push(h), h.setResource(l, 0)), c.bindGroup = h, this._currentGlobalUniformData = c;
    }
    push(t) {
      this.bind(t), this._globalUniformDataStack[this._stackIndex++] = this._currentGlobalUniformData;
    }
    pop() {
      this._currentGlobalUniformData = this._globalUniformDataStack[--this._stackIndex - 1], this._renderer.type === ge.WEBGL && this._currentGlobalUniformData.bindGroup.resources[0].update();
    }
    get bindGroup() {
      return this._currentGlobalUniformData.bindGroup;
    }
    get uniformGroup() {
      return this._currentGlobalUniformData.bindGroup.resources[0];
    }
    _createUniforms() {
      return new Qt({
        uProjectionMatrix: {
          value: new st(),
          type: "mat3x3<f32>"
        },
        uWorldTransformMatrix: {
          value: new st(),
          type: "mat3x3<f32>"
        },
        uWorldColorAlpha: {
          value: new Float32Array(4),
          type: "vec4<f32>"
        },
        uResolution: {
          value: [
            0,
            0
          ],
          type: "vec2<f32>"
        }
      }, {
        isStatic: true
      });
    }
    destroy() {
      this._renderer = null;
    }
  }
  _f.extension = {
    type: [
      P.WebGLSystem,
      P.WebGPUSystem,
      P.CanvasSystem
    ],
    name: "globalUniforms"
  };
  let Lu = false;
  const Hu = "8.2.6";
  function y0(i) {
    if (!Lu) {
      if (St.get().getNavigator().userAgent.toLowerCase().indexOf("chrome") > -1) {
        const t = [
          `%c  %c  %c  %c  %c PixiJS %c v${Hu} (${i}) http://www.pixijs.com/

`,
          "background: #E72264; padding:5px 0;",
          "background: #6CA2EA; padding:5px 0;",
          "background: #B5D33D; padding:5px 0;",
          "background: #FED23F; padding:5px 0;",
          "color: #FFFFFF; background: #E72264; padding:5px 0;",
          "color: #E72264; background: #FFFFFF; padding:5px 0;"
        ];
        globalThis.console.log(...t);
      } else globalThis.console && globalThis.console.log(`PixiJS ${Hu} - ${i} - http://www.pixijs.com/`);
      Lu = true;
    }
  }
  class Ba {
    constructor(t) {
      this._renderer = t;
    }
    init(t) {
      if (t.hello) {
        let e = this._renderer.name;
        this._renderer.type === ge.WEBGL && (e += ` ${this._renderer.context.webGLVersion}`), y0(e);
      }
    }
  }
  Ba.extension = {
    type: [
      P.WebGLSystem,
      P.WebGPUSystem,
      P.CanvasSystem
    ],
    name: "hello",
    priority: -2
  };
  Ba.defaultOptions = {
    hello: false
  };
  const Ma = class gf {
    constructor(t) {
      this._renderer = t, this.count = 0, this.checkCount = 0;
    }
    init(t) {
      t = {
        ...gf.defaultOptions,
        ...t
      }, this.checkCountMax = t.textureGCCheckCountMax, this.maxIdle = t.textureGCAMaxIdle, this.active = t.textureGCActive;
    }
    postrender() {
      this._renderer.renderingToScreen && (this.count++, this.active && (this.checkCount++, this.checkCount > this.checkCountMax && (this.checkCount = 0, this.run())));
    }
    run() {
      const t = this._renderer.texture.managedTextures;
      for (let e = 0; e < t.length; e++) {
        const r = t[e];
        r.autoGarbageCollect && r.resource && r._touched > -1 && this.count - r._touched > this.maxIdle && (r._touched = -1, r.unload());
      }
    }
    destroy() {
      this._renderer = null;
    }
  };
  Ma.extension = {
    type: [
      P.WebGLSystem,
      P.WebGPUSystem
    ],
    name: "textureGC"
  };
  Ma.defaultOptions = {
    textureGCActive: true,
    textureGCAMaxIdle: 60 * 60,
    textureGCCheckCountMax: 600
  };
  let mf = Ma;
  Mt.add(mf);
  const Da = class bf {
    get resolution() {
      return this.texture.source._resolution;
    }
    set resolution(t) {
      this.texture.source.resize(this.texture.source.width, this.texture.source.height, t);
    }
    init(t) {
      t = {
        ...bf.defaultOptions,
        ...t
      }, t.view && (lt(dt, "ViewSystem.view has been renamed to ViewSystem.canvas"), t.canvas = t.view), this.screen = new Et(0, 0, t.width, t.height), this.canvas = t.canvas || St.get().createCanvas(), this.antialias = !!t.antialias, this.texture = Hd(this.canvas, t), this.renderTarget = new zo({
        colorTextures: [
          this.texture
        ],
        depth: !!t.depth,
        isRoot: true
      }), this.texture.source.transparent = t.backgroundAlpha < 1, this.multiView = !!t.multiView, this.autoDensity && (this.canvas.style.width = `${this.texture.width}px`, this.canvas.style.height = `${this.texture.height}px`), this.resolution = t.resolution;
    }
    resize(t, e, r) {
      this.texture.source.resize(t, e, r), this.screen.width = this.texture.frame.width, this.screen.height = this.texture.frame.height, this.autoDensity && (this.canvas.style.width = `${t}px`, this.canvas.style.height = `${e}px`);
    }
    destroy(t = false) {
      (typeof t == "boolean" ? t : !!(t == null ? void 0 : t.removeView)) && this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas);
    }
  };
  Da.extension = {
    type: [
      P.WebGLSystem,
      P.WebGPUSystem,
      P.CanvasSystem
    ],
    name: "view",
    priority: 0
  };
  Da.defaultOptions = {
    width: 800,
    height: 600,
    autoDensity: false,
    antialias: false
  };
  let x0 = Da;
  const wf = [
    p0,
    _f,
    Ba,
    x0,
    uf,
    mf,
    pf,
    _0,
    gh
  ], yf = [
    df,
    vd,
    lf,
    sf,
    Ed,
    Cd,
    Td,
    ef
  ], v0 = [
    ...wf,
    Ld,
    vy,
    my,
    Ad,
    Zd,
    Vd,
    Md,
    Yd,
    $d,
    Fd,
    Ky,
    Ud,
    Id
  ], S0 = [
    ...yf
  ], E0 = [
    yd,
    tf,
    Qd
  ], xf = [], vf = [], Sf = [];
  Mt.handleByNamedList(P.WebGLSystem, xf);
  Mt.handleByNamedList(P.WebGLPipes, vf);
  Mt.handleByNamedList(P.WebGLPipesAdaptor, Sf);
  Mt.add(...v0, ...S0, ...E0);
  class T0 extends Ys {
    constructor() {
      const t = {
        name: "webgl",
        type: ge.WEBGL,
        systems: xf,
        renderPipes: vf,
        renderPipeAdaptors: Sf
      };
      super(t);
    }
  }
  const C0 = Object.freeze(Object.defineProperty({
    __proto__: null,
    WebGLRenderer: T0
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  class Ef {
    constructor(t) {
      this._hash = /* @__PURE__ */ Object.create(null), this._renderer = t;
    }
    contextChange(t) {
      this._gpu = t;
    }
    getBindGroup(t, e, r) {
      return t._updateKey(), this._hash[t._key] || this._createBindGroup(t, e, r);
    }
    _createBindGroup(t, e, r) {
      const s = this._gpu.device, n = e.layout[r], o = [], a = this._renderer;
      for (const u in n) {
        const h = t.resources[u] ?? t.resources[n[u]];
        let d;
        if (h._resourceType === "uniformGroup") {
          const p = h;
          a.ubo.updateUniformGroup(p);
          const g = p.buffer;
          d = {
            buffer: a.buffer.getGPUBuffer(g),
            offset: 0,
            size: g.descriptor.size
          };
        } else if (h._resourceType === "buffer") {
          const p = h;
          d = {
            buffer: a.buffer.getGPUBuffer(p),
            offset: 0,
            size: p.descriptor.size
          };
        } else if (h._resourceType === "bufferResource") {
          const p = h;
          d = {
            buffer: a.buffer.getGPUBuffer(p.buffer),
            offset: p.offset,
            size: p.size
          };
        } else if (h._resourceType === "textureSampler") {
          const p = h;
          d = a.texture.getGpuSampler(p);
        } else if (h._resourceType === "textureSource") {
          const p = h;
          d = a.texture.getGpuSource(p).createView({});
        }
        o.push({
          binding: n[u],
          resource: d
        });
      }
      const c = a.shader.getProgramData(e).bindGroups[r], l = s.createBindGroup({
        layout: c,
        entries: o
      });
      return this._hash[t._key] = l, l;
    }
    destroy() {
      for (const t of Object.keys(this._hash)) this._hash[t] = null;
      this._hash = null, this._renderer = null;
    }
  }
  Ef.extension = {
    type: [
      P.WebGPUSystem
    ],
    name: "bindGroup"
  };
  class Tf {
    constructor() {
      this._gpuBuffers = /* @__PURE__ */ Object.create(null), this._managedBuffers = [];
    }
    contextChange(t) {
      this._gpu = t;
    }
    getGPUBuffer(t) {
      return this._gpuBuffers[t.uid] || this.createGPUBuffer(t);
    }
    updateBuffer(t) {
      const e = this._gpuBuffers[t.uid] || this.createGPUBuffer(t), r = t.data;
      return t._updateID && r && (t._updateID = 0, this._gpu.device.queue.writeBuffer(e, 0, r.buffer, 0, (t._updateSize || r.byteLength) + 3 & -4)), e;
    }
    destroyAll() {
      for (const t in this._gpuBuffers) this._gpuBuffers[t].destroy();
      this._gpuBuffers = {};
    }
    createGPUBuffer(t) {
      this._gpuBuffers[t.uid] || (t.on("update", this.updateBuffer, this), t.on("change", this.onBufferChange, this), t.on("destroy", this.onBufferDestroy, this), this._managedBuffers.push(t));
      const e = this._gpu.device.createBuffer(t.descriptor);
      return t._updateID = 0, t.data && (Do(t.data.buffer, e.getMappedRange()), e.unmap()), this._gpuBuffers[t.uid] = e, e;
    }
    onBufferChange(t) {
      this._gpuBuffers[t.uid].destroy(), t._updateID = 0, this._gpuBuffers[t.uid] = this.createGPUBuffer(t);
    }
    onBufferDestroy(t) {
      this._managedBuffers.splice(this._managedBuffers.indexOf(t), 1), this._destroyBuffer(t);
    }
    destroy() {
      this._managedBuffers.forEach((t) => this._destroyBuffer(t)), this._managedBuffers = null, this._gpuBuffers = null;
    }
    _destroyBuffer(t) {
      this._gpuBuffers[t.uid].destroy(), t.off("update", this.updateBuffer, this), t.off("change", this.onBufferChange, this), t.off("destroy", this.onBufferDestroy, this), this._gpuBuffers[t.uid] = null;
    }
  }
  Tf.extension = {
    type: [
      P.WebGPUSystem
    ],
    name: "buffer"
  };
  class A0 {
    constructor({ minUniformOffsetAlignment: t }) {
      this._minUniformOffsetAlignment = 256, this.byteIndex = 0, this._minUniformOffsetAlignment = t, this.data = new Float32Array(65535);
    }
    clear() {
      this.byteIndex = 0;
    }
    addEmptyGroup(t) {
      if (t > this._minUniformOffsetAlignment / 4) throw new Error(`UniformBufferBatch: array is too large: ${t * 4}`);
      const e = this.byteIndex;
      let r = e + t * 4;
      if (r = Math.ceil(r / this._minUniformOffsetAlignment) * this._minUniformOffsetAlignment, r > this.data.length * 4) throw new Error("UniformBufferBatch: ubo batch got too big");
      return this.byteIndex = r, e;
    }
    addGroup(t) {
      const e = this.addEmptyGroup(t.length);
      for (let r = 0; r < t.length; r++) this.data[e / 4 + r] = t[r];
      return e;
    }
    destroy() {
      this._buffer.destroy(), this._buffer = null, this.data = null;
    }
  }
  class Cf {
    constructor(t) {
      this._colorMaskCache = 15, this._renderer = t;
    }
    setMask(t) {
      this._colorMaskCache !== t && (this._colorMaskCache = t, this._renderer.pipeline.setColorMask(t));
    }
    destroy() {
      this._renderer = null, this._colorMaskCache = null;
    }
  }
  Cf.extension = {
    type: [
      P.WebGPUSystem
    ],
    name: "colorMask"
  };
  class Ia {
    constructor(t) {
      this._renderer = t;
    }
    async init(t) {
      return this._initPromise ? this._initPromise : (this._initPromise = this._createDeviceAndAdaptor(t).then((e) => {
        this.gpu = e, this._renderer.runners.contextChange.emit(this.gpu);
      }), this._initPromise);
    }
    contextChange(t) {
      this._renderer.gpu = t;
    }
    async _createDeviceAndAdaptor(t) {
      const e = await navigator.gpu.requestAdapter({
        powerPreference: t.powerPreference,
        forceFallbackAdapter: t.forceFallbackAdapter
      }), r = [
        "texture-compression-bc",
        "texture-compression-astc",
        "texture-compression-etc2"
      ].filter((n) => e.features.has(n)), s = await e.requestDevice({
        requiredFeatures: r
      });
      return {
        adapter: e,
        device: s
      };
    }
    destroy() {
      this.gpu = null, this._renderer = null;
    }
  }
  Ia.extension = {
    type: [
      P.WebGPUSystem
    ],
    name: "device"
  };
  Ia.defaultOptions = {
    powerPreference: void 0,
    forceFallbackAdapter: false
  };
  class Af {
    constructor(t) {
      this._boundBindGroup = /* @__PURE__ */ Object.create(null), this._boundVertexBuffer = /* @__PURE__ */ Object.create(null), this._renderer = t;
    }
    renderStart() {
      this.commandFinished = new Promise((t) => {
        this._resolveCommandFinished = t;
      }), this.commandEncoder = this._renderer.gpu.device.createCommandEncoder();
    }
    beginRenderPass(t) {
      this.endRenderPass(), this._clearCache(), this.renderPassEncoder = this.commandEncoder.beginRenderPass(t.descriptor);
    }
    endRenderPass() {
      this.renderPassEncoder && this.renderPassEncoder.end(), this.renderPassEncoder = null;
    }
    setViewport(t) {
      this.renderPassEncoder.setViewport(t.x, t.y, t.width, t.height, 0, 1);
    }
    setPipelineFromGeometryProgramAndState(t, e, r, s) {
      const n = this._renderer.pipeline.getPipeline(t, e, r, s);
      this.setPipeline(n);
    }
    setPipeline(t) {
      this._boundPipeline !== t && (this._boundPipeline = t, this.renderPassEncoder.setPipeline(t));
    }
    _setVertexBuffer(t, e) {
      this._boundVertexBuffer[t] !== e && (this._boundVertexBuffer[t] = e, this.renderPassEncoder.setVertexBuffer(t, this._renderer.buffer.updateBuffer(e)));
    }
    _setIndexBuffer(t) {
      if (this._boundIndexBuffer === t) return;
      this._boundIndexBuffer = t;
      const e = t.data.BYTES_PER_ELEMENT === 2 ? "uint16" : "uint32";
      this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(t), e);
    }
    resetBindGroup(t) {
      this._boundBindGroup[t] = null;
    }
    setBindGroup(t, e, r) {
      if (this._boundBindGroup[t] === e) return;
      this._boundBindGroup[t] = e, e._touch(this._renderer.textureGC.count);
      const s = this._renderer.bindGroup.getBindGroup(e, r, t);
      this.renderPassEncoder.setBindGroup(t, s);
    }
    setGeometry(t) {
      for (const e in t.attributes) {
        const r = t.attributes[e];
        this._setVertexBuffer(r.location, r.buffer);
      }
      t.indexBuffer && this._setIndexBuffer(t.indexBuffer);
    }
    _setShaderBindGroups(t, e) {
      for (const r in t.groups) {
        const s = t.groups[r];
        e || this._syncBindGroup(s), this.setBindGroup(r, s, t.gpuProgram);
      }
    }
    _syncBindGroup(t) {
      for (const e in t.resources) {
        const r = t.resources[e];
        r.isUniformGroup && this._renderer.ubo.updateUniformGroup(r);
      }
    }
    draw(t) {
      const { geometry: e, shader: r, state: s, topology: n, size: o, start: a, instanceCount: c, skipSync: l } = t;
      this.setPipelineFromGeometryProgramAndState(e, r.gpuProgram, s, n), this.setGeometry(e), this._setShaderBindGroups(r, l), e.indexBuffer ? this.renderPassEncoder.drawIndexed(o || e.indexBuffer.data.length, c || e.instanceCount, a || 0) : this.renderPassEncoder.draw(o || e.getSize(), c || e.instanceCount, a || 0);
    }
    finishRenderPass() {
      this.renderPassEncoder && (this.renderPassEncoder.end(), this.renderPassEncoder = null);
    }
    postrender() {
      this.finishRenderPass(), this._gpu.device.queue.submit([
        this.commandEncoder.finish()
      ]), this._resolveCommandFinished(), this.commandEncoder = null;
    }
    restoreRenderPass() {
      const t = this._renderer.renderTarget.adaptor.getDescriptor(this._renderer.renderTarget.renderTarget, false, [
        0,
        0,
        0,
        1
      ]);
      this.renderPassEncoder = this.commandEncoder.beginRenderPass(t);
      const e = this._boundPipeline, r = {
        ...this._boundVertexBuffer
      }, s = this._boundIndexBuffer, n = {
        ...this._boundBindGroup
      };
      this._clearCache();
      const o = this._renderer.renderTarget.viewport;
      this.renderPassEncoder.setViewport(o.x, o.y, o.width, o.height, 0, 1), this.setPipeline(e);
      for (const a in r) this._setVertexBuffer(a, r[a]);
      for (const a in n) this.setBindGroup(a, n[a], null);
      this._setIndexBuffer(s);
    }
    _clearCache() {
      for (let t = 0; t < 16; t++) this._boundBindGroup[t] = null, this._boundVertexBuffer[t] = null;
      this._boundIndexBuffer = null, this._boundPipeline = null;
    }
    destroy() {
      this._renderer = null, this._gpu = null, this._boundBindGroup = null, this._boundVertexBuffer = null, this._boundIndexBuffer = null, this._boundPipeline = null;
    }
    contextChange(t) {
      this._gpu = t;
    }
  }
  Af.extension = {
    type: [
      P.WebGPUSystem
    ],
    name: "encoder",
    priority: 1
  };
  class Rf {
    constructor(t) {
      this._renderTargetStencilState = /* @__PURE__ */ Object.create(null), this._renderer = t, t.renderTarget.onRenderTargetChange.add(this);
    }
    onRenderTargetChange(t) {
      let e = this._renderTargetStencilState[t.uid];
      e || (e = this._renderTargetStencilState[t.uid] = {
        stencilMode: Kt.DISABLED,
        stencilReference: 0
      }), this._activeRenderTarget = t, this.setStencilMode(e.stencilMode, e.stencilReference);
    }
    setStencilMode(t, e) {
      const r = this._renderTargetStencilState[this._activeRenderTarget.uid];
      r.stencilMode = t, r.stencilReference = e;
      const s = this._renderer;
      s.pipeline.setStencilMode(t), s.encoder.renderPassEncoder.setStencilReference(e);
    }
    destroy() {
      this._renderer.renderTarget.onRenderTargetChange.remove(this), this._renderer = null, this._activeRenderTarget = null, this._renderTargetStencilState = null;
    }
  }
  Rf.extension = {
    type: [
      P.WebGPUSystem
    ],
    name: "stencil"
  };
  const Ts = {
    i32: {
      align: 4,
      size: 4
    },
    u32: {
      align: 4,
      size: 4
    },
    f32: {
      align: 4,
      size: 4
    },
    f16: {
      align: 2,
      size: 2
    },
    "vec2<i32>": {
      align: 8,
      size: 8
    },
    "vec2<u32>": {
      align: 8,
      size: 8
    },
    "vec2<f32>": {
      align: 8,
      size: 8
    },
    "vec2<f16>": {
      align: 4,
      size: 4
    },
    "vec3<i32>": {
      align: 16,
      size: 12
    },
    "vec3<u32>": {
      align: 16,
      size: 12
    },
    "vec3<f32>": {
      align: 16,
      size: 12
    },
    "vec3<f16>": {
      align: 8,
      size: 6
    },
    "vec4<i32>": {
      align: 16,
      size: 16
    },
    "vec4<u32>": {
      align: 16,
      size: 16
    },
    "vec4<f32>": {
      align: 16,
      size: 16
    },
    "vec4<f16>": {
      align: 8,
      size: 8
    },
    "mat2x2<f32>": {
      align: 8,
      size: 16
    },
    "mat2x2<f16>": {
      align: 4,
      size: 8
    },
    "mat3x2<f32>": {
      align: 8,
      size: 24
    },
    "mat3x2<f16>": {
      align: 4,
      size: 12
    },
    "mat4x2<f32>": {
      align: 8,
      size: 32
    },
    "mat4x2<f16>": {
      align: 4,
      size: 16
    },
    "mat2x3<f32>": {
      align: 16,
      size: 32
    },
    "mat2x3<f16>": {
      align: 8,
      size: 16
    },
    "mat3x3<f32>": {
      align: 16,
      size: 48
    },
    "mat3x3<f16>": {
      align: 8,
      size: 24
    },
    "mat4x3<f32>": {
      align: 16,
      size: 64
    },
    "mat4x3<f16>": {
      align: 8,
      size: 32
    },
    "mat2x4<f32>": {
      align: 16,
      size: 32
    },
    "mat2x4<f16>": {
      align: 8,
      size: 16
    },
    "mat3x4<f32>": {
      align: 16,
      size: 48
    },
    "mat3x4<f16>": {
      align: 8,
      size: 24
    },
    "mat4x4<f32>": {
      align: 16,
      size: 64
    },
    "mat4x4<f16>": {
      align: 8,
      size: 32
    }
  };
  function R0(i) {
    const t = i.map((r) => ({
      data: r,
      offset: 0,
      size: 0
    }));
    let e = 0;
    for (let r = 0; r < t.length; r++) {
      const s = t[r];
      let n = Ts[s.data.type].size;
      const o = Ts[s.data.type].align;
      if (!Ts[s.data.type]) throw new Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${s.data.type}`);
      s.data.size > 1 && (n = Math.max(n, o) * s.data.size), e = Math.ceil(e / o) * o, s.size = n, s.offset = e, e += n;
    }
    return e = Math.ceil(e / 16) * 16, {
      uboElements: t,
      size: e
    };
  }
  function P0(i, t) {
    const { size: e, align: r } = Ts[i.data.type], s = (r - e) / 4;
    return `
         v = uv.${i.data.name};
         ${t !== 0 ? `offset += ${t};` : ""}

         arrayOffset = offset;

         t = 0;

         for(var i=0; i < ${i.data.size * (e / 4)}; i++)
         {
             for(var j = 0; j < ${e / 4}; j++)
             {
                 data[arrayOffset++] = v[t++];
             }
             ${s !== 0 ? `arrayOffset += ${s};` : ""}
         }
     `;
  }
  function B0(i) {
    return Od(i, "uboWgsl", P0, Ty);
  }
  class Pf extends kd {
    constructor() {
      super({
        createUboElements: R0,
        generateUboSync: B0
      });
    }
  }
  Pf.extension = {
    type: [
      P.WebGPUSystem
    ],
    name: "ubo"
  };
  const or = 128;
  class Bf {
    constructor(t) {
      this._bindGroupHash = /* @__PURE__ */ Object.create(null), this._buffers = [], this._bindGroups = [], this._bufferResources = [], this._renderer = t, this._batchBuffer = new A0({
        minUniformOffsetAlignment: or
      });
      const e = 256 / or;
      for (let r = 0; r < e; r++) {
        let s = yt.UNIFORM | yt.COPY_DST;
        r === 0 && (s |= yt.COPY_SRC), this._buffers.push(new Pe({
          data: this._batchBuffer.data,
          usage: s
        }));
      }
    }
    renderEnd() {
      this._uploadBindGroups(), this._resetBindGroups();
    }
    _resetBindGroups() {
      for (const t in this._bindGroupHash) this._bindGroupHash[t] = null;
      this._batchBuffer.clear();
    }
    getUniformBindGroup(t, e) {
      if (!e && this._bindGroupHash[t.uid]) return this._bindGroupHash[t.uid];
      this._renderer.ubo.ensureUniformGroup(t);
      const r = t.buffer.data, s = this._batchBuffer.addEmptyGroup(r.length);
      return this._renderer.ubo.syncUniformGroup(t, this._batchBuffer.data, s / 4), this._bindGroupHash[t.uid] = this._getBindGroup(s / or), this._bindGroupHash[t.uid];
    }
    getUboResource(t) {
      this._renderer.ubo.updateUniformGroup(t);
      const e = t.buffer.data, r = this._batchBuffer.addGroup(e);
      return this._getBufferResource(r / or);
    }
    getArrayBindGroup(t) {
      const e = this._batchBuffer.addGroup(t);
      return this._getBindGroup(e / or);
    }
    getArrayBufferResource(t) {
      const r = this._batchBuffer.addGroup(t) / or;
      return this._getBufferResource(r);
    }
    _getBufferResource(t) {
      if (!this._bufferResources[t]) {
        const e = this._buffers[t % 2];
        this._bufferResources[t] = new Ta({
          buffer: e,
          offset: (t / 2 | 0) * 256,
          size: or
        });
      }
      return this._bufferResources[t];
    }
    _getBindGroup(t) {
      if (!this._bindGroups[t]) {
        const e = new Ze({
          0: this._getBufferResource(t)
        });
        this._bindGroups[t] = e;
      }
      return this._bindGroups[t];
    }
    _uploadBindGroups() {
      const t = this._renderer.buffer, e = this._buffers[0];
      e.update(this._batchBuffer.byteIndex), t.updateBuffer(e);
      const r = this._renderer.gpu.device.createCommandEncoder();
      for (let s = 1; s < this._buffers.length; s++) {
        const n = this._buffers[s];
        r.copyBufferToBuffer(t.getGPUBuffer(e), or, t.getGPUBuffer(n), 0, this._batchBuffer.byteIndex);
      }
      this._renderer.gpu.device.queue.submit([
        r.finish()
      ]);
    }
    destroy() {
      for (let t = 0; t < this._bindGroups.length; t++) this._bindGroups[t].destroy();
      this._bindGroups = null, this._bindGroupHash = null;
      for (let t = 0; t < this._buffers.length; t++) this._buffers[t].destroy();
      this._buffers = null;
      for (let t = 0; t < this._bufferResources.length; t++) this._bufferResources[t].destroy();
      this._bufferResources = null, this._batchBuffer.destroy(), this._bindGroupHash = null, this._renderer = null;
    }
  }
  Bf.extension = {
    type: [
      P.WebGPUPipes
    ],
    name: "uniformBatch"
  };
  const M0 = {
    "point-list": 0,
    "line-list": 1,
    "line-strip": 2,
    "triangle-list": 3,
    "triangle-strip": 4
  };
  function D0(i, t, e, r, s) {
    return i << 24 | t << 16 | e << 10 | r << 5 | s;
  }
  function I0(i, t, e, r) {
    return e << 6 | i << 3 | r << 1 | t;
  }
  class Mf {
    constructor(t) {
      this._moduleCache = /* @__PURE__ */ Object.create(null), this._bufferLayoutsCache = /* @__PURE__ */ Object.create(null), this._pipeCache = /* @__PURE__ */ Object.create(null), this._pipeStateCaches = /* @__PURE__ */ Object.create(null), this._colorMask = 15, this._multisampleCount = 1, this._renderer = t;
    }
    contextChange(t) {
      this._gpu = t, this.setStencilMode(Kt.DISABLED), this._updatePipeHash();
    }
    setMultisampleCount(t) {
      this._multisampleCount !== t && (this._multisampleCount = t, this._updatePipeHash());
    }
    setRenderTarget(t) {
      this._multisampleCount = t.msaaSamples, this._depthStencilAttachment = t.descriptor.depthStencilAttachment ? 1 : 0, this._updatePipeHash();
    }
    setColorMask(t) {
      this._colorMask !== t && (this._colorMask = t, this._updatePipeHash());
    }
    setStencilMode(t) {
      this._stencilMode !== t && (this._stencilMode = t, this._stencilState = kr[t], this._updatePipeHash());
    }
    setPipeline(t, e, r, s) {
      const n = this.getPipeline(t, e, r);
      s.setPipeline(n);
    }
    getPipeline(t, e, r, s) {
      t._layoutKey || (Pd(t, e.attributeData), this._generateBufferKey(t)), s = s || t.topology;
      const n = D0(t._layoutKey, e._layoutKey, r.data, r._blendModeId, M0[s]);
      return this._pipeCache[n] ? this._pipeCache[n] : (this._pipeCache[n] = this._createPipeline(t, e, r, s), this._pipeCache[n]);
    }
    _createPipeline(t, e, r, s) {
      const n = this._gpu.device, o = this._createVertexBufferLayouts(t), a = this._renderer.state.getColorTargets(r);
      a[0].writeMask = this._stencilMode === Kt.RENDERING_MASK_ADD ? 0 : this._colorMask;
      const c = this._renderer.shader.getProgramData(e).pipeline, l = {
        vertex: {
          module: this._getModule(e.vertex.source),
          entryPoint: e.vertex.entryPoint,
          buffers: o
        },
        fragment: {
          module: this._getModule(e.fragment.source),
          entryPoint: e.fragment.entryPoint,
          targets: a
        },
        primitive: {
          topology: s,
          cullMode: r.cullMode
        },
        layout: c,
        multisample: {
          count: this._multisampleCount
        },
        label: "PIXI Pipeline"
      };
      return this._depthStencilAttachment && (l.depthStencil = {
        ...this._stencilState,
        format: "depth24plus-stencil8",
        depthWriteEnabled: r.depthTest,
        depthCompare: r.depthTest ? "less" : "always"
      }), n.createRenderPipeline(l);
    }
    _getModule(t) {
      return this._moduleCache[t] || this._createModule(t);
    }
    _createModule(t) {
      const e = this._gpu.device;
      return this._moduleCache[t] = e.createShaderModule({
        code: t
      }), this._moduleCache[t];
    }
    _generateBufferKey(t) {
      const e = [];
      let r = 0;
      const s = Object.keys(t.attributes).sort();
      for (let o = 0; o < s.length; o++) {
        const a = t.attributes[s[o]];
        e[r++] = a.location, e[r++] = a.offset, e[r++] = a.format, e[r++] = a.stride;
      }
      const n = e.join("");
      return t._layoutKey = $s(n, "geometry"), t._layoutKey;
    }
    _createVertexBufferLayouts(t) {
      if (this._bufferLayoutsCache[t._layoutKey]) return this._bufferLayoutsCache[t._layoutKey];
      const e = [];
      return t.buffers.forEach((r) => {
        const s = {
          arrayStride: 0,
          stepMode: "vertex",
          attributes: []
        }, n = s.attributes;
        for (const o in t.attributes) {
          const a = t.attributes[o];
          (a.divisor ?? 1) !== 1 && ut(`Attribute ${o} has an invalid divisor value of '${a.divisor}'. WebGPU only supports a divisor value of 1`), a.buffer === r && (s.arrayStride = a.stride, s.stepMode = a.instance ? "instance" : "vertex", n.push({
            shaderLocation: a.location,
            offset: a.offset,
            format: a.format
          }));
        }
        n.length && e.push(s);
      }), this._bufferLayoutsCache[t._layoutKey] = e, e;
    }
    _updatePipeHash() {
      const t = I0(this._stencilMode, this._multisampleCount, this._colorMask, this._depthStencilAttachment);
      this._pipeStateCaches[t] || (this._pipeStateCaches[t] = /* @__PURE__ */ Object.create(null)), this._pipeCache = this._pipeStateCaches[t];
    }
    destroy() {
      this._renderer = null, this._bufferLayoutsCache = null;
    }
  }
  Mf.extension = {
    type: [
      P.WebGPUSystem
    ],
    name: "pipeline"
  };
  class F0 {
    constructor() {
      this.contexts = [], this.msaaTextures = [], this.msaaSamples = 1;
    }
  }
  class U0 {
    init(t, e) {
      this._renderer = t, this._renderTargetSystem = e;
    }
    copyToTexture(t, e, r, s, n) {
      const o = this._renderer, a = this._getGpuColorTexture(t), c = o.texture.getGpuSource(e.source);
      return o.encoder.commandEncoder.copyTextureToTexture({
        texture: a,
        origin: r
      }, {
        texture: c,
        origin: n
      }, s), e;
    }
    startRenderPass(t, e = true, r, s) {
      const o = this._renderTargetSystem.getGpuRenderTarget(t), a = this.getDescriptor(t, e, r);
      o.descriptor = a, this._renderer.pipeline.setRenderTarget(o), this._renderer.encoder.beginRenderPass(o), this._renderer.encoder.setViewport(s);
    }
    finishRenderPass() {
      this._renderer.encoder.endRenderPass();
    }
    _getGpuColorTexture(t) {
      const e = this._renderTargetSystem.getGpuRenderTarget(t);
      return e.contexts[0] ? e.contexts[0].getCurrentTexture() : this._renderer.texture.getGpuSource(t.colorTextures[0].source);
    }
    getDescriptor(t, e, r) {
      typeof e == "boolean" && (e = e ? pe.ALL : pe.NONE);
      const s = this._renderTargetSystem, n = s.getGpuRenderTarget(t), o = t.colorTextures.map((l, u) => {
        const h = n.contexts[u];
        let d, p;
        h ? d = h.getCurrentTexture().createView() : d = this._renderer.texture.getGpuSource(l).createView({
          mipLevelCount: 1
        }), n.msaaTextures[u] && (p = d, d = this._renderer.texture.getTextureView(n.msaaTextures[u]));
        const g = e & pe.COLOR ? "clear" : "load";
        return r ?? (r = s.defaultClearColor), {
          view: d,
          resolveTarget: p,
          clearValue: r,
          storeOp: "store",
          loadOp: g
        };
      });
      let a;
      if ((t.stencil || t.depth) && !t.depthStencilTexture && (t.ensureDepthStencilTexture(), t.depthStencilTexture.source.sampleCount = n.msaa ? 4 : 1), t.depthStencilTexture) {
        const l = e & pe.STENCIL ? "clear" : "load", u = e & pe.DEPTH ? "clear" : "load";
        a = {
          view: this._renderer.texture.getGpuSource(t.depthStencilTexture.source).createView(),
          stencilStoreOp: "store",
          stencilLoadOp: l,
          depthClearValue: 1,
          depthLoadOp: u,
          depthStoreOp: "store"
        };
      }
      return {
        colorAttachments: o,
        depthStencilAttachment: a
      };
    }
    clear(t, e = true, r, s) {
      if (!e) return;
      const { gpu: n, encoder: o } = this._renderer, a = n.device;
      if (o.commandEncoder === null) {
        const l = a.createCommandEncoder(), u = this.getDescriptor(t, e, r), h = l.beginRenderPass(u);
        h.setViewport(s.x, s.y, s.width, s.height, 0, 1), h.end();
        const d = l.finish();
        a.queue.submit([
          d
        ]);
      } else this.startRenderPass(t, e, r, s);
    }
    initGpuRenderTarget(t) {
      t.isRoot = true;
      const e = new F0();
      return t.colorTextures.forEach((r, s) => {
        if (Jr.test(r.resource)) {
          const n = r.resource.getContext("webgpu"), o = r.transparent ? "premultiplied" : "opaque";
          try {
            n.configure({
              device: this._renderer.gpu.device,
              usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
              format: "bgra8unorm",
              alphaMode: o
            });
          } catch (a) {
            console.error(a);
          }
          e.contexts[s] = n;
        }
        if (e.msaa = r.source.antialias, r.source.antialias) {
          const n = new Ht({
            width: 0,
            height: 0,
            sampleCount: 4
          });
          e.msaaTextures[s] = n;
        }
      }), e.msaa && (e.msaaSamples = 4, t.depthStencilTexture && (t.depthStencilTexture.source.sampleCount = 4)), e;
    }
    destroyGpuRenderTarget(t) {
      t.contexts.forEach((e) => {
        e.unconfigure();
      }), t.msaaTextures.forEach((e) => {
        e.destroy();
      }), t.msaaTextures.length = 0, t.contexts.length = 0;
    }
    ensureDepthStencilTexture(t) {
      const e = this._renderTargetSystem.getGpuRenderTarget(t);
      t.depthStencilTexture && e.msaa && (t.depthStencilTexture.source.sampleCount = 4);
    }
    resizeGpuRenderTarget(t) {
      const e = this._renderTargetSystem.getGpuRenderTarget(t);
      e.width = t.width, e.height = t.height, e.msaa && t.colorTextures.forEach((r, s) => {
        var _a2;
        (_a2 = e.msaaTextures[s]) == null ? void 0 : _a2.resize(r.source.width, r.source.height, r.source._resolution);
      });
    }
  }
  class Df extends Wd {
    constructor(t) {
      super(t), this.adaptor = new U0(), this.adaptor.init(t, this);
    }
  }
  Df.extension = {
    type: [
      P.WebGPUSystem
    ],
    name: "renderTarget"
  };
  class If {
    constructor() {
      this._gpuProgramData = /* @__PURE__ */ Object.create(null);
    }
    contextChange(t) {
      this._gpu = t;
    }
    getProgramData(t) {
      return this._gpuProgramData[t._layoutKey] || this._createGPUProgramData(t);
    }
    _createGPUProgramData(t) {
      const e = this._gpu.device, r = t.gpuLayout.map((n) => e.createBindGroupLayout({
        entries: n
      })), s = {
        bindGroupLayouts: r
      };
      return this._gpuProgramData[t._layoutKey] = {
        bindGroups: r,
        pipeline: e.createPipelineLayout(s)
      }, this._gpuProgramData[t._layoutKey];
    }
    destroy() {
      this._gpu = null, this._gpuProgramData = null;
    }
  }
  If.extension = {
    type: [
      P.WebGPUSystem
    ],
    name: "shader"
  };
  const xe = {};
  xe.normal = {
    alpha: {
      srcFactor: "one",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    },
    color: {
      srcFactor: "one",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    }
  };
  xe.add = {
    alpha: {
      srcFactor: "src-alpha",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    },
    color: {
      srcFactor: "one",
      dstFactor: "one",
      operation: "add"
    }
  };
  xe.multiply = {
    alpha: {
      srcFactor: "one",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    },
    color: {
      srcFactor: "dst",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    }
  };
  xe.screen = {
    alpha: {
      srcFactor: "one",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    },
    color: {
      srcFactor: "one",
      dstFactor: "one-minus-src",
      operation: "add"
    }
  };
  xe.overlay = {
    alpha: {
      srcFactor: "one",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    },
    color: {
      srcFactor: "one",
      dstFactor: "one-minus-src",
      operation: "add"
    }
  };
  xe.none = {
    alpha: {
      srcFactor: "one",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    },
    color: {
      srcFactor: "zero",
      dstFactor: "zero",
      operation: "add"
    }
  };
  xe["normal-npm"] = {
    alpha: {
      srcFactor: "one",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    },
    color: {
      srcFactor: "src-alpha",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    }
  };
  xe["add-npm"] = {
    alpha: {
      srcFactor: "one",
      dstFactor: "one",
      operation: "add"
    },
    color: {
      srcFactor: "src-alpha",
      dstFactor: "one",
      operation: "add"
    }
  };
  xe["screen-npm"] = {
    alpha: {
      srcFactor: "one",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    },
    color: {
      srcFactor: "src-alpha",
      dstFactor: "one-minus-src",
      operation: "add"
    }
  };
  xe.erase = {
    alpha: {
      srcFactor: "zero",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    },
    color: {
      srcFactor: "zero",
      dstFactor: "one-minus-src",
      operation: "add"
    }
  };
  class Ff {
    constructor() {
      this.defaultState = new Le(), this.defaultState.blend = true;
    }
    contextChange(t) {
      this.gpu = t;
    }
    getColorTargets(t) {
      return [
        {
          format: "bgra8unorm",
          writeMask: 0,
          blend: xe[t.blendMode] || xe.normal
        }
      ];
    }
    destroy() {
      this.gpu = null;
    }
  }
  Ff.extension = {
    type: [
      P.WebGPUSystem
    ],
    name: "state"
  };
  const k0 = {
    type: "image",
    upload(i, t, e) {
      const r = i.resource, s = (i.pixelWidth | 0) * (i.pixelHeight | 0), n = r.byteLength / s;
      e.device.queue.writeTexture({
        texture: t
      }, r, {
        offset: 0,
        rowsPerImage: i.pixelHeight,
        bytesPerRow: i.pixelHeight * n
      }, {
        width: i.pixelWidth,
        height: i.pixelHeight,
        depthOrArrayLayers: 1
      });
    }
  }, Uf = {
    "bc1-rgba-unorm": {
      blockBytes: 8,
      blockWidth: 4,
      blockHeight: 4
    },
    "bc2-rgba-unorm": {
      blockBytes: 16,
      blockWidth: 4,
      blockHeight: 4
    },
    "bc3-rgba-unorm": {
      blockBytes: 16,
      blockWidth: 4,
      blockHeight: 4
    },
    "bc7-rgba-unorm": {
      blockBytes: 16,
      blockWidth: 4,
      blockHeight: 4
    },
    "etc1-rgb-unorm": {
      blockBytes: 8,
      blockWidth: 4,
      blockHeight: 4
    },
    "etc2-rgba8unorm": {
      blockBytes: 16,
      blockWidth: 4,
      blockHeight: 4
    },
    "astc-4x4-unorm": {
      blockBytes: 16,
      blockWidth: 4,
      blockHeight: 4
    }
  }, G0 = {
    blockBytes: 4,
    blockWidth: 1,
    blockHeight: 1
  }, O0 = {
    type: "compressed",
    upload(i, t, e) {
      let r = i.pixelWidth, s = i.pixelHeight;
      const n = Uf[i.format] || G0;
      for (let o = 0; o < i.resource.length; o++) {
        const a = i.resource[o], c = Math.ceil(r / n.blockWidth) * n.blockBytes;
        e.device.queue.writeTexture({
          texture: t,
          mipLevel: o
        }, a, {
          offset: 0,
          bytesPerRow: c
        }, {
          width: Math.ceil(r / n.blockWidth) * n.blockWidth,
          height: Math.ceil(s / n.blockHeight) * n.blockHeight,
          depthOrArrayLayers: 1
        }), r = Math.max(r >> 1, 1), s = Math.max(s >> 1, 1);
      }
    }
  }, kf = {
    type: "image",
    upload(i, t, e) {
      const r = i.resource;
      if (!r) return;
      const s = Math.min(t.width, i.resourceWidth || i.pixelWidth), n = Math.min(t.height, i.resourceHeight || i.pixelHeight), o = i.alphaMode === "premultiply-alpha-on-upload";
      e.device.queue.copyExternalImageToTexture({
        source: r
      }, {
        texture: t,
        premultipliedAlpha: o
      }, {
        width: s,
        height: n
      });
    }
  }, N0 = {
    type: "video",
    upload(i, t, e) {
      kf.upload(i, t, e);
    }
  };
  class L0 {
    constructor(t) {
      this.device = t, this.sampler = t.createSampler({
        minFilter: "linear"
      }), this.pipelines = {};
    }
    _getMipmapPipeline(t) {
      let e = this.pipelines[t];
      return e || (this.mipmapShaderModule || (this.mipmapShaderModule = this.device.createShaderModule({
        code: `
                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(
                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));

                        struct VertexOutput {
                        @builtin(position) position : vec4<f32>,
                        @location(0) texCoord : vec2<f32>,
                        };

                        @vertex
                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
                        var output : VertexOutput;
                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
                        return output;
                        }

                        @group(0) @binding(0) var imgSampler : sampler;
                        @group(0) @binding(1) var img : texture_2d<f32>;

                        @fragment
                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
                        return textureSample(img, imgSampler, texCoord);
                        }
                    `
      })), e = this.device.createRenderPipeline({
        layout: "auto",
        vertex: {
          module: this.mipmapShaderModule,
          entryPoint: "vertexMain"
        },
        fragment: {
          module: this.mipmapShaderModule,
          entryPoint: "fragmentMain",
          targets: [
            {
              format: t
            }
          ]
        }
      }), this.pipelines[t] = e), e;
    }
    generateMipmap(t) {
      const e = this._getMipmapPipeline(t.format);
      if (t.dimension === "3d" || t.dimension === "1d") throw new Error("Generating mipmaps for non-2d textures is currently unsupported!");
      let r = t;
      const s = t.depthOrArrayLayers || 1, n = t.usage & GPUTextureUsage.RENDER_ATTACHMENT;
      if (!n) {
        const c = {
          size: {
            width: Math.ceil(t.width / 2),
            height: Math.ceil(t.height / 2),
            depthOrArrayLayers: s
          },
          format: t.format,
          usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,
          mipLevelCount: t.mipLevelCount - 1
        };
        r = this.device.createTexture(c);
      }
      const o = this.device.createCommandEncoder({}), a = e.getBindGroupLayout(0);
      for (let c = 0; c < s; ++c) {
        let l = t.createView({
          baseMipLevel: 0,
          mipLevelCount: 1,
          dimension: "2d",
          baseArrayLayer: c,
          arrayLayerCount: 1
        }), u = n ? 1 : 0;
        for (let h = 1; h < t.mipLevelCount; ++h) {
          const d = r.createView({
            baseMipLevel: u++,
            mipLevelCount: 1,
            dimension: "2d",
            baseArrayLayer: c,
            arrayLayerCount: 1
          }), p = o.beginRenderPass({
            colorAttachments: [
              {
                view: d,
                storeOp: "store",
                loadOp: "clear",
                clearValue: {
                  r: 0,
                  g: 0,
                  b: 0,
                  a: 0
                }
              }
            ]
          }), g = this.device.createBindGroup({
            layout: a,
            entries: [
              {
                binding: 0,
                resource: this.sampler
              },
              {
                binding: 1,
                resource: l
              }
            ]
          });
          p.setPipeline(e), p.setBindGroup(0, g), p.draw(3, 1, 0, 0), p.end(), l = d;
        }
      }
      if (!n) {
        const c = {
          width: Math.ceil(t.width / 2),
          height: Math.ceil(t.height / 2),
          depthOrArrayLayers: s
        };
        for (let l = 1; l < t.mipLevelCount; ++l) o.copyTextureToTexture({
          texture: r,
          mipLevel: l - 1
        }, {
          texture: t,
          mipLevel: l
        }, c), c.width = Math.ceil(c.width / 2), c.height = Math.ceil(c.height / 2);
      }
      return this.device.queue.submit([
        o.finish()
      ]), n || r.destroy(), t;
    }
  }
  class Gf {
    constructor(t) {
      this.managedTextures = [], this._gpuSources = /* @__PURE__ */ Object.create(null), this._gpuSamplers = /* @__PURE__ */ Object.create(null), this._bindGroupHash = /* @__PURE__ */ Object.create(null), this._textureViewHash = /* @__PURE__ */ Object.create(null), this._uploads = {
        image: kf,
        buffer: k0,
        video: N0,
        compressed: O0
      }, this._renderer = t;
    }
    contextChange(t) {
      this._gpu = t;
    }
    initSource(t) {
      if (t.autoGenerateMipmaps) {
        const c = Math.max(t.pixelWidth, t.pixelHeight);
        t.mipLevelCount = Math.floor(Math.log2(c)) + 1;
      }
      let e = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;
      t.uploadMethodId !== "compressed" && (e |= GPUTextureUsage.RENDER_ATTACHMENT, e |= GPUTextureUsage.COPY_SRC);
      const r = Uf[t.format] || {
        blockBytes: 4,
        blockWidth: 1,
        blockHeight: 1
      }, s = Math.ceil(t.pixelWidth / r.blockWidth) * r.blockWidth, n = Math.ceil(t.pixelHeight / r.blockHeight) * r.blockHeight, o = {
        label: t.label,
        size: {
          width: s,
          height: n
        },
        format: t.format,
        sampleCount: t.sampleCount,
        mipLevelCount: t.mipLevelCount,
        dimension: t.dimension,
        usage: e
      }, a = this._gpu.device.createTexture(o);
      return this._gpuSources[t.uid] = a, this.managedTextures.includes(t) || (t.on("update", this.onSourceUpdate, this), t.on("resize", this.onSourceResize, this), t.on("destroy", this.onSourceDestroy, this), t.on("unload", this.onSourceUnload, this), t.on("updateMipmaps", this.onUpdateMipmaps, this), this.managedTextures.push(t)), this.onSourceUpdate(t), a;
    }
    onSourceUpdate(t) {
      const e = this.getGpuSource(t);
      e && (this._uploads[t.uploadMethodId] && this._uploads[t.uploadMethodId].upload(t, e, this._gpu), t.autoGenerateMipmaps && t.mipLevelCount > 1 && this.onUpdateMipmaps(t));
    }
    onSourceUnload(t) {
      const e = this._gpuSources[t.uid];
      e && (this._gpuSources[t.uid] = null, e.destroy());
    }
    onUpdateMipmaps(t) {
      this._mipmapGenerator || (this._mipmapGenerator = new L0(this._gpu.device));
      const e = this.getGpuSource(t);
      this._mipmapGenerator.generateMipmap(e);
    }
    onSourceDestroy(t) {
      t.off("update", this.onSourceUpdate, this), t.off("unload", this.onSourceUnload, this), t.off("destroy", this.onSourceDestroy, this), t.off("resize", this.onSourceResize, this), t.off("updateMipmaps", this.onUpdateMipmaps, this), this.managedTextures.splice(this.managedTextures.indexOf(t), 1), this.onSourceUnload(t);
    }
    onSourceResize(t) {
      const e = this._gpuSources[t.uid];
      e ? (e.width !== t.pixelWidth || e.height !== t.pixelHeight) && (this._textureViewHash[t.uid] = null, this._bindGroupHash[t.uid] = null, this.onSourceUnload(t), this.initSource(t)) : this.initSource(t);
    }
    _initSampler(t) {
      return this._gpuSamplers[t._resourceId] = this._gpu.device.createSampler(t), this._gpuSamplers[t._resourceId];
    }
    getGpuSampler(t) {
      return this._gpuSamplers[t._resourceId] || this._initSampler(t);
    }
    getGpuSource(t) {
      return this._gpuSources[t.uid] || this.initSource(t);
    }
    getTextureBindGroup(t) {
      return this._bindGroupHash[t.uid] ?? this._createTextureBindGroup(t);
    }
    _createTextureBindGroup(t) {
      const e = t.source, r = e.uid;
      return this._bindGroupHash[r] = new Ze({
        0: e,
        1: e.style
      }), this._bindGroupHash[r];
    }
    getTextureView(t) {
      const e = t.source;
      return this._textureViewHash[e.uid] ?? this._createTextureView(e);
    }
    _createTextureView(t) {
      return this._textureViewHash[t.uid] = this.getGpuSource(t).createView(), this._textureViewHash[t.uid];
    }
    generateCanvas(t) {
      const e = this._renderer, r = e.gpu.device.createCommandEncoder(), s = St.get().createCanvas();
      s.width = t.source.pixelWidth, s.height = t.source.pixelHeight;
      const n = s.getContext("webgpu");
      return n.configure({
        device: e.gpu.device,
        usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,
        format: navigator.gpu.getPreferredCanvasFormat(),
        alphaMode: "premultiplied"
      }), r.copyTextureToTexture({
        texture: e.texture.getGpuSource(t.source),
        origin: {
          x: 0,
          y: 0
        }
      }, {
        texture: n.getCurrentTexture()
      }, {
        width: s.width,
        height: s.height
      }), e.gpu.device.queue.submit([
        r.finish()
      ]), s;
    }
    getPixels(t) {
      const e = this.generateCanvas(t), r = Qe.getOptimalCanvasAndContext(e.width, e.height), s = r.context;
      s.drawImage(e, 0, 0);
      const { width: n, height: o } = e, a = s.getImageData(0, 0, n, o), c = new Uint8ClampedArray(a.data.buffer);
      return Qe.returnCanvasAndContext(r), {
        pixels: c,
        width: n,
        height: o
      };
    }
    destroy() {
      var _a2;
      this.managedTextures.slice().forEach((t) => this.onSourceDestroy(t)), this.managedTextures = null;
      for (const t of Object.keys(this._bindGroupHash)) {
        const e = Number(t);
        (_a2 = this._bindGroupHash[e]) == null ? void 0 : _a2.destroy(), this._bindGroupHash[e] = null;
      }
      this._gpu = null, this._mipmapGenerator = null, this._gpuSources = null, this._bindGroupHash = null, this._textureViewHash = null, this._gpuSamplers = null;
    }
  }
  Gf.extension = {
    type: [
      P.WebGPUSystem
    ],
    name: "texture"
  };
  class Of {
    init() {
      const t = new Qt({
        uTransformMatrix: {
          value: new st(),
          type: "mat3x3<f32>"
        },
        uColor: {
          value: new Float32Array([
            1,
            1,
            1,
            1
          ]),
          type: "vec4<f32>"
        },
        uRound: {
          value: 0,
          type: "f32"
        }
      }), e = ki({
        name: "graphics",
        bits: [
          ma,
          wa(Fr()),
          uy,
          Oi
        ]
      });
      this.shader = new Se({
        gpuProgram: e,
        resources: {
          localUniforms: t
        }
      });
    }
    execute(t, e) {
      const r = e.context, s = r.customShader || this.shader, n = t.renderer, o = n.graphicsContext, { geometry: a, instructions: c } = o.getContextRenderData(r), l = n.encoder;
      l.setPipelineFromGeometryProgramAndState(a, s.gpuProgram, t.state), l.setGeometry(a);
      const u = n.globalUniforms.bindGroup;
      l.setBindGroup(0, u, s.gpuProgram);
      const h = n.renderPipes.uniformBatch.getUniformBindGroup(s.resources.localUniforms, true);
      l.setBindGroup(2, h, s.gpuProgram);
      const d = c.instructions;
      for (let p = 0; p < c.instructionSize; p++) {
        const g = d[p];
        if (s.groups[1] = g.bindGroup, !g.gpuBindGroup) {
          const y = g.textures;
          g.bindGroup = aa(y.textures, y.count), g.gpuBindGroup = n.bindGroup.getBindGroup(g.bindGroup, s.gpuProgram, 1);
        }
        l.setBindGroup(1, g.bindGroup, s.gpuProgram), l.renderPassEncoder.drawIndexed(g.size, 1, g.start);
      }
    }
    destroy() {
      this.shader.destroy(true), this.shader = null;
    }
  }
  Of.extension = {
    type: [
      P.WebGPUPipesAdaptor
    ],
    name: "graphics"
  };
  class Nf {
    init() {
      const t = ki({
        name: "mesh",
        bits: [
          Ei,
          ly,
          Oi
        ]
      });
      this._shader = new Se({
        gpuProgram: t,
        resources: {
          uTexture: Z.EMPTY._source,
          uSampler: Z.EMPTY._source.style,
          textureUniforms: {
            uTextureMatrix: {
              type: "mat3x3<f32>",
              value: new st()
            }
          }
        }
      });
    }
    execute(t, e) {
      const r = t.renderer;
      let s = e._shader;
      if (!s) s = this._shader, s.resources.uTexture = e.texture.source, s.resources.uSampler = e.texture.source.style, s.resources.textureUniforms.uniforms.uTextureMatrix = e.texture.textureMatrix.mapCoord;
      else if (!s.gpuProgram) {
        ut("Mesh shader has no gpuProgram", e.shader);
        return;
      }
      const n = s.gpuProgram;
      if (n.autoAssignGlobalUniforms && (s.groups[0] = r.globalUniforms.bindGroup), n.autoAssignLocalUniforms) {
        const o = t.localUniforms;
        s.groups[1] = r.renderPipes.uniformBatch.getUniformBindGroup(o, true);
      }
      r.encoder.draw({
        geometry: e._geometry,
        shader: s,
        state: e.state
      });
    }
    destroy() {
      this._shader.destroy(true), this._shader = null;
    }
  }
  Nf.extension = {
    type: [
      P.WebGPUPipesAdaptor
    ],
    name: "mesh"
  };
  const H0 = [
    ...wf,
    Pf,
    Af,
    Ia,
    Tf,
    Gf,
    Df,
    If,
    Ff,
    Mf,
    Cf,
    Rf,
    Ef
  ], z0 = [
    ...yf,
    Bf
  ], j0 = [
    xd,
    Nf,
    Of
  ], Lf = [], Hf = [], zf = [];
  Mt.handleByNamedList(P.WebGPUSystem, Lf);
  Mt.handleByNamedList(P.WebGPUPipes, Hf);
  Mt.handleByNamedList(P.WebGPUPipesAdaptor, zf);
  Mt.add(...H0, ...z0, ...j0);
  class W0 extends Ys {
    constructor() {
      const t = {
        name: "webgpu",
        type: ge.WEBGPU,
        systems: Lf,
        renderPipes: Hf,
        renderPipeAdaptors: zf
      };
      super(t);
    }
  }
  const V0 = Object.freeze(Object.defineProperty({
    __proto__: null,
    WebGPURenderer: W0
  }, Symbol.toStringTag, {
    value: "Module"
  })), zu = {
    POINTS: "point-list",
    LINES: "line-list",
    LINE_STRIP: "line-strip",
    TRIANGLES: "triangle-list",
    TRIANGLE_STRIP: "triangle-strip"
  }, _R = new Proxy(zu, {
    get(i, t) {
      return lt(dt, `DRAW_MODES.${t} is deprecated, use '${zu[t]}' instead`), i[t];
    }
  }), gR = new Et(0, 0, 1, 1);
  var Wo = ((i) => (i.CLAMP = "clamp-to-edge", i.REPEAT = "repeat", i.MIRRORED_REPEAT = "mirror-repeat", i))(Wo || {});
  const mR = new Proxy(Wo, {
    get(i, t) {
      return lt(dt, `DRAW_MODES.${t} is deprecated, use '${Wo[t]}' instead`), i[t];
    }
  });
  var Vo = ((i) => (i.NEAREST = "nearest", i.LINEAR = "linear", i))(Vo || {});
  const bR = new Proxy(Vo, {
    get(i, t) {
      return lt(dt, `DRAW_MODES.${t} is deprecated, use '${Vo[t]}' instead`), i[t];
    }
  });
  X0 = class {
    constructor(t, e) {
      this.state = Le.for2d(), this._graphicsBatchesHash = /* @__PURE__ */ Object.create(null), this.renderer = t, this._adaptor = e, this._adaptor.init();
    }
    validateRenderable(t) {
      const e = t.context, r = !!this._graphicsBatchesHash[t.uid], s = this.renderer.graphicsContext.updateGpuContext(e);
      return !!(s.isBatchable || r !== s.isBatchable);
    }
    addRenderable(t, e) {
      const r = this.renderer.graphicsContext.updateGpuContext(t.context);
      t._didGraphicsUpdate && (t._didGraphicsUpdate = false, this._rebuild(t)), r.isBatchable ? this._addToBatcher(t) : (this.renderer.renderPipes.batch.break(e), e.add(t));
    }
    updateRenderable(t) {
      const e = this._graphicsBatchesHash[t.uid];
      if (e) for (let r = 0; r < e.length; r++) {
        const s = e[r];
        s.batcher.updateElement(s);
      }
    }
    destroyRenderable(t) {
      this._graphicsBatchesHash[t.uid] && this._removeBatchForRenderable(t.uid);
    }
    execute(t) {
      if (!t.isRenderable) return;
      const e = this.renderer, r = t.context;
      if (!e.graphicsContext.getGpuContext(r).batches.length) return;
      const n = r.customShader || this._adaptor.shader;
      this.state.blendMode = t.groupBlendMode;
      const o = n.resources.localUniforms.uniforms;
      o.uTransformMatrix = t.groupTransform, o.uRound = e._roundPixels | t._roundPixels, on(t.groupColorAlpha, o.uColor, 0), this._adaptor.execute(this, t);
    }
    _rebuild(t) {
      const e = !!this._graphicsBatchesHash[t.uid], r = this.renderer.graphicsContext.updateGpuContext(t.context);
      e && this._removeBatchForRenderable(t.uid), r.isBatchable && this._initBatchesForRenderable(t), t.batched = r.isBatchable;
    }
    _addToBatcher(t) {
      const e = this.renderer.renderPipes.batch, r = this._getBatchesForRenderable(t);
      for (let s = 0; s < r.length; s++) {
        const n = r[s];
        e.addToBatch(n);
      }
    }
    _getBatchesForRenderable(t) {
      return this._graphicsBatchesHash[t.uid] || this._initBatchesForRenderable(t);
    }
    _initBatchesForRenderable(t) {
      const e = t.context, r = this.renderer.graphicsContext.getGpuContext(e), s = this.renderer._roundPixels | t._roundPixels, n = r.batches.map((o) => {
        const a = vt.get(ca);
        return o.copyTo(a), a.renderable = t, a.roundPixels = s, a;
      });
      return this._graphicsBatchesHash[t.uid] === void 0 && t.on("destroyed", () => {
        this.destroyRenderable(t);
      }), this._graphicsBatchesHash[t.uid] = n, n;
    }
    _removeBatchForRenderable(t) {
      this._graphicsBatchesHash[t].forEach((e) => {
        vt.return(e);
      }), this._graphicsBatchesHash[t] = null;
    }
    destroy() {
      this.renderer = null, this._adaptor.destroy(), this._adaptor = null, this.state = null;
      for (const t in this._graphicsBatchesHash) this._removeBatchForRenderable(t);
      this._graphicsBatchesHash = null;
    }
  };
  X0.extension = {
    type: [
      P.WebGLPipes,
      P.WebGPUPipes,
      P.CanvasPipes
    ],
    name: "graphics"
  };
  const jf = class Wf extends Ui {
    constructor(...t) {
      super({});
      let e = t[0] ?? {};
      typeof e == "number" && (lt(dt, "PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead"), e = {
        width: e,
        height: t[1],
        verticesX: t[2],
        verticesY: t[3]
      }), this.build(e);
    }
    build(t) {
      t = {
        ...Wf.defaultOptions,
        ...t
      }, this.verticesX = this.verticesX ?? t.verticesX, this.verticesY = this.verticesY ?? t.verticesY, this.width = this.width ?? t.width, this.height = this.height ?? t.height;
      const e = this.verticesX * this.verticesY, r = [], s = [], n = [], o = this.verticesX - 1, a = this.verticesY - 1, c = this.width / o, l = this.height / a;
      for (let h = 0; h < e; h++) {
        const d = h % this.verticesX, p = h / this.verticesX | 0;
        r.push(d * c, p * l), s.push(d / o, p / a);
      }
      const u = o * a;
      for (let h = 0; h < u; h++) {
        const d = h % o, p = h / o | 0, g = p * this.verticesX + d, y = p * this.verticesX + d + 1, m = (p + 1) * this.verticesX + d, v = (p + 1) * this.verticesX + d + 1;
        n.push(g, y, m, y, v, m);
      }
      this.buffers[0].data = new Float32Array(r), this.buffers[1].data = new Float32Array(s), this.indexBuffer.data = new Uint32Array(n), this.buffers[0].update(), this.buffers[1].update(), this.indexBuffer.update();
    }
  };
  jf.defaultOptions = {
    width: 100,
    height: 100,
    verticesX: 10,
    verticesY: 10
  };
  let q0 = jf;
  const Vf = class Xf extends Ui {
    constructor(t) {
      const { width: e, points: r, textureScale: s } = {
        ...Xf.defaultOptions,
        ...t
      };
      super({
        positions: new Float32Array(r.length * 4),
        uvs: new Float32Array(r.length * 4),
        indices: new Uint32Array((r.length - 1) * 6)
      }), this.points = r, this._width = e, this.textureScale = s, this._build();
    }
    get width() {
      return this._width;
    }
    _build() {
      const t = this.points;
      if (!t) return;
      const e = this.getBuffer("aPosition"), r = this.getBuffer("aUV"), s = this.getIndex();
      if (t.length < 1) return;
      e.data.length / 4 !== t.length && (e.data = new Float32Array(t.length * 4), r.data = new Float32Array(t.length * 4), s.data = new Uint16Array((t.length - 1) * 6));
      const n = r.data, o = s.data;
      n[0] = 0, n[1] = 0, n[2] = 0, n[3] = 1;
      let a = 0, c = t[0];
      const l = this._width * this.textureScale, u = t.length;
      for (let d = 0; d < u; d++) {
        const p = d * 4;
        if (this.textureScale > 0) {
          const g = c.x - t[d].x, y = c.y - t[d].y, m = Math.sqrt(g * g + y * y);
          c = t[d], a += m / l;
        } else a = d / (u - 1);
        n[p] = a, n[p + 1] = 0, n[p + 2] = a, n[p + 3] = 1;
      }
      let h = 0;
      for (let d = 0; d < u - 1; d++) {
        const p = d * 2;
        o[h++] = p, o[h++] = p + 1, o[h++] = p + 2, o[h++] = p + 2, o[h++] = p + 1, o[h++] = p + 3;
      }
      r.update(), s.update(), this.updateVertices();
    }
    updateVertices() {
      const t = this.points;
      if (t.length < 1) return;
      let e = t[0], r, s = 0, n = 0;
      const o = this.buffers[0].data, a = t.length, c = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;
      for (let l = 0; l < a; l++) {
        const u = t[l], h = l * 4;
        l < t.length - 1 ? r = t[l + 1] : r = u, n = -(r.x - e.x), s = r.y - e.y;
        let d = (1 - l / (a - 1)) * 10;
        d > 1 && (d = 1);
        const p = Math.sqrt(s * s + n * n);
        p < 1e-6 ? (s = 0, n = 0) : (s /= p, n /= p, s *= c, n *= c), o[h] = u.x + s, o[h + 1] = u.y + n, o[h + 2] = u.x - s, o[h + 3] = u.y - n, e = u;
      }
      this.buffers[0].update();
    }
    update() {
      this.textureScale > 0 ? this._build() : this.updateVertices();
    }
  };
  Vf.defaultOptions = {
    width: 200,
    points: [],
    textureScale: 0
  };
  let $0 = Vf;
  const Y0 = class qf extends hd {
    constructor(t) {
      const { texture: e, points: r, textureScale: s, ...n } = {
        ...qf.defaultOptions,
        ...t
      }, o = new $0(yo({
        width: e.height,
        points: r,
        textureScale: s
      }));
      s > 0 && (e.source.style.addressMode = "repeat"), super(yo({
        ...n,
        texture: e,
        geometry: o
      })), this.autoUpdate = true, this.onRender = this._render;
    }
    _render() {
      const t = this.geometry;
      (this.autoUpdate || t._width !== this.texture.height) && (t._width = this.texture.height, t.update());
    }
  };
  Y0.defaultOptions = {
    textureScale: 0
  };
  class Fa {
    constructor() {
      this.batcher = null, this.batch = null, this.roundPixels = 0, this._uvUpdateId = -1, this._textureMatrixUpdateId = -1;
    }
    get blendMode() {
      return this.mesh.groupBlendMode;
    }
    reset() {
      this.mesh = null, this.texture = null, this.batcher = null, this.batch = null;
    }
    packIndex(t, e, r) {
      const s = this.geometry.indices;
      for (let n = 0; n < s.length; n++) t[e++] = s[n] + r;
    }
    packAttributes(t, e, r, s) {
      const n = this.mesh, o = this.geometry, a = n.groupTransform, c = s << 16 | this.roundPixels & 65535, l = a.a, u = a.b, h = a.c, d = a.d, p = a.tx, g = a.ty, y = o.positions, m = o.getBuffer("aUV"), v = m.data;
      let S = v;
      const C = this.texture.textureMatrix;
      C.isSimple || (S = this._transformedUvs, (this._textureMatrixUpdateId !== C._updateID || this._uvUpdateId !== m._updateID) && ((!S || S.length < v.length) && (S = this._transformedUvs = new Float32Array(v.length)), this._textureMatrixUpdateId = C._updateID, this._uvUpdateId = m._updateID, C.multiplyUvs(v, S)));
      const G = n.groupColorAlpha;
      for (let H = 0; H < y.length; H += 2) {
        const Y = y[H], L = y[H + 1];
        t[r] = l * Y + h * L + p, t[r + 1] = u * Y + d * L + g, t[r + 2] = S[H], t[r + 3] = S[H + 1], e[r + 4] = G, e[r + 5] = c, r += 6;
      }
    }
    get vertexSize() {
      return this.geometry.positions.length / 2;
    }
    get indexSize() {
      return this.geometry.indices.length;
    }
  }
  K0 = class {
    constructor(t, e) {
      this.localUniforms = new Qt({
        uTransformMatrix: {
          value: new st(),
          type: "mat3x3<f32>"
        },
        uColor: {
          value: new Float32Array([
            1,
            1,
            1,
            1
          ]),
          type: "vec4<f32>"
        },
        uRound: {
          value: 0,
          type: "f32"
        }
      }), this.localUniformsBindGroup = new Ze({
        0: this.localUniforms
      }), this._meshDataHash = /* @__PURE__ */ Object.create(null), this._gpuBatchableMeshHash = /* @__PURE__ */ Object.create(null), this.renderer = t, this._adaptor = e, this._adaptor.init();
    }
    validateRenderable(t) {
      const e = this._getMeshData(t), r = e.batched, s = t.batched;
      if (e.batched = s, r !== s) return true;
      if (s) {
        const n = t._geometry;
        if (n.indices.length !== e.indexSize || n.positions.length !== e.vertexSize) return e.indexSize = n.indices.length, e.vertexSize = n.positions.length, true;
        const o = this._getBatchableMesh(t), a = t.texture;
        if (o.texture._source !== a._source && o.texture._source !== a._source) return !o.batcher.checkAndUpdateTexture(o, a);
      }
      return false;
    }
    addRenderable(t, e) {
      const r = this.renderer.renderPipes.batch, { batched: s } = this._getMeshData(t);
      if (s) {
        const n = this._getBatchableMesh(t);
        n.texture = t._texture, n.geometry = t._geometry, r.addToBatch(n);
      } else r.break(e), e.add(t);
    }
    updateRenderable(t) {
      if (t.batched) {
        const e = this._gpuBatchableMeshHash[t.uid];
        e.texture = t._texture, e.geometry = t._geometry, e.batcher.updateElement(e);
      }
    }
    destroyRenderable(t) {
      this._meshDataHash[t.uid] = null;
      const e = this._gpuBatchableMeshHash[t.uid];
      e && (vt.return(e), this._gpuBatchableMeshHash[t.uid] = null);
    }
    execute(t) {
      if (!t.isRenderable) return;
      t.state.blendMode = Ds(t.groupBlendMode, t.texture._source);
      const e = this.localUniforms;
      e.uniforms.uTransformMatrix = t.groupTransform, e.uniforms.uRound = this.renderer._roundPixels | t._roundPixels, e.update(), on(t.groupColorAlpha, e.uniforms.uColor, 0), this._adaptor.execute(this, t);
    }
    _getMeshData(t) {
      return this._meshDataHash[t.uid] || this._initMeshData(t);
    }
    _initMeshData(t) {
      var _a2, _b2;
      return this._meshDataHash[t.uid] = {
        batched: t.batched,
        indexSize: (_a2 = t._geometry.indices) == null ? void 0 : _a2.length,
        vertexSize: (_b2 = t._geometry.positions) == null ? void 0 : _b2.length
      }, t.on("destroyed", () => {
        this.destroyRenderable(t);
      }), this._meshDataHash[t.uid];
    }
    _getBatchableMesh(t) {
      return this._gpuBatchableMeshHash[t.uid] || this._initBatchableMesh(t);
    }
    _initBatchableMesh(t) {
      const e = vt.get(Fa);
      return e.mesh = t, e.texture = t._texture, e.roundPixels = this.renderer._roundPixels | t._roundPixels, this._gpuBatchableMeshHash[t.uid] = e, e.mesh = t, e;
    }
    destroy() {
      for (const t in this._gpuBatchableMeshHash) this._gpuBatchableMeshHash[t] && vt.return(this._gpuBatchableMeshHash[t]);
      this._gpuBatchableMeshHash = null, this._meshDataHash = null, this.localUniforms = null, this.localUniformsBindGroup = null, this._adaptor.destroy(), this._adaptor = null, this.renderer = null;
    }
  };
  K0.extension = {
    type: [
      P.WebGLPipes,
      P.WebGPUPipes,
      P.CanvasPipes
    ],
    name: "mesh"
  };
  const $f = class Yf extends q0 {
    constructor(t = {}) {
      t = {
        ...Yf.defaultOptions,
        ...t
      }, super({
        width: t.width,
        height: t.height,
        verticesX: 4,
        verticesY: 4
      }), this.update(t);
    }
    update(t) {
      this.width = t.width ?? this.width, this.height = t.height ?? this.height, this._originalWidth = t.originalWidth ?? this._originalWidth, this._originalHeight = t.originalHeight ?? this._originalHeight, this._leftWidth = t.leftWidth ?? this._leftWidth, this._rightWidth = t.rightWidth ?? this._rightWidth, this._topHeight = t.topHeight ?? this._topHeight, this._bottomHeight = t.bottomHeight ?? this._bottomHeight, this.updateUvs(), this.updatePositions();
    }
    updatePositions() {
      const t = this.positions, e = this._leftWidth + this._rightWidth, r = this.width > e ? 1 : this.width / e, s = this._topHeight + this._bottomHeight, n = this.height > s ? 1 : this.height / s, o = Math.min(r, n);
      t[9] = t[11] = t[13] = t[15] = this._topHeight * o, t[17] = t[19] = t[21] = t[23] = this.height - this._bottomHeight * o, t[25] = t[27] = t[29] = t[31] = this.height, t[2] = t[10] = t[18] = t[26] = this._leftWidth * o, t[4] = t[12] = t[20] = t[28] = this.width - this._rightWidth * o, t[6] = t[14] = t[22] = t[30] = this.width, this.getBuffer("aPosition").update();
    }
    updateUvs() {
      const t = this.uvs;
      t[0] = t[8] = t[16] = t[24] = 0, t[1] = t[3] = t[5] = t[7] = 0, t[6] = t[14] = t[22] = t[30] = 1, t[25] = t[27] = t[29] = t[31] = 1;
      const e = 1 / this._originalWidth, r = 1 / this._originalHeight;
      t[2] = t[10] = t[18] = t[26] = e * this._leftWidth, t[9] = t[11] = t[13] = t[15] = r * this._topHeight, t[4] = t[12] = t[20] = t[28] = 1 - e * this._rightWidth, t[17] = t[19] = t[21] = t[23] = 1 - r * this._bottomHeight, this.getBuffer("aUV").update();
    }
  };
  $f.defaultOptions = {
    width: 100,
    height: 100,
    leftWidth: 10,
    topHeight: 10,
    rightWidth: 10,
    bottomHeight: 10,
    originalWidth: 100,
    originalHeight: 100
  };
  let Rr = $f;
  const J0 = class Kf extends Dt {
    constructor(t) {
      var _a2, _b2, _c2, _d2;
      t instanceof Z && (t = {
        texture: t
      });
      const { width: e, height: r, leftWidth: s, rightWidth: n, topHeight: o, bottomHeight: a, texture: c, roundPixels: l, ...u } = t;
      super({
        label: "NineSliceSprite",
        ...u
      }), this._roundPixels = 0, this.renderPipeId = "nineSliceSprite", this.batched = true, this._didSpriteUpdate = true, this.bounds = {
        minX: 0,
        minY: 0,
        maxX: 0,
        maxY: 0
      }, this._leftWidth = s ?? ((_a2 = c == null ? void 0 : c.defaultBorders) == null ? void 0 : _a2.left) ?? Rr.defaultOptions.leftWidth, this._topHeight = o ?? ((_b2 = c == null ? void 0 : c.defaultBorders) == null ? void 0 : _b2.top) ?? Rr.defaultOptions.topHeight, this._rightWidth = n ?? ((_c2 = c == null ? void 0 : c.defaultBorders) == null ? void 0 : _c2.right) ?? Rr.defaultOptions.rightWidth, this._bottomHeight = a ?? ((_d2 = c == null ? void 0 : c.defaultBorders) == null ? void 0 : _d2.bottom) ?? Rr.defaultOptions.bottomHeight, this.bounds.maxX = this._width = e ?? c.width ?? Rr.defaultOptions.width, this.bounds.maxY = this._height = r ?? c.height ?? Rr.defaultOptions.height, this.allowChildren = false, this.texture = c ?? Kf.defaultOptions.texture, this.roundPixels = l ?? false;
    }
    get width() {
      return this._width;
    }
    set width(t) {
      this.bounds.maxX = this._width = t, this.onViewUpdate();
    }
    get height() {
      return this._height;
    }
    set height(t) {
      this.bounds.maxY = this._height = t, this.onViewUpdate();
    }
    get leftWidth() {
      return this._leftWidth;
    }
    set leftWidth(t) {
      this._leftWidth = t, this.onViewUpdate();
    }
    get topHeight() {
      return this._topHeight;
    }
    set topHeight(t) {
      this._topHeight = t, this.onViewUpdate();
    }
    get rightWidth() {
      return this._rightWidth;
    }
    set rightWidth(t) {
      this._rightWidth = t, this.onViewUpdate();
    }
    get bottomHeight() {
      return this._bottomHeight;
    }
    set bottomHeight(t) {
      this._bottomHeight = t, this.onViewUpdate();
    }
    get texture() {
      return this._texture;
    }
    set texture(t) {
      t || (t = Z.EMPTY);
      const e = this._texture;
      e !== t && (e && e.dynamic && e.off("update", this.onViewUpdate, this), t.dynamic && t.on("update", this.onViewUpdate, this), this._texture = t, this.onViewUpdate());
    }
    get roundPixels() {
      return !!this._roundPixels;
    }
    set roundPixels(t) {
      this._roundPixels = t ? 1 : 0;
    }
    get originalWidth() {
      return this._texture.width;
    }
    get originalHeight() {
      return this._texture.height;
    }
    onViewUpdate() {
      if (this._didChangeId += 4096, this._didSpriteUpdate = true, this.didViewUpdate) return;
      this.didViewUpdate = true;
      const t = this.renderGroup || this.parentRenderGroup;
      t && t.onChildViewUpdate(this);
    }
    addBounds(t) {
      const e = this.bounds;
      t.addFrame(e.minX, e.minY, e.maxX, e.maxY);
    }
    containsPoint(t) {
      const e = this.bounds;
      return t.x >= e.minX && t.x <= e.maxX && t.y >= e.minY && t.y <= e.maxY;
    }
    destroy(t) {
      if (super.destroy(t), typeof t == "boolean" ? t : t == null ? void 0 : t.texture) {
        const r = typeof t == "boolean" ? t : t == null ? void 0 : t.textureSource;
        this._texture.destroy(r);
      }
      this._texture = null, this.bounds = null;
    }
  };
  J0.defaultOptions = {
    texture: Z.EMPTY
  };
  Z0 = class {
    constructor(t) {
      this._gpuSpriteHash = /* @__PURE__ */ Object.create(null), this._renderer = t;
    }
    addRenderable(t, e) {
      const r = this._getGpuSprite(t);
      t._didSpriteUpdate && this._updateBatchableSprite(t, r), this._renderer.renderPipes.batch.addToBatch(r);
    }
    updateRenderable(t) {
      const e = this._gpuSpriteHash[t.uid];
      t._didSpriteUpdate && this._updateBatchableSprite(t, e), e.batcher.updateElement(e);
    }
    validateRenderable(t) {
      const e = t._texture, r = this._getGpuSprite(t);
      return r.texture._source !== e._source ? !r.batcher.checkAndUpdateTexture(r, e) : false;
    }
    destroyRenderable(t) {
      const e = this._gpuSpriteHash[t.uid];
      vt.return(e), this._gpuSpriteHash[t.uid] = null;
    }
    _updateBatchableSprite(t, e) {
      t._didSpriteUpdate = false, e.geometry.update(t), e.texture = t._texture;
    }
    _getGpuSprite(t) {
      return this._gpuSpriteHash[t.uid] || this._initGPUSprite(t);
    }
    _initGPUSprite(t) {
      const e = new Fa();
      return e.geometry = new Rr(), e.mesh = t, e.texture = t._texture, e.roundPixels = this._renderer._roundPixels | t._roundPixels, this._gpuSpriteHash[t.uid] = e, t.on("destroyed", () => {
        this.destroyRenderable(t);
      }), e;
    }
    destroy() {
      for (const t in this._gpuSpriteHash) this._gpuSpriteHash[t].geometry.destroy();
      this._gpuSpriteHash = null, this._renderer = null;
    }
  };
  Z0.extension = {
    type: [
      P.WebGLPipes,
      P.WebGPUPipes,
      P.CanvasPipes
    ],
    name: "nineSliceSprite"
  };
  const Q0 = {
    name: "tiling-bit",
    vertex: {
      header: `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `,
      main: `
            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;

            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;
        `
    },
    fragment: {
      header: `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `,
      main: `

            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);
            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;
            var unclamped = coord;
            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);

            var bias = 0.;

            if(unclamped.x == coord.x && unclamped.y == coord.y)
            {
                bias = -32.;
            } 

            outColor = textureSampleBias(uTexture, uSampler, coord, bias);
        `
    }
  }, tx = {
    name: "tiling-bit",
    vertex: {
      header: `
            uniform mat3 uTextureTransform;
            uniform vec4 uSizeAnchor;
        
        `,
      main: `
            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;

            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;
        `
    },
    fragment: {
      header: `
            uniform sampler2D uTexture;
            uniform mat3 uMapCoord;
            uniform vec4 uClampFrame;
            uniform vec2 uClampOffset;
        `,
      main: `

        vec2 coord = vUV + ceil(uClampOffset - vUV);
        coord = (uMapCoord * vec3(coord, 1.0)).xy;
        vec2 unclamped = coord;
        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);
        
        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0
    
        `
    }
  };
  let fo, po;
  class ex extends Se {
    constructor() {
      fo ?? (fo = ki({
        name: "tiling-sprite-shader",
        bits: [
          Ei,
          Q0,
          Oi
        ]
      })), po ?? (po = Gi({
        name: "tiling-sprite-shader",
        bits: [
          va,
          tx,
          Ni
        ]
      }));
      const t = new Qt({
        uMapCoord: {
          value: new st(),
          type: "mat3x3<f32>"
        },
        uClampFrame: {
          value: new Float32Array([
            0,
            0,
            1,
            1
          ]),
          type: "vec4<f32>"
        },
        uClampOffset: {
          value: new Float32Array([
            0,
            0
          ]),
          type: "vec2<f32>"
        },
        uTextureTransform: {
          value: new st(),
          type: "mat3x3<f32>"
        },
        uSizeAnchor: {
          value: new Float32Array([
            100,
            100,
            0.5,
            0.5
          ]),
          type: "vec4<f32>"
        }
      });
      super({
        glProgram: po,
        gpuProgram: fo,
        resources: {
          localUniforms: new Qt({
            uTransformMatrix: {
              value: new st(),
              type: "mat3x3<f32>"
            },
            uColor: {
              value: new Float32Array([
                1,
                1,
                1,
                1
              ]),
              type: "vec4<f32>"
            },
            uRound: {
              value: 0,
              type: "f32"
            }
          }),
          tilingUniforms: t,
          uTexture: Z.EMPTY.source,
          uSampler: Z.EMPTY.source.style
        }
      });
    }
    updateUniforms(t, e, r, s, n, o) {
      const a = this.resources.tilingUniforms, c = o.width, l = o.height, u = o.textureMatrix, h = a.uniforms.uTextureTransform;
      h.set(r.a * c / t, r.b * c / e, r.c * l / t, r.d * l / e, r.tx / t, r.ty / e), h.invert(), a.uniforms.uMapCoord = u.mapCoord, a.uniforms.uClampFrame = u.uClampFrame, a.uniforms.uClampOffset = u.uClampOffset, a.uniforms.uTextureTransform = h, a.uniforms.uSizeAnchor[0] = t, a.uniforms.uSizeAnchor[1] = e, a.uniforms.uSizeAnchor[2] = s, a.uniforms.uSizeAnchor[3] = n, o && (this.resources.uTexture = o.source, this.resources.uSampler = o.source.style);
    }
  }
  class rx extends Ui {
    constructor() {
      super({
        positions: new Float32Array([
          0,
          0,
          1,
          0,
          1,
          1,
          0,
          1
        ]),
        uvs: new Float32Array([
          0,
          0,
          1,
          0,
          1,
          1,
          0,
          1
        ]),
        indices: new Uint32Array([
          0,
          1,
          2,
          0,
          2,
          3
        ])
      });
    }
  }
  function ix(i, t) {
    const e = i.anchor.x, r = i.anchor.y;
    t[0] = -e * i.width, t[1] = -r * i.height, t[2] = (1 - e) * i.width, t[3] = -r * i.height, t[4] = (1 - e) * i.width, t[5] = (1 - r) * i.height, t[6] = -e * i.width, t[7] = (1 - r) * i.height;
  }
  function sx(i, t, e, r) {
    let s = 0;
    const n = i.length / (t || 2), o = r.a, a = r.b, c = r.c, l = r.d, u = r.tx, h = r.ty;
    for (e *= t; s < n; ) {
      const d = i[e], p = i[e + 1];
      i[e] = o * d + c * p + u, i[e + 1] = a * d + l * p + h, e += t, s++;
    }
  }
  function nx(i, t) {
    const e = i.texture, r = e.frame.width, s = e.frame.height;
    let n = 0, o = 0;
    i._applyAnchorToTexture && (n = i.anchor.x, o = i.anchor.y), t[0] = t[6] = -n, t[2] = t[4] = 1 - n, t[1] = t[3] = -o, t[5] = t[7] = 1 - o;
    const a = st.shared;
    a.copyFrom(i._tileTransform.matrix), a.tx /= i.width, a.ty /= i.height, a.invert(), a.scale(i.width / r, i.height / s), sx(t, 2, 0, a);
  }
  const ps = new rx();
  ox = class {
    constructor(t) {
      this._state = Le.default2d, this._tilingSpriteDataHash = /* @__PURE__ */ Object.create(null), this._renderer = t;
    }
    validateRenderable(t) {
      const e = this._getTilingSpriteData(t), r = e.canBatch;
      this._updateCanBatch(t);
      const s = e.canBatch;
      if (s && s === r) {
        const { batchableMesh: n } = e;
        if (n && n.texture._source !== t.texture._source) return !n.batcher.checkAndUpdateTexture(n, t.texture);
      }
      return r !== s;
    }
    addRenderable(t, e) {
      const r = this._renderer.renderPipes.batch;
      this._updateCanBatch(t);
      const s = this._getTilingSpriteData(t), { geometry: n, canBatch: o } = s;
      if (o) {
        s.batchableMesh || (s.batchableMesh = new Fa());
        const a = s.batchableMesh;
        t._didTilingSpriteUpdate && (t._didTilingSpriteUpdate = false, this._updateBatchableMesh(t), a.geometry = n, a.mesh = t, a.texture = t._texture), a.roundPixels = this._renderer._roundPixels | t._roundPixels, r.addToBatch(a);
      } else r.break(e), s.shader || (s.shader = new ex()), this.updateRenderable(t), e.add(t);
    }
    execute(t) {
      const { shader: e } = this._tilingSpriteDataHash[t.uid];
      e.groups[0] = this._renderer.globalUniforms.bindGroup;
      const r = e.resources.localUniforms.uniforms;
      r.uTransformMatrix = t.groupTransform, r.uRound = this._renderer._roundPixels | t._roundPixels, on(t.groupColorAlpha, r.uColor, 0), this._state.blendMode = Ds(t.groupBlendMode, t.texture._source), this._renderer.encoder.draw({
        geometry: ps,
        shader: e,
        state: this._state
      });
    }
    updateRenderable(t) {
      const e = this._getTilingSpriteData(t), { canBatch: r } = e;
      if (r) {
        const { batchableMesh: s } = e;
        t._didTilingSpriteUpdate && this._updateBatchableMesh(t), s.batcher.updateElement(s);
      } else if (t._didTilingSpriteUpdate) {
        const { shader: s } = e;
        s.updateUniforms(t.width, t.height, t._tileTransform.matrix, t.anchor.x, t.anchor.y, t.texture);
      }
      t._didTilingSpriteUpdate = false;
    }
    destroyRenderable(t) {
      var _a2;
      const e = this._getTilingSpriteData(t);
      e.batchableMesh = null, (_a2 = e.shader) == null ? void 0 : _a2.destroy(), this._tilingSpriteDataHash[t.uid] = null;
    }
    _getTilingSpriteData(t) {
      return this._tilingSpriteDataHash[t.uid] || this._initTilingSpriteData(t);
    }
    _initTilingSpriteData(t) {
      const e = new Ui({
        indices: ps.indices,
        positions: ps.positions.slice(),
        uvs: ps.uvs.slice()
      });
      return this._tilingSpriteDataHash[t.uid] = {
        canBatch: true,
        renderable: t,
        geometry: e
      }, t.on("destroyed", () => {
        this.destroyRenderable(t);
      }), this._tilingSpriteDataHash[t.uid];
    }
    _updateBatchableMesh(t) {
      const e = this._getTilingSpriteData(t), { geometry: r } = e, s = t.texture.source.style;
      s.addressMode !== "repeat" && (s.addressMode = "repeat", s.update()), nx(t, r.uvs), ix(t, r.positions);
    }
    destroy() {
      for (const t in this._tilingSpriteDataHash) this.destroyRenderable(this._tilingSpriteDataHash[t].renderable);
      this._tilingSpriteDataHash = null, this._renderer = null;
    }
    _updateCanBatch(t) {
      const e = this._getTilingSpriteData(t), r = t.texture;
      let s = true;
      return this._renderer.type === ge.WEBGL && (s = this._renderer.context.supports.nonPowOf2wrapping), e.canBatch = r.textureMatrix.isSimple && (s || r.source.isPowerOfTwo), e.canBatch;
    }
  };
  ox.extension = {
    type: [
      P.WebGLPipes,
      P.WebGPUPipes,
      P.CanvasPipes
    ],
    name: "tilingSprite"
  };
  const ax = {
    name: "local-uniform-msdf-bit",
    vertex: {
      header: `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32,
                uRound:f32,
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `,
      main: `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `,
      end: `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `
    },
    fragment: {
      header: `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
         `,
      main: ` 
            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));
        `
    }
  }, cx = {
    name: "local-uniform-msdf-bit",
    vertex: {
      header: `
            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `,
      main: `
            vColor *= uColor;
            modelMatrix *= uTransformMatrix;
        `,
      end: `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `
    },
    fragment: {
      header: `
            uniform float uDistance;
         `,
      main: ` 
            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));
        `
    }
  }, ux = {
    name: "msdf-bit",
    fragment: {
      header: `
            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {
                
                // MSDF
                var median = msdfColor.r + msdfColor.g + msdfColor.b -
                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));
            
                // SDF
                median = min(median, msdfColor.a);

                var screenPxDistance = distance * (median - 0.5);
                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));
                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);
                var coverage: f32 = pow(shapeColor.a * alpha, gamma);

                return coverage;
             
            }
        `
    }
  }, lx = {
    name: "msdf-bit",
    fragment: {
      header: `
            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {
                
                // MSDF
                float median = msdfColor.r + msdfColor.g + msdfColor.b -
                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));
               
                // SDF
                median = min(median, msdfColor.a);
            
                float screenPxDistance = distance * (median - 0.5);
                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
           
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));
                float gamma = mix(1.0, 1.0 / 2.2, luma);
                float coverage = pow(shapeColor.a * alpha, gamma);  
              
                return coverage;
            }
        `
    }
  };
  let _o, go;
  class hx extends Se {
    constructor() {
      const t = new Qt({
        uColor: {
          value: new Float32Array([
            1,
            1,
            1,
            1
          ]),
          type: "vec4<f32>"
        },
        uTransformMatrix: {
          value: new st(),
          type: "mat3x3<f32>"
        },
        uDistance: {
          value: 4,
          type: "f32"
        },
        uRound: {
          value: 0,
          type: "f32"
        }
      }), e = Fr();
      _o ?? (_o = ki({
        name: "sdf-shader",
        bits: [
          ma,
          wa(e),
          ax,
          ux,
          Oi
        ]
      })), go ?? (go = Gi({
        name: "sdf-shader",
        bits: [
          ba,
          ya(e),
          cx,
          lx,
          Ni
        ]
      })), super({
        glProgram: go,
        gpuProgram: _o,
        resources: {
          localUniforms: t,
          batchSamplers: xa(e)
        }
      });
    }
  }
  dx = class {
    constructor(t) {
      this._gpuBitmapText = {}, this._renderer = t;
    }
    validateRenderable(t) {
      const e = this._getGpuBitmapText(t);
      return t._didTextUpdate && (t._didTextUpdate = false, this._updateContext(t, e)), this._renderer.renderPipes.graphics.validateRenderable(e);
    }
    addRenderable(t, e) {
      const r = this._getGpuBitmapText(t);
      ju(t, r), t._didTextUpdate && (t._didTextUpdate = false, this._updateContext(t, r)), this._renderer.renderPipes.graphics.addRenderable(r, e), r.context.customShader && this._updateDistanceField(t);
    }
    destroyRenderable(t) {
      this._destroyRenderableByUid(t.uid);
    }
    _destroyRenderableByUid(t) {
      const e = this._gpuBitmapText[t].context;
      e.customShader && (vt.return(e.customShader), e.customShader = null), vt.return(this._gpuBitmapText[t]), this._gpuBitmapText[t] = null;
    }
    updateRenderable(t) {
      const e = this._getGpuBitmapText(t);
      ju(t, e), this._renderer.renderPipes.graphics.updateRenderable(e), e.context.customShader && this._updateDistanceField(t);
    }
    _updateContext(t, e) {
      const { context: r } = e, s = ks.getFont(t.text, t._style);
      r.clear(), s.distanceField.type !== "none" && (r.customShader || (r.customShader = vt.get(hx)));
      const n = Array.from(t.text), o = t._style;
      let a = s.baseLineOffset;
      const c = Nh(n, o, s);
      let l = 0;
      const u = o.padding, h = c.scale;
      let d = c.width, p = c.height + c.offsetY;
      o._stroke && (d += o._stroke.width / h, p += o._stroke.width / h), r.translate(-t._anchor._x * d - u, -t._anchor._y * p - u).scale(h, h);
      const g = s.applyFillAsTint ? o._fill.color : 16777215;
      for (let y = 0; y < c.lines.length; y++) {
        const m = c.lines[y];
        for (let v = 0; v < m.charPositions.length; v++) {
          const S = n[l++], C = s.chars[S];
          (C == null ? void 0 : C.texture) && r.texture(C.texture, g || "black", Math.round(m.charPositions[v] + C.xOffset), Math.round(a + C.yOffset));
        }
        a += s.lineHeight;
      }
    }
    _getGpuBitmapText(t) {
      return this._gpuBitmapText[t.uid] || this.initGpuText(t);
    }
    initGpuText(t) {
      const e = vt.get($e);
      return this._gpuBitmapText[t.uid] = e, this._updateContext(t, e), t.on("destroyed", () => {
        this.destroyRenderable(t);
      }), this._gpuBitmapText[t.uid];
    }
    _updateDistanceField(t) {
      const e = this._getGpuBitmapText(t).context, r = t._style.fontFamily, s = Ct.get(`${r}-bitmap`), { a: n, b: o, c: a, d: c } = t.groupTransform, l = Math.sqrt(n * n + o * o), u = Math.sqrt(a * a + c * c), h = (Math.abs(l) + Math.abs(u)) / 2, d = s.baseRenderedFontSize / t._style.fontSize, p = h * s.distanceField.range * (1 / d);
      e.customShader.resources.localUniforms.uniforms.uDistance = p;
    }
    destroy() {
      for (const t in this._gpuBitmapText) this._destroyRenderableByUid(t);
      this._gpuBitmapText = null, this._renderer = null;
    }
  };
  dx.extension = {
    type: [
      P.WebGLPipes,
      P.WebGPUPipes,
      P.CanvasPipes
    ],
    name: "bitmapText"
  };
  function ju(i, t) {
    t.groupTransform = i.groupTransform, t.groupColorAlpha = i.groupColorAlpha, t.groupColor = i.groupColor, t.groupBlendMode = i.groupBlendMode, t.globalDisplayStatus = i.globalDisplayStatus, t.groupTransform = i.groupTransform, t.localDisplayStatus = i.localDisplayStatus, t.groupAlpha = i.groupAlpha, t._roundPixels = i._roundPixels;
  }
  fx = class {
    constructor(t) {
      this._gpuText = /* @__PURE__ */ Object.create(null), this._renderer = t, this._renderer.runners.resolutionChange.add(this);
    }
    resolutionChange() {
      for (const t in this._gpuText) {
        const r = this._gpuText[t].batchableSprite.renderable;
        r._autoResolution && (r._resolution = this._renderer.resolution, r.onViewUpdate());
      }
    }
    validateRenderable(t) {
      const e = this._getGpuText(t), r = t._getKey();
      return e.textureNeedsUploading ? (e.textureNeedsUploading = false, true) : e.currentKey !== r;
    }
    addRenderable(t, e) {
      const s = this._getGpuText(t).batchableSprite;
      t._didTextUpdate && this._updateText(t), this._renderer.renderPipes.batch.addToBatch(s);
    }
    updateRenderable(t) {
      const r = this._getGpuText(t).batchableSprite;
      t._didTextUpdate && this._updateText(t), r.batcher.updateElement(r);
    }
    destroyRenderable(t) {
      this._destroyRenderableById(t.uid);
    }
    _destroyRenderableById(t) {
      const e = this._gpuText[t];
      this._renderer.htmlText.decreaseReferenceCount(e.currentKey), vt.return(e.batchableSprite), this._gpuText[t] = null;
    }
    _updateText(t) {
      const e = t._getKey(), r = this._getGpuText(t), s = r.batchableSprite;
      r.currentKey !== e && this._updateGpuText(t).catch((o) => {
        console.error(o);
      }), t._didTextUpdate = false;
      const n = t._style.padding;
      As(s.bounds, t._anchor, s.texture, n);
    }
    async _updateGpuText(t) {
      t._didTextUpdate = false;
      const e = this._getGpuText(t);
      if (e.generatingTexture) return;
      const r = t._getKey();
      this._renderer.htmlText.decreaseReferenceCount(e.currentKey), e.generatingTexture = true, e.currentKey = r;
      const s = t.resolution ?? this._renderer.resolution, n = await this._renderer.htmlText.getManagedTexture(t.text, s, t._style, t._getKey()), o = e.batchableSprite;
      o.texture = e.texture = n, e.generatingTexture = false, e.textureNeedsUploading = true, t.onViewUpdate();
      const a = t._style.padding;
      As(o.bounds, t._anchor, o.texture, a);
    }
    _getGpuText(t) {
      return this._gpuText[t.uid] || this.initGpuText(t);
    }
    initGpuText(t) {
      const e = {
        texture: Z.EMPTY,
        currentKey: "--",
        batchableSprite: vt.get(Aa),
        textureNeedsUploading: false,
        generatingTexture: false
      }, r = e.batchableSprite;
      return r.renderable = t, r.texture = Z.EMPTY, r.bounds = {
        minX: 0,
        maxX: 1,
        minY: 0,
        maxY: 0
      }, r.roundPixels = this._renderer._roundPixels | t._roundPixels, t._resolution = t._autoResolution ? this._renderer.resolution : t.resolution, this._gpuText[t.uid] = e, t.on("destroyed", () => {
        this.destroyRenderable(t);
      }), e;
    }
    destroy() {
      for (const t in this._gpuText) this._destroyRenderableById(t);
      this._gpuText = null, this._renderer = null;
    }
  };
  fx.extension = {
    type: [
      P.WebGLPipes,
      P.WebGPUPipes,
      P.CanvasPipes
    ],
    name: "htmlText"
  };
  function px() {
    const { userAgent: i } = St.get().getNavigator();
    return /^((?!chrome|android).)*safari/i.test(i);
  }
  const _x = new re();
  function Jf(i, t, e, r) {
    const s = _x;
    s.minX = 0, s.minY = 0, s.maxX = i.width / r | 0, s.maxY = i.height / r | 0;
    const n = Zt.getOptimalTexture(s.width, s.height, r, false);
    return n.source.uploadMethodId = "image", n.source.resource = i, n.source.alphaMode = "premultiply-alpha-on-upload", n.frame.width = t / r, n.frame.height = e / r, n.source.emit("update", n.source), n.updateUvs(), n;
  }
  function gx(i, t) {
    const e = t.fontFamily, r = [], s = {}, n = /font-family:([^;"\s]+)/g, o = i.match(n);
    function a(c) {
      s[c] || (r.push(c), s[c] = true);
    }
    if (Array.isArray(e)) for (let c = 0; c < e.length; c++) a(e[c]);
    else a(e);
    o && o.forEach((c) => {
      const l = c.split(":")[1].trim();
      a(l);
    });
    for (const c in t.tagStyles) {
      const l = t.tagStyles[c].fontFamily;
      a(l);
    }
    return r;
  }
  async function mx(i) {
    const e = await (await St.get().fetch(i)).blob(), r = new FileReader();
    return await new Promise((n, o) => {
      r.onloadend = () => n(r.result), r.onerror = o, r.readAsDataURL(e);
    });
  }
  async function Wu(i, t) {
    const e = await mx(t);
    return `@font-face {
        font-family: "${i.fontFamily}";
        src: url('${e}');
        font-weight: ${i.fontWeight};
        font-style: ${i.fontStyle};
    }`;
  }
  const _s = /* @__PURE__ */ new Map();
  async function bx(i, t, e) {
    const r = i.filter((s) => Ct.has(`${s}-and-url`)).map((s, n) => {
      if (!_s.has(s)) {
        const { url: o } = Ct.get(`${s}-and-url`);
        n === 0 ? _s.set(s, Wu({
          fontWeight: t.fontWeight,
          fontStyle: t.fontStyle,
          fontFamily: s
        }, o)) : _s.set(s, Wu({
          fontWeight: e.fontWeight,
          fontStyle: e.fontStyle,
          fontFamily: s
        }, o));
      }
      return _s.get(s);
    });
    return (await Promise.all(r)).join(`
`);
  }
  function wx(i, t, e, r, s) {
    const { domElement: n, styleElement: o, svgRoot: a } = s;
    n.innerHTML = `<style>${t.cssStyle}</style><div style='padding:0;'>${i}</div>`, n.setAttribute("style", `transform: scale(${e});transform-origin: top left; display: inline-block`), o.textContent = r;
    const { width: c, height: l } = s.image;
    return a.setAttribute("width", c.toString()), a.setAttribute("height", l.toString()), new XMLSerializer().serializeToString(a);
  }
  function yx(i, t) {
    const e = Qe.getOptimalCanvasAndContext(i.width, i.height, t), { context: r } = e;
    return r.clearRect(0, 0, i.width, i.height), r.drawImage(i, 0, 0), Qe.returnCanvasAndContext(e), e.canvas;
  }
  function xx(i, t, e) {
    return new Promise(async (r) => {
      e && await new Promise((s) => setTimeout(s, 100)), i.onload = () => {
        r();
      }, i.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(t)}`, i.crossOrigin = "anonymous";
    });
  }
  Zf = class {
    constructor(t) {
      this._activeTextures = {}, this._renderer = t, this._createCanvas = t.type === ge.WEBGPU;
    }
    getTexture(t) {
      return this._buildTexturePromise(t.text, t.resolution, t.style);
    }
    getManagedTexture(t, e, r, s) {
      if (this._activeTextures[s]) return this._increaseReferenceCount(s), this._activeTextures[s].promise;
      const n = this._buildTexturePromise(t, e, r).then((o) => (this._activeTextures[s].texture = o, o));
      return this._activeTextures[s] = {
        texture: null,
        promise: n,
        usageCount: 1
      }, n;
    }
    async _buildTexturePromise(t, e, r) {
      const s = vt.get(gd), n = gx(t, r), o = await bx(n, r, sn.defaultTextStyle), a = md(t, r, o, s), c = Math.ceil(Math.ceil(Math.max(1, a.width) + r.padding * 2) * e), l = Math.ceil(Math.ceil(Math.max(1, a.height) + r.padding * 2) * e), u = s.image, h = 2;
      u.width = (c | 0) + h, u.height = (l | 0) + h;
      const d = wx(t, r, e, o, s);
      await xx(u, d, px() && n.length > 0);
      let p = u;
      this._createCanvas && (p = yx(u, e));
      const g = Jf(p, u.width - h, u.height - h, e);
      return this._createCanvas && this._renderer.texture.initSource(g.source), vt.return(s), g;
    }
    _increaseReferenceCount(t) {
      this._activeTextures[t].usageCount++;
    }
    decreaseReferenceCount(t) {
      const e = this._activeTextures[t];
      e && (e.usageCount--, e.usageCount === 0 && (e.texture ? this._cleanUp(e) : e.promise.then((r) => {
        e.texture = r, this._cleanUp(e);
      }).catch(() => {
        ut("HTMLTextSystem: Failed to clean texture");
      }), this._activeTextures[t] = null));
    }
    _cleanUp(t) {
      Zt.returnTexture(t.texture), t.texture.source.resource = null, t.texture.source.uploadMethodId = "unknown";
    }
    getReferenceCount(t) {
      return this._activeTextures[t].usageCount;
    }
    destroy() {
      this._activeTextures = null;
    }
  };
  Zf.extension = {
    type: [
      P.WebGLSystem,
      P.WebGPUSystem,
      P.CanvasSystem
    ],
    name: "htmlText"
  };
  Zf.defaultFontOptions = {
    fontFamily: "Arial",
    fontStyle: "normal",
    fontWeight: "normal"
  };
  vx = class {
    constructor(t) {
      this._gpuText = /* @__PURE__ */ Object.create(null), this._renderer = t, this._renderer.runners.resolutionChange.add(this);
    }
    resolutionChange() {
      for (const t in this._gpuText) {
        const r = this._gpuText[t].batchableSprite.renderable;
        r._autoResolution && (r._resolution = this._renderer.resolution, r.onViewUpdate());
      }
    }
    validateRenderable(t) {
      const e = this._getGpuText(t), r = t._getKey();
      if (e.currentKey !== r) {
        const { width: s, height: n } = this._renderer.canvasText.getTextureSize(t.text, t.resolution, t._style);
        return !(this._renderer.canvasText.getReferenceCount(e.currentKey) === 1 && s === e.texture._source.width && n === e.texture._source.height);
      }
      return false;
    }
    addRenderable(t, e) {
      const s = this._getGpuText(t).batchableSprite;
      t._didTextUpdate && this._updateText(t), this._renderer.renderPipes.batch.addToBatch(s);
    }
    updateRenderable(t) {
      const r = this._getGpuText(t).batchableSprite;
      t._didTextUpdate && this._updateText(t), r.batcher.updateElement(r);
    }
    destroyRenderable(t) {
      this._destroyRenderableById(t.uid);
    }
    _destroyRenderableById(t) {
      const e = this._gpuText[t];
      this._renderer.canvasText.decreaseReferenceCount(e.currentKey), vt.return(e.batchableSprite), this._gpuText[t] = null;
    }
    _updateText(t) {
      const e = t._getKey(), r = this._getGpuText(t), s = r.batchableSprite;
      r.currentKey !== e && this._updateGpuText(t), t._didTextUpdate = false;
      const n = t._style.padding;
      As(s.bounds, t._anchor, s.texture, n);
    }
    _updateGpuText(t) {
      const e = this._getGpuText(t), r = e.batchableSprite;
      e.texture && this._renderer.canvasText.decreaseReferenceCount(e.currentKey), e.texture = r.texture = this._renderer.canvasText.getManagedTexture(t), e.currentKey = t._getKey(), r.texture = e.texture;
    }
    _getGpuText(t) {
      return this._gpuText[t.uid] || this.initGpuText(t);
    }
    initGpuText(t) {
      const e = {
        texture: null,
        currentKey: "--",
        batchableSprite: vt.get(Aa)
      };
      return e.batchableSprite.renderable = t, e.batchableSprite.bounds = {
        minX: 0,
        maxX: 1,
        minY: 0,
        maxY: 0
      }, e.batchableSprite.roundPixels = this._renderer._roundPixels | t._roundPixels, this._gpuText[t.uid] = e, t._resolution = t._autoResolution ? this._renderer.resolution : t.resolution, this._updateText(t), t.on("destroyed", () => {
        this.destroyRenderable(t);
      }), e;
    }
    destroy() {
      for (const t in this._gpuText) this._destroyRenderableById(t);
      this._gpuText = null, this._renderer = null;
    }
  };
  vx.extension = {
    type: [
      P.WebGLPipes,
      P.WebGPUPipes,
      P.CanvasPipes
    ],
    name: "text"
  };
  function Vu(i, t, e) {
    for (let r = 0, s = 4 * e * t; r < t; ++r, s += 4) if (i[s + 3] !== 0) return false;
    return true;
  }
  function Xu(i, t, e, r, s) {
    const n = 4 * t;
    for (let o = r, a = r * n + 4 * e; o <= s; ++o, a += n) if (i[a + 3] !== 0) return false;
    return true;
  }
  function Sx(i, t = 1) {
    const { width: e, height: r } = i, s = i.getContext("2d", {
      willReadFrequently: true
    });
    if (s === null) throw new TypeError("Failed to get canvas 2D context");
    const o = s.getImageData(0, 0, e, r).data;
    let a = 0, c = 0, l = e - 1, u = r - 1;
    for (; c < r && Vu(o, e, c); ) ++c;
    if (c === r) return Et.EMPTY;
    for (; Vu(o, e, u); ) --u;
    for (; Xu(o, e, a, c, u); ) ++a;
    for (; Xu(o, e, l, c, u); ) --l;
    return ++l, ++u, new Et(a / t, c / t, (l - a) / t, (u - c) / t);
  }
  Ex = class {
    constructor(t) {
      this._activeTextures = {}, this._renderer = t;
    }
    getTextureSize(t, e, r) {
      const s = Ge.measureText(t || " ", r);
      let n = Math.ceil(Math.ceil(Math.max(1, s.width) + r.padding * 2) * e), o = Math.ceil(Math.ceil(Math.max(1, s.height) + r.padding * 2) * e);
      return n = Math.ceil(n - 1e-6), o = Math.ceil(o - 1e-6), n = Yr(n), o = Yr(o), {
        width: n,
        height: o
      };
    }
    getTexture(t, e, r, s) {
      typeof t == "string" && (lt("8.0.0", "CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments"), t = {
        text: t,
        style: r,
        resolution: e
      }), t.style instanceof Oe || (t.style = new Oe(t.style));
      const { texture: n, canvasAndContext: o } = this.createTextureAndCanvas(t);
      return this._renderer.texture.initSource(n._source), Qe.returnCanvasAndContext(o), n;
    }
    createTextureAndCanvas(t) {
      const { text: e, style: r } = t, s = t.resolution ?? this._renderer.resolution, n = Ge.measureText(e || " ", r), o = Math.ceil(Math.ceil(Math.max(1, n.width) + r.padding * 2) * s), a = Math.ceil(Math.ceil(Math.max(1, n.height) + r.padding * 2) * s), c = Qe.getOptimalCanvasAndContext(o, a), { canvas: l } = c;
      this.renderTextToCanvas(e, r, s, c);
      const u = Jf(l, o, a, s);
      if (r.trim) {
        const h = Sx(l, s);
        u.frame.copyFrom(h), u.updateUvs();
      }
      return {
        texture: u,
        canvasAndContext: c
      };
    }
    getManagedTexture(t) {
      t._resolution = t._autoResolution ? this._renderer.resolution : t.resolution;
      const e = t._getKey();
      if (this._activeTextures[e]) return this._increaseReferenceCount(e), this._activeTextures[e].texture;
      const { texture: r, canvasAndContext: s } = this.createTextureAndCanvas(t);
      return this._activeTextures[e] = {
        canvasAndContext: s,
        texture: r,
        usageCount: 1
      }, r;
    }
    _increaseReferenceCount(t) {
      this._activeTextures[t].usageCount++;
    }
    decreaseReferenceCount(t) {
      const e = this._activeTextures[t];
      if (e.usageCount--, e.usageCount === 0) {
        Qe.returnCanvasAndContext(e.canvasAndContext), Zt.returnTexture(e.texture);
        const r = e.texture.source;
        r.resource = null, r.uploadMethodId = "unknown", r.alphaMode = "no-premultiply-alpha", this._activeTextures[t] = null;
      }
    }
    getReferenceCount(t) {
      return this._activeTextures[t].usageCount;
    }
    renderTextToCanvas(t, e, r, s) {
      var _a2, _b2, _c2, _d2, _e2;
      const { canvas: n, context: o } = s, a = Fs(e), c = Ge.measureText(t || " ", e), l = c.lines, u = c.lineHeight, h = c.lineWidths, d = c.maxLineWidth, p = c.fontProperties, g = n.height;
      o.resetTransform(), o.scale(r, r);
      const y = e.padding * 2;
      if (o.clearRect(0, 0, c.width + 4 + y, c.height + 4 + y), (_a2 = e._stroke) == null ? void 0 : _a2.width) {
        const C = e._stroke;
        o.lineWidth = C.width, o.miterLimit = C.miterLimit, o.lineJoin = C.join, o.lineCap = C.cap;
      }
      o.font = a;
      let m, v;
      const S = e.dropShadow ? 2 : 1;
      for (let C = 0; C < S; ++C) {
        const G = e.dropShadow && C === 0, H = G ? Math.ceil(Math.max(1, g) + e.padding * 2) : 0, Y = H * r;
        if (G) {
          o.fillStyle = "black", o.strokeStyle = "black";
          const A = e.dropShadow, I = A.color, z = A.alpha;
          o.shadowColor = Tt.shared.setValue(I).setAlpha(z).toRgbaString();
          const J = A.blur * r, j = A.distance * r;
          o.shadowBlur = J, o.shadowOffsetX = Math.cos(A.angle) * j, o.shadowOffsetY = Math.sin(A.angle) * j + Y;
        } else o.globalAlpha = ((_b2 = e._fill) == null ? void 0 : _b2.alpha) ?? 1, o.fillStyle = e._fill ? Us(e._fill, o) : null, ((_c2 = e._stroke) == null ? void 0 : _c2.width) && (o.strokeStyle = Us(e._stroke, o)), o.shadowColor = "black";
        let L = (u - p.fontSize) / 2;
        u - p.fontSize < 0 && (L = 0);
        const W = ((_d2 = e._stroke) == null ? void 0 : _d2.width) ?? 0;
        for (let A = 0; A < l.length; A++) m = W / 2, v = W / 2 + A * u + p.ascent + L, e.align === "right" ? m += d - h[A] : e.align === "center" && (m += (d - h[A]) / 2), ((_e2 = e._stroke) == null ? void 0 : _e2.width) && this._drawLetterSpacing(l[A], e, s, m + e.padding, v + e.padding - H, true), e._fill !== void 0 && this._drawLetterSpacing(l[A], e, s, m + e.padding, v + e.padding - H);
      }
    }
    _drawLetterSpacing(t, e, r, s, n, o = false) {
      const { context: a } = r, c = e.letterSpacing;
      let l = false;
      if (Ge.experimentalLetterSpacingSupported && (Ge.experimentalLetterSpacing ? (a.letterSpacing = `${c}px`, a.textLetterSpacing = `${c}px`, l = true) : (a.letterSpacing = "0px", a.textLetterSpacing = "0px")), c === 0 || l) {
        o ? a.strokeText(t, s, n) : a.fillText(t, s, n);
        return;
      }
      let u = s;
      const h = Ge.graphemeSegmenter(t);
      let d = a.measureText(t).width, p = 0;
      for (let g = 0; g < h.length; ++g) {
        const y = h[g];
        o ? a.strokeText(y, u, n) : a.fillText(y, u, n);
        let m = "";
        for (let v = g + 1; v < h.length; ++v) m += h[v];
        p = a.measureText(m).width, u += d - p + c, d = p;
      }
    }
    destroy() {
      this._activeTextures = null;
    }
  };
  Ex.extension = {
    type: [
      P.WebGLSystem,
      P.WebGPUSystem,
      P.CanvasSystem
    ],
    name: "canvasText"
  };
  Mt.add(Sp, Ep);
  const Tx = "" + new URL("rapier_wasm2d_bg-BXUr3HkR.wasm", import.meta.url).href, Cx = async (i = {}, t) => {
    let e;
    if (t.startsWith("data:")) {
      const r = t.replace(/^data:.*?base64,/, "");
      let s;
      if (typeof Buffer == "function" && typeof Buffer.from == "function") s = Buffer.from(r, "base64");
      else if (typeof atob == "function") {
        const n = atob(r);
        s = new Uint8Array(n.length);
        for (let o = 0; o < n.length; o++) s[o] = n.charCodeAt(o);
      } else throw new Error("Cannot decode base64-encoded data URL");
      e = await WebAssembly.instantiate(s, i);
    } else {
      const r = await fetch(t), s = r.headers.get("Content-Type") || "";
      if ("instantiateStreaming" in WebAssembly && s.startsWith("application/wasm")) e = await WebAssembly.instantiateStreaming(r, i);
      else {
        const n = await r.arrayBuffer();
        e = await WebAssembly.instantiate(n, i);
      }
    }
    return e.instance.exports;
  };
  let f;
  function Ax(i) {
    f = i;
  }
  const mt = new Array(128).fill(void 0);
  mt.push(void 0, null, true, false);
  let Ci = mt.length;
  function Vt(i) {
    Ci === mt.length && mt.push(mt.length + 1);
    const t = Ci;
    return Ci = mt[t], mt[t] = i, t;
  }
  function xt(i) {
    return mt[i];
  }
  function Rx(i) {
    i < 132 || (mt[i] = Ci, Ci = i);
  }
  function Ns(i) {
    const t = xt(i);
    return Rx(i), t;
  }
  function et(i) {
    return i == null;
  }
  let gs = null;
  function Ls() {
    return (gs === null || gs.byteLength === 0) && (gs = new Float64Array(f.memory.buffer)), gs;
  }
  let ms = null;
  function It() {
    return (ms === null || ms.byteLength === 0) && (ms = new Int32Array(f.memory.buffer)), ms;
  }
  const Px = typeof TextDecoder > "u" ? (0, module.require)("util").TextDecoder : TextDecoder;
  let Qf = new Px("utf-8", {
    ignoreBOM: true,
    fatal: true
  });
  Qf.decode();
  let bs = null;
  function Bx() {
    return (bs === null || bs.byteLength === 0) && (bs = new Uint8Array(f.memory.buffer)), bs;
  }
  function Mx(i, t) {
    return i = i >>> 0, Qf.decode(Bx().subarray(i, i + t));
  }
  function M(i, t) {
    if (!(i instanceof t)) throw new Error(`expected instance of ${t.name}`);
    return i.ptr;
  }
  let ws = null;
  function lr() {
    return (ws === null || ws.byteLength === 0) && (ws = new Float32Array(f.memory.buffer)), ws;
  }
  let Rt = 128;
  function Gt(i) {
    if (Rt == 1) throw new Error("out of js stack");
    return mt[--Rt] = i, Rt;
  }
  function qu(i, t) {
    return i = i >>> 0, lr().subarray(i / 4, i / 4 + t);
  }
  let ys = null;
  function tp() {
    return (ys === null || ys.byteLength === 0) && (ys = new Uint32Array(f.memory.buffer)), ys;
  }
  function Dx(i, t) {
    return i = i >>> 0, tp().subarray(i / 4, i / 4 + t);
  }
  let Ae = 0;
  function Sr(i, t) {
    const e = t(i.length * 4, 4) >>> 0;
    return lr().set(i, e / 4), Ae = i.length, e;
  }
  function $u(i, t) {
    const e = t(i.length * 4, 4) >>> 0;
    return tp().set(i, e / 4), Ae = i.length, e;
  }
  function Ua(i, t) {
    try {
      return i.apply(this, t);
    } catch (e) {
      f.__wbindgen_exn_store(Vt(e));
    }
  }
  const wR = Object.freeze({
    Dynamic: 0,
    0: "Dynamic",
    Fixed: 1,
    1: "Fixed",
    KinematicPositionBased: 2,
    2: "KinematicPositionBased",
    KinematicVelocityBased: 3,
    3: "KinematicVelocityBased"
  }), ue = Object.freeze({
    Ball: 0,
    0: "Ball",
    Cuboid: 1,
    1: "Cuboid",
    Capsule: 2,
    2: "Capsule",
    Segment: 3,
    3: "Segment",
    Polyline: 4,
    4: "Polyline",
    Triangle: 5,
    5: "Triangle",
    TriMesh: 6,
    6: "TriMesh",
    HeightField: 7,
    7: "HeightField",
    Compound: 8,
    8: "Compound",
    ConvexPolygon: 9,
    9: "ConvexPolygon",
    RoundCuboid: 10,
    10: "RoundCuboid",
    RoundTriangle: 11,
    11: "RoundTriangle",
    RoundConvexPolygon: 12,
    12: "RoundConvexPolygon",
    HalfSpace: 13,
    13: "HalfSpace"
  }), cr = Object.freeze({
    Revolute: 0,
    0: "Revolute",
    Fixed: 1,
    1: "Fixed",
    Prismatic: 2,
    2: "Prismatic",
    Rope: 3,
    3: "Rope",
    Spring: 4,
    4: "Spring",
    Generic: 5,
    5: "Generic"
  }), yR = Object.freeze({
    AccelerationBased: 0,
    0: "AccelerationBased",
    ForceBased: 1,
    1: "ForceBased"
  }), xR = Object.freeze({
    Vertex: 0,
    0: "Vertex",
    Face: 1,
    1: "Face",
    Unknown: 2,
    2: "Unknown"
  }), an = Object.freeze({
    LinX: 0,
    0: "LinX",
    LinY: 1,
    1: "LinY",
    AngX: 2,
    2: "AngX"
  }), Yu = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => f.__wbg_rawbroadphase_free(i >>> 0));
  class Mr {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(Mr.prototype);
      return e.__wbg_ptr = t, Yu.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, Yu.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawbroadphase_free(t);
    }
    constructor() {
      const t = f.rawbroadphase_new();
      return this.__wbg_ptr = t >>> 0, this;
    }
  }
  const Ix = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => f.__wbg_rawccdsolver_free(i >>> 0));
  class Xo {
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, Ix.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawccdsolver_free(t);
    }
    constructor() {
      const t = f.rawccdsolver_new();
      return this.__wbg_ptr = t >>> 0, this;
    }
  }
  const Fx = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => f.__wbg_rawcharactercollision_free(i >>> 0));
  class ep {
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, Fx.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawcharactercollision_free(t);
    }
    constructor() {
      const t = f.rawcharactercollision_new();
      return this.__wbg_ptr = t >>> 0, this;
    }
    handle() {
      return f.rawcharactercollision_handle(this.__wbg_ptr);
    }
    translationDeltaApplied() {
      const t = f.rawcharactercollision_translationDeltaApplied(this.__wbg_ptr);
      return F.__wrap(t);
    }
    translationDeltaRemaining() {
      const t = f.rawcharactercollision_translationDeltaRemaining(this.__wbg_ptr);
      return F.__wrap(t);
    }
    toi() {
      return f.rawcharactercollision_toi(this.__wbg_ptr);
    }
    worldWitness1() {
      const t = f.rawcharactercollision_worldWitness1(this.__wbg_ptr);
      return F.__wrap(t);
    }
    worldWitness2() {
      const t = f.rawcharactercollision_worldWitness2(this.__wbg_ptr);
      return F.__wrap(t);
    }
    worldNormal1() {
      const t = f.rawcharactercollision_worldNormal1(this.__wbg_ptr);
      return F.__wrap(t);
    }
    worldNormal2() {
      const t = f.rawcharactercollision_worldNormal2(this.__wbg_ptr);
      return F.__wrap(t);
    }
  }
  const Ku = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => f.__wbg_rawcolliderset_free(i >>> 0));
  class Nt {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(Nt.prototype);
      return e.__wbg_ptr = t, Ku.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, Ku.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawcolliderset_free(t);
    }
    coTranslation(t) {
      const e = f.rawcolliderset_coTranslation(this.__wbg_ptr, t);
      return F.__wrap(e);
    }
    coRotation(t) {
      const e = f.rawcolliderset_coRotation(this.__wbg_ptr, t);
      return bt.__wrap(e);
    }
    coSetTranslation(t, e, r) {
      f.rawcolliderset_coSetTranslation(this.__wbg_ptr, t, e, r);
    }
    coSetTranslationWrtParent(t, e, r) {
      f.rawcolliderset_coSetTranslationWrtParent(this.__wbg_ptr, t, e, r);
    }
    coSetRotation(t, e) {
      f.rawcolliderset_coSetRotation(this.__wbg_ptr, t, e);
    }
    coSetRotationWrtParent(t, e) {
      f.rawcolliderset_coSetRotationWrtParent(this.__wbg_ptr, t, e);
    }
    coIsSensor(t) {
      return f.rawcolliderset_coIsSensor(this.__wbg_ptr, t) !== 0;
    }
    coShapeType(t) {
      return f.rawcolliderset_coShapeType(this.__wbg_ptr, t);
    }
    coHalfspaceNormal(t) {
      const e = f.rawcolliderset_coHalfspaceNormal(this.__wbg_ptr, t);
      return e === 0 ? void 0 : F.__wrap(e);
    }
    coHalfExtents(t) {
      const e = f.rawcolliderset_coHalfExtents(this.__wbg_ptr, t);
      return e === 0 ? void 0 : F.__wrap(e);
    }
    coSetHalfExtents(t, e) {
      M(e, F), f.rawcolliderset_coSetHalfExtents(this.__wbg_ptr, t, e.__wbg_ptr);
    }
    coRadius(t) {
      try {
        const s = f.__wbindgen_add_to_stack_pointer(-16);
        f.rawcolliderset_coRadius(s, this.__wbg_ptr, t);
        var e = It()[s / 4 + 0], r = lr()[s / 4 + 1];
        return e === 0 ? void 0 : r;
      } finally {
        f.__wbindgen_add_to_stack_pointer(16);
      }
    }
    coSetRadius(t, e) {
      f.rawcolliderset_coSetRadius(this.__wbg_ptr, t, e);
    }
    coHalfHeight(t) {
      try {
        const s = f.__wbindgen_add_to_stack_pointer(-16);
        f.rawcolliderset_coHalfHeight(s, this.__wbg_ptr, t);
        var e = It()[s / 4 + 0], r = lr()[s / 4 + 1];
        return e === 0 ? void 0 : r;
      } finally {
        f.__wbindgen_add_to_stack_pointer(16);
      }
    }
    coSetHalfHeight(t, e) {
      f.rawcolliderset_coSetHalfHeight(this.__wbg_ptr, t, e);
    }
    coRoundRadius(t) {
      try {
        const s = f.__wbindgen_add_to_stack_pointer(-16);
        f.rawcolliderset_coRoundRadius(s, this.__wbg_ptr, t);
        var e = It()[s / 4 + 0], r = lr()[s / 4 + 1];
        return e === 0 ? void 0 : r;
      } finally {
        f.__wbindgen_add_to_stack_pointer(16);
      }
    }
    coSetRoundRadius(t, e) {
      f.rawcolliderset_coSetRoundRadius(this.__wbg_ptr, t, e);
    }
    coVertices(t) {
      try {
        const s = f.__wbindgen_add_to_stack_pointer(-16);
        f.rawcolliderset_coVertices(s, this.__wbg_ptr, t);
        var e = It()[s / 4 + 0], r = It()[s / 4 + 1];
        let n;
        return e !== 0 && (n = qu(e, r).slice(), f.__wbindgen_free(e, r * 4, 4)), n;
      } finally {
        f.__wbindgen_add_to_stack_pointer(16);
      }
    }
    coIndices(t) {
      try {
        const s = f.__wbindgen_add_to_stack_pointer(-16);
        f.rawcolliderset_coIndices(s, this.__wbg_ptr, t);
        var e = It()[s / 4 + 0], r = It()[s / 4 + 1];
        let n;
        return e !== 0 && (n = Dx(e, r).slice(), f.__wbindgen_free(e, r * 4, 4)), n;
      } finally {
        f.__wbindgen_add_to_stack_pointer(16);
      }
    }
    coTriMeshFlags(t) {
      try {
        const s = f.__wbindgen_add_to_stack_pointer(-16);
        f.rawcolliderset_coTriMeshFlags(s, this.__wbg_ptr, t);
        var e = It()[s / 4 + 0], r = It()[s / 4 + 1];
        return e === 0 ? void 0 : r >>> 0;
      } finally {
        f.__wbindgen_add_to_stack_pointer(16);
      }
    }
    coHeightfieldHeights(t) {
      try {
        const s = f.__wbindgen_add_to_stack_pointer(-16);
        f.rawcolliderset_coHeightfieldHeights(s, this.__wbg_ptr, t);
        var e = It()[s / 4 + 0], r = It()[s / 4 + 1];
        let n;
        return e !== 0 && (n = qu(e, r).slice(), f.__wbindgen_free(e, r * 4, 4)), n;
      } finally {
        f.__wbindgen_add_to_stack_pointer(16);
      }
    }
    coHeightfieldScale(t) {
      const e = f.rawcolliderset_coHeightfieldScale(this.__wbg_ptr, t);
      return e === 0 ? void 0 : F.__wrap(e);
    }
    coParent(t) {
      try {
        const s = f.__wbindgen_add_to_stack_pointer(-16);
        f.rawcolliderset_coParent(s, this.__wbg_ptr, t);
        var e = It()[s / 4 + 0], r = Ls()[s / 8 + 1];
        return e === 0 ? void 0 : r;
      } finally {
        f.__wbindgen_add_to_stack_pointer(16);
      }
    }
    coSetEnabled(t, e) {
      f.rawcolliderset_coSetEnabled(this.__wbg_ptr, t, e);
    }
    coIsEnabled(t) {
      return f.rawcolliderset_coIsEnabled(this.__wbg_ptr, t) !== 0;
    }
    coSetContactSkin(t, e) {
      f.rawcolliderset_coSetContactSkin(this.__wbg_ptr, t, e);
    }
    coContactSkin(t) {
      return f.rawcolliderset_coContactSkin(this.__wbg_ptr, t);
    }
    coFriction(t) {
      return f.rawcolliderset_coFriction(this.__wbg_ptr, t);
    }
    coRestitution(t) {
      return f.rawcolliderset_coRestitution(this.__wbg_ptr, t);
    }
    coDensity(t) {
      return f.rawcolliderset_coDensity(this.__wbg_ptr, t);
    }
    coMass(t) {
      return f.rawcolliderset_coMass(this.__wbg_ptr, t);
    }
    coVolume(t) {
      return f.rawcolliderset_coVolume(this.__wbg_ptr, t);
    }
    coCollisionGroups(t) {
      return f.rawcolliderset_coCollisionGroups(this.__wbg_ptr, t) >>> 0;
    }
    coSolverGroups(t) {
      return f.rawcolliderset_coSolverGroups(this.__wbg_ptr, t) >>> 0;
    }
    coActiveHooks(t) {
      return f.rawcolliderset_coActiveHooks(this.__wbg_ptr, t) >>> 0;
    }
    coActiveCollisionTypes(t) {
      return f.rawcolliderset_coActiveCollisionTypes(this.__wbg_ptr, t);
    }
    coActiveEvents(t) {
      return f.rawcolliderset_coActiveEvents(this.__wbg_ptr, t) >>> 0;
    }
    coContactForceEventThreshold(t) {
      return f.rawcolliderset_coContactForceEventThreshold(this.__wbg_ptr, t);
    }
    coContainsPoint(t, e) {
      return M(e, F), f.rawcolliderset_coContainsPoint(this.__wbg_ptr, t, e.__wbg_ptr) !== 0;
    }
    coCastShape(t, e, r, s, n, o, a, c, l) {
      M(e, F), M(r, ct), M(s, F), M(n, bt), M(o, F);
      const u = f.rawcolliderset_coCastShape(this.__wbg_ptr, t, e.__wbg_ptr, r.__wbg_ptr, s.__wbg_ptr, n.__wbg_ptr, o.__wbg_ptr, a, c, l);
      return u === 0 ? void 0 : dn.__wrap(u);
    }
    coCastCollider(t, e, r, s, n, o, a) {
      M(e, F), M(s, F);
      const c = f.rawcolliderset_coCastCollider(this.__wbg_ptr, t, e.__wbg_ptr, r, s.__wbg_ptr, n, o, a);
      return c === 0 ? void 0 : cn.__wrap(c);
    }
    coIntersectsShape(t, e, r, s) {
      return M(e, ct), M(r, F), M(s, bt), f.rawcolliderset_coIntersectsShape(this.__wbg_ptr, t, e.__wbg_ptr, r.__wbg_ptr, s.__wbg_ptr) !== 0;
    }
    coContactShape(t, e, r, s, n) {
      M(e, ct), M(r, F), M(s, bt);
      const o = f.rawcolliderset_coContactShape(this.__wbg_ptr, t, e.__wbg_ptr, r.__wbg_ptr, s.__wbg_ptr, n);
      return o === 0 ? void 0 : Bi.__wrap(o);
    }
    coContactCollider(t, e, r) {
      const s = f.rawcolliderset_coContactCollider(this.__wbg_ptr, t, e, r);
      return s === 0 ? void 0 : Bi.__wrap(s);
    }
    coProjectPoint(t, e, r) {
      M(e, F);
      const s = f.rawcolliderset_coProjectPoint(this.__wbg_ptr, t, e.__wbg_ptr, r);
      return un.__wrap(s);
    }
    coIntersectsRay(t, e, r, s) {
      return M(e, F), M(r, F), f.rawcolliderset_coIntersectsRay(this.__wbg_ptr, t, e.__wbg_ptr, r.__wbg_ptr, s) !== 0;
    }
    coCastRay(t, e, r, s, n) {
      return M(e, F), M(r, F), f.rawcolliderset_coCastRay(this.__wbg_ptr, t, e.__wbg_ptr, r.__wbg_ptr, s, n);
    }
    coCastRayAndGetNormal(t, e, r, s, n) {
      M(e, F), M(r, F);
      const o = f.rawcolliderset_coCastRayAndGetNormal(this.__wbg_ptr, t, e.__wbg_ptr, r.__wbg_ptr, s, n);
      return o === 0 ? void 0 : hn.__wrap(o);
    }
    coSetSensor(t, e) {
      f.rawcolliderset_coSetSensor(this.__wbg_ptr, t, e);
    }
    coSetRestitution(t, e) {
      f.rawcolliderset_coSetRestitution(this.__wbg_ptr, t, e);
    }
    coSetFriction(t, e) {
      f.rawcolliderset_coSetFriction(this.__wbg_ptr, t, e);
    }
    coFrictionCombineRule(t) {
      return f.rawcolliderset_coFrictionCombineRule(this.__wbg_ptr, t) >>> 0;
    }
    coSetFrictionCombineRule(t, e) {
      f.rawcolliderset_coSetFrictionCombineRule(this.__wbg_ptr, t, e);
    }
    coRestitutionCombineRule(t) {
      return f.rawcolliderset_coRestitutionCombineRule(this.__wbg_ptr, t) >>> 0;
    }
    coSetRestitutionCombineRule(t, e) {
      f.rawcolliderset_coSetRestitutionCombineRule(this.__wbg_ptr, t, e);
    }
    coSetCollisionGroups(t, e) {
      f.rawcolliderset_coSetCollisionGroups(this.__wbg_ptr, t, e);
    }
    coSetSolverGroups(t, e) {
      f.rawcolliderset_coSetSolverGroups(this.__wbg_ptr, t, e);
    }
    coSetActiveHooks(t, e) {
      f.rawcolliderset_coSetActiveHooks(this.__wbg_ptr, t, e);
    }
    coSetActiveEvents(t, e) {
      f.rawcolliderset_coSetActiveEvents(this.__wbg_ptr, t, e);
    }
    coSetActiveCollisionTypes(t, e) {
      f.rawcolliderset_coSetActiveCollisionTypes(this.__wbg_ptr, t, e);
    }
    coSetShape(t, e) {
      M(e, ct), f.rawcolliderset_coSetShape(this.__wbg_ptr, t, e.__wbg_ptr);
    }
    coSetContactForceEventThreshold(t, e) {
      f.rawcolliderset_coSetContactForceEventThreshold(this.__wbg_ptr, t, e);
    }
    coSetDensity(t, e) {
      f.rawcolliderset_coSetDensity(this.__wbg_ptr, t, e);
    }
    coSetMass(t, e) {
      f.rawcolliderset_coSetMass(this.__wbg_ptr, t, e);
    }
    coSetMassProperties(t, e, r, s) {
      M(r, F), f.rawcolliderset_coSetMassProperties(this.__wbg_ptr, t, e, r.__wbg_ptr, s);
    }
    constructor() {
      const t = f.rawcolliderset_new();
      return this.__wbg_ptr = t >>> 0, this;
    }
    len() {
      return f.rawcolliderset_len(this.__wbg_ptr) >>> 0;
    }
    contains(t) {
      return f.rawcolliderset_contains(this.__wbg_ptr, t) !== 0;
    }
    createCollider(t, e, r, s, n, o, a, c, l, u, h, d, p, g, y, m, v, S, C, G, H, Y, L, W) {
      try {
        const z = f.__wbindgen_add_to_stack_pointer(-16);
        M(e, ct), M(r, F), M(s, bt), M(a, F), M(W, Wt), f.rawcolliderset_createCollider(z, this.__wbg_ptr, t, e.__wbg_ptr, r.__wbg_ptr, s.__wbg_ptr, n, o, a.__wbg_ptr, c, l, u, h, d, p, g, y, m, v, S, C, G, H, Y, L, W.__wbg_ptr);
        var A = It()[z / 4 + 0], I = Ls()[z / 8 + 1];
        return A === 0 ? void 0 : I;
      } finally {
        f.__wbindgen_add_to_stack_pointer(16);
      }
    }
    remove(t, e, r, s) {
      M(e, er), M(r, Wt), f.rawcolliderset_remove(this.__wbg_ptr, t, e.__wbg_ptr, r.__wbg_ptr, s);
    }
    isHandleValid(t) {
      return f.rawcolliderset_contains(this.__wbg_ptr, t) !== 0;
    }
    forEachColliderHandle(t) {
      try {
        f.rawcolliderset_forEachColliderHandle(this.__wbg_ptr, Gt(t));
      } finally {
        mt[Rt++] = void 0;
      }
    }
  }
  const Ju = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => f.__wbg_rawcollidershapecasthit_free(i >>> 0));
  class cn {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(cn.prototype);
      return e.__wbg_ptr = t, Ju.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, Ju.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawcollidershapecasthit_free(t);
    }
    colliderHandle() {
      return f.rawcollidershapecasthit_colliderHandle(this.__wbg_ptr);
    }
    time_of_impact() {
      return f.rawcollidershapecasthit_time_of_impact(this.__wbg_ptr);
    }
    witness1() {
      const t = f.rawcollidershapecasthit_witness1(this.__wbg_ptr);
      return F.__wrap(t);
    }
    witness2() {
      const t = f.rawcollidershapecasthit_witness2(this.__wbg_ptr);
      return F.__wrap(t);
    }
    normal1() {
      const t = f.rawcollidershapecasthit_normal1(this.__wbg_ptr);
      return F.__wrap(t);
    }
    normal2() {
      const t = f.rawcollidershapecasthit_normal2(this.__wbg_ptr);
      return F.__wrap(t);
    }
  }
  const Zu = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => f.__wbg_rawcontactforceevent_free(i >>> 0));
  class ka {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(ka.prototype);
      return e.__wbg_ptr = t, Zu.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, Zu.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawcontactforceevent_free(t);
    }
    collider1() {
      return f.rawcollidershapecasthit_colliderHandle(this.__wbg_ptr);
    }
    collider2() {
      return f.rawcontactforceevent_collider2(this.__wbg_ptr);
    }
    total_force() {
      const t = f.rawcontactforceevent_total_force(this.__wbg_ptr);
      return F.__wrap(t);
    }
    total_force_magnitude() {
      return f.rawcontactforceevent_total_force_magnitude(this.__wbg_ptr);
    }
    max_force_direction() {
      const t = f.rawcharactercollision_translationDeltaApplied(this.__wbg_ptr);
      return F.__wrap(t);
    }
    max_force_magnitude() {
      return f.rawcontactforceevent_max_force_magnitude(this.__wbg_ptr);
    }
  }
  const Qu = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => f.__wbg_rawcontactmanifold_free(i >>> 0));
  class Ga {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(Ga.prototype);
      return e.__wbg_ptr = t, Qu.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, Qu.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawcontactmanifold_free(t);
    }
    normal() {
      const t = f.rawcontactmanifold_normal(this.__wbg_ptr);
      return F.__wrap(t);
    }
    local_n1() {
      const t = f.rawcontactmanifold_local_n1(this.__wbg_ptr);
      return F.__wrap(t);
    }
    local_n2() {
      const t = f.rawcontactmanifold_local_n2(this.__wbg_ptr);
      return F.__wrap(t);
    }
    subshape1() {
      return f.rawcontactmanifold_subshape1(this.__wbg_ptr) >>> 0;
    }
    subshape2() {
      return f.rawcontactmanifold_subshape2(this.__wbg_ptr) >>> 0;
    }
    num_contacts() {
      return f.rawcontactmanifold_num_contacts(this.__wbg_ptr) >>> 0;
    }
    contact_local_p1(t) {
      const e = f.rawcontactmanifold_contact_local_p1(this.__wbg_ptr, t);
      return e === 0 ? void 0 : F.__wrap(e);
    }
    contact_local_p2(t) {
      const e = f.rawcontactmanifold_contact_local_p2(this.__wbg_ptr, t);
      return e === 0 ? void 0 : F.__wrap(e);
    }
    contact_dist(t) {
      return f.rawcontactmanifold_contact_dist(this.__wbg_ptr, t);
    }
    contact_fid1(t) {
      return f.rawcontactmanifold_contact_fid1(this.__wbg_ptr, t) >>> 0;
    }
    contact_fid2(t) {
      return f.rawcontactmanifold_contact_fid2(this.__wbg_ptr, t) >>> 0;
    }
    contact_impulse(t) {
      return f.rawcontactmanifold_contact_impulse(this.__wbg_ptr, t);
    }
    contact_tangent_impulse(t) {
      return f.rawcontactmanifold_contact_tangent_impulse(this.__wbg_ptr, t);
    }
    num_solver_contacts() {
      return f.rawcontactmanifold_num_solver_contacts(this.__wbg_ptr) >>> 0;
    }
    solver_contact_point(t) {
      const e = f.rawcontactmanifold_solver_contact_point(this.__wbg_ptr, t);
      return e === 0 ? void 0 : F.__wrap(e);
    }
    solver_contact_dist(t) {
      return f.rawcontactmanifold_solver_contact_dist(this.__wbg_ptr, t);
    }
    solver_contact_friction(t) {
      return f.rawcontactmanifold_solver_contact_friction(this.__wbg_ptr, t);
    }
    solver_contact_restitution(t) {
      return f.rawcontactmanifold_solver_contact_restitution(this.__wbg_ptr, t);
    }
    solver_contact_tangent_velocity(t) {
      const e = f.rawcontactmanifold_solver_contact_tangent_velocity(this.__wbg_ptr, t);
      return F.__wrap(e);
    }
  }
  const tl = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => f.__wbg_rawcontactpair_free(i >>> 0));
  class Oa {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(Oa.prototype);
      return e.__wbg_ptr = t, tl.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, tl.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawcontactpair_free(t);
    }
    collider1() {
      return f.rawcontactpair_collider1(this.__wbg_ptr);
    }
    collider2() {
      return f.rawcontactpair_collider2(this.__wbg_ptr);
    }
    numContactManifolds() {
      return f.rawcontactpair_numContactManifolds(this.__wbg_ptr) >>> 0;
    }
    contactManifold(t) {
      const e = f.rawcontactpair_contactManifold(this.__wbg_ptr, t);
      return e === 0 ? void 0 : Ga.__wrap(e);
    }
  }
  const Ux = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => f.__wbg_rawdebugrenderpipeline_free(i >>> 0));
  class kx {
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, Ux.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawdebugrenderpipeline_free(t);
    }
    constructor() {
      const t = f.rawdebugrenderpipeline_new();
      return this.__wbg_ptr = t >>> 0, this;
    }
    vertices() {
      const t = f.rawdebugrenderpipeline_vertices(this.__wbg_ptr);
      return Ns(t);
    }
    colors() {
      const t = f.rawdebugrenderpipeline_colors(this.__wbg_ptr);
      return Ns(t);
    }
    render(t, e, r, s, n) {
      M(t, Wt), M(e, Nt), M(r, tr), M(s, rr), M(n, fr), f.rawdebugrenderpipeline_render(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, r.__wbg_ptr, s.__wbg_ptr, n.__wbg_ptr);
    }
  }
  const el = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => f.__wbg_rawdeserializedworld_free(i >>> 0));
  class Na {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(Na.prototype);
      return e.__wbg_ptr = t, el.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, el.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawdeserializedworld_free(t);
    }
    takeGravity() {
      const t = f.rawdeserializedworld_takeGravity(this.__wbg_ptr);
      return t === 0 ? void 0 : F.__wrap(t);
    }
    takeIntegrationParameters() {
      const t = f.rawdeserializedworld_takeIntegrationParameters(this.__wbg_ptr);
      return t === 0 ? void 0 : Dr.__wrap(t);
    }
    takeIslandManager() {
      const t = f.rawdeserializedworld_takeIslandManager(this.__wbg_ptr);
      return t === 0 ? void 0 : er.__wrap(t);
    }
    takeBroadPhase() {
      const t = f.rawdeserializedworld_takeBroadPhase(this.__wbg_ptr);
      return t === 0 ? void 0 : Mr.__wrap(t);
    }
    takeNarrowPhase() {
      const t = f.rawdeserializedworld_takeNarrowPhase(this.__wbg_ptr);
      return t === 0 ? void 0 : fr.__wrap(t);
    }
    takeBodies() {
      const t = f.rawdeserializedworld_takeBodies(this.__wbg_ptr);
      return t === 0 ? void 0 : Wt.__wrap(t);
    }
    takeColliders() {
      const t = f.rawdeserializedworld_takeColliders(this.__wbg_ptr);
      return t === 0 ? void 0 : Nt.__wrap(t);
    }
    takeImpulseJoints() {
      const t = f.rawdeserializedworld_takeImpulseJoints(this.__wbg_ptr);
      return t === 0 ? void 0 : tr.__wrap(t);
    }
    takeMultibodyJoints() {
      const t = f.rawdeserializedworld_takeMultibodyJoints(this.__wbg_ptr);
      return t === 0 ? void 0 : rr.__wrap(t);
    }
  }
  const Gx = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => f.__wbg_raweventqueue_free(i >>> 0));
  class Ox {
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, Gx.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_raweventqueue_free(t);
    }
    constructor(t) {
      const e = f.raweventqueue_new(t);
      return this.__wbg_ptr = e >>> 0, this;
    }
    drainCollisionEvents(t) {
      try {
        f.raweventqueue_drainCollisionEvents(this.__wbg_ptr, Gt(t));
      } finally {
        mt[Rt++] = void 0;
      }
    }
    drainContactForceEvents(t) {
      try {
        f.raweventqueue_drainContactForceEvents(this.__wbg_ptr, Gt(t));
      } finally {
        mt[Rt++] = void 0;
      }
    }
    clear() {
      f.raweventqueue_clear(this.__wbg_ptr);
    }
  }
  const rl = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => f.__wbg_rawgenericjoint_free(i >>> 0));
  class qe {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(qe.prototype);
      return e.__wbg_ptr = t, rl.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, rl.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawgenericjoint_free(t);
    }
    static spring(t, e, r, s, n) {
      M(s, F), M(n, F);
      const o = f.rawgenericjoint_spring(t, e, r, s.__wbg_ptr, n.__wbg_ptr);
      return qe.__wrap(o);
    }
    static rope(t, e, r) {
      M(e, F), M(r, F);
      const s = f.rawgenericjoint_rope(t, e.__wbg_ptr, r.__wbg_ptr);
      return qe.__wrap(s);
    }
    static prismatic(t, e, r, s, n, o) {
      M(t, F), M(e, F), M(r, F);
      const a = f.rawgenericjoint_prismatic(t.__wbg_ptr, e.__wbg_ptr, r.__wbg_ptr, s, n, o);
      return a === 0 ? void 0 : qe.__wrap(a);
    }
    static fixed(t, e, r, s) {
      M(t, F), M(e, bt), M(r, F), M(s, bt);
      const n = f.rawgenericjoint_fixed(t.__wbg_ptr, e.__wbg_ptr, r.__wbg_ptr, s.__wbg_ptr);
      return qe.__wrap(n);
    }
    static revolute(t, e) {
      M(t, F), M(e, F);
      const r = f.rawgenericjoint_revolute(t.__wbg_ptr, e.__wbg_ptr);
      return r === 0 ? void 0 : qe.__wrap(r);
    }
  }
  const il = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => f.__wbg_rawimpulsejointset_free(i >>> 0));
  class tr {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(tr.prototype);
      return e.__wbg_ptr = t, il.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, il.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawimpulsejointset_free(t);
    }
    jointType(t) {
      return f.rawimpulsejointset_jointType(this.__wbg_ptr, t);
    }
    jointBodyHandle1(t) {
      return f.rawimpulsejointset_jointBodyHandle1(this.__wbg_ptr, t);
    }
    jointBodyHandle2(t) {
      return f.rawimpulsejointset_jointBodyHandle2(this.__wbg_ptr, t);
    }
    jointFrameX1(t) {
      const e = f.rawimpulsejointset_jointFrameX1(this.__wbg_ptr, t);
      return bt.__wrap(e);
    }
    jointFrameX2(t) {
      const e = f.rawimpulsejointset_jointFrameX2(this.__wbg_ptr, t);
      return bt.__wrap(e);
    }
    jointAnchor1(t) {
      const e = f.rawimpulsejointset_jointAnchor1(this.__wbg_ptr, t);
      return F.__wrap(e);
    }
    jointAnchor2(t) {
      const e = f.rawimpulsejointset_jointAnchor2(this.__wbg_ptr, t);
      return F.__wrap(e);
    }
    jointSetAnchor1(t, e) {
      M(e, F), f.rawimpulsejointset_jointSetAnchor1(this.__wbg_ptr, t, e.__wbg_ptr);
    }
    jointSetAnchor2(t, e) {
      M(e, F), f.rawimpulsejointset_jointSetAnchor2(this.__wbg_ptr, t, e.__wbg_ptr);
    }
    jointContactsEnabled(t) {
      return f.rawimpulsejointset_jointContactsEnabled(this.__wbg_ptr, t) !== 0;
    }
    jointSetContactsEnabled(t, e) {
      f.rawimpulsejointset_jointSetContactsEnabled(this.__wbg_ptr, t, e);
    }
    jointLimitsEnabled(t, e) {
      return f.rawimpulsejointset_jointLimitsEnabled(this.__wbg_ptr, t, e) !== 0;
    }
    jointLimitsMin(t, e) {
      return f.rawimpulsejointset_jointLimitsMin(this.__wbg_ptr, t, e);
    }
    jointLimitsMax(t, e) {
      return f.rawimpulsejointset_jointLimitsMax(this.__wbg_ptr, t, e);
    }
    jointSetLimits(t, e, r, s) {
      f.rawimpulsejointset_jointSetLimits(this.__wbg_ptr, t, e, r, s);
    }
    jointConfigureMotorModel(t, e, r) {
      f.rawimpulsejointset_jointConfigureMotorModel(this.__wbg_ptr, t, e, r);
    }
    jointConfigureMotorVelocity(t, e, r, s) {
      f.rawimpulsejointset_jointConfigureMotorVelocity(this.__wbg_ptr, t, e, r, s);
    }
    jointConfigureMotorPosition(t, e, r, s, n) {
      f.rawimpulsejointset_jointConfigureMotorPosition(this.__wbg_ptr, t, e, r, s, n);
    }
    jointConfigureMotor(t, e, r, s, n, o) {
      f.rawimpulsejointset_jointConfigureMotor(this.__wbg_ptr, t, e, r, s, n, o);
    }
    constructor() {
      const t = f.rawimpulsejointset_new();
      return this.__wbg_ptr = t >>> 0, this;
    }
    createJoint(t, e, r, s) {
      return M(t, qe), f.rawimpulsejointset_createJoint(this.__wbg_ptr, t.__wbg_ptr, e, r, s);
    }
    remove(t, e) {
      f.rawimpulsejointset_remove(this.__wbg_ptr, t, e);
    }
    len() {
      return f.rawimpulsejointset_len(this.__wbg_ptr) >>> 0;
    }
    contains(t) {
      return f.rawimpulsejointset_contains(this.__wbg_ptr, t) !== 0;
    }
    forEachJointHandle(t) {
      try {
        f.rawimpulsejointset_forEachJointHandle(this.__wbg_ptr, Gt(t));
      } finally {
        mt[Rt++] = void 0;
      }
    }
    forEachJointAttachedToRigidBody(t, e) {
      try {
        f.rawimpulsejointset_forEachJointAttachedToRigidBody(this.__wbg_ptr, t, Gt(e));
      } finally {
        mt[Rt++] = void 0;
      }
    }
  }
  const sl = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => f.__wbg_rawintegrationparameters_free(i >>> 0));
  class Dr {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(Dr.prototype);
      return e.__wbg_ptr = t, sl.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, sl.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawintegrationparameters_free(t);
    }
    constructor() {
      const t = f.rawintegrationparameters_new();
      return this.__wbg_ptr = t >>> 0, this;
    }
    get dt() {
      return f.rawintegrationparameters_dt(this.__wbg_ptr);
    }
    get contact_erp() {
      return f.rawintegrationparameters_contact_erp(this.__wbg_ptr);
    }
    get normalizedAllowedLinearError() {
      return f.rawcontactforceevent_max_force_magnitude(this.__wbg_ptr);
    }
    get normalizedPredictionDistance() {
      return f.rawintegrationparameters_normalizedPredictionDistance(this.__wbg_ptr);
    }
    get numSolverIterations() {
      return f.rawintegrationparameters_numSolverIterations(this.__wbg_ptr) >>> 0;
    }
    get numAdditionalFrictionIterations() {
      return f.rawintegrationparameters_numAdditionalFrictionIterations(this.__wbg_ptr) >>> 0;
    }
    get numInternalPgsIterations() {
      return f.rawintegrationparameters_numInternalPgsIterations(this.__wbg_ptr) >>> 0;
    }
    get minIslandSize() {
      return f.rawimpulsejointset_len(this.__wbg_ptr) >>> 0;
    }
    get maxCcdSubsteps() {
      return f.rawintegrationparameters_maxCcdSubsteps(this.__wbg_ptr) >>> 0;
    }
    get lengthUnit() {
      return f.rawcontactforceevent_total_force_magnitude(this.__wbg_ptr);
    }
    set dt(t) {
      f.rawintegrationparameters_set_dt(this.__wbg_ptr, t);
    }
    set contact_natural_frequency(t) {
      f.rawintegrationparameters_set_contact_natural_frequency(this.__wbg_ptr, t);
    }
    set normalizedAllowedLinearError(t) {
      f.rawintegrationparameters_set_normalizedAllowedLinearError(this.__wbg_ptr, t);
    }
    set normalizedPredictionDistance(t) {
      f.rawintegrationparameters_set_normalizedPredictionDistance(this.__wbg_ptr, t);
    }
    set numSolverIterations(t) {
      f.rawintegrationparameters_set_numSolverIterations(this.__wbg_ptr, t);
    }
    set numAdditionalFrictionIterations(t) {
      f.rawintegrationparameters_set_numAdditionalFrictionIterations(this.__wbg_ptr, t);
    }
    set numInternalPgsIterations(t) {
      f.rawintegrationparameters_set_numInternalPgsIterations(this.__wbg_ptr, t);
    }
    set minIslandSize(t) {
      f.rawintegrationparameters_set_minIslandSize(this.__wbg_ptr, t);
    }
    set maxCcdSubsteps(t) {
      f.rawintegrationparameters_set_maxCcdSubsteps(this.__wbg_ptr, t);
    }
    set lengthUnit(t) {
      f.rawintegrationparameters_set_lengthUnit(this.__wbg_ptr, t);
    }
    switchToStandardPgsSolver() {
      f.rawintegrationparameters_switchToStandardPgsSolver(this.__wbg_ptr);
    }
    switchToSmallStepsPgsSolver() {
      f.rawintegrationparameters_switchToSmallStepsPgsSolver(this.__wbg_ptr);
    }
    switchToSmallStepsPgsSolverWithoutWarmstart() {
      f.rawintegrationparameters_switchToSmallStepsPgsSolverWithoutWarmstart(this.__wbg_ptr);
    }
  }
  const nl = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => f.__wbg_rawislandmanager_free(i >>> 0));
  class er {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(er.prototype);
      return e.__wbg_ptr = t, nl.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, nl.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawislandmanager_free(t);
    }
    constructor() {
      const t = f.rawislandmanager_new();
      return this.__wbg_ptr = t >>> 0, this;
    }
    forEachActiveRigidBodyHandle(t) {
      try {
        f.rawislandmanager_forEachActiveRigidBodyHandle(this.__wbg_ptr, Gt(t));
      } finally {
        mt[Rt++] = void 0;
      }
    }
  }
  const Nx = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => f.__wbg_rawkinematiccharactercontroller_free(i >>> 0));
  class Lx {
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, Nx.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawkinematiccharactercontroller_free(t);
    }
    constructor(t) {
      const e = f.rawkinematiccharactercontroller_new(t);
      return this.__wbg_ptr = e >>> 0, this;
    }
    up() {
      const t = f.rawcollidershapecasthit_normal2(this.__wbg_ptr);
      return F.__wrap(t);
    }
    setUp(t) {
      M(t, F), f.rawkinematiccharactercontroller_setUp(this.__wbg_ptr, t.__wbg_ptr);
    }
    normalNudgeFactor() {
      return f.rawkinematiccharactercontroller_normalNudgeFactor(this.__wbg_ptr);
    }
    setNormalNudgeFactor(t) {
      f.rawkinematiccharactercontroller_setNormalNudgeFactor(this.__wbg_ptr, t);
    }
    offset() {
      return f.rawintegrationparameters_dt(this.__wbg_ptr);
    }
    setOffset(t) {
      f.rawkinematiccharactercontroller_setOffset(this.__wbg_ptr, t);
    }
    slideEnabled() {
      return f.rawkinematiccharactercontroller_slideEnabled(this.__wbg_ptr) !== 0;
    }
    setSlideEnabled(t) {
      f.rawkinematiccharactercontroller_setSlideEnabled(this.__wbg_ptr, t);
    }
    autostepMaxHeight() {
      try {
        const r = f.__wbindgen_add_to_stack_pointer(-16);
        f.rawkinematiccharactercontroller_autostepMaxHeight(r, this.__wbg_ptr);
        var t = It()[r / 4 + 0], e = lr()[r / 4 + 1];
        return t === 0 ? void 0 : e;
      } finally {
        f.__wbindgen_add_to_stack_pointer(16);
      }
    }
    autostepMinWidth() {
      try {
        const r = f.__wbindgen_add_to_stack_pointer(-16);
        f.rawkinematiccharactercontroller_autostepMinWidth(r, this.__wbg_ptr);
        var t = It()[r / 4 + 0], e = lr()[r / 4 + 1];
        return t === 0 ? void 0 : e;
      } finally {
        f.__wbindgen_add_to_stack_pointer(16);
      }
    }
    autostepIncludesDynamicBodies() {
      const t = f.rawkinematiccharactercontroller_autostepIncludesDynamicBodies(this.__wbg_ptr);
      return t === 16777215 ? void 0 : t !== 0;
    }
    autostepEnabled() {
      return f.rawkinematiccharactercontroller_autostepEnabled(this.__wbg_ptr) !== 0;
    }
    enableAutostep(t, e, r) {
      f.rawkinematiccharactercontroller_enableAutostep(this.__wbg_ptr, t, e, r);
    }
    disableAutostep() {
      f.rawkinematiccharactercontroller_disableAutostep(this.__wbg_ptr);
    }
    maxSlopeClimbAngle() {
      return f.rawintegrationparameters_normalizedPredictionDistance(this.__wbg_ptr);
    }
    setMaxSlopeClimbAngle(t) {
      f.rawintegrationparameters_set_normalizedPredictionDistance(this.__wbg_ptr, t);
    }
    minSlopeSlideAngle() {
      return f.rawkinematiccharactercontroller_minSlopeSlideAngle(this.__wbg_ptr);
    }
    setMinSlopeSlideAngle(t) {
      f.rawkinematiccharactercontroller_setMinSlopeSlideAngle(this.__wbg_ptr, t);
    }
    snapToGroundDistance() {
      try {
        const r = f.__wbindgen_add_to_stack_pointer(-16);
        f.rawkinematiccharactercontroller_snapToGroundDistance(r, this.__wbg_ptr);
        var t = It()[r / 4 + 0], e = lr()[r / 4 + 1];
        return t === 0 ? void 0 : e;
      } finally {
        f.__wbindgen_add_to_stack_pointer(16);
      }
    }
    enableSnapToGround(t) {
      f.rawkinematiccharactercontroller_enableSnapToGround(this.__wbg_ptr, t);
    }
    disableSnapToGround() {
      f.rawkinematiccharactercontroller_disableSnapToGround(this.__wbg_ptr);
    }
    snapToGroundEnabled() {
      return f.rawkinematiccharactercontroller_snapToGroundEnabled(this.__wbg_ptr) !== 0;
    }
    computeColliderMovement(t, e, r, s, n, o, a, c, l, u, h) {
      try {
        M(e, Wt), M(r, Nt), M(s, rp), M(o, F), f.rawkinematiccharactercontroller_computeColliderMovement(this.__wbg_ptr, t, e.__wbg_ptr, r.__wbg_ptr, s.__wbg_ptr, n, o.__wbg_ptr, a, !et(c), et(c) ? 0 : c, l, !et(u), et(u) ? 0 : u, Gt(h));
      } finally {
        mt[Rt++] = void 0;
      }
    }
    computedMovement() {
      const t = f.rawkinematiccharactercontroller_computedMovement(this.__wbg_ptr);
      return F.__wrap(t);
    }
    computedGrounded() {
      return f.rawkinematiccharactercontroller_computedGrounded(this.__wbg_ptr) !== 0;
    }
    numComputedCollisions() {
      return f.rawkinematiccharactercontroller_numComputedCollisions(this.__wbg_ptr) >>> 0;
    }
    computedCollision(t, e) {
      return M(e, ep), f.rawkinematiccharactercontroller_computedCollision(this.__wbg_ptr, t, e.__wbg_ptr) !== 0;
    }
  }
  const ol = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => f.__wbg_rawmultibodyjointset_free(i >>> 0));
  class rr {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(rr.prototype);
      return e.__wbg_ptr = t, ol.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, ol.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawmultibodyjointset_free(t);
    }
    jointType(t) {
      return f.rawmultibodyjointset_jointType(this.__wbg_ptr, t);
    }
    jointFrameX1(t) {
      const e = f.rawmultibodyjointset_jointFrameX1(this.__wbg_ptr, t);
      return bt.__wrap(e);
    }
    jointFrameX2(t) {
      const e = f.rawmultibodyjointset_jointFrameX2(this.__wbg_ptr, t);
      return bt.__wrap(e);
    }
    jointAnchor1(t) {
      const e = f.rawmultibodyjointset_jointAnchor1(this.__wbg_ptr, t);
      return F.__wrap(e);
    }
    jointAnchor2(t) {
      const e = f.rawmultibodyjointset_jointAnchor2(this.__wbg_ptr, t);
      return F.__wrap(e);
    }
    jointContactsEnabled(t) {
      return f.rawmultibodyjointset_jointContactsEnabled(this.__wbg_ptr, t) !== 0;
    }
    jointSetContactsEnabled(t, e) {
      f.rawmultibodyjointset_jointSetContactsEnabled(this.__wbg_ptr, t, e);
    }
    jointLimitsEnabled(t, e) {
      return f.rawmultibodyjointset_jointLimitsEnabled(this.__wbg_ptr, t, e) !== 0;
    }
    jointLimitsMin(t, e) {
      return f.rawmultibodyjointset_jointLimitsMin(this.__wbg_ptr, t, e);
    }
    jointLimitsMax(t, e) {
      return f.rawmultibodyjointset_jointLimitsMax(this.__wbg_ptr, t, e);
    }
    constructor() {
      const t = f.rawmultibodyjointset_new();
      return this.__wbg_ptr = t >>> 0, this;
    }
    createJoint(t, e, r, s) {
      return M(t, qe), f.rawmultibodyjointset_createJoint(this.__wbg_ptr, t.__wbg_ptr, e, r, s);
    }
    remove(t, e) {
      f.rawmultibodyjointset_remove(this.__wbg_ptr, t, e);
    }
    contains(t) {
      return f.rawmultibodyjointset_contains(this.__wbg_ptr, t) !== 0;
    }
    forEachJointHandle(t) {
      try {
        f.rawmultibodyjointset_forEachJointHandle(this.__wbg_ptr, Gt(t));
      } finally {
        mt[Rt++] = void 0;
      }
    }
    forEachJointAttachedToRigidBody(t, e) {
      try {
        f.rawmultibodyjointset_forEachJointAttachedToRigidBody(this.__wbg_ptr, t, Gt(e));
      } finally {
        mt[Rt++] = void 0;
      }
    }
  }
  const al = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => f.__wbg_rawnarrowphase_free(i >>> 0));
  class fr {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(fr.prototype);
      return e.__wbg_ptr = t, al.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, al.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawnarrowphase_free(t);
    }
    constructor() {
      const t = f.rawnarrowphase_new();
      return this.__wbg_ptr = t >>> 0, this;
    }
    contact_pairs_with(t, e) {
      f.rawnarrowphase_contact_pairs_with(this.__wbg_ptr, t, Vt(e));
    }
    contact_pair(t, e) {
      const r = f.rawnarrowphase_contact_pair(this.__wbg_ptr, t, e);
      return r === 0 ? void 0 : Oa.__wrap(r);
    }
    intersection_pairs_with(t, e) {
      f.rawnarrowphase_intersection_pairs_with(this.__wbg_ptr, t, Vt(e));
    }
    intersection_pair(t, e) {
      return f.rawnarrowphase_intersection_pair(this.__wbg_ptr, t, e) !== 0;
    }
  }
  const Hx = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => f.__wbg_rawphysicspipeline_free(i >>> 0));
  class zx {
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, Hx.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawphysicspipeline_free(t);
    }
    constructor() {
      const t = f.rawphysicspipeline_new();
      return this.__wbg_ptr = t >>> 0, this;
    }
    step(t, e, r, s, n, o, a, c, l, u) {
      M(t, F), M(e, Dr), M(r, er), M(s, Mr), M(n, fr), M(o, Wt), M(a, Nt), M(c, tr), M(l, rr), M(u, Xo), f.rawphysicspipeline_step(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, r.__wbg_ptr, s.__wbg_ptr, n.__wbg_ptr, o.__wbg_ptr, a.__wbg_ptr, c.__wbg_ptr, l.__wbg_ptr, u.__wbg_ptr);
    }
    stepWithEvents(t, e, r, s, n, o, a, c, l, u, h, d, p, g) {
      M(t, F), M(e, Dr), M(r, er), M(s, Mr), M(n, fr), M(o, Wt), M(a, Nt), M(c, tr), M(l, rr), M(u, Xo), M(h, Ox), f.rawphysicspipeline_stepWithEvents(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, r.__wbg_ptr, s.__wbg_ptr, n.__wbg_ptr, o.__wbg_ptr, a.__wbg_ptr, c.__wbg_ptr, l.__wbg_ptr, u.__wbg_ptr, h.__wbg_ptr, Vt(d), Vt(p), Vt(g));
    }
  }
  const cl = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => f.__wbg_rawpointcolliderprojection_free(i >>> 0));
  class Hs {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(Hs.prototype);
      return e.__wbg_ptr = t, cl.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, cl.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawpointcolliderprojection_free(t);
    }
    colliderHandle() {
      return f.rawpointcolliderprojection_colliderHandle(this.__wbg_ptr);
    }
    point() {
      const t = f.rawpointcolliderprojection_point(this.__wbg_ptr);
      return F.__wrap(t);
    }
    isInside() {
      return f.rawpointcolliderprojection_isInside(this.__wbg_ptr) !== 0;
    }
    featureType() {
      return f.rawpointcolliderprojection_featureType(this.__wbg_ptr);
    }
    featureId() {
      try {
        const r = f.__wbindgen_add_to_stack_pointer(-16);
        f.rawpointcolliderprojection_featureId(r, this.__wbg_ptr);
        var t = It()[r / 4 + 0], e = It()[r / 4 + 1];
        return t === 0 ? void 0 : e >>> 0;
      } finally {
        f.__wbindgen_add_to_stack_pointer(16);
      }
    }
  }
  const ul = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => f.__wbg_rawpointprojection_free(i >>> 0));
  class un {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(un.prototype);
      return e.__wbg_ptr = t, ul.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, ul.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawpointprojection_free(t);
    }
    point() {
      const t = f.rawpointprojection_point(this.__wbg_ptr);
      return F.__wrap(t);
    }
    isInside() {
      return f.rawpointprojection_isInside(this.__wbg_ptr) !== 0;
    }
  }
  const jx = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => f.__wbg_rawquerypipeline_free(i >>> 0));
  class rp {
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, jx.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawquerypipeline_free(t);
    }
    constructor() {
      const t = f.rawquerypipeline_new();
      return this.__wbg_ptr = t >>> 0, this;
    }
    update(t) {
      M(t, Nt), f.rawquerypipeline_update(this.__wbg_ptr, t.__wbg_ptr);
    }
    castRay(t, e, r, s, n, o, a, c, l, u, h) {
      try {
        M(t, Wt), M(e, Nt), M(r, F), M(s, F);
        const d = f.rawquerypipeline_castRay(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, r.__wbg_ptr, s.__wbg_ptr, n, o, a, !et(c), et(c) ? 0 : c, !et(l), et(l) ? 0 : l, !et(u), et(u) ? 0 : u, Gt(h));
        return d === 0 ? void 0 : La.__wrap(d);
      } finally {
        mt[Rt++] = void 0;
      }
    }
    castRayAndGetNormal(t, e, r, s, n, o, a, c, l, u, h) {
      try {
        M(t, Wt), M(e, Nt), M(r, F), M(s, F);
        const d = f.rawquerypipeline_castRayAndGetNormal(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, r.__wbg_ptr, s.__wbg_ptr, n, o, a, !et(c), et(c) ? 0 : c, !et(l), et(l) ? 0 : l, !et(u), et(u) ? 0 : u, Gt(h));
        return d === 0 ? void 0 : ln.__wrap(d);
      } finally {
        mt[Rt++] = void 0;
      }
    }
    intersectionsWithRay(t, e, r, s, n, o, a, c, l, u, h, d) {
      try {
        M(t, Wt), M(e, Nt), M(r, F), M(s, F), f.rawquerypipeline_intersectionsWithRay(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, r.__wbg_ptr, s.__wbg_ptr, n, o, Gt(a), c, !et(l), et(l) ? 0 : l, !et(u), et(u) ? 0 : u, !et(h), et(h) ? 0 : h, Gt(d));
      } finally {
        mt[Rt++] = void 0, mt[Rt++] = void 0;
      }
    }
    intersectionWithShape(t, e, r, s, n, o, a, c, l, u) {
      try {
        const p = f.__wbindgen_add_to_stack_pointer(-16);
        M(t, Wt), M(e, Nt), M(r, F), M(s, bt), M(n, ct), f.rawquerypipeline_intersectionWithShape(p, this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, r.__wbg_ptr, s.__wbg_ptr, n.__wbg_ptr, o, !et(a), et(a) ? 0 : a, !et(c), et(c) ? 0 : c, !et(l), et(l) ? 0 : l, Gt(u));
        var h = It()[p / 4 + 0], d = Ls()[p / 8 + 1];
        return h === 0 ? void 0 : d;
      } finally {
        f.__wbindgen_add_to_stack_pointer(16), mt[Rt++] = void 0;
      }
    }
    projectPoint(t, e, r, s, n, o, a, c, l) {
      try {
        M(t, Wt), M(e, Nt), M(r, F);
        const u = f.rawquerypipeline_projectPoint(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, r.__wbg_ptr, s, n, !et(o), et(o) ? 0 : o, !et(a), et(a) ? 0 : a, !et(c), et(c) ? 0 : c, Gt(l));
        return u === 0 ? void 0 : Hs.__wrap(u);
      } finally {
        mt[Rt++] = void 0;
      }
    }
    projectPointAndGetFeature(t, e, r, s, n, o, a, c) {
      try {
        M(t, Wt), M(e, Nt), M(r, F);
        const l = f.rawquerypipeline_projectPointAndGetFeature(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, r.__wbg_ptr, s, !et(n), et(n) ? 0 : n, !et(o), et(o) ? 0 : o, !et(a), et(a) ? 0 : a, Gt(c));
        return l === 0 ? void 0 : Hs.__wrap(l);
      } finally {
        mt[Rt++] = void 0;
      }
    }
    intersectionsWithPoint(t, e, r, s, n, o, a, c, l) {
      try {
        M(t, Wt), M(e, Nt), M(r, F), f.rawquerypipeline_intersectionsWithPoint(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, r.__wbg_ptr, Gt(s), n, !et(o), et(o) ? 0 : o, !et(a), et(a) ? 0 : a, !et(c), et(c) ? 0 : c, Gt(l));
      } finally {
        mt[Rt++] = void 0, mt[Rt++] = void 0;
      }
    }
    castShape(t, e, r, s, n, o, a, c, l, u, h, d, p, g) {
      try {
        M(t, Wt), M(e, Nt), M(r, F), M(s, bt), M(n, F), M(o, ct);
        const y = f.rawquerypipeline_castShape(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, r.__wbg_ptr, s.__wbg_ptr, n.__wbg_ptr, o.__wbg_ptr, a, c, l, u, !et(h), et(h) ? 0 : h, !et(d), et(d) ? 0 : d, !et(p), et(p) ? 0 : p, Gt(g));
        return y === 0 ? void 0 : cn.__wrap(y);
      } finally {
        mt[Rt++] = void 0;
      }
    }
    intersectionsWithShape(t, e, r, s, n, o, a, c, l, u, h) {
      try {
        M(t, Wt), M(e, Nt), M(r, F), M(s, bt), M(n, ct), f.rawquerypipeline_intersectionsWithShape(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, r.__wbg_ptr, s.__wbg_ptr, n.__wbg_ptr, Gt(o), a, !et(c), et(c) ? 0 : c, !et(l), et(l) ? 0 : l, !et(u), et(u) ? 0 : u, Gt(h));
      } finally {
        mt[Rt++] = void 0, mt[Rt++] = void 0;
      }
    }
    collidersWithAabbIntersectingAabb(t, e, r) {
      try {
        M(t, F), M(e, F), f.rawquerypipeline_collidersWithAabbIntersectingAabb(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, Gt(r));
      } finally {
        mt[Rt++] = void 0;
      }
    }
  }
  const ll = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => f.__wbg_rawraycolliderhit_free(i >>> 0));
  class La {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(La.prototype);
      return e.__wbg_ptr = t, ll.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, ll.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawraycolliderhit_free(t);
    }
    colliderHandle() {
      return f.rawcollidershapecasthit_colliderHandle(this.__wbg_ptr);
    }
    timeOfImpact() {
      return f.rawcollidershapecasthit_time_of_impact(this.__wbg_ptr);
    }
  }
  const hl = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => f.__wbg_rawraycolliderintersection_free(i >>> 0));
  class ln {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(ln.prototype);
      return e.__wbg_ptr = t, hl.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, hl.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawraycolliderintersection_free(t);
    }
    colliderHandle() {
      return f.rawpointcolliderprojection_colliderHandle(this.__wbg_ptr);
    }
    normal() {
      const t = f.rawcollidershapecasthit_witness1(this.__wbg_ptr);
      return F.__wrap(t);
    }
    time_of_impact() {
      return f.rawcollidershapecasthit_time_of_impact(this.__wbg_ptr);
    }
    featureType() {
      return f.rawpointcolliderprojection_featureType(this.__wbg_ptr);
    }
    featureId() {
      try {
        const r = f.__wbindgen_add_to_stack_pointer(-16);
        f.rawpointcolliderprojection_featureId(r, this.__wbg_ptr);
        var t = It()[r / 4 + 0], e = It()[r / 4 + 1];
        return t === 0 ? void 0 : e >>> 0;
      } finally {
        f.__wbindgen_add_to_stack_pointer(16);
      }
    }
  }
  const dl = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => f.__wbg_rawrayintersection_free(i >>> 0));
  class hn {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(hn.prototype);
      return e.__wbg_ptr = t, dl.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, dl.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawrayintersection_free(t);
    }
    normal() {
      const t = f.rawcollidershapecasthit_witness1(this.__wbg_ptr);
      return F.__wrap(t);
    }
    time_of_impact() {
      return f.rawcollidershapecasthit_time_of_impact(this.__wbg_ptr);
    }
    featureType() {
      return f.rawpointcolliderprojection_featureType(this.__wbg_ptr);
    }
    featureId() {
      try {
        const r = f.__wbindgen_add_to_stack_pointer(-16);
        f.rawpointcolliderprojection_featureId(r, this.__wbg_ptr);
        var t = It()[r / 4 + 0], e = It()[r / 4 + 1];
        return t === 0 ? void 0 : e >>> 0;
      } finally {
        f.__wbindgen_add_to_stack_pointer(16);
      }
    }
  }
  const fl = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => f.__wbg_rawrigidbodyset_free(i >>> 0));
  class Wt {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(Wt.prototype);
      return e.__wbg_ptr = t, fl.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, fl.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawrigidbodyset_free(t);
    }
    rbTranslation(t) {
      const e = f.rawrigidbodyset_rbTranslation(this.__wbg_ptr, t);
      return F.__wrap(e);
    }
    rbRotation(t) {
      const e = f.rawrigidbodyset_rbRotation(this.__wbg_ptr, t);
      return bt.__wrap(e);
    }
    rbSleep(t) {
      f.rawrigidbodyset_rbSleep(this.__wbg_ptr, t);
    }
    rbIsSleeping(t) {
      return f.rawrigidbodyset_rbIsSleeping(this.__wbg_ptr, t) !== 0;
    }
    rbIsMoving(t) {
      return f.rawrigidbodyset_rbIsMoving(this.__wbg_ptr, t) !== 0;
    }
    rbNextTranslation(t) {
      const e = f.rawrigidbodyset_rbNextTranslation(this.__wbg_ptr, t);
      return F.__wrap(e);
    }
    rbNextRotation(t) {
      const e = f.rawrigidbodyset_rbNextRotation(this.__wbg_ptr, t);
      return bt.__wrap(e);
    }
    rbSetTranslation(t, e, r, s) {
      f.rawrigidbodyset_rbSetTranslation(this.__wbg_ptr, t, e, r, s);
    }
    rbSetRotation(t, e, r) {
      f.rawrigidbodyset_rbSetRotation(this.__wbg_ptr, t, e, r);
    }
    rbSetLinvel(t, e, r) {
      M(e, F), f.rawrigidbodyset_rbSetLinvel(this.__wbg_ptr, t, e.__wbg_ptr, r);
    }
    rbSetAngvel(t, e, r) {
      f.rawrigidbodyset_rbSetAngvel(this.__wbg_ptr, t, e, r);
    }
    rbSetNextKinematicTranslation(t, e, r) {
      f.rawrigidbodyset_rbSetNextKinematicTranslation(this.__wbg_ptr, t, e, r);
    }
    rbSetNextKinematicRotation(t, e) {
      f.rawrigidbodyset_rbSetNextKinematicRotation(this.__wbg_ptr, t, e);
    }
    rbRecomputeMassPropertiesFromColliders(t, e) {
      M(e, Nt), f.rawrigidbodyset_rbRecomputeMassPropertiesFromColliders(this.__wbg_ptr, t, e.__wbg_ptr);
    }
    rbSetAdditionalMass(t, e, r) {
      f.rawrigidbodyset_rbSetAdditionalMass(this.__wbg_ptr, t, e, r);
    }
    rbSetAdditionalMassProperties(t, e, r, s, n) {
      M(r, F), f.rawrigidbodyset_rbSetAdditionalMassProperties(this.__wbg_ptr, t, e, r.__wbg_ptr, s, n);
    }
    rbLinvel(t) {
      const e = f.rawrigidbodyset_rbLinvel(this.__wbg_ptr, t);
      return F.__wrap(e);
    }
    rbAngvel(t) {
      return f.rawrigidbodyset_rbAngvel(this.__wbg_ptr, t);
    }
    rbLockTranslations(t, e, r) {
      f.rawrigidbodyset_rbLockTranslations(this.__wbg_ptr, t, e, r);
    }
    rbSetEnabledTranslations(t, e, r, s) {
      f.rawrigidbodyset_rbSetEnabledTranslations(this.__wbg_ptr, t, e, r, s);
    }
    rbLockRotations(t, e, r) {
      f.rawrigidbodyset_rbLockRotations(this.__wbg_ptr, t, e, r);
    }
    rbDominanceGroup(t) {
      return f.rawrigidbodyset_rbDominanceGroup(this.__wbg_ptr, t);
    }
    rbSetDominanceGroup(t, e) {
      f.rawrigidbodyset_rbSetDominanceGroup(this.__wbg_ptr, t, e);
    }
    rbEnableCcd(t, e) {
      f.rawrigidbodyset_rbEnableCcd(this.__wbg_ptr, t, e);
    }
    rbSetSoftCcdPrediction(t, e) {
      f.rawrigidbodyset_rbSetSoftCcdPrediction(this.__wbg_ptr, t, e);
    }
    rbMass(t) {
      return f.rawrigidbodyset_rbMass(this.__wbg_ptr, t);
    }
    rbInvMass(t) {
      return f.rawrigidbodyset_rbInvMass(this.__wbg_ptr, t);
    }
    rbEffectiveInvMass(t) {
      const e = f.rawrigidbodyset_rbEffectiveInvMass(this.__wbg_ptr, t);
      return F.__wrap(e);
    }
    rbLocalCom(t) {
      const e = f.rawrigidbodyset_rbLocalCom(this.__wbg_ptr, t);
      return F.__wrap(e);
    }
    rbWorldCom(t) {
      const e = f.rawrigidbodyset_rbWorldCom(this.__wbg_ptr, t);
      return F.__wrap(e);
    }
    rbInvPrincipalInertiaSqrt(t) {
      return f.rawrigidbodyset_rbInvPrincipalInertiaSqrt(this.__wbg_ptr, t);
    }
    rbPrincipalInertia(t) {
      return f.rawrigidbodyset_rbPrincipalInertia(this.__wbg_ptr, t);
    }
    rbEffectiveWorldInvInertiaSqrt(t) {
      return f.rawrigidbodyset_rbEffectiveWorldInvInertiaSqrt(this.__wbg_ptr, t);
    }
    rbEffectiveAngularInertia(t) {
      return f.rawrigidbodyset_rbEffectiveAngularInertia(this.__wbg_ptr, t);
    }
    rbWakeUp(t) {
      f.rawrigidbodyset_rbWakeUp(this.__wbg_ptr, t);
    }
    rbIsCcdEnabled(t) {
      return f.rawrigidbodyset_rbIsCcdEnabled(this.__wbg_ptr, t) !== 0;
    }
    rbSoftCcdPrediction(t) {
      return f.rawrigidbodyset_rbSoftCcdPrediction(this.__wbg_ptr, t);
    }
    rbNumColliders(t) {
      return f.rawrigidbodyset_rbNumColliders(this.__wbg_ptr, t) >>> 0;
    }
    rbCollider(t, e) {
      return f.rawrigidbodyset_rbCollider(this.__wbg_ptr, t, e);
    }
    rbBodyType(t) {
      return f.rawrigidbodyset_rbBodyType(this.__wbg_ptr, t);
    }
    rbSetBodyType(t, e, r) {
      f.rawrigidbodyset_rbSetBodyType(this.__wbg_ptr, t, e, r);
    }
    rbIsFixed(t) {
      return f.rawrigidbodyset_rbIsFixed(this.__wbg_ptr, t) !== 0;
    }
    rbIsKinematic(t) {
      return f.rawrigidbodyset_rbIsKinematic(this.__wbg_ptr, t) !== 0;
    }
    rbIsDynamic(t) {
      return f.rawrigidbodyset_rbIsDynamic(this.__wbg_ptr, t) !== 0;
    }
    rbLinearDamping(t) {
      return f.rawrigidbodyset_rbLinearDamping(this.__wbg_ptr, t);
    }
    rbAngularDamping(t) {
      return f.rawrigidbodyset_rbAngularDamping(this.__wbg_ptr, t);
    }
    rbSetLinearDamping(t, e) {
      f.rawrigidbodyset_rbSetLinearDamping(this.__wbg_ptr, t, e);
    }
    rbSetAngularDamping(t, e) {
      f.rawrigidbodyset_rbSetAngularDamping(this.__wbg_ptr, t, e);
    }
    rbSetEnabled(t, e) {
      f.rawrigidbodyset_rbSetEnabled(this.__wbg_ptr, t, e);
    }
    rbIsEnabled(t) {
      return f.rawrigidbodyset_rbIsEnabled(this.__wbg_ptr, t) !== 0;
    }
    rbGravityScale(t) {
      return f.rawrigidbodyset_rbGravityScale(this.__wbg_ptr, t);
    }
    rbSetGravityScale(t, e, r) {
      f.rawrigidbodyset_rbSetGravityScale(this.__wbg_ptr, t, e, r);
    }
    rbResetForces(t, e) {
      f.rawrigidbodyset_rbResetForces(this.__wbg_ptr, t, e);
    }
    rbResetTorques(t, e) {
      f.rawrigidbodyset_rbResetTorques(this.__wbg_ptr, t, e);
    }
    rbAddForce(t, e, r) {
      M(e, F), f.rawrigidbodyset_rbAddForce(this.__wbg_ptr, t, e.__wbg_ptr, r);
    }
    rbApplyImpulse(t, e, r) {
      M(e, F), f.rawrigidbodyset_rbApplyImpulse(this.__wbg_ptr, t, e.__wbg_ptr, r);
    }
    rbAddTorque(t, e, r) {
      f.rawrigidbodyset_rbAddTorque(this.__wbg_ptr, t, e, r);
    }
    rbApplyTorqueImpulse(t, e, r) {
      f.rawrigidbodyset_rbApplyTorqueImpulse(this.__wbg_ptr, t, e, r);
    }
    rbAddForceAtPoint(t, e, r, s) {
      M(e, F), M(r, F), f.rawrigidbodyset_rbAddForceAtPoint(this.__wbg_ptr, t, e.__wbg_ptr, r.__wbg_ptr, s);
    }
    rbApplyImpulseAtPoint(t, e, r, s) {
      M(e, F), M(r, F), f.rawrigidbodyset_rbApplyImpulseAtPoint(this.__wbg_ptr, t, e.__wbg_ptr, r.__wbg_ptr, s);
    }
    rbAdditionalSolverIterations(t) {
      return f.rawrigidbodyset_rbAdditionalSolverIterations(this.__wbg_ptr, t) >>> 0;
    }
    rbSetAdditionalSolverIterations(t, e) {
      f.rawrigidbodyset_rbSetAdditionalSolverIterations(this.__wbg_ptr, t, e);
    }
    rbUserData(t) {
      return f.rawrigidbodyset_rbUserData(this.__wbg_ptr, t) >>> 0;
    }
    rbSetUserData(t, e) {
      f.rawrigidbodyset_rbSetUserData(this.__wbg_ptr, t, e);
    }
    rbUserForce(t) {
      const e = f.rawrigidbodyset_rbUserForce(this.__wbg_ptr, t);
      return F.__wrap(e);
    }
    rbUserTorque(t) {
      return f.rawrigidbodyset_rbUserTorque(this.__wbg_ptr, t);
    }
    constructor() {
      const t = f.rawrigidbodyset_new();
      return this.__wbg_ptr = t >>> 0, this;
    }
    createRigidBody(t, e, r, s, n, o, a, c, l, u, h, d, p, g, y, m, v, S, C, G, H, Y) {
      return M(e, F), M(r, bt), M(a, F), M(c, F), f.rawrigidbodyset_createRigidBody(this.__wbg_ptr, t, e.__wbg_ptr, r.__wbg_ptr, s, n, o, a.__wbg_ptr, c.__wbg_ptr, l, u, h, d, p, g, y, m, v, S, C, G, H, Y);
    }
    remove(t, e, r, s, n) {
      M(e, er), M(r, Nt), M(s, tr), M(n, rr), f.rawrigidbodyset_remove(this.__wbg_ptr, t, e.__wbg_ptr, r.__wbg_ptr, s.__wbg_ptr, n.__wbg_ptr);
    }
    len() {
      return f.rawcolliderset_len(this.__wbg_ptr) >>> 0;
    }
    contains(t) {
      return f.rawrigidbodyset_contains(this.__wbg_ptr, t) !== 0;
    }
    forEachRigidBodyHandle(t) {
      try {
        f.rawrigidbodyset_forEachRigidBodyHandle(this.__wbg_ptr, Gt(t));
      } finally {
        mt[Rt++] = void 0;
      }
    }
    propagateModifiedBodyPositionsToColliders(t) {
      M(t, Nt), f.rawrigidbodyset_propagateModifiedBodyPositionsToColliders(this.__wbg_ptr, t.__wbg_ptr);
    }
  }
  const pl = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => f.__wbg_rawrotation_free(i >>> 0));
  class bt {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(bt.prototype);
      return e.__wbg_ptr = t, pl.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, pl.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawrotation_free(t);
    }
    static identity() {
      const t = f.rawrotation_identity();
      return bt.__wrap(t);
    }
    static fromAngle(t) {
      const e = f.rawrotation_fromAngle(t);
      return bt.__wrap(e);
    }
    get im() {
      return f.rawintegrationparameters_dt(this.__wbg_ptr);
    }
    get re() {
      return f.rawrotation_re(this.__wbg_ptr);
    }
    get angle() {
      return f.rawrotation_angle(this.__wbg_ptr);
    }
  }
  const Wx = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => f.__wbg_rawserializationpipeline_free(i >>> 0));
  class Vx {
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, Wx.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawserializationpipeline_free(t);
    }
    constructor() {
      const t = f.rawserializationpipeline_new();
      return this.__wbg_ptr = t >>> 0, this;
    }
    serializeAll(t, e, r, s, n, o, a, c, l) {
      M(t, F), M(e, Dr), M(r, er), M(s, Mr), M(n, fr), M(o, Wt), M(a, Nt), M(c, tr), M(l, rr);
      const u = f.rawserializationpipeline_serializeAll(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, r.__wbg_ptr, s.__wbg_ptr, n.__wbg_ptr, o.__wbg_ptr, a.__wbg_ptr, c.__wbg_ptr, l.__wbg_ptr);
      return Ns(u);
    }
    deserializeAll(t) {
      const e = f.rawserializationpipeline_deserializeAll(this.__wbg_ptr, Vt(t));
      return e === 0 ? void 0 : Na.__wrap(e);
    }
  }
  const _l = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => f.__wbg_rawshape_free(i >>> 0));
  class ct {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(ct.prototype);
      return e.__wbg_ptr = t, _l.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, _l.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawshape_free(t);
    }
    static cuboid(t, e) {
      const r = f.rawshape_cuboid(t, e);
      return ct.__wrap(r);
    }
    static roundCuboid(t, e, r) {
      const s = f.rawshape_roundCuboid(t, e, r);
      return ct.__wrap(s);
    }
    static ball(t) {
      const e = f.rawshape_ball(t);
      return ct.__wrap(e);
    }
    static halfspace(t) {
      M(t, F);
      const e = f.rawshape_halfspace(t.__wbg_ptr);
      return ct.__wrap(e);
    }
    static capsule(t, e) {
      const r = f.rawshape_capsule(t, e);
      return ct.__wrap(r);
    }
    static polyline(t, e) {
      const r = Sr(t, f.__wbindgen_malloc), s = Ae, n = $u(e, f.__wbindgen_malloc), o = Ae, a = f.rawshape_polyline(r, s, n, o);
      return ct.__wrap(a);
    }
    static trimesh(t, e, r) {
      const s = Sr(t, f.__wbindgen_malloc), n = Ae, o = $u(e, f.__wbindgen_malloc), a = Ae, c = f.rawshape_trimesh(s, n, o, a, r);
      return ct.__wrap(c);
    }
    static heightfield(t, e) {
      const r = Sr(t, f.__wbindgen_malloc), s = Ae;
      M(e, F);
      const n = f.rawshape_heightfield(r, s, e.__wbg_ptr);
      return ct.__wrap(n);
    }
    static segment(t, e) {
      M(t, F), M(e, F);
      const r = f.rawshape_segment(t.__wbg_ptr, e.__wbg_ptr);
      return ct.__wrap(r);
    }
    static triangle(t, e, r) {
      M(t, F), M(e, F), M(r, F);
      const s = f.rawshape_triangle(t.__wbg_ptr, e.__wbg_ptr, r.__wbg_ptr);
      return ct.__wrap(s);
    }
    static roundTriangle(t, e, r, s) {
      M(t, F), M(e, F), M(r, F);
      const n = f.rawshape_roundTriangle(t.__wbg_ptr, e.__wbg_ptr, r.__wbg_ptr, s);
      return ct.__wrap(n);
    }
    static convexHull(t) {
      const e = Sr(t, f.__wbindgen_malloc), r = Ae, s = f.rawshape_convexHull(e, r);
      return s === 0 ? void 0 : ct.__wrap(s);
    }
    static roundConvexHull(t, e) {
      const r = Sr(t, f.__wbindgen_malloc), s = Ae, n = f.rawshape_roundConvexHull(r, s, e);
      return n === 0 ? void 0 : ct.__wrap(n);
    }
    static convexPolyline(t) {
      const e = Sr(t, f.__wbindgen_malloc), r = Ae, s = f.rawshape_convexPolyline(e, r);
      return s === 0 ? void 0 : ct.__wrap(s);
    }
    static roundConvexPolyline(t, e) {
      const r = Sr(t, f.__wbindgen_malloc), s = Ae, n = f.rawshape_roundConvexPolyline(r, s, e);
      return n === 0 ? void 0 : ct.__wrap(n);
    }
    castShape(t, e, r, s, n, o, a, c, l, u) {
      M(t, F), M(e, bt), M(r, F), M(s, ct), M(n, F), M(o, bt), M(a, F);
      const h = f.rawshape_castShape(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, r.__wbg_ptr, s.__wbg_ptr, n.__wbg_ptr, o.__wbg_ptr, a.__wbg_ptr, c, l, u);
      return h === 0 ? void 0 : dn.__wrap(h);
    }
    intersectsShape(t, e, r, s, n) {
      return M(t, F), M(e, bt), M(r, ct), M(s, F), M(n, bt), f.rawshape_intersectsShape(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, r.__wbg_ptr, s.__wbg_ptr, n.__wbg_ptr) !== 0;
    }
    contactShape(t, e, r, s, n, o) {
      M(t, F), M(e, bt), M(r, ct), M(s, F), M(n, bt);
      const a = f.rawshape_contactShape(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, r.__wbg_ptr, s.__wbg_ptr, n.__wbg_ptr, o);
      return a === 0 ? void 0 : Bi.__wrap(a);
    }
    containsPoint(t, e, r) {
      return M(t, F), M(e, bt), M(r, F), f.rawshape_containsPoint(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, r.__wbg_ptr) !== 0;
    }
    projectPoint(t, e, r, s) {
      M(t, F), M(e, bt), M(r, F);
      const n = f.rawshape_projectPoint(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, r.__wbg_ptr, s);
      return un.__wrap(n);
    }
    intersectsRay(t, e, r, s, n) {
      return M(t, F), M(e, bt), M(r, F), M(s, F), f.rawshape_intersectsRay(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, r.__wbg_ptr, s.__wbg_ptr, n) !== 0;
    }
    castRay(t, e, r, s, n, o) {
      return M(t, F), M(e, bt), M(r, F), M(s, F), f.rawshape_castRay(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, r.__wbg_ptr, s.__wbg_ptr, n, o);
    }
    castRayAndGetNormal(t, e, r, s, n, o) {
      M(t, F), M(e, bt), M(r, F), M(s, F);
      const a = f.rawshape_castRayAndGetNormal(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, r.__wbg_ptr, s.__wbg_ptr, n, o);
      return a === 0 ? void 0 : hn.__wrap(a);
    }
  }
  const gl = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => f.__wbg_rawshapecasthit_free(i >>> 0));
  class dn {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(dn.prototype);
      return e.__wbg_ptr = t, gl.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, gl.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawshapecasthit_free(t);
    }
    time_of_impact() {
      return f.rawrotation_re(this.__wbg_ptr);
    }
    witness1() {
      const t = f.rawshapecasthit_witness1(this.__wbg_ptr);
      return F.__wrap(t);
    }
    witness2() {
      const t = f.rawcollidershapecasthit_witness1(this.__wbg_ptr);
      return F.__wrap(t);
    }
    normal1() {
      const t = f.rawcollidershapecasthit_witness2(this.__wbg_ptr);
      return F.__wrap(t);
    }
    normal2() {
      const t = f.rawcollidershapecasthit_normal1(this.__wbg_ptr);
      return F.__wrap(t);
    }
  }
  const ml = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => f.__wbg_rawshapecontact_free(i >>> 0));
  class Bi {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(Bi.prototype);
      return e.__wbg_ptr = t, ml.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, ml.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawshapecontact_free(t);
    }
    distance() {
      return f.rawcontactforceevent_total_force_magnitude(this.__wbg_ptr);
    }
    point1() {
      const t = f.rawpointprojection_point(this.__wbg_ptr);
      return F.__wrap(t);
    }
    point2() {
      const t = f.rawpointcolliderprojection_point(this.__wbg_ptr);
      return F.__wrap(t);
    }
    normal1() {
      const t = f.rawcontactforceevent_total_force(this.__wbg_ptr);
      return F.__wrap(t);
    }
    normal2() {
      const t = f.rawcharactercollision_translationDeltaApplied(this.__wbg_ptr);
      return F.__wrap(t);
    }
  }
  const bl = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => f.__wbg_rawvector_free(i >>> 0));
  class F {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(F.prototype);
      return e.__wbg_ptr = t, bl.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, bl.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawvector_free(t);
    }
    static zero() {
      const t = f.rawvector_zero();
      return F.__wrap(t);
    }
    constructor(t, e) {
      const r = f.rawvector_new(t, e);
      return this.__wbg_ptr = r >>> 0, this;
    }
    get x() {
      return f.rawrotation_re(this.__wbg_ptr);
    }
    set x(t) {
      f.rawvector_set_x(this.__wbg_ptr, t);
    }
    get y() {
      return f.rawintegrationparameters_dt(this.__wbg_ptr);
    }
    set y(t) {
      f.rawintegrationparameters_set_dt(this.__wbg_ptr, t);
    }
    xy() {
      const t = f.rawvector_xy(this.__wbg_ptr);
      return F.__wrap(t);
    }
    yx() {
      const t = f.rawvector_yx(this.__wbg_ptr);
      return F.__wrap(t);
    }
  }
  function Xx(i) {
    return Vt(i);
  }
  function qx(i) {
    const t = xt(i);
    return typeof t == "boolean" ? t ? 1 : 0 : 2;
  }
  function $x(i) {
    Ns(i);
  }
  function Yx(i, t) {
    const e = xt(t), r = typeof e == "number" ? e : void 0;
    Ls()[i / 8 + 1] = et(r) ? 0 : r, It()[i / 4 + 0] = !et(r);
  }
  function Kx(i) {
    return typeof xt(i) == "function";
  }
  function Jx(i) {
    const t = ln.__wrap(i);
    return Vt(t);
  }
  function Zx(i) {
    const t = ka.__wrap(i);
    return Vt(t);
  }
  function Qx() {
    return Ua(function(i, t, e) {
      const r = xt(i).call(xt(t), xt(e));
      return Vt(r);
    }, arguments);
  }
  function t2() {
    return Ua(function(i, t, e, r) {
      const s = xt(i).call(xt(t), xt(e), xt(r));
      return Vt(s);
    }, arguments);
  }
  function e2() {
    return Ua(function(i, t, e, r, s) {
      const n = xt(i).call(xt(t), xt(e), xt(r), xt(s));
      return Vt(n);
    }, arguments);
  }
  function r2(i, t, e, r) {
    const s = xt(i).bind(xt(t), xt(e), xt(r));
    return Vt(s);
  }
  function i2(i) {
    const t = xt(i).buffer;
    return Vt(t);
  }
  function s2(i, t, e) {
    const r = new Uint8Array(xt(i), t >>> 0, e >>> 0);
    return Vt(r);
  }
  function n2(i) {
    const t = new Uint8Array(xt(i));
    return Vt(t);
  }
  function o2(i, t, e) {
    xt(i).set(xt(t), e >>> 0);
  }
  function a2(i) {
    return xt(i).length;
  }
  function c2(i, t, e) {
    const r = new Float32Array(xt(i), t >>> 0, e >>> 0);
    return Vt(r);
  }
  function u2(i, t, e) {
    xt(i).set(xt(t), e >>> 0);
  }
  function l2(i) {
    return xt(i).length;
  }
  function h2(i) {
    const t = new Float32Array(i >>> 0);
    return Vt(t);
  }
  function d2(i, t) {
    throw new Error(Mx(i, t));
  }
  function f2() {
    const i = f.memory;
    return Vt(i);
  }
  URL = globalThis.URL;
  const _ = await Cx({
    "./rapier_wasm2d_bg.js": {
      __wbindgen_number_new: Xx,
      __wbindgen_boolean_get: qx,
      __wbindgen_object_drop_ref: $x,
      __wbindgen_number_get: Yx,
      __wbindgen_is_function: Kx,
      __wbg_rawraycolliderintersection_new: Jx,
      __wbg_rawcontactforceevent_new: Zx,
      __wbg_call_b3ca7c6051f9bec1: Qx,
      __wbg_call_8e7cb608789c2528: t2,
      __wbg_call_938992c832f74314: e2,
      __wbg_bind_4d857b598695205e: r2,
      __wbg_buffer_12d079cc21e14bdb: i2,
      __wbg_newwithbyteoffsetandlength_aa4a17c33a06e5cb: s2,
      __wbg_new_63b92bc8671ed464: n2,
      __wbg_set_a47bac70306a19a7: o2,
      __wbg_length_c20a40f15020d68a: a2,
      __wbg_newwithbyteoffsetandlength_4a659d079a1650e0: c2,
      __wbg_set_bd975934d1b1fddb: u2,
      __wbg_length_d25bbcbc3367f684: l2,
      __wbg_newwithlength_1e8b839a06de01c5: h2,
      __wbindgen_throw: d2,
      __wbindgen_memory: f2
    }
  }, Tx), p2 = _.memory, _2 = _.version, g2 = _.__wbg_rawkinematiccharactercontroller_free, m2 = _.rawkinematiccharactercontroller_new, b2 = _.rawkinematiccharactercontroller_setUp, w2 = _.rawkinematiccharactercontroller_normalNudgeFactor, y2 = _.rawkinematiccharactercontroller_setNormalNudgeFactor, x2 = _.rawkinematiccharactercontroller_setOffset, v2 = _.rawkinematiccharactercontroller_slideEnabled, S2 = _.rawkinematiccharactercontroller_setSlideEnabled, E2 = _.rawkinematiccharactercontroller_autostepMaxHeight, T2 = _.rawkinematiccharactercontroller_autostepMinWidth, C2 = _.rawkinematiccharactercontroller_autostepIncludesDynamicBodies, A2 = _.rawkinematiccharactercontroller_autostepEnabled, R2 = _.rawkinematiccharactercontroller_enableAutostep, P2 = _.rawkinematiccharactercontroller_disableAutostep, B2 = _.rawkinematiccharactercontroller_minSlopeSlideAngle, M2 = _.rawkinematiccharactercontroller_setMinSlopeSlideAngle, D2 = _.rawkinematiccharactercontroller_snapToGroundDistance, I2 = _.rawkinematiccharactercontroller_enableSnapToGround, F2 = _.rawkinematiccharactercontroller_disableSnapToGround, U2 = _.rawkinematiccharactercontroller_snapToGroundEnabled, k2 = _.rawkinematiccharactercontroller_computeColliderMovement, G2 = _.rawkinematiccharactercontroller_computedMovement, O2 = _.rawkinematiccharactercontroller_computedGrounded, N2 = _.rawkinematiccharactercontroller_numComputedCollisions, L2 = _.rawkinematiccharactercontroller_computedCollision, H2 = _.__wbg_rawcharactercollision_free, z2 = _.rawcharactercollision_new, j2 = _.rawcharactercollision_handle, W2 = _.rawcharactercollision_translationDeltaApplied, V2 = _.rawcharactercollision_translationDeltaRemaining, X2 = _.rawcharactercollision_toi, q2 = _.rawcharactercollision_worldWitness1, $2 = _.rawcharactercollision_worldWitness2, Y2 = _.rawcharactercollision_worldNormal1, K2 = _.rawcharactercollision_worldNormal2, J2 = _.__wbg_rawccdsolver_free, Z2 = _.rawccdsolver_new, Q2 = _.rawimpulsejointset_jointType, tv = _.rawimpulsejointset_jointBodyHandle1, ev = _.rawimpulsejointset_jointBodyHandle2, rv = _.rawimpulsejointset_jointFrameX1, iv = _.rawimpulsejointset_jointFrameX2, sv = _.rawimpulsejointset_jointAnchor1, nv = _.rawimpulsejointset_jointAnchor2, ov = _.rawimpulsejointset_jointSetAnchor1, av = _.rawimpulsejointset_jointSetAnchor2, cv = _.rawimpulsejointset_jointContactsEnabled, uv = _.rawimpulsejointset_jointSetContactsEnabled, lv = _.rawimpulsejointset_jointLimitsEnabled, hv = _.rawimpulsejointset_jointLimitsMin, dv = _.rawimpulsejointset_jointLimitsMax, fv = _.rawimpulsejointset_jointSetLimits, pv = _.rawimpulsejointset_jointConfigureMotorModel, _v = _.rawimpulsejointset_jointConfigureMotorVelocity, gv = _.rawimpulsejointset_jointConfigureMotorPosition, mv = _.rawimpulsejointset_jointConfigureMotor, bv = _.__wbg_rawimpulsejointset_free, wv = _.rawimpulsejointset_new, yv = _.rawimpulsejointset_createJoint, xv = _.rawimpulsejointset_remove, vv = _.rawimpulsejointset_len, Sv = _.rawimpulsejointset_contains, Ev = _.rawimpulsejointset_forEachJointHandle, Tv = _.rawimpulsejointset_forEachJointAttachedToRigidBody, Cv = _.__wbg_rawintegrationparameters_free, Av = _.rawintegrationparameters_new, Rv = _.rawintegrationparameters_dt, Pv = _.rawintegrationparameters_contact_erp, Bv = _.rawintegrationparameters_normalizedPredictionDistance, Mv = _.rawintegrationparameters_numSolverIterations, Dv = _.rawintegrationparameters_numAdditionalFrictionIterations, Iv = _.rawintegrationparameters_numInternalPgsIterations, Fv = _.rawintegrationparameters_maxCcdSubsteps, Uv = _.rawintegrationparameters_set_dt, kv = _.rawintegrationparameters_set_contact_natural_frequency, Gv = _.rawintegrationparameters_set_normalizedAllowedLinearError, Ov = _.rawintegrationparameters_set_normalizedPredictionDistance, Nv = _.rawintegrationparameters_set_numSolverIterations, Lv = _.rawintegrationparameters_set_numAdditionalFrictionIterations, Hv = _.rawintegrationparameters_set_numInternalPgsIterations, zv = _.rawintegrationparameters_set_minIslandSize, jv = _.rawintegrationparameters_set_maxCcdSubsteps, Wv = _.rawintegrationparameters_set_lengthUnit, Vv = _.rawintegrationparameters_switchToStandardPgsSolver, Xv = _.rawintegrationparameters_switchToSmallStepsPgsSolver, qv = _.rawintegrationparameters_switchToSmallStepsPgsSolverWithoutWarmstart, $v = _.__wbg_rawislandmanager_free, Yv = _.rawislandmanager_new, Kv = _.rawislandmanager_forEachActiveRigidBodyHandle, Jv = _.__wbg_rawgenericjoint_free, Zv = _.rawgenericjoint_spring, Qv = _.rawgenericjoint_rope, t1 = _.rawgenericjoint_prismatic, e1 = _.rawgenericjoint_fixed, r1 = _.rawgenericjoint_revolute, i1 = _.rawmultibodyjointset_jointType, s1 = _.rawmultibodyjointset_jointFrameX1, n1 = _.rawmultibodyjointset_jointFrameX2, o1 = _.rawmultibodyjointset_jointAnchor1, a1 = _.rawmultibodyjointset_jointAnchor2, c1 = _.rawmultibodyjointset_jointContactsEnabled, u1 = _.rawmultibodyjointset_jointSetContactsEnabled, l1 = _.rawmultibodyjointset_jointLimitsEnabled, h1 = _.rawmultibodyjointset_jointLimitsMin, d1 = _.rawmultibodyjointset_jointLimitsMax, f1 = _.__wbg_rawmultibodyjointset_free, p1 = _.rawmultibodyjointset_new, _1 = _.rawmultibodyjointset_createJoint, g1 = _.rawmultibodyjointset_remove, m1 = _.rawmultibodyjointset_contains, b1 = _.rawmultibodyjointset_forEachJointHandle, w1 = _.rawmultibodyjointset_forEachJointAttachedToRigidBody, y1 = _.rawrigidbodyset_rbTranslation, x1 = _.rawrigidbodyset_rbRotation, v1 = _.rawrigidbodyset_rbSleep, S1 = _.rawrigidbodyset_rbIsSleeping, E1 = _.rawrigidbodyset_rbIsMoving, T1 = _.rawrigidbodyset_rbNextTranslation, C1 = _.rawrigidbodyset_rbNextRotation, A1 = _.rawrigidbodyset_rbSetTranslation, R1 = _.rawrigidbodyset_rbSetRotation, P1 = _.rawrigidbodyset_rbSetLinvel, B1 = _.rawrigidbodyset_rbSetAngvel, M1 = _.rawrigidbodyset_rbSetNextKinematicTranslation, D1 = _.rawrigidbodyset_rbSetNextKinematicRotation, I1 = _.rawrigidbodyset_rbRecomputeMassPropertiesFromColliders, F1 = _.rawrigidbodyset_rbSetAdditionalMass, U1 = _.rawrigidbodyset_rbSetAdditionalMassProperties, k1 = _.rawrigidbodyset_rbLinvel, G1 = _.rawrigidbodyset_rbAngvel, O1 = _.rawrigidbodyset_rbLockTranslations, N1 = _.rawrigidbodyset_rbSetEnabledTranslations, L1 = _.rawrigidbodyset_rbLockRotations, H1 = _.rawrigidbodyset_rbDominanceGroup, z1 = _.rawrigidbodyset_rbSetDominanceGroup, j1 = _.rawrigidbodyset_rbEnableCcd, W1 = _.rawrigidbodyset_rbSetSoftCcdPrediction, V1 = _.rawrigidbodyset_rbMass, X1 = _.rawrigidbodyset_rbInvMass, q1 = _.rawrigidbodyset_rbEffectiveInvMass, $1 = _.rawrigidbodyset_rbLocalCom, Y1 = _.rawrigidbodyset_rbWorldCom, K1 = _.rawrigidbodyset_rbInvPrincipalInertiaSqrt, J1 = _.rawrigidbodyset_rbPrincipalInertia, Z1 = _.rawrigidbodyset_rbEffectiveWorldInvInertiaSqrt, Q1 = _.rawrigidbodyset_rbEffectiveAngularInertia, tS = _.rawrigidbodyset_rbWakeUp, eS = _.rawrigidbodyset_rbIsCcdEnabled, rS = _.rawrigidbodyset_rbSoftCcdPrediction, iS = _.rawrigidbodyset_rbNumColliders, sS = _.rawrigidbodyset_rbCollider, nS = _.rawrigidbodyset_rbBodyType, oS = _.rawrigidbodyset_rbSetBodyType, aS = _.rawrigidbodyset_rbIsFixed, cS = _.rawrigidbodyset_rbIsKinematic, uS = _.rawrigidbodyset_rbIsDynamic, lS = _.rawrigidbodyset_rbLinearDamping, hS = _.rawrigidbodyset_rbAngularDamping, dS = _.rawrigidbodyset_rbSetLinearDamping, fS = _.rawrigidbodyset_rbSetAngularDamping, pS = _.rawrigidbodyset_rbSetEnabled, _S = _.rawrigidbodyset_rbIsEnabled, gS = _.rawrigidbodyset_rbGravityScale, mS = _.rawrigidbodyset_rbSetGravityScale, bS = _.rawrigidbodyset_rbResetForces, wS = _.rawrigidbodyset_rbResetTorques, yS = _.rawrigidbodyset_rbAddForce, xS = _.rawrigidbodyset_rbApplyImpulse, vS = _.rawrigidbodyset_rbAddTorque, SS = _.rawrigidbodyset_rbApplyTorqueImpulse, ES = _.rawrigidbodyset_rbAddForceAtPoint, TS = _.rawrigidbodyset_rbApplyImpulseAtPoint, CS = _.rawrigidbodyset_rbAdditionalSolverIterations, AS = _.rawrigidbodyset_rbSetAdditionalSolverIterations, RS = _.rawrigidbodyset_rbUserData, PS = _.rawrigidbodyset_rbSetUserData, BS = _.rawrigidbodyset_rbUserForce, MS = _.rawrigidbodyset_rbUserTorque, DS = _.__wbg_rawrigidbodyset_free, IS = _.rawrigidbodyset_new, FS = _.rawrigidbodyset_createRigidBody, US = _.rawrigidbodyset_remove, kS = _.rawrigidbodyset_contains, GS = _.rawrigidbodyset_forEachRigidBodyHandle, OS = _.rawrigidbodyset_propagateModifiedBodyPositionsToColliders, NS = _.__wbg_rawbroadphase_free, LS = _.rawbroadphase_new, HS = _.rawcolliderset_coTranslation, zS = _.rawcolliderset_coRotation, jS = _.rawcolliderset_coSetTranslation, WS = _.rawcolliderset_coSetTranslationWrtParent, VS = _.rawcolliderset_coSetRotation, XS = _.rawcolliderset_coSetRotationWrtParent, qS = _.rawcolliderset_coIsSensor, $S = _.rawcolliderset_coShapeType, YS = _.rawcolliderset_coHalfspaceNormal, KS = _.rawcolliderset_coHalfExtents, JS = _.rawcolliderset_coSetHalfExtents, ZS = _.rawcolliderset_coRadius, QS = _.rawcolliderset_coSetRadius, tE = _.rawcolliderset_coHalfHeight, eE = _.rawcolliderset_coSetHalfHeight, rE = _.rawcolliderset_coRoundRadius, iE = _.rawcolliderset_coSetRoundRadius, sE = _.rawcolliderset_coVertices, nE = _.rawcolliderset_coIndices, oE = _.rawcolliderset_coTriMeshFlags, aE = _.rawcolliderset_coHeightfieldHeights, cE = _.rawcolliderset_coHeightfieldScale, uE = _.rawcolliderset_coParent, lE = _.rawcolliderset_coSetEnabled, hE = _.rawcolliderset_coIsEnabled, dE = _.rawcolliderset_coSetContactSkin, fE = _.rawcolliderset_coContactSkin, pE = _.rawcolliderset_coFriction, _E = _.rawcolliderset_coRestitution, gE = _.rawcolliderset_coDensity, mE = _.rawcolliderset_coMass, bE = _.rawcolliderset_coVolume, wE = _.rawcolliderset_coCollisionGroups, yE = _.rawcolliderset_coSolverGroups, xE = _.rawcolliderset_coActiveHooks, vE = _.rawcolliderset_coActiveCollisionTypes, SE = _.rawcolliderset_coActiveEvents, EE = _.rawcolliderset_coContactForceEventThreshold, TE = _.rawcolliderset_coContainsPoint, CE = _.rawcolliderset_coCastShape, AE = _.rawcolliderset_coCastCollider, RE = _.rawcolliderset_coIntersectsShape, PE = _.rawcolliderset_coContactShape, BE = _.rawcolliderset_coContactCollider, ME = _.rawcolliderset_coProjectPoint, DE = _.rawcolliderset_coIntersectsRay, IE = _.rawcolliderset_coCastRay, FE = _.rawcolliderset_coCastRayAndGetNormal, UE = _.rawcolliderset_coSetSensor, kE = _.rawcolliderset_coSetRestitution, GE = _.rawcolliderset_coSetFriction, OE = _.rawcolliderset_coFrictionCombineRule, NE = _.rawcolliderset_coSetFrictionCombineRule, LE = _.rawcolliderset_coRestitutionCombineRule, HE = _.rawcolliderset_coSetRestitutionCombineRule, zE = _.rawcolliderset_coSetCollisionGroups, jE = _.rawcolliderset_coSetSolverGroups, WE = _.rawcolliderset_coSetActiveHooks, VE = _.rawcolliderset_coSetActiveEvents, XE = _.rawcolliderset_coSetActiveCollisionTypes, qE = _.rawcolliderset_coSetShape, $E = _.rawcolliderset_coSetContactForceEventThreshold, YE = _.rawcolliderset_coSetDensity, KE = _.rawcolliderset_coSetMass, JE = _.rawcolliderset_coSetMassProperties, ZE = _.__wbg_rawcolliderset_free, QE = _.rawcolliderset_new, tT = _.rawcolliderset_len, eT = _.rawcolliderset_contains, rT = _.rawcolliderset_createCollider, iT = _.rawcolliderset_remove, sT = _.rawcolliderset_forEachColliderHandle, nT = _.__wbg_rawshapecontact_free, oT = _.__wbg_rawnarrowphase_free, aT = _.rawnarrowphase_new, cT = _.rawnarrowphase_contact_pairs_with, uT = _.rawnarrowphase_contact_pair, lT = _.rawnarrowphase_intersection_pairs_with, hT = _.rawnarrowphase_intersection_pair, dT = _.__wbg_rawcontactmanifold_free, fT = _.rawcontactpair_collider1, pT = _.rawcontactpair_collider2, _T = _.rawcontactpair_numContactManifolds, gT = _.rawcontactpair_contactManifold, mT = _.rawcontactmanifold_normal, bT = _.rawcontactmanifold_local_n1, wT = _.rawcontactmanifold_local_n2, yT = _.rawcontactmanifold_subshape1, xT = _.rawcontactmanifold_subshape2, vT = _.rawcontactmanifold_num_contacts, ST = _.rawcontactmanifold_contact_local_p1, ET = _.rawcontactmanifold_contact_local_p2, TT = _.rawcontactmanifold_contact_dist, CT = _.rawcontactmanifold_contact_fid1, AT = _.rawcontactmanifold_contact_fid2, RT = _.rawcontactmanifold_contact_impulse, PT = _.rawcontactmanifold_contact_tangent_impulse, BT = _.rawcontactmanifold_num_solver_contacts, MT = _.rawcontactmanifold_solver_contact_point, DT = _.rawcontactmanifold_solver_contact_dist, IT = _.rawcontactmanifold_solver_contact_friction, FT = _.rawcontactmanifold_solver_contact_restitution, UT = _.rawcontactmanifold_solver_contact_tangent_velocity, kT = _.__wbg_rawpointprojection_free, GT = _.rawpointprojection_point, OT = _.rawpointprojection_isInside, NT = _.__wbg_rawpointcolliderprojection_free, LT = _.rawpointcolliderprojection_colliderHandle, HT = _.rawpointcolliderprojection_point, zT = _.rawpointcolliderprojection_isInside, jT = _.rawpointcolliderprojection_featureType, WT = _.rawpointcolliderprojection_featureId, VT = _.__wbg_rawrayintersection_free, XT = _.__wbg_rawshape_free, qT = _.rawshape_cuboid, $T = _.rawshape_roundCuboid, YT = _.rawshape_ball, KT = _.rawshape_halfspace, JT = _.rawshape_capsule, ZT = _.rawshape_polyline, QT = _.rawshape_trimesh, tC = _.rawshape_heightfield, eC = _.rawshape_segment, rC = _.rawshape_triangle, iC = _.rawshape_roundTriangle, sC = _.rawshape_convexHull, nC = _.rawshape_roundConvexHull, oC = _.rawshape_convexPolyline, aC = _.rawshape_roundConvexPolyline, cC = _.rawshape_castShape, uC = _.rawshape_intersectsShape, lC = _.rawshape_contactShape, hC = _.rawshape_containsPoint, dC = _.rawshape_projectPoint, fC = _.rawshape_intersectsRay, pC = _.rawshape_castRay, _C = _.rawshape_castRayAndGetNormal, gC = _.rawshapecasthit_witness1, mC = _.__wbg_rawcollidershapecasthit_free, bC = _.rawcollidershapecasthit_colliderHandle, wC = _.rawcollidershapecasthit_time_of_impact, yC = _.rawcollidershapecasthit_witness1, xC = _.rawcollidershapecasthit_witness2, vC = _.rawcollidershapecasthit_normal1, SC = _.rawcollidershapecasthit_normal2, EC = _.__wbg_rawrotation_free, TC = _.rawrotation_identity, CC = _.rawrotation_fromAngle, AC = _.rawrotation_re, RC = _.rawrotation_angle, PC = _.__wbg_rawvector_free, BC = _.rawvector_zero, MC = _.rawvector_new, DC = _.rawvector_set_x, IC = _.rawvector_xy, FC = _.rawvector_yx, UC = _.__wbg_rawdebugrenderpipeline_free, kC = _.rawdebugrenderpipeline_new, GC = _.rawdebugrenderpipeline_vertices, OC = _.rawdebugrenderpipeline_colors, NC = _.rawdebugrenderpipeline_render, LC = _.__wbg_raweventqueue_free, HC = _.__wbg_rawcontactforceevent_free, zC = _.rawcontactforceevent_collider2, jC = _.rawcontactforceevent_total_force, WC = _.rawcontactforceevent_total_force_magnitude, VC = _.rawcontactforceevent_max_force_magnitude, XC = _.raweventqueue_new, qC = _.raweventqueue_drainCollisionEvents, $C = _.raweventqueue_drainContactForceEvents, YC = _.raweventqueue_clear, KC = _.__wbg_rawphysicspipeline_free, JC = _.rawphysicspipeline_new, ZC = _.rawphysicspipeline_step, QC = _.rawphysicspipeline_stepWithEvents, tA = _.rawquerypipeline_new, eA = _.rawquerypipeline_update, rA = _.rawquerypipeline_castRay, iA = _.rawquerypipeline_castRayAndGetNormal, sA = _.rawquerypipeline_intersectionsWithRay, nA = _.rawquerypipeline_intersectionWithShape, oA = _.rawquerypipeline_projectPoint, aA = _.rawquerypipeline_projectPointAndGetFeature, cA = _.rawquerypipeline_intersectionsWithPoint, uA = _.rawquerypipeline_castShape, lA = _.rawquerypipeline_intersectionsWithShape, hA = _.rawquerypipeline_collidersWithAabbIntersectingAabb, dA = _.__wbg_rawdeserializedworld_free, fA = _.rawdeserializedworld_takeGravity, pA = _.rawdeserializedworld_takeIntegrationParameters, _A = _.rawdeserializedworld_takeIslandManager, gA = _.rawdeserializedworld_takeBroadPhase, mA = _.rawdeserializedworld_takeNarrowPhase, bA = _.rawdeserializedworld_takeBodies, wA = _.rawdeserializedworld_takeColliders, yA = _.rawdeserializedworld_takeImpulseJoints, xA = _.rawdeserializedworld_takeMultibodyJoints, vA = _.rawserializationpipeline_new, SA = _.rawserializationpipeline_serializeAll, EA = _.rawserializationpipeline_deserializeAll, TA = _.rawkinematiccharactercontroller_offset, CA = _.rawkinematiccharactercontroller_maxSlopeClimbAngle, AA = _.rawintegrationparameters_minIslandSize, RA = _.rawrigidbodyset_len, PA = _.rawshapecontact_distance, BA = _.rawrayintersection_featureType, MA = _.rawraycolliderintersection_colliderHandle, DA = _.rawrayintersection_time_of_impact, IA = _.rawraycolliderintersection_featureType, FA = _.rawraycolliderintersection_time_of_impact, UA = _.rawraycolliderhit_colliderHandle, kA = _.rawraycolliderhit_timeOfImpact, GA = _.rawrotation_im, OA = _.rawshapecasthit_time_of_impact, NA = _.rawvector_x, LA = _.rawvector_y, HA = _.rawcontactforceevent_collider1, zA = _.rawintegrationparameters_lengthUnit, jA = _.rawintegrationparameters_normalizedAllowedLinearError, WA = _.rawcolliderset_isHandleValid, VA = _.rawshapecontact_normal2, XA = _.rawshapecontact_point1, qA = _.rawshapecontact_point2, $A = _.rawrayintersection_normal, YA = _.rawshapecasthit_witness2, KA = _.rawraycolliderintersection_normal, JA = _.rawshapecasthit_normal1, ZA = _.rawshapecasthit_normal2, QA = _.rawkinematiccharactercontroller_up, t3 = _.rawshapecontact_normal1, e3 = _.rawcontactforceevent_max_force_direction, r3 = _.rawkinematiccharactercontroller_setMaxSlopeClimbAngle, i3 = _.rawvector_set_y, s3 = _.__wbg_rawcontactpair_free, n3 = _.__wbg_rawraycolliderintersection_free, o3 = _.__wbg_rawraycolliderhit_free, a3 = _.__wbg_rawshapecasthit_free, c3 = _.__wbg_rawserializationpipeline_free, u3 = _.rawrayintersection_featureId, l3 = _.rawraycolliderintersection_featureId, h3 = _.__wbg_rawquerypipeline_free, d3 = _.__wbindgen_add_to_stack_pointer, f3 = _.__wbindgen_free, p3 = _.__wbindgen_malloc, _3 = _.__wbindgen_exn_store, g3 = Object.freeze(Object.defineProperty({
    __proto__: null,
    __wbg_rawbroadphase_free: NS,
    __wbg_rawccdsolver_free: J2,
    __wbg_rawcharactercollision_free: H2,
    __wbg_rawcolliderset_free: ZE,
    __wbg_rawcollidershapecasthit_free: mC,
    __wbg_rawcontactforceevent_free: HC,
    __wbg_rawcontactmanifold_free: dT,
    __wbg_rawcontactpair_free: s3,
    __wbg_rawdebugrenderpipeline_free: UC,
    __wbg_rawdeserializedworld_free: dA,
    __wbg_raweventqueue_free: LC,
    __wbg_rawgenericjoint_free: Jv,
    __wbg_rawimpulsejointset_free: bv,
    __wbg_rawintegrationparameters_free: Cv,
    __wbg_rawislandmanager_free: $v,
    __wbg_rawkinematiccharactercontroller_free: g2,
    __wbg_rawmultibodyjointset_free: f1,
    __wbg_rawnarrowphase_free: oT,
    __wbg_rawphysicspipeline_free: KC,
    __wbg_rawpointcolliderprojection_free: NT,
    __wbg_rawpointprojection_free: kT,
    __wbg_rawquerypipeline_free: h3,
    __wbg_rawraycolliderhit_free: o3,
    __wbg_rawraycolliderintersection_free: n3,
    __wbg_rawrayintersection_free: VT,
    __wbg_rawrigidbodyset_free: DS,
    __wbg_rawrotation_free: EC,
    __wbg_rawserializationpipeline_free: c3,
    __wbg_rawshape_free: XT,
    __wbg_rawshapecasthit_free: a3,
    __wbg_rawshapecontact_free: nT,
    __wbg_rawvector_free: PC,
    __wbindgen_add_to_stack_pointer: d3,
    __wbindgen_exn_store: _3,
    __wbindgen_free: f3,
    __wbindgen_malloc: p3,
    memory: p2,
    rawbroadphase_new: LS,
    rawccdsolver_new: Z2,
    rawcharactercollision_handle: j2,
    rawcharactercollision_new: z2,
    rawcharactercollision_toi: X2,
    rawcharactercollision_translationDeltaApplied: W2,
    rawcharactercollision_translationDeltaRemaining: V2,
    rawcharactercollision_worldNormal1: Y2,
    rawcharactercollision_worldNormal2: K2,
    rawcharactercollision_worldWitness1: q2,
    rawcharactercollision_worldWitness2: $2,
    rawcolliderset_coActiveCollisionTypes: vE,
    rawcolliderset_coActiveEvents: SE,
    rawcolliderset_coActiveHooks: xE,
    rawcolliderset_coCastCollider: AE,
    rawcolliderset_coCastRay: IE,
    rawcolliderset_coCastRayAndGetNormal: FE,
    rawcolliderset_coCastShape: CE,
    rawcolliderset_coCollisionGroups: wE,
    rawcolliderset_coContactCollider: BE,
    rawcolliderset_coContactForceEventThreshold: EE,
    rawcolliderset_coContactShape: PE,
    rawcolliderset_coContactSkin: fE,
    rawcolliderset_coContainsPoint: TE,
    rawcolliderset_coDensity: gE,
    rawcolliderset_coFriction: pE,
    rawcolliderset_coFrictionCombineRule: OE,
    rawcolliderset_coHalfExtents: KS,
    rawcolliderset_coHalfHeight: tE,
    rawcolliderset_coHalfspaceNormal: YS,
    rawcolliderset_coHeightfieldHeights: aE,
    rawcolliderset_coHeightfieldScale: cE,
    rawcolliderset_coIndices: nE,
    rawcolliderset_coIntersectsRay: DE,
    rawcolliderset_coIntersectsShape: RE,
    rawcolliderset_coIsEnabled: hE,
    rawcolliderset_coIsSensor: qS,
    rawcolliderset_coMass: mE,
    rawcolliderset_coParent: uE,
    rawcolliderset_coProjectPoint: ME,
    rawcolliderset_coRadius: ZS,
    rawcolliderset_coRestitution: _E,
    rawcolliderset_coRestitutionCombineRule: LE,
    rawcolliderset_coRotation: zS,
    rawcolliderset_coRoundRadius: rE,
    rawcolliderset_coSetActiveCollisionTypes: XE,
    rawcolliderset_coSetActiveEvents: VE,
    rawcolliderset_coSetActiveHooks: WE,
    rawcolliderset_coSetCollisionGroups: zE,
    rawcolliderset_coSetContactForceEventThreshold: $E,
    rawcolliderset_coSetContactSkin: dE,
    rawcolliderset_coSetDensity: YE,
    rawcolliderset_coSetEnabled: lE,
    rawcolliderset_coSetFriction: GE,
    rawcolliderset_coSetFrictionCombineRule: NE,
    rawcolliderset_coSetHalfExtents: JS,
    rawcolliderset_coSetHalfHeight: eE,
    rawcolliderset_coSetMass: KE,
    rawcolliderset_coSetMassProperties: JE,
    rawcolliderset_coSetRadius: QS,
    rawcolliderset_coSetRestitution: kE,
    rawcolliderset_coSetRestitutionCombineRule: HE,
    rawcolliderset_coSetRotation: VS,
    rawcolliderset_coSetRotationWrtParent: XS,
    rawcolliderset_coSetRoundRadius: iE,
    rawcolliderset_coSetSensor: UE,
    rawcolliderset_coSetShape: qE,
    rawcolliderset_coSetSolverGroups: jE,
    rawcolliderset_coSetTranslation: jS,
    rawcolliderset_coSetTranslationWrtParent: WS,
    rawcolliderset_coShapeType: $S,
    rawcolliderset_coSolverGroups: yE,
    rawcolliderset_coTranslation: HS,
    rawcolliderset_coTriMeshFlags: oE,
    rawcolliderset_coVertices: sE,
    rawcolliderset_coVolume: bE,
    rawcolliderset_contains: eT,
    rawcolliderset_createCollider: rT,
    rawcolliderset_forEachColliderHandle: sT,
    rawcolliderset_isHandleValid: WA,
    rawcolliderset_len: tT,
    rawcolliderset_new: QE,
    rawcolliderset_remove: iT,
    rawcollidershapecasthit_colliderHandle: bC,
    rawcollidershapecasthit_normal1: vC,
    rawcollidershapecasthit_normal2: SC,
    rawcollidershapecasthit_time_of_impact: wC,
    rawcollidershapecasthit_witness1: yC,
    rawcollidershapecasthit_witness2: xC,
    rawcontactforceevent_collider1: HA,
    rawcontactforceevent_collider2: zC,
    rawcontactforceevent_max_force_direction: e3,
    rawcontactforceevent_max_force_magnitude: VC,
    rawcontactforceevent_total_force: jC,
    rawcontactforceevent_total_force_magnitude: WC,
    rawcontactmanifold_contact_dist: TT,
    rawcontactmanifold_contact_fid1: CT,
    rawcontactmanifold_contact_fid2: AT,
    rawcontactmanifold_contact_impulse: RT,
    rawcontactmanifold_contact_local_p1: ST,
    rawcontactmanifold_contact_local_p2: ET,
    rawcontactmanifold_contact_tangent_impulse: PT,
    rawcontactmanifold_local_n1: bT,
    rawcontactmanifold_local_n2: wT,
    rawcontactmanifold_normal: mT,
    rawcontactmanifold_num_contacts: vT,
    rawcontactmanifold_num_solver_contacts: BT,
    rawcontactmanifold_solver_contact_dist: DT,
    rawcontactmanifold_solver_contact_friction: IT,
    rawcontactmanifold_solver_contact_point: MT,
    rawcontactmanifold_solver_contact_restitution: FT,
    rawcontactmanifold_solver_contact_tangent_velocity: UT,
    rawcontactmanifold_subshape1: yT,
    rawcontactmanifold_subshape2: xT,
    rawcontactpair_collider1: fT,
    rawcontactpair_collider2: pT,
    rawcontactpair_contactManifold: gT,
    rawcontactpair_numContactManifolds: _T,
    rawdebugrenderpipeline_colors: OC,
    rawdebugrenderpipeline_new: kC,
    rawdebugrenderpipeline_render: NC,
    rawdebugrenderpipeline_vertices: GC,
    rawdeserializedworld_takeBodies: bA,
    rawdeserializedworld_takeBroadPhase: gA,
    rawdeserializedworld_takeColliders: wA,
    rawdeserializedworld_takeGravity: fA,
    rawdeserializedworld_takeImpulseJoints: yA,
    rawdeserializedworld_takeIntegrationParameters: pA,
    rawdeserializedworld_takeIslandManager: _A,
    rawdeserializedworld_takeMultibodyJoints: xA,
    rawdeserializedworld_takeNarrowPhase: mA,
    raweventqueue_clear: YC,
    raweventqueue_drainCollisionEvents: qC,
    raweventqueue_drainContactForceEvents: $C,
    raweventqueue_new: XC,
    rawgenericjoint_fixed: e1,
    rawgenericjoint_prismatic: t1,
    rawgenericjoint_revolute: r1,
    rawgenericjoint_rope: Qv,
    rawgenericjoint_spring: Zv,
    rawimpulsejointset_contains: Sv,
    rawimpulsejointset_createJoint: yv,
    rawimpulsejointset_forEachJointAttachedToRigidBody: Tv,
    rawimpulsejointset_forEachJointHandle: Ev,
    rawimpulsejointset_jointAnchor1: sv,
    rawimpulsejointset_jointAnchor2: nv,
    rawimpulsejointset_jointBodyHandle1: tv,
    rawimpulsejointset_jointBodyHandle2: ev,
    rawimpulsejointset_jointConfigureMotor: mv,
    rawimpulsejointset_jointConfigureMotorModel: pv,
    rawimpulsejointset_jointConfigureMotorPosition: gv,
    rawimpulsejointset_jointConfigureMotorVelocity: _v,
    rawimpulsejointset_jointContactsEnabled: cv,
    rawimpulsejointset_jointFrameX1: rv,
    rawimpulsejointset_jointFrameX2: iv,
    rawimpulsejointset_jointLimitsEnabled: lv,
    rawimpulsejointset_jointLimitsMax: dv,
    rawimpulsejointset_jointLimitsMin: hv,
    rawimpulsejointset_jointSetAnchor1: ov,
    rawimpulsejointset_jointSetAnchor2: av,
    rawimpulsejointset_jointSetContactsEnabled: uv,
    rawimpulsejointset_jointSetLimits: fv,
    rawimpulsejointset_jointType: Q2,
    rawimpulsejointset_len: vv,
    rawimpulsejointset_new: wv,
    rawimpulsejointset_remove: xv,
    rawintegrationparameters_contact_erp: Pv,
    rawintegrationparameters_dt: Rv,
    rawintegrationparameters_lengthUnit: zA,
    rawintegrationparameters_maxCcdSubsteps: Fv,
    rawintegrationparameters_minIslandSize: AA,
    rawintegrationparameters_new: Av,
    rawintegrationparameters_normalizedAllowedLinearError: jA,
    rawintegrationparameters_normalizedPredictionDistance: Bv,
    rawintegrationparameters_numAdditionalFrictionIterations: Dv,
    rawintegrationparameters_numInternalPgsIterations: Iv,
    rawintegrationparameters_numSolverIterations: Mv,
    rawintegrationparameters_set_contact_natural_frequency: kv,
    rawintegrationparameters_set_dt: Uv,
    rawintegrationparameters_set_lengthUnit: Wv,
    rawintegrationparameters_set_maxCcdSubsteps: jv,
    rawintegrationparameters_set_minIslandSize: zv,
    rawintegrationparameters_set_normalizedAllowedLinearError: Gv,
    rawintegrationparameters_set_normalizedPredictionDistance: Ov,
    rawintegrationparameters_set_numAdditionalFrictionIterations: Lv,
    rawintegrationparameters_set_numInternalPgsIterations: Hv,
    rawintegrationparameters_set_numSolverIterations: Nv,
    rawintegrationparameters_switchToSmallStepsPgsSolver: Xv,
    rawintegrationparameters_switchToSmallStepsPgsSolverWithoutWarmstart: qv,
    rawintegrationparameters_switchToStandardPgsSolver: Vv,
    rawislandmanager_forEachActiveRigidBodyHandle: Kv,
    rawislandmanager_new: Yv,
    rawkinematiccharactercontroller_autostepEnabled: A2,
    rawkinematiccharactercontroller_autostepIncludesDynamicBodies: C2,
    rawkinematiccharactercontroller_autostepMaxHeight: E2,
    rawkinematiccharactercontroller_autostepMinWidth: T2,
    rawkinematiccharactercontroller_computeColliderMovement: k2,
    rawkinematiccharactercontroller_computedCollision: L2,
    rawkinematiccharactercontroller_computedGrounded: O2,
    rawkinematiccharactercontroller_computedMovement: G2,
    rawkinematiccharactercontroller_disableAutostep: P2,
    rawkinematiccharactercontroller_disableSnapToGround: F2,
    rawkinematiccharactercontroller_enableAutostep: R2,
    rawkinematiccharactercontroller_enableSnapToGround: I2,
    rawkinematiccharactercontroller_maxSlopeClimbAngle: CA,
    rawkinematiccharactercontroller_minSlopeSlideAngle: B2,
    rawkinematiccharactercontroller_new: m2,
    rawkinematiccharactercontroller_normalNudgeFactor: w2,
    rawkinematiccharactercontroller_numComputedCollisions: N2,
    rawkinematiccharactercontroller_offset: TA,
    rawkinematiccharactercontroller_setMaxSlopeClimbAngle: r3,
    rawkinematiccharactercontroller_setMinSlopeSlideAngle: M2,
    rawkinematiccharactercontroller_setNormalNudgeFactor: y2,
    rawkinematiccharactercontroller_setOffset: x2,
    rawkinematiccharactercontroller_setSlideEnabled: S2,
    rawkinematiccharactercontroller_setUp: b2,
    rawkinematiccharactercontroller_slideEnabled: v2,
    rawkinematiccharactercontroller_snapToGroundDistance: D2,
    rawkinematiccharactercontroller_snapToGroundEnabled: U2,
    rawkinematiccharactercontroller_up: QA,
    rawmultibodyjointset_contains: m1,
    rawmultibodyjointset_createJoint: _1,
    rawmultibodyjointset_forEachJointAttachedToRigidBody: w1,
    rawmultibodyjointset_forEachJointHandle: b1,
    rawmultibodyjointset_jointAnchor1: o1,
    rawmultibodyjointset_jointAnchor2: a1,
    rawmultibodyjointset_jointContactsEnabled: c1,
    rawmultibodyjointset_jointFrameX1: s1,
    rawmultibodyjointset_jointFrameX2: n1,
    rawmultibodyjointset_jointLimitsEnabled: l1,
    rawmultibodyjointset_jointLimitsMax: d1,
    rawmultibodyjointset_jointLimitsMin: h1,
    rawmultibodyjointset_jointSetContactsEnabled: u1,
    rawmultibodyjointset_jointType: i1,
    rawmultibodyjointset_new: p1,
    rawmultibodyjointset_remove: g1,
    rawnarrowphase_contact_pair: uT,
    rawnarrowphase_contact_pairs_with: cT,
    rawnarrowphase_intersection_pair: hT,
    rawnarrowphase_intersection_pairs_with: lT,
    rawnarrowphase_new: aT,
    rawphysicspipeline_new: JC,
    rawphysicspipeline_step: ZC,
    rawphysicspipeline_stepWithEvents: QC,
    rawpointcolliderprojection_colliderHandle: LT,
    rawpointcolliderprojection_featureId: WT,
    rawpointcolliderprojection_featureType: jT,
    rawpointcolliderprojection_isInside: zT,
    rawpointcolliderprojection_point: HT,
    rawpointprojection_isInside: OT,
    rawpointprojection_point: GT,
    rawquerypipeline_castRay: rA,
    rawquerypipeline_castRayAndGetNormal: iA,
    rawquerypipeline_castShape: uA,
    rawquerypipeline_collidersWithAabbIntersectingAabb: hA,
    rawquerypipeline_intersectionWithShape: nA,
    rawquerypipeline_intersectionsWithPoint: cA,
    rawquerypipeline_intersectionsWithRay: sA,
    rawquerypipeline_intersectionsWithShape: lA,
    rawquerypipeline_new: tA,
    rawquerypipeline_projectPoint: oA,
    rawquerypipeline_projectPointAndGetFeature: aA,
    rawquerypipeline_update: eA,
    rawraycolliderhit_colliderHandle: UA,
    rawraycolliderhit_timeOfImpact: kA,
    rawraycolliderintersection_colliderHandle: MA,
    rawraycolliderintersection_featureId: l3,
    rawraycolliderintersection_featureType: IA,
    rawraycolliderintersection_normal: KA,
    rawraycolliderintersection_time_of_impact: FA,
    rawrayintersection_featureId: u3,
    rawrayintersection_featureType: BA,
    rawrayintersection_normal: $A,
    rawrayintersection_time_of_impact: DA,
    rawrigidbodyset_contains: kS,
    rawrigidbodyset_createRigidBody: FS,
    rawrigidbodyset_forEachRigidBodyHandle: GS,
    rawrigidbodyset_len: RA,
    rawrigidbodyset_new: IS,
    rawrigidbodyset_propagateModifiedBodyPositionsToColliders: OS,
    rawrigidbodyset_rbAddForce: yS,
    rawrigidbodyset_rbAddForceAtPoint: ES,
    rawrigidbodyset_rbAddTorque: vS,
    rawrigidbodyset_rbAdditionalSolverIterations: CS,
    rawrigidbodyset_rbAngularDamping: hS,
    rawrigidbodyset_rbAngvel: G1,
    rawrigidbodyset_rbApplyImpulse: xS,
    rawrigidbodyset_rbApplyImpulseAtPoint: TS,
    rawrigidbodyset_rbApplyTorqueImpulse: SS,
    rawrigidbodyset_rbBodyType: nS,
    rawrigidbodyset_rbCollider: sS,
    rawrigidbodyset_rbDominanceGroup: H1,
    rawrigidbodyset_rbEffectiveAngularInertia: Q1,
    rawrigidbodyset_rbEffectiveInvMass: q1,
    rawrigidbodyset_rbEffectiveWorldInvInertiaSqrt: Z1,
    rawrigidbodyset_rbEnableCcd: j1,
    rawrigidbodyset_rbGravityScale: gS,
    rawrigidbodyset_rbInvMass: X1,
    rawrigidbodyset_rbInvPrincipalInertiaSqrt: K1,
    rawrigidbodyset_rbIsCcdEnabled: eS,
    rawrigidbodyset_rbIsDynamic: uS,
    rawrigidbodyset_rbIsEnabled: _S,
    rawrigidbodyset_rbIsFixed: aS,
    rawrigidbodyset_rbIsKinematic: cS,
    rawrigidbodyset_rbIsMoving: E1,
    rawrigidbodyset_rbIsSleeping: S1,
    rawrigidbodyset_rbLinearDamping: lS,
    rawrigidbodyset_rbLinvel: k1,
    rawrigidbodyset_rbLocalCom: $1,
    rawrigidbodyset_rbLockRotations: L1,
    rawrigidbodyset_rbLockTranslations: O1,
    rawrigidbodyset_rbMass: V1,
    rawrigidbodyset_rbNextRotation: C1,
    rawrigidbodyset_rbNextTranslation: T1,
    rawrigidbodyset_rbNumColliders: iS,
    rawrigidbodyset_rbPrincipalInertia: J1,
    rawrigidbodyset_rbRecomputeMassPropertiesFromColliders: I1,
    rawrigidbodyset_rbResetForces: bS,
    rawrigidbodyset_rbResetTorques: wS,
    rawrigidbodyset_rbRotation: x1,
    rawrigidbodyset_rbSetAdditionalMass: F1,
    rawrigidbodyset_rbSetAdditionalMassProperties: U1,
    rawrigidbodyset_rbSetAdditionalSolverIterations: AS,
    rawrigidbodyset_rbSetAngularDamping: fS,
    rawrigidbodyset_rbSetAngvel: B1,
    rawrigidbodyset_rbSetBodyType: oS,
    rawrigidbodyset_rbSetDominanceGroup: z1,
    rawrigidbodyset_rbSetEnabled: pS,
    rawrigidbodyset_rbSetEnabledTranslations: N1,
    rawrigidbodyset_rbSetGravityScale: mS,
    rawrigidbodyset_rbSetLinearDamping: dS,
    rawrigidbodyset_rbSetLinvel: P1,
    rawrigidbodyset_rbSetNextKinematicRotation: D1,
    rawrigidbodyset_rbSetNextKinematicTranslation: M1,
    rawrigidbodyset_rbSetRotation: R1,
    rawrigidbodyset_rbSetSoftCcdPrediction: W1,
    rawrigidbodyset_rbSetTranslation: A1,
    rawrigidbodyset_rbSetUserData: PS,
    rawrigidbodyset_rbSleep: v1,
    rawrigidbodyset_rbSoftCcdPrediction: rS,
    rawrigidbodyset_rbTranslation: y1,
    rawrigidbodyset_rbUserData: RS,
    rawrigidbodyset_rbUserForce: BS,
    rawrigidbodyset_rbUserTorque: MS,
    rawrigidbodyset_rbWakeUp: tS,
    rawrigidbodyset_rbWorldCom: Y1,
    rawrigidbodyset_remove: US,
    rawrotation_angle: RC,
    rawrotation_fromAngle: CC,
    rawrotation_identity: TC,
    rawrotation_im: GA,
    rawrotation_re: AC,
    rawserializationpipeline_deserializeAll: EA,
    rawserializationpipeline_new: vA,
    rawserializationpipeline_serializeAll: SA,
    rawshape_ball: YT,
    rawshape_capsule: JT,
    rawshape_castRay: pC,
    rawshape_castRayAndGetNormal: _C,
    rawshape_castShape: cC,
    rawshape_contactShape: lC,
    rawshape_containsPoint: hC,
    rawshape_convexHull: sC,
    rawshape_convexPolyline: oC,
    rawshape_cuboid: qT,
    rawshape_halfspace: KT,
    rawshape_heightfield: tC,
    rawshape_intersectsRay: fC,
    rawshape_intersectsShape: uC,
    rawshape_polyline: ZT,
    rawshape_projectPoint: dC,
    rawshape_roundConvexHull: nC,
    rawshape_roundConvexPolyline: aC,
    rawshape_roundCuboid: $T,
    rawshape_roundTriangle: iC,
    rawshape_segment: eC,
    rawshape_triangle: rC,
    rawshape_trimesh: QT,
    rawshapecasthit_normal1: JA,
    rawshapecasthit_normal2: ZA,
    rawshapecasthit_time_of_impact: OA,
    rawshapecasthit_witness1: gC,
    rawshapecasthit_witness2: YA,
    rawshapecontact_distance: PA,
    rawshapecontact_normal1: t3,
    rawshapecontact_normal2: VA,
    rawshapecontact_point1: XA,
    rawshapecontact_point2: qA,
    rawvector_new: MC,
    rawvector_set_x: DC,
    rawvector_set_y: i3,
    rawvector_x: NA,
    rawvector_xy: IC,
    rawvector_y: LA,
    rawvector_yx: FC,
    rawvector_zero: BC,
    version: _2
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  Ax(g3);
  class m3 {
    constructor(t, e) {
      this.x = t, this.y = e;
    }
  }
  class U {
    static new(t, e) {
      return new m3(t, e);
    }
    static zeros() {
      return U.new(0, 0);
    }
    static fromRaw(t) {
      if (!t) return null;
      let e = U.new(t.x, t.y);
      return t.free(), e;
    }
    static intoRaw(t) {
      return new F(t.x, t.y);
    }
    static copy(t, e) {
      t.x = e.x, t.y = e.y;
    }
  }
  class Ft {
    static identity() {
      return 0;
    }
    static fromRaw(t) {
      if (!t) return null;
      let e = t.angle;
      return t.free(), e;
    }
    static intoRaw(t) {
      return bt.fromAngle(t);
    }
  }
  var ke;
  (function(i) {
    i[i.Dynamic = 0] = "Dynamic", i[i.Fixed = 1] = "Fixed", i[i.KinematicPositionBased = 2] = "KinematicPositionBased", i[i.KinematicVelocityBased = 3] = "KinematicVelocityBased";
  })(ke || (ke = {}));
  class wl {
    constructor(t, e, r) {
      this.rawSet = t, this.colliderSet = e, this.handle = r;
    }
    finalizeDeserialization(t) {
      this.colliderSet = t;
    }
    isValid() {
      return this.rawSet.contains(this.handle);
    }
    lockTranslations(t, e) {
      return this.rawSet.rbLockTranslations(this.handle, t, e);
    }
    lockRotations(t, e) {
      return this.rawSet.rbLockRotations(this.handle, t, e);
    }
    setEnabledTranslations(t, e, r) {
      return this.rawSet.rbSetEnabledTranslations(this.handle, t, e, r);
    }
    restrictTranslations(t, e, r) {
      this.setEnabledTranslations(t, t, r);
    }
    dominanceGroup() {
      return this.rawSet.rbDominanceGroup(this.handle);
    }
    setDominanceGroup(t) {
      this.rawSet.rbSetDominanceGroup(this.handle, t);
    }
    additionalSolverIterations() {
      return this.rawSet.rbAdditionalSolverIterations(this.handle);
    }
    setAdditionalSolverIterations(t) {
      this.rawSet.rbSetAdditionalSolverIterations(this.handle, t);
    }
    enableCcd(t) {
      this.rawSet.rbEnableCcd(this.handle, t);
    }
    setSoftCcdPrediction(t) {
      this.rawSet.rbSetSoftCcdPrediction(this.handle, t);
    }
    softCcdPrediction() {
      return this.rawSet.rbSoftCcdPrediction(this.handle);
    }
    translation() {
      let t = this.rawSet.rbTranslation(this.handle);
      return U.fromRaw(t);
    }
    rotation() {
      let t = this.rawSet.rbRotation(this.handle);
      return Ft.fromRaw(t);
    }
    nextTranslation() {
      let t = this.rawSet.rbNextTranslation(this.handle);
      return U.fromRaw(t);
    }
    nextRotation() {
      let t = this.rawSet.rbNextRotation(this.handle);
      return Ft.fromRaw(t);
    }
    setTranslation(t, e) {
      this.rawSet.rbSetTranslation(this.handle, t.x, t.y, e);
    }
    setLinvel(t, e) {
      let r = U.intoRaw(t);
      this.rawSet.rbSetLinvel(this.handle, r, e), r.free();
    }
    gravityScale() {
      return this.rawSet.rbGravityScale(this.handle);
    }
    setGravityScale(t, e) {
      this.rawSet.rbSetGravityScale(this.handle, t, e);
    }
    setRotation(t, e) {
      this.rawSet.rbSetRotation(this.handle, t, e);
    }
    setAngvel(t, e) {
      this.rawSet.rbSetAngvel(this.handle, t, e);
    }
    setNextKinematicTranslation(t) {
      this.rawSet.rbSetNextKinematicTranslation(this.handle, t.x, t.y);
    }
    setNextKinematicRotation(t) {
      this.rawSet.rbSetNextKinematicRotation(this.handle, t);
    }
    linvel() {
      return U.fromRaw(this.rawSet.rbLinvel(this.handle));
    }
    angvel() {
      return this.rawSet.rbAngvel(this.handle);
    }
    mass() {
      return this.rawSet.rbMass(this.handle);
    }
    effectiveInvMass() {
      return U.fromRaw(this.rawSet.rbEffectiveInvMass(this.handle));
    }
    invMass() {
      return this.rawSet.rbInvMass(this.handle);
    }
    localCom() {
      return U.fromRaw(this.rawSet.rbLocalCom(this.handle));
    }
    worldCom() {
      return U.fromRaw(this.rawSet.rbWorldCom(this.handle));
    }
    invPrincipalInertiaSqrt() {
      return this.rawSet.rbInvPrincipalInertiaSqrt(this.handle);
    }
    principalInertia() {
      return this.rawSet.rbPrincipalInertia(this.handle);
    }
    effectiveWorldInvInertiaSqrt() {
      return this.rawSet.rbEffectiveWorldInvInertiaSqrt(this.handle);
    }
    effectiveAngularInertia() {
      return this.rawSet.rbEffectiveAngularInertia(this.handle);
    }
    sleep() {
      this.rawSet.rbSleep(this.handle);
    }
    wakeUp() {
      this.rawSet.rbWakeUp(this.handle);
    }
    isCcdEnabled() {
      return this.rawSet.rbIsCcdEnabled(this.handle);
    }
    numColliders() {
      return this.rawSet.rbNumColliders(this.handle);
    }
    collider(t) {
      return this.colliderSet.get(this.rawSet.rbCollider(this.handle, t));
    }
    setEnabled(t) {
      this.rawSet.rbSetEnabled(this.handle, t);
    }
    isEnabled() {
      return this.rawSet.rbIsEnabled(this.handle);
    }
    bodyType() {
      return this.rawSet.rbBodyType(this.handle);
    }
    setBodyType(t, e) {
      return this.rawSet.rbSetBodyType(this.handle, t, e);
    }
    isSleeping() {
      return this.rawSet.rbIsSleeping(this.handle);
    }
    isMoving() {
      return this.rawSet.rbIsMoving(this.handle);
    }
    isFixed() {
      return this.rawSet.rbIsFixed(this.handle);
    }
    isKinematic() {
      return this.rawSet.rbIsKinematic(this.handle);
    }
    isDynamic() {
      return this.rawSet.rbIsDynamic(this.handle);
    }
    linearDamping() {
      return this.rawSet.rbLinearDamping(this.handle);
    }
    angularDamping() {
      return this.rawSet.rbAngularDamping(this.handle);
    }
    setLinearDamping(t) {
      this.rawSet.rbSetLinearDamping(this.handle, t);
    }
    recomputeMassPropertiesFromColliders() {
      this.rawSet.rbRecomputeMassPropertiesFromColliders(this.handle, this.colliderSet.raw);
    }
    setAdditionalMass(t, e) {
      this.rawSet.rbSetAdditionalMass(this.handle, t, e);
    }
    setAdditionalMassProperties(t, e, r, s) {
      let n = U.intoRaw(e);
      this.rawSet.rbSetAdditionalMassProperties(this.handle, t, n, r, s), n.free();
    }
    setAngularDamping(t) {
      this.rawSet.rbSetAngularDamping(this.handle, t);
    }
    resetForces(t) {
      this.rawSet.rbResetForces(this.handle, t);
    }
    resetTorques(t) {
      this.rawSet.rbResetTorques(this.handle, t);
    }
    addForce(t, e) {
      const r = U.intoRaw(t);
      this.rawSet.rbAddForce(this.handle, r, e), r.free();
    }
    applyImpulse(t, e) {
      const r = U.intoRaw(t);
      this.rawSet.rbApplyImpulse(this.handle, r, e), r.free();
    }
    addTorque(t, e) {
      this.rawSet.rbAddTorque(this.handle, t, e);
    }
    applyTorqueImpulse(t, e) {
      this.rawSet.rbApplyTorqueImpulse(this.handle, t, e);
    }
    addForceAtPoint(t, e, r) {
      const s = U.intoRaw(t), n = U.intoRaw(e);
      this.rawSet.rbAddForceAtPoint(this.handle, s, n, r), s.free(), n.free();
    }
    applyImpulseAtPoint(t, e, r) {
      const s = U.intoRaw(t), n = U.intoRaw(e);
      this.rawSet.rbApplyImpulseAtPoint(this.handle, s, n, r), s.free(), n.free();
    }
    userForce() {
      return U.fromRaw(this.rawSet.rbUserForce(this.handle));
    }
    userTorque() {
      return this.rawSet.rbUserTorque(this.handle);
    }
  }
  class fe {
    constructor(t) {
      this.enabled = true, this.status = t, this.translation = U.zeros(), this.rotation = Ft.identity(), this.gravityScale = 1, this.linvel = U.zeros(), this.mass = 0, this.massOnly = false, this.centerOfMass = U.zeros(), this.translationsEnabledX = true, this.translationsEnabledY = true, this.angvel = 0, this.principalAngularInertia = 0, this.rotationsEnabled = true, this.linearDamping = 0, this.angularDamping = 0, this.canSleep = true, this.sleeping = false, this.ccdEnabled = false, this.softCcdPrediction = 0, this.dominanceGroup = 0, this.additionalSolverIterations = 0;
    }
    static dynamic() {
      return new fe(ke.Dynamic);
    }
    static kinematicPositionBased() {
      return new fe(ke.KinematicPositionBased);
    }
    static kinematicVelocityBased() {
      return new fe(ke.KinematicVelocityBased);
    }
    static fixed() {
      return new fe(ke.Fixed);
    }
    static newDynamic() {
      return new fe(ke.Dynamic);
    }
    static newKinematicPositionBased() {
      return new fe(ke.KinematicPositionBased);
    }
    static newKinematicVelocityBased() {
      return new fe(ke.KinematicVelocityBased);
    }
    static newStatic() {
      return new fe(ke.Fixed);
    }
    setDominanceGroup(t) {
      return this.dominanceGroup = t, this;
    }
    setAdditionalSolverIterations(t) {
      return this.additionalSolverIterations = t, this;
    }
    setEnabled(t) {
      return this.enabled = t, this;
    }
    setTranslation(t, e) {
      if (typeof t != "number" || typeof e != "number") throw TypeError("The translation components must be numbers.");
      return this.translation = {
        x: t,
        y: e
      }, this;
    }
    setRotation(t) {
      return this.rotation = t, this;
    }
    setGravityScale(t) {
      return this.gravityScale = t, this;
    }
    setAdditionalMass(t) {
      return this.mass = t, this.massOnly = true, this;
    }
    setLinvel(t, e) {
      if (typeof t != "number" || typeof e != "number") throw TypeError("The linvel components must be numbers.");
      return this.linvel = {
        x: t,
        y: e
      }, this;
    }
    setAngvel(t) {
      return this.angvel = t, this;
    }
    setAdditionalMassProperties(t, e, r) {
      return this.mass = t, U.copy(this.centerOfMass, e), this.principalAngularInertia = r, this.massOnly = false, this;
    }
    enabledTranslations(t, e) {
      return this.translationsEnabledX = t, this.translationsEnabledY = e, this;
    }
    restrictTranslations(t, e) {
      return this.enabledTranslations(t, e);
    }
    lockTranslations() {
      return this.restrictTranslations(false, false);
    }
    lockRotations() {
      return this.rotationsEnabled = false, this;
    }
    setLinearDamping(t) {
      return this.linearDamping = t, this;
    }
    setAngularDamping(t) {
      return this.angularDamping = t, this;
    }
    setCanSleep(t) {
      return this.canSleep = t, this;
    }
    setSleeping(t) {
      return this.sleeping = t, this;
    }
    setCcdEnabled(t) {
      return this.ccdEnabled = t, this;
    }
    setSoftCcdPrediction(t) {
      return this.softCcdPrediction = t, this;
    }
    setUserData(t) {
      return this.userData = t, this;
    }
  }
  class fn {
    constructor() {
      this.fconv = new Float64Array(1), this.uconv = new Uint32Array(this.fconv.buffer), this.data = new Array(), this.size = 0;
    }
    set(t, e) {
      let r = this.index(t);
      for (; this.data.length <= r; ) this.data.push(null);
      this.data[r] == null && (this.size += 1), this.data[r] = e;
    }
    len() {
      return this.size;
    }
    delete(t) {
      let e = this.index(t);
      e < this.data.length && (this.data[e] != null && (this.size -= 1), this.data[e] = null);
    }
    clear() {
      this.data = new Array();
    }
    get(t) {
      let e = this.index(t);
      return e < this.data.length ? this.data[e] : null;
    }
    forEach(t) {
      for (const e of this.data) e != null && t(e);
    }
    getAll() {
      return this.data.filter((t) => t != null);
    }
    index(t) {
      return this.fconv[0] = t, this.uconv[0];
    }
  }
  class b3 {
    constructor(t) {
      this.raw = t || new Wt(), this.map = new fn(), t && t.forEachRigidBodyHandle((e) => {
        this.map.set(e, new wl(t, null, e));
      });
    }
    free() {
      this.raw && this.raw.free(), this.raw = void 0, this.map && this.map.clear(), this.map = void 0;
    }
    finalizeDeserialization(t) {
      this.map.forEach((e) => e.finalizeDeserialization(t));
    }
    createRigidBody(t, e) {
      let r = U.intoRaw(e.translation), s = Ft.intoRaw(e.rotation), n = U.intoRaw(e.linvel), o = U.intoRaw(e.centerOfMass), a = this.raw.createRigidBody(e.enabled, r, s, e.gravityScale, e.mass, e.massOnly, o, n, e.angvel, e.principalAngularInertia, e.translationsEnabledX, e.translationsEnabledY, e.rotationsEnabled, e.linearDamping, e.angularDamping, e.status, e.canSleep, e.sleeping, e.softCcdPrediction, e.ccdEnabled, e.dominanceGroup, e.additionalSolverIterations);
      r.free(), s.free(), n.free(), o.free();
      const c = new wl(this.raw, t, a);
      return c.userData = e.userData, this.map.set(a, c), c;
    }
    remove(t, e, r, s, n) {
      for (let o = 0; o < this.raw.rbNumColliders(t); o += 1) r.unmap(this.raw.rbCollider(t, o));
      s.forEachJointHandleAttachedToRigidBody(t, (o) => s.unmap(o)), n.forEachJointHandleAttachedToRigidBody(t, (o) => n.unmap(o)), this.raw.remove(t, e.raw, r.raw, s.raw, n.raw), this.map.delete(t);
    }
    len() {
      return this.map.len();
    }
    contains(t) {
      return this.get(t) != null;
    }
    get(t) {
      return this.map.get(t);
    }
    forEach(t) {
      this.map.forEach(t);
    }
    forEachActiveRigidBody(t, e) {
      t.forEachActiveRigidBodyHandle((r) => {
        e(this.get(r));
      });
    }
    getAll() {
      return this.map.getAll();
    }
  }
  class w3 {
    constructor(t) {
      this.raw = t || new Dr();
    }
    free() {
      this.raw && this.raw.free(), this.raw = void 0;
    }
    get dt() {
      return this.raw.dt;
    }
    get contact_erp() {
      return this.raw.contact_erp;
    }
    get lengthUnit() {
      return this.raw.lengthUnit;
    }
    get normalizedAllowedLinearError() {
      return this.raw.normalizedAllowedLinearError;
    }
    get normalizedPredictionDistance() {
      return this.raw.normalizedPredictionDistance;
    }
    get numSolverIterations() {
      return this.raw.numSolverIterations;
    }
    get numAdditionalFrictionIterations() {
      return this.raw.numAdditionalFrictionIterations;
    }
    get numInternalPgsIterations() {
      return this.raw.numInternalPgsIterations;
    }
    get minIslandSize() {
      return this.raw.minIslandSize;
    }
    get maxCcdSubsteps() {
      return this.raw.maxCcdSubsteps;
    }
    set dt(t) {
      this.raw.dt = t;
    }
    set contact_natural_frequency(t) {
      this.raw.contact_natural_frequency = t;
    }
    set lengthUnit(t) {
      this.raw.lengthUnit = t;
    }
    set normalizedAllowedLinearError(t) {
      this.raw.normalizedAllowedLinearError = t;
    }
    set normalizedPredictionDistance(t) {
      this.raw.normalizedPredictionDistance = t;
    }
    set numSolverIterations(t) {
      this.raw.numSolverIterations = t;
    }
    set numAdditionalFrictionIterations(t) {
      this.raw.numAdditionalFrictionIterations = t;
    }
    set numInternalPgsIterations(t) {
      this.raw.numInternalPgsIterations = t;
    }
    set minIslandSize(t) {
      this.raw.minIslandSize = t;
    }
    set maxCcdSubsteps(t) {
      this.raw.maxCcdSubsteps = t;
    }
    switchToStandardPgsSolver() {
      this.raw.switchToStandardPgsSolver();
    }
    switchToSmallStepsPgsSolver() {
      this.raw.switchToSmallStepsPgsSolver();
    }
    switchToSmallStepsPgsSolverWithoutWarmstart() {
      this.raw.switchToSmallStepsPgsSolverWithoutWarmstart();
    }
  }
  var yl;
  (function(i) {
    i[i.Revolute = 0] = "Revolute", i[i.Fixed = 1] = "Fixed", i[i.Prismatic = 2] = "Prismatic", i[i.Rope = 3] = "Rope", i[i.Spring = 4] = "Spring";
  })(yl || (yl = {}));
  var xl;
  (function(i) {
    i[i.AccelerationBased = 0] = "AccelerationBased", i[i.ForceBased = 1] = "ForceBased";
  })(xl || (xl = {}));
  var vl;
  (function(i) {
    i[i.LinX = 1] = "LinX", i[i.LinY = 2] = "LinY", i[i.LinZ = 4] = "LinZ", i[i.AngX = 8] = "AngX", i[i.AngY = 16] = "AngY", i[i.AngZ = 32] = "AngZ";
  })(vl || (vl = {}));
  class pr {
    constructor(t, e, r) {
      this.rawSet = t, this.bodySet = e, this.handle = r;
    }
    static newTyped(t, e, r) {
      switch (t.jointType(r)) {
        case cr.Revolute:
          return new E3(t, e, r);
        case cr.Prismatic:
          return new S3(t, e, r);
        case cr.Fixed:
          return new y3(t, e, r);
        case cr.Spring:
          return new v3(t, e, r);
        case cr.Rope:
          return new x3(t, e, r);
        default:
          return new pr(t, e, r);
      }
    }
    finalizeDeserialization(t) {
      this.bodySet = t;
    }
    isValid() {
      return this.rawSet.contains(this.handle);
    }
    body1() {
      return this.bodySet.get(this.rawSet.jointBodyHandle1(this.handle));
    }
    body2() {
      return this.bodySet.get(this.rawSet.jointBodyHandle2(this.handle));
    }
    type() {
      return this.rawSet.jointType(this.handle);
    }
    anchor1() {
      return U.fromRaw(this.rawSet.jointAnchor1(this.handle));
    }
    anchor2() {
      return U.fromRaw(this.rawSet.jointAnchor2(this.handle));
    }
    setAnchor1(t) {
      const e = U.intoRaw(t);
      this.rawSet.jointSetAnchor1(this.handle, e), e.free();
    }
    setAnchor2(t) {
      const e = U.intoRaw(t);
      this.rawSet.jointSetAnchor2(this.handle, e), e.free();
    }
    setContactsEnabled(t) {
      this.rawSet.jointSetContactsEnabled(this.handle, t);
    }
    contactsEnabled() {
      return this.rawSet.jointContactsEnabled(this.handle);
    }
  }
  class ip extends pr {
    limitsEnabled() {
      return this.rawSet.jointLimitsEnabled(this.handle, this.rawAxis());
    }
    limitsMin() {
      return this.rawSet.jointLimitsMin(this.handle, this.rawAxis());
    }
    limitsMax() {
      return this.rawSet.jointLimitsMax(this.handle, this.rawAxis());
    }
    setLimits(t, e) {
      this.rawSet.jointSetLimits(this.handle, this.rawAxis(), t, e);
    }
    configureMotorModel(t) {
      this.rawSet.jointConfigureMotorModel(this.handle, this.rawAxis(), t);
    }
    configureMotorVelocity(t, e) {
      this.rawSet.jointConfigureMotorVelocity(this.handle, this.rawAxis(), t, e);
    }
    configureMotorPosition(t, e, r) {
      this.rawSet.jointConfigureMotorPosition(this.handle, this.rawAxis(), t, e, r);
    }
    configureMotor(t, e, r, s) {
      this.rawSet.jointConfigureMotor(this.handle, this.rawAxis(), t, e, r, s);
    }
  }
  class y3 extends pr {
  }
  class x3 extends pr {
  }
  class v3 extends pr {
  }
  class S3 extends ip {
    rawAxis() {
      return an.LinX;
    }
  }
  class E3 extends ip {
    rawAxis() {
      return an.AngX;
    }
  }
  class T3 {
    constructor(t) {
      this.raw = t || new tr(), this.map = new fn(), t && t.forEachJointHandle((e) => {
        this.map.set(e, pr.newTyped(t, null, e));
      });
    }
    free() {
      this.raw && this.raw.free(), this.raw = void 0, this.map && this.map.clear(), this.map = void 0;
    }
    finalizeDeserialization(t) {
      this.map.forEach((e) => e.finalizeDeserialization(t));
    }
    createJoint(t, e, r, s, n) {
      const o = e.intoRaw(), a = this.raw.createJoint(o, r, s, n);
      o.free();
      let c = pr.newTyped(this.raw, t, a);
      return this.map.set(a, c), c;
    }
    remove(t, e) {
      this.raw.remove(t, e), this.unmap(t);
    }
    forEachJointHandleAttachedToRigidBody(t, e) {
      this.raw.forEachJointAttachedToRigidBody(t, e);
    }
    unmap(t) {
      this.map.delete(t);
    }
    len() {
      return this.map.len();
    }
    contains(t) {
      return this.get(t) != null;
    }
    get(t) {
      return this.map.get(t);
    }
    forEach(t) {
      this.map.forEach(t);
    }
    getAll() {
      return this.map.getAll();
    }
  }
  class ti {
    constructor(t, e) {
      this.rawSet = t, this.handle = e;
    }
    static newTyped(t, e) {
      switch (t.jointType(e)) {
        case cr.Revolute:
          return new R3(t, e);
        case cr.Prismatic:
          return new A3(t, e);
        case cr.Fixed:
          return new C3(t, e);
        default:
          return new ti(t, e);
      }
    }
    isValid() {
      return this.rawSet.contains(this.handle);
    }
    setContactsEnabled(t) {
      this.rawSet.jointSetContactsEnabled(this.handle, t);
    }
    contactsEnabled() {
      return this.rawSet.jointContactsEnabled(this.handle);
    }
  }
  class sp extends ti {
  }
  class C3 extends ti {
  }
  class A3 extends sp {
    rawAxis() {
      return an.LinX;
    }
  }
  class R3 extends sp {
    rawAxis() {
      return an.AngX;
    }
  }
  class P3 {
    constructor(t) {
      this.raw = t || new rr(), this.map = new fn(), t && t.forEachJointHandle((e) => {
        this.map.set(e, ti.newTyped(this.raw, e));
      });
    }
    free() {
      this.raw && this.raw.free(), this.raw = void 0, this.map && this.map.clear(), this.map = void 0;
    }
    createJoint(t, e, r, s) {
      const n = t.intoRaw(), o = this.raw.createJoint(n, e, r, s);
      n.free();
      let a = ti.newTyped(this.raw, o);
      return this.map.set(o, a), a;
    }
    remove(t, e) {
      this.raw.remove(t, e), this.map.delete(t);
    }
    unmap(t) {
      this.map.delete(t);
    }
    len() {
      return this.map.len();
    }
    contains(t) {
      return this.get(t) != null;
    }
    get(t) {
      return this.map.get(t);
    }
    forEach(t) {
      this.map.forEach(t);
    }
    forEachJointHandleAttachedToRigidBody(t, e) {
      this.raw.forEachJointAttachedToRigidBody(t, e);
    }
    getAll() {
      return this.map.getAll();
    }
  }
  var zs;
  (function(i) {
    i[i.Average = 0] = "Average", i[i.Min = 1] = "Min", i[i.Multiply = 2] = "Multiply", i[i.Max = 3] = "Max";
  })(zs || (zs = {}));
  class B3 {
    constructor(t) {
      this.raw = t || new Xo();
    }
    free() {
      this.raw && this.raw.free(), this.raw = void 0;
    }
  }
  class M3 {
    constructor(t) {
      this.raw = t || new er();
    }
    free() {
      this.raw && this.raw.free(), this.raw = void 0;
    }
    forEachActiveRigidBodyHandle(t) {
      this.raw.forEachActiveRigidBodyHandle(t);
    }
  }
  class D3 {
    constructor(t) {
      this.raw = t || new Mr();
    }
    free() {
      this.raw && this.raw.free(), this.raw = void 0;
    }
  }
  class I3 {
    constructor(t) {
      this.raw = t || new fr(), this.tempManifold = new F3(null);
    }
    free() {
      this.raw && this.raw.free(), this.raw = void 0;
    }
    contactPairsWith(t, e) {
      this.raw.contact_pairs_with(t, e);
    }
    intersectionPairsWith(t, e) {
      this.raw.intersection_pairs_with(t, e);
    }
    contactPair(t, e, r) {
      const s = this.raw.contact_pair(t, e);
      if (s) {
        const n = s.collider1() != t;
        let o;
        for (o = 0; o < s.numContactManifolds(); ++o) this.tempManifold.raw = s.contactManifold(o), this.tempManifold.raw && r(this.tempManifold, n), this.tempManifold.free();
        s.free();
      }
    }
    intersectionPair(t, e) {
      return this.raw.intersection_pair(t, e);
    }
  }
  class F3 {
    constructor(t) {
      this.raw = t;
    }
    free() {
      this.raw && this.raw.free(), this.raw = void 0;
    }
    normal() {
      return U.fromRaw(this.raw.normal());
    }
    localNormal1() {
      return U.fromRaw(this.raw.local_n1());
    }
    localNormal2() {
      return U.fromRaw(this.raw.local_n2());
    }
    subshape1() {
      return this.raw.subshape1();
    }
    subshape2() {
      return this.raw.subshape2();
    }
    numContacts() {
      return this.raw.num_contacts();
    }
    localContactPoint1(t) {
      return U.fromRaw(this.raw.contact_local_p1(t));
    }
    localContactPoint2(t) {
      return U.fromRaw(this.raw.contact_local_p2(t));
    }
    contactDist(t) {
      return this.raw.contact_dist(t);
    }
    contactFid1(t) {
      return this.raw.contact_fid1(t);
    }
    contactFid2(t) {
      return this.raw.contact_fid2(t);
    }
    contactImpulse(t) {
      return this.raw.contact_impulse(t);
    }
    contactTangentImpulse(t) {
      return this.raw.contact_tangent_impulse(t);
    }
    numSolverContacts() {
      return this.raw.num_solver_contacts();
    }
    solverContactPoint(t) {
      return U.fromRaw(this.raw.solver_contact_point(t));
    }
    solverContactDist(t) {
      return this.raw.solver_contact_dist(t);
    }
    solverContactFriction(t) {
      return this.raw.solver_contact_friction(t);
    }
    solverContactRestitution(t) {
      return this.raw.solver_contact_restitution(t);
    }
    solverContactTangentVelocity(t) {
      return U.fromRaw(this.raw.solver_contact_tangent_velocity(t));
    }
  }
  class Mi {
    constructor(t, e, r, s, n) {
      this.distance = t, this.point1 = e, this.point2 = r, this.normal1 = s, this.normal2 = n;
    }
    static fromRaw(t) {
      if (!t) return null;
      const e = new Mi(t.distance(), U.fromRaw(t.point1()), U.fromRaw(t.point2()), U.fromRaw(t.normal1()), U.fromRaw(t.normal2()));
      return t.free(), e;
    }
  }
  var Di;
  (function(i) {
    i[i.Vertex = 0] = "Vertex", i[i.Face = 1] = "Face", i[i.Unknown = 2] = "Unknown";
  })(Di || (Di = {}));
  class pn {
    constructor(t, e) {
      this.point = t, this.isInside = e;
    }
    static fromRaw(t) {
      if (!t) return null;
      const e = new pn(U.fromRaw(t.point()), t.isInside());
      return t.free(), e;
    }
  }
  class js {
    constructor(t, e, r, s, n) {
      this.featureType = Di.Unknown, this.featureId = void 0, this.collider = t, this.point = e, this.isInside = r, n !== void 0 && (this.featureId = n), s !== void 0 && (this.featureType = s);
    }
    static fromRaw(t, e) {
      if (!e) return null;
      const r = new js(t.get(e.colliderHandle()), U.fromRaw(e.point()), e.isInside(), e.featureType(), e.featureId());
      return e.free(), r;
    }
  }
  class _n {
    constructor(t, e, r, s) {
      this.featureType = Di.Unknown, this.featureId = void 0, this.timeOfImpact = t, this.normal = e, s !== void 0 && (this.featureId = s), r !== void 0 && (this.featureType = r);
    }
    static fromRaw(t) {
      if (!t) return null;
      const e = new _n(t.time_of_impact(), U.fromRaw(t.normal()), t.featureType(), t.featureId());
      return t.free(), e;
    }
  }
  class Ws {
    constructor(t, e, r, s, n) {
      this.featureType = Di.Unknown, this.featureId = void 0, this.collider = t, this.timeOfImpact = e, this.normal = r, n !== void 0 && (this.featureId = n), s !== void 0 && (this.featureType = s);
    }
    static fromRaw(t, e) {
      if (!e) return null;
      const r = new Ws(t.get(e.colliderHandle()), e.time_of_impact(), U.fromRaw(e.normal()), e.featureType(), e.featureId());
      return e.free(), r;
    }
  }
  class Ha {
    constructor(t, e) {
      this.collider = t, this.timeOfImpact = e;
    }
    static fromRaw(t, e) {
      if (!e) return null;
      const r = new Ha(t.get(e.colliderHandle()), e.timeOfImpact());
      return e.free(), r;
    }
  }
  class Li {
    constructor(t, e, r, s, n) {
      this.time_of_impact = t, this.witness1 = e, this.witness2 = r, this.normal1 = s, this.normal2 = n;
    }
    static fromRaw(t, e) {
      if (!e) return null;
      const r = new Li(e.time_of_impact(), U.fromRaw(e.witness1()), U.fromRaw(e.witness2()), U.fromRaw(e.normal1()), U.fromRaw(e.normal2()));
      return e.free(), r;
    }
  }
  class gn extends Li {
    constructor(t, e, r, s, n, o) {
      super(e, r, s, n, o), this.collider = t;
    }
    static fromRaw(t, e) {
      if (!e) return null;
      const r = new gn(t.get(e.colliderHandle()), e.time_of_impact(), U.fromRaw(e.witness1()), U.fromRaw(e.witness2()), U.fromRaw(e.normal1()), U.fromRaw(e.normal2()));
      return e.free(), r;
    }
  }
  class ce {
    static fromRaw(t, e) {
      const r = t.coShapeType(e);
      let s, n, o, a, c, l, u;
      switch (r) {
        case ue.Ball:
          return new np(t.coRadius(e));
        case ue.Cuboid:
          return s = t.coHalfExtents(e), new ap(s.x, s.y);
        case ue.RoundCuboid:
          return s = t.coHalfExtents(e), n = t.coRoundRadius(e), new cp(s.x, s.y, n);
        case ue.Capsule:
          return c = t.coHalfHeight(e), l = t.coRadius(e), new up(c, l);
        case ue.Segment:
          return o = t.coVertices(e), new lp(U.new(o[0], o[1]), U.new(o[2], o[3]));
        case ue.Polyline:
          return o = t.coVertices(e), a = t.coIndices(e), new fp(o, a);
        case ue.Triangle:
          return o = t.coVertices(e), new hp(U.new(o[0], o[1]), U.new(o[2], o[3]), U.new(o[4], o[5]));
        case ue.RoundTriangle:
          return o = t.coVertices(e), n = t.coRoundRadius(e), new dp(U.new(o[0], o[1]), U.new(o[2], o[3]), U.new(o[4], o[5]), n);
        case ue.HalfSpace:
          return u = U.fromRaw(t.coHalfspaceNormal(e)), new op(u);
        case ue.TriMesh:
          o = t.coVertices(e), a = t.coIndices(e);
          const h = t.coTriMeshFlags(e);
          return new pp(o, a, h);
        case ue.HeightField:
          const d = t.coHeightfieldScale(e), p = t.coHeightfieldHeights(e);
          return new _p(p, d);
        case ue.ConvexPolygon:
          return o = t.coVertices(e), new qo(o, false);
        case ue.RoundConvexPolygon:
          return o = t.coVertices(e), n = t.coRoundRadius(e), new $o(o, n, false);
        default:
          throw new Error("unknown shape type: " + r);
      }
    }
    castShape(t, e, r, s, n, o, a, c, l, u) {
      let h = U.intoRaw(t), d = Ft.intoRaw(e), p = U.intoRaw(r), g = U.intoRaw(n), y = Ft.intoRaw(o), m = U.intoRaw(a), v = this.intoRaw(), S = s.intoRaw(), C = Li.fromRaw(null, v.castShape(h, d, p, S, g, y, m, c, l, u));
      return h.free(), d.free(), p.free(), g.free(), y.free(), m.free(), v.free(), S.free(), C;
    }
    intersectsShape(t, e, r, s, n) {
      let o = U.intoRaw(t), a = Ft.intoRaw(e), c = U.intoRaw(s), l = Ft.intoRaw(n), u = this.intoRaw(), h = r.intoRaw(), d = u.intersectsShape(o, a, h, c, l);
      return o.free(), a.free(), c.free(), l.free(), u.free(), h.free(), d;
    }
    contactShape(t, e, r, s, n, o) {
      let a = U.intoRaw(t), c = Ft.intoRaw(e), l = U.intoRaw(s), u = Ft.intoRaw(n), h = this.intoRaw(), d = r.intoRaw(), p = Mi.fromRaw(h.contactShape(a, c, d, l, u, o));
      return a.free(), c.free(), l.free(), u.free(), h.free(), d.free(), p;
    }
    containsPoint(t, e, r) {
      let s = U.intoRaw(t), n = Ft.intoRaw(e), o = U.intoRaw(r), a = this.intoRaw(), c = a.containsPoint(s, n, o);
      return s.free(), n.free(), o.free(), a.free(), c;
    }
    projectPoint(t, e, r, s) {
      let n = U.intoRaw(t), o = Ft.intoRaw(e), a = U.intoRaw(r), c = this.intoRaw(), l = pn.fromRaw(c.projectPoint(n, o, a, s));
      return n.free(), o.free(), a.free(), c.free(), l;
    }
    intersectsRay(t, e, r, s) {
      let n = U.intoRaw(e), o = Ft.intoRaw(r), a = U.intoRaw(t.origin), c = U.intoRaw(t.dir), l = this.intoRaw(), u = l.intersectsRay(n, o, a, c, s);
      return n.free(), o.free(), a.free(), c.free(), l.free(), u;
    }
    castRay(t, e, r, s, n) {
      let o = U.intoRaw(e), a = Ft.intoRaw(r), c = U.intoRaw(t.origin), l = U.intoRaw(t.dir), u = this.intoRaw(), h = u.castRay(o, a, c, l, s, n);
      return o.free(), a.free(), c.free(), l.free(), u.free(), h;
    }
    castRayAndGetNormal(t, e, r, s, n) {
      let o = U.intoRaw(e), a = Ft.intoRaw(r), c = U.intoRaw(t.origin), l = U.intoRaw(t.dir), u = this.intoRaw(), h = _n.fromRaw(u.castRayAndGetNormal(o, a, c, l, s, n));
      return o.free(), a.free(), c.free(), l.free(), u.free(), h;
    }
  }
  var ie;
  (function(i) {
    i[i.Ball = 0] = "Ball", i[i.Cuboid = 1] = "Cuboid", i[i.Capsule = 2] = "Capsule", i[i.Segment = 3] = "Segment", i[i.Polyline = 4] = "Polyline", i[i.Triangle = 5] = "Triangle", i[i.TriMesh = 6] = "TriMesh", i[i.HeightField = 7] = "HeightField", i[i.ConvexPolygon = 9] = "ConvexPolygon", i[i.RoundCuboid = 10] = "RoundCuboid", i[i.RoundTriangle = 11] = "RoundTriangle", i[i.RoundConvexPolygon = 12] = "RoundConvexPolygon", i[i.HalfSpace = 13] = "HalfSpace";
  })(ie || (ie = {}));
  var Sl;
  (function(i) {
    i[i.DELETE_BAD_TOPOLOGY_TRIANGLES = 4] = "DELETE_BAD_TOPOLOGY_TRIANGLES", i[i.ORIENTED = 8] = "ORIENTED", i[i.MERGE_DUPLICATE_VERTICES = 16] = "MERGE_DUPLICATE_VERTICES", i[i.DELETE_DEGENERATE_TRIANGLES = 32] = "DELETE_DEGENERATE_TRIANGLES", i[i.DELETE_DUPLICATE_TRIANGLES = 64] = "DELETE_DUPLICATE_TRIANGLES", i[i.FIX_INTERNAL_EDGES = 152] = "FIX_INTERNAL_EDGES";
  })(Sl || (Sl = {}));
  class np extends ce {
    constructor(t) {
      super(), this.type = ie.Ball, this.radius = t;
    }
    intoRaw() {
      return ct.ball(this.radius);
    }
  }
  class op extends ce {
    constructor(t) {
      super(), this.type = ie.HalfSpace, this.normal = t;
    }
    intoRaw() {
      let t = U.intoRaw(this.normal), e = ct.halfspace(t);
      return t.free(), e;
    }
  }
  class ap extends ce {
    constructor(t, e) {
      super(), this.type = ie.Cuboid, this.halfExtents = U.new(t, e);
    }
    intoRaw() {
      return ct.cuboid(this.halfExtents.x, this.halfExtents.y);
    }
  }
  class cp extends ce {
    constructor(t, e, r) {
      super(), this.type = ie.RoundCuboid, this.halfExtents = U.new(t, e), this.borderRadius = r;
    }
    intoRaw() {
      return ct.roundCuboid(this.halfExtents.x, this.halfExtents.y, this.borderRadius);
    }
  }
  class up extends ce {
    constructor(t, e) {
      super(), this.type = ie.Capsule, this.halfHeight = t, this.radius = e;
    }
    intoRaw() {
      return ct.capsule(this.halfHeight, this.radius);
    }
  }
  class lp extends ce {
    constructor(t, e) {
      super(), this.type = ie.Segment, this.a = t, this.b = e;
    }
    intoRaw() {
      let t = U.intoRaw(this.a), e = U.intoRaw(this.b), r = ct.segment(t, e);
      return t.free(), e.free(), r;
    }
  }
  class hp extends ce {
    constructor(t, e, r) {
      super(), this.type = ie.Triangle, this.a = t, this.b = e, this.c = r;
    }
    intoRaw() {
      let t = U.intoRaw(this.a), e = U.intoRaw(this.b), r = U.intoRaw(this.c), s = ct.triangle(t, e, r);
      return t.free(), e.free(), r.free(), s;
    }
  }
  class dp extends ce {
    constructor(t, e, r, s) {
      super(), this.type = ie.RoundTriangle, this.a = t, this.b = e, this.c = r, this.borderRadius = s;
    }
    intoRaw() {
      let t = U.intoRaw(this.a), e = U.intoRaw(this.b), r = U.intoRaw(this.c), s = ct.roundTriangle(t, e, r, this.borderRadius);
      return t.free(), e.free(), r.free(), s;
    }
  }
  class fp extends ce {
    constructor(t, e) {
      super(), this.type = ie.Polyline, this.vertices = t, this.indices = e ?? new Uint32Array(0);
    }
    intoRaw() {
      return ct.polyline(this.vertices, this.indices);
    }
  }
  class pp extends ce {
    constructor(t, e, r) {
      super(), this.type = ie.TriMesh, this.vertices = t, this.indices = e, this.flags = r;
    }
    intoRaw() {
      return ct.trimesh(this.vertices, this.indices, this.flags);
    }
  }
  class qo extends ce {
    constructor(t, e) {
      super(), this.type = ie.ConvexPolygon, this.vertices = t, this.skipConvexHullComputation = !!e;
    }
    intoRaw() {
      return this.skipConvexHullComputation ? ct.convexPolyline(this.vertices) : ct.convexHull(this.vertices);
    }
  }
  class $o extends ce {
    constructor(t, e, r) {
      super(), this.type = ie.RoundConvexPolygon, this.vertices = t, this.borderRadius = e, this.skipConvexHullComputation = !!r;
    }
    intoRaw() {
      return this.skipConvexHullComputation ? ct.roundConvexPolyline(this.vertices, this.borderRadius) : ct.roundConvexHull(this.vertices, this.borderRadius);
    }
  }
  class _p extends ce {
    constructor(t, e) {
      super(), this.type = ie.HeightField, this.heights = t, this.scale = e;
    }
    intoRaw() {
      let t = U.intoRaw(this.scale), e = ct.heightfield(this.heights, t);
      return t.free(), e;
    }
  }
  class U3 {
    constructor(t) {
      this.raw = t || new zx();
    }
    free() {
      this.raw && this.raw.free(), this.raw = void 0;
    }
    step(t, e, r, s, n, o, a, c, l, u, h, d) {
      let p = U.intoRaw(t);
      h ? this.raw.stepWithEvents(p, e.raw, r.raw, s.raw, n.raw, o.raw, a.raw, c.raw, l.raw, u.raw, h.raw, d, d ? d.filterContactPair : null, d ? d.filterIntersectionPair : null) : this.raw.step(p, e.raw, r.raw, s.raw, n.raw, o.raw, a.raw, c.raw, l.raw, u.raw), p.free();
    }
  }
  var El;
  (function(i) {
    i[i.EXCLUDE_FIXED = 1] = "EXCLUDE_FIXED", i[i.EXCLUDE_KINEMATIC = 2] = "EXCLUDE_KINEMATIC", i[i.EXCLUDE_DYNAMIC = 4] = "EXCLUDE_DYNAMIC", i[i.EXCLUDE_SENSORS = 8] = "EXCLUDE_SENSORS", i[i.EXCLUDE_SOLIDS = 16] = "EXCLUDE_SOLIDS", i[i.ONLY_DYNAMIC = 3] = "ONLY_DYNAMIC", i[i.ONLY_KINEMATIC = 5] = "ONLY_KINEMATIC", i[i.ONLY_FIXED = 6] = "ONLY_FIXED";
  })(El || (El = {}));
  class k3 {
    constructor(t) {
      this.raw = t || new rp();
    }
    free() {
      this.raw && this.raw.free(), this.raw = void 0;
    }
    update(t) {
      this.raw.update(t.raw);
    }
    castRay(t, e, r, s, n, o, a, c, l, u) {
      let h = U.intoRaw(r.origin), d = U.intoRaw(r.dir), p = Ha.fromRaw(e, this.raw.castRay(t.raw, e.raw, h, d, s, n, o, a, c, l, u));
      return h.free(), d.free(), p;
    }
    castRayAndGetNormal(t, e, r, s, n, o, a, c, l, u) {
      let h = U.intoRaw(r.origin), d = U.intoRaw(r.dir), p = Ws.fromRaw(e, this.raw.castRayAndGetNormal(t.raw, e.raw, h, d, s, n, o, a, c, l, u));
      return h.free(), d.free(), p;
    }
    intersectionsWithRay(t, e, r, s, n, o, a, c, l, u, h) {
      let d = U.intoRaw(r.origin), p = U.intoRaw(r.dir), g = (y) => o(Ws.fromRaw(e, y));
      this.raw.intersectionsWithRay(t.raw, e.raw, d, p, s, n, g, a, c, l, u, h), d.free(), p.free();
    }
    intersectionWithShape(t, e, r, s, n, o, a, c, l, u) {
      let h = U.intoRaw(r), d = Ft.intoRaw(s), p = n.intoRaw(), g = this.raw.intersectionWithShape(t.raw, e.raw, h, d, p, o, a, c, l, u);
      return h.free(), d.free(), p.free(), g;
    }
    projectPoint(t, e, r, s, n, o, a, c, l) {
      let u = U.intoRaw(r), h = js.fromRaw(e, this.raw.projectPoint(t.raw, e.raw, u, s, n, o, a, c, l));
      return u.free(), h;
    }
    projectPointAndGetFeature(t, e, r, s, n, o, a, c) {
      let l = U.intoRaw(r), u = js.fromRaw(e, this.raw.projectPointAndGetFeature(t.raw, e.raw, l, s, n, o, a, c));
      return l.free(), u;
    }
    intersectionsWithPoint(t, e, r, s, n, o, a, c, l) {
      let u = U.intoRaw(r);
      this.raw.intersectionsWithPoint(t.raw, e.raw, u, s, n, o, a, c, l), u.free();
    }
    castShape(t, e, r, s, n, o, a, c, l, u, h, d, p, g) {
      let y = U.intoRaw(r), m = Ft.intoRaw(s), v = U.intoRaw(n), S = o.intoRaw(), C = gn.fromRaw(e, this.raw.castShape(t.raw, e.raw, y, m, v, S, a, c, l, u, h, d, p, g));
      return y.free(), m.free(), v.free(), S.free(), C;
    }
    intersectionsWithShape(t, e, r, s, n, o, a, c, l, u, h) {
      let d = U.intoRaw(r), p = Ft.intoRaw(s), g = n.intoRaw();
      this.raw.intersectionsWithShape(t.raw, e.raw, d, p, g, o, a, c, l, u, h), d.free(), p.free(), g.free();
    }
    collidersWithAabbIntersectingAabb(t, e, r) {
      let s = U.intoRaw(t), n = U.intoRaw(e);
      this.raw.collidersWithAabbIntersectingAabb(s, n, r), s.free(), n.free();
    }
  }
  class Tl {
    constructor(t) {
      this.raw = t || new Vx();
    }
    free() {
      this.raw && this.raw.free(), this.raw = void 0;
    }
    serializeAll(t, e, r, s, n, o, a, c, l) {
      let u = U.intoRaw(t);
      const h = this.raw.serializeAll(u, e.raw, r.raw, s.raw, n.raw, o.raw, a.raw, c.raw, l.raw);
      return u.free(), h;
    }
    deserializeAll(t) {
      return gp.fromRaw(this.raw.deserializeAll(t));
    }
  }
  class G3 {
    constructor(t, e) {
      this.vertices = t, this.colors = e;
    }
  }
  class O3 {
    constructor(t) {
      this.raw = t || new kx();
    }
    free() {
      this.raw && this.raw.free(), this.raw = void 0, this.vertices = void 0, this.colors = void 0;
    }
    render(t, e, r, s, n) {
      this.raw.render(t.raw, e.raw, r.raw, s.raw, n.raw), this.vertices = this.raw.vertices(), this.colors = this.raw.colors();
    }
  }
  class N3 {
  }
  class L3 {
    constructor(t, e, r, s, n) {
      this.params = e, this.bodies = r, this.colliders = s, this.queries = n, this.raw = new Lx(t), this.rawCharacterCollision = new ep(), this._applyImpulsesToDynamicBodies = false, this._characterMass = null;
    }
    free() {
      this.raw && (this.raw.free(), this.rawCharacterCollision.free()), this.raw = void 0, this.rawCharacterCollision = void 0;
    }
    up() {
      return this.raw.up();
    }
    setUp(t) {
      let e = U.intoRaw(t);
      return this.raw.setUp(e);
    }
    applyImpulsesToDynamicBodies() {
      return this._applyImpulsesToDynamicBodies;
    }
    setApplyImpulsesToDynamicBodies(t) {
      this._applyImpulsesToDynamicBodies = t;
    }
    characterMass() {
      return this._characterMass;
    }
    setCharacterMass(t) {
      this._characterMass = t;
    }
    offset() {
      return this.raw.offset();
    }
    setOffset(t) {
      this.raw.setOffset(t);
    }
    normalNudgeFactor() {
      return this.raw.normalNudgeFactor();
    }
    setNormalNudgeFactor(t) {
      this.raw.setNormalNudgeFactor(t);
    }
    slideEnabled() {
      return this.raw.slideEnabled();
    }
    setSlideEnabled(t) {
      this.raw.setSlideEnabled(t);
    }
    autostepMaxHeight() {
      return this.raw.autostepMaxHeight();
    }
    autostepMinWidth() {
      return this.raw.autostepMinWidth();
    }
    autostepIncludesDynamicBodies() {
      return this.raw.autostepIncludesDynamicBodies();
    }
    autostepEnabled() {
      return this.raw.autostepEnabled();
    }
    enableAutostep(t, e, r) {
      this.raw.enableAutostep(t, e, r);
    }
    disableAutostep() {
      return this.raw.disableAutostep();
    }
    maxSlopeClimbAngle() {
      return this.raw.maxSlopeClimbAngle();
    }
    setMaxSlopeClimbAngle(t) {
      this.raw.setMaxSlopeClimbAngle(t);
    }
    minSlopeSlideAngle() {
      return this.raw.minSlopeSlideAngle();
    }
    setMinSlopeSlideAngle(t) {
      this.raw.setMinSlopeSlideAngle(t);
    }
    snapToGroundDistance() {
      return this.raw.snapToGroundDistance();
    }
    enableSnapToGround(t) {
      this.raw.enableSnapToGround(t);
    }
    disableSnapToGround() {
      this.raw.disableSnapToGround();
    }
    snapToGroundEnabled() {
      return this.raw.snapToGroundEnabled();
    }
    computeColliderMovement(t, e, r, s, n) {
      let o = U.intoRaw(e);
      this.raw.computeColliderMovement(this.params.dt, this.bodies.raw, this.colliders.raw, this.queries.raw, t.handle, o, this._applyImpulsesToDynamicBodies, this._characterMass, r, s, this.colliders.castClosure(n)), o.free();
    }
    computedMovement() {
      return U.fromRaw(this.raw.computedMovement());
    }
    computedGrounded() {
      return this.raw.computedGrounded();
    }
    numComputedCollisions() {
      return this.raw.numComputedCollisions();
    }
    computedCollision(t, e) {
      if (this.raw.computedCollision(t, this.rawCharacterCollision)) {
        let r = this.rawCharacterCollision;
        return e = e ?? new N3(), e.translationDeltaApplied = U.fromRaw(r.translationDeltaApplied()), e.translationDeltaRemaining = U.fromRaw(r.translationDeltaRemaining()), e.toi = r.toi(), e.witness1 = U.fromRaw(r.worldWitness1()), e.witness2 = U.fromRaw(r.worldWitness2()), e.normal1 = U.fromRaw(r.worldNormal1()), e.normal2 = U.fromRaw(r.worldNormal2()), e.collider = this.colliders.get(r.handle()), e;
      } else return null;
    }
  }
  let gp = class mp {
    constructor(t, e, r, s, n, o, a, c, l, u, h, d, p, g) {
      this.gravity = t, this.integrationParameters = new w3(e), this.islands = new M3(r), this.broadPhase = new D3(s), this.narrowPhase = new I3(n), this.bodies = new b3(o), this.colliders = new H3(a), this.impulseJoints = new T3(c), this.multibodyJoints = new P3(l), this.ccdSolver = new B3(u), this.queryPipeline = new k3(h), this.physicsPipeline = new U3(d), this.serializationPipeline = new Tl(p), this.debugRenderPipeline = new O3(g), this.characterControllers = /* @__PURE__ */ new Set(), this.impulseJoints.finalizeDeserialization(this.bodies), this.bodies.finalizeDeserialization(this.colliders), this.colliders.finalizeDeserialization(this.bodies);
    }
    free() {
      this.integrationParameters.free(), this.islands.free(), this.broadPhase.free(), this.narrowPhase.free(), this.bodies.free(), this.colliders.free(), this.impulseJoints.free(), this.multibodyJoints.free(), this.ccdSolver.free(), this.queryPipeline.free(), this.physicsPipeline.free(), this.serializationPipeline.free(), this.debugRenderPipeline.free(), this.characterControllers.forEach((t) => t.free()), this.integrationParameters = void 0, this.islands = void 0, this.broadPhase = void 0, this.narrowPhase = void 0, this.bodies = void 0, this.colliders = void 0, this.ccdSolver = void 0, this.impulseJoints = void 0, this.multibodyJoints = void 0, this.queryPipeline = void 0, this.physicsPipeline = void 0, this.serializationPipeline = void 0, this.debugRenderPipeline = void 0, this.characterControllers = void 0;
    }
    static fromRaw(t) {
      return t ? new mp(U.fromRaw(t.takeGravity()), t.takeIntegrationParameters(), t.takeIslandManager(), t.takeBroadPhase(), t.takeNarrowPhase(), t.takeBodies(), t.takeColliders(), t.takeImpulseJoints(), t.takeMultibodyJoints()) : null;
    }
    takeSnapshot() {
      return this.serializationPipeline.serializeAll(this.gravity, this.integrationParameters, this.islands, this.broadPhase, this.narrowPhase, this.bodies, this.colliders, this.impulseJoints, this.multibodyJoints);
    }
    static restoreSnapshot(t) {
      return new Tl().deserializeAll(t);
    }
    debugRender() {
      return this.debugRenderPipeline.render(this.bodies, this.colliders, this.impulseJoints, this.multibodyJoints, this.narrowPhase), new G3(this.debugRenderPipeline.vertices, this.debugRenderPipeline.colors);
    }
    step(t, e) {
      this.physicsPipeline.step(this.gravity, this.integrationParameters, this.islands, this.broadPhase, this.narrowPhase, this.bodies, this.colliders, this.impulseJoints, this.multibodyJoints, this.ccdSolver, t, e), this.queryPipeline.update(this.colliders);
    }
    propagateModifiedBodyPositionsToColliders() {
      this.bodies.raw.propagateModifiedBodyPositionsToColliders(this.colliders.raw);
    }
    updateSceneQueries() {
      this.propagateModifiedBodyPositionsToColliders(), this.queryPipeline.update(this.colliders);
    }
    get timestep() {
      return this.integrationParameters.dt;
    }
    set timestep(t) {
      this.integrationParameters.dt = t;
    }
    get lengthUnit() {
      return this.integrationParameters.lengthUnit;
    }
    set lengthUnit(t) {
      this.integrationParameters.lengthUnit = t;
    }
    get numSolverIterations() {
      return this.integrationParameters.numSolverIterations;
    }
    set numSolverIterations(t) {
      this.integrationParameters.numSolverIterations = t;
    }
    get numAdditionalFrictionIterations() {
      return this.integrationParameters.numAdditionalFrictionIterations;
    }
    set numAdditionalFrictionIterations(t) {
      this.integrationParameters.numAdditionalFrictionIterations = t;
    }
    get numInternalPgsIterations() {
      return this.integrationParameters.numInternalPgsIterations;
    }
    set numInternalPgsIterations(t) {
      this.integrationParameters.numInternalPgsIterations = t;
    }
    switchToStandardPgsSolver() {
      this.integrationParameters.switchToStandardPgsSolver();
    }
    switchToSmallStepsPgsSolver() {
      this.integrationParameters.switchToSmallStepsPgsSolver();
    }
    switchToSmallStepsPgsSolverWithoutWarmstart() {
      this.integrationParameters.switchToSmallStepsPgsSolverWithoutWarmstart();
    }
    createRigidBody(t) {
      return this.bodies.createRigidBody(this.colliders, t);
    }
    createCharacterController(t) {
      let e = new L3(t, this.integrationParameters, this.bodies, this.colliders, this.queryPipeline);
      return this.characterControllers.add(e), e;
    }
    removeCharacterController(t) {
      this.characterControllers.delete(t), t.free();
    }
    createCollider(t, e) {
      let r = e ? e.handle : void 0;
      return this.colliders.createCollider(this.bodies, t, r);
    }
    createImpulseJoint(t, e, r, s) {
      return this.impulseJoints.createJoint(this.bodies, t, e.handle, r.handle, s);
    }
    createMultibodyJoint(t, e, r, s) {
      return this.multibodyJoints.createJoint(t, e.handle, r.handle, s);
    }
    getRigidBody(t) {
      return this.bodies.get(t);
    }
    getCollider(t) {
      return this.colliders.get(t);
    }
    getImpulseJoint(t) {
      return this.impulseJoints.get(t);
    }
    getMultibodyJoint(t) {
      return this.multibodyJoints.get(t);
    }
    removeRigidBody(t) {
      this.bodies && this.bodies.remove(t.handle, this.islands, this.colliders, this.impulseJoints, this.multibodyJoints);
    }
    removeCollider(t, e) {
      this.colliders && this.colliders.remove(t.handle, this.islands, this.bodies, e);
    }
    removeImpulseJoint(t, e) {
      this.impulseJoints && this.impulseJoints.remove(t.handle, e);
    }
    removeMultibodyJoint(t, e) {
      this.impulseJoints && this.multibodyJoints.remove(t.handle, e);
    }
    forEachCollider(t) {
      this.colliders.forEach(t);
    }
    forEachRigidBody(t) {
      this.bodies.forEach(t);
    }
    forEachActiveRigidBody(t) {
      this.bodies.forEachActiveRigidBody(this.islands, t);
    }
    castRay(t, e, r, s, n, o, a, c) {
      return this.queryPipeline.castRay(this.bodies, this.colliders, t, e, r, s, n, o ? o.handle : null, a ? a.handle : null, this.colliders.castClosure(c));
    }
    castRayAndGetNormal(t, e, r, s, n, o, a, c) {
      return this.queryPipeline.castRayAndGetNormal(this.bodies, this.colliders, t, e, r, s, n, o ? o.handle : null, a ? a.handle : null, this.colliders.castClosure(c));
    }
    intersectionsWithRay(t, e, r, s, n, o, a, c, l) {
      this.queryPipeline.intersectionsWithRay(this.bodies, this.colliders, t, e, r, s, n, o, a ? a.handle : null, c ? c.handle : null, this.colliders.castClosure(l));
    }
    intersectionWithShape(t, e, r, s, n, o, a, c) {
      let l = this.queryPipeline.intersectionWithShape(this.bodies, this.colliders, t, e, r, s, n, o ? o.handle : null, a ? a.handle : null, this.colliders.castClosure(c));
      return l != null ? this.colliders.get(l) : null;
    }
    projectPoint(t, e, r, s, n, o, a) {
      return this.queryPipeline.projectPoint(this.bodies, this.colliders, t, e, r, s, n ? n.handle : null, o ? o.handle : null, this.colliders.castClosure(a));
    }
    projectPointAndGetFeature(t, e, r, s, n, o) {
      return this.queryPipeline.projectPointAndGetFeature(this.bodies, this.colliders, t, e, r, s ? s.handle : null, n ? n.handle : null, this.colliders.castClosure(o));
    }
    intersectionsWithPoint(t, e, r, s, n, o, a) {
      this.queryPipeline.intersectionsWithPoint(this.bodies, this.colliders, t, this.colliders.castClosure(e), r, s, n ? n.handle : null, o ? o.handle : null, this.colliders.castClosure(a));
    }
    castShape(t, e, r, s, n, o, a, c, l, u, h, d) {
      return this.queryPipeline.castShape(this.bodies, this.colliders, t, e, r, s, n, o, a, c, l, u ? u.handle : null, h ? h.handle : null, this.colliders.castClosure(d));
    }
    intersectionsWithShape(t, e, r, s, n, o, a, c, l) {
      this.queryPipeline.intersectionsWithShape(this.bodies, this.colliders, t, e, r, this.colliders.castClosure(s), n, o, a ? a.handle : null, c ? c.handle : null, this.colliders.castClosure(l));
    }
    collidersWithAabbIntersectingAabb(t, e, r) {
      this.queryPipeline.collidersWithAabbIntersectingAabb(t, e, this.colliders.castClosure(r));
    }
    contactPairsWith(t, e) {
      this.narrowPhase.contactPairsWith(t.handle, this.colliders.castClosure(e));
    }
    intersectionPairsWith(t, e) {
      this.narrowPhase.intersectionPairsWith(t.handle, this.colliders.castClosure(e));
    }
    contactPair(t, e, r) {
      this.narrowPhase.contactPair(t.handle, e.handle, r);
    }
    intersectionPair(t, e) {
      return this.narrowPhase.intersectionPair(t.handle, e.handle);
    }
  };
  var Yo;
  (function(i) {
    i[i.NONE = 0] = "NONE", i[i.COLLISION_EVENTS = 1] = "COLLISION_EVENTS", i[i.CONTACT_FORCE_EVENTS = 2] = "CONTACT_FORCE_EVENTS";
  })(Yo || (Yo = {}));
  var Ko;
  (function(i) {
    i[i.NONE = 0] = "NONE", i[i.FILTER_CONTACT_PAIRS = 1] = "FILTER_CONTACT_PAIRS", i[i.FILTER_INTERSECTION_PAIRS = 2] = "FILTER_INTERSECTION_PAIRS";
  })(Ko || (Ko = {}));
  var Cl;
  (function(i) {
    i[i.EMPTY = 0] = "EMPTY", i[i.COMPUTE_IMPULSE = 1] = "COMPUTE_IMPULSE";
  })(Cl || (Cl = {}));
  var Jo;
  (function(i) {
    i[i.DYNAMIC_DYNAMIC = 1] = "DYNAMIC_DYNAMIC", i[i.DYNAMIC_KINEMATIC = 12] = "DYNAMIC_KINEMATIC", i[i.DYNAMIC_FIXED = 2] = "DYNAMIC_FIXED", i[i.KINEMATIC_KINEMATIC = 52224] = "KINEMATIC_KINEMATIC", i[i.KINEMATIC_FIXED = 8704] = "KINEMATIC_FIXED", i[i.FIXED_FIXED = 32] = "FIXED_FIXED", i[i.DEFAULT = 15] = "DEFAULT", i[i.ALL = 60943] = "ALL";
  })(Jo || (Jo = {}));
  class Al {
    constructor(t, e, r, s) {
      this.colliderSet = t, this.handle = e, this._parent = r, this._shape = s;
    }
    finalizeDeserialization(t) {
      this.handle != null && (this._parent = t.get(this.colliderSet.raw.coParent(this.handle)));
    }
    ensureShapeIsCached() {
      this._shape || (this._shape = ce.fromRaw(this.colliderSet.raw, this.handle));
    }
    get shape() {
      return this.ensureShapeIsCached(), this._shape;
    }
    isValid() {
      return this.colliderSet.raw.contains(this.handle);
    }
    translation() {
      return U.fromRaw(this.colliderSet.raw.coTranslation(this.handle));
    }
    rotation() {
      return Ft.fromRaw(this.colliderSet.raw.coRotation(this.handle));
    }
    isSensor() {
      return this.colliderSet.raw.coIsSensor(this.handle);
    }
    setSensor(t) {
      this.colliderSet.raw.coSetSensor(this.handle, t);
    }
    setShape(t) {
      let e = t.intoRaw();
      this.colliderSet.raw.coSetShape(this.handle, e), e.free(), this._shape = t;
    }
    setEnabled(t) {
      this.colliderSet.raw.coSetEnabled(this.handle, t);
    }
    isEnabled() {
      return this.colliderSet.raw.coIsEnabled(this.handle);
    }
    setRestitution(t) {
      this.colliderSet.raw.coSetRestitution(this.handle, t);
    }
    setFriction(t) {
      this.colliderSet.raw.coSetFriction(this.handle, t);
    }
    frictionCombineRule() {
      return this.colliderSet.raw.coFrictionCombineRule(this.handle);
    }
    setFrictionCombineRule(t) {
      this.colliderSet.raw.coSetFrictionCombineRule(this.handle, t);
    }
    restitutionCombineRule() {
      return this.colliderSet.raw.coRestitutionCombineRule(this.handle);
    }
    setRestitutionCombineRule(t) {
      this.colliderSet.raw.coSetRestitutionCombineRule(this.handle, t);
    }
    setCollisionGroups(t) {
      this.colliderSet.raw.coSetCollisionGroups(this.handle, t);
    }
    setSolverGroups(t) {
      this.colliderSet.raw.coSetSolverGroups(this.handle, t);
    }
    contactSkin() {
      return this.colliderSet.raw.coContactSkin(this.handle);
    }
    setContactSkin(t) {
      return this.colliderSet.raw.coSetContactSkin(this.handle, t);
    }
    activeHooks() {
      return this.colliderSet.raw.coActiveHooks(this.handle);
    }
    setActiveHooks(t) {
      this.colliderSet.raw.coSetActiveHooks(this.handle, t);
    }
    activeEvents() {
      return this.colliderSet.raw.coActiveEvents(this.handle);
    }
    setActiveEvents(t) {
      this.colliderSet.raw.coSetActiveEvents(this.handle, t);
    }
    activeCollisionTypes() {
      return this.colliderSet.raw.coActiveCollisionTypes(this.handle);
    }
    setContactForceEventThreshold(t) {
      return this.colliderSet.raw.coSetContactForceEventThreshold(this.handle, t);
    }
    contactForceEventThreshold() {
      return this.colliderSet.raw.coContactForceEventThreshold(this.handle);
    }
    setActiveCollisionTypes(t) {
      this.colliderSet.raw.coSetActiveCollisionTypes(this.handle, t);
    }
    setDensity(t) {
      this.colliderSet.raw.coSetDensity(this.handle, t);
    }
    setMass(t) {
      this.colliderSet.raw.coSetMass(this.handle, t);
    }
    setMassProperties(t, e, r) {
      let s = U.intoRaw(e);
      this.colliderSet.raw.coSetMassProperties(this.handle, t, s, r), s.free();
    }
    setTranslation(t) {
      this.colliderSet.raw.coSetTranslation(this.handle, t.x, t.y);
    }
    setTranslationWrtParent(t) {
      this.colliderSet.raw.coSetTranslationWrtParent(this.handle, t.x, t.y);
    }
    setRotation(t) {
      this.colliderSet.raw.coSetRotation(this.handle, t);
    }
    setRotationWrtParent(t) {
      this.colliderSet.raw.coSetRotationWrtParent(this.handle, t);
    }
    shapeType() {
      return this.colliderSet.raw.coShapeType(this.handle);
    }
    halfExtents() {
      return U.fromRaw(this.colliderSet.raw.coHalfExtents(this.handle));
    }
    setHalfExtents(t) {
      const e = U.intoRaw(t);
      this.colliderSet.raw.coSetHalfExtents(this.handle, e);
    }
    radius() {
      return this.colliderSet.raw.coRadius(this.handle);
    }
    setRadius(t) {
      this.colliderSet.raw.coSetRadius(this.handle, t);
    }
    roundRadius() {
      return this.colliderSet.raw.coRoundRadius(this.handle);
    }
    setRoundRadius(t) {
      this.colliderSet.raw.coSetRoundRadius(this.handle, t);
    }
    halfHeight() {
      return this.colliderSet.raw.coHalfHeight(this.handle);
    }
    setHalfHeight(t) {
      this.colliderSet.raw.coSetHalfHeight(this.handle, t);
    }
    vertices() {
      return this.colliderSet.raw.coVertices(this.handle);
    }
    indices() {
      return this.colliderSet.raw.coIndices(this.handle);
    }
    heightfieldHeights() {
      return this.colliderSet.raw.coHeightfieldHeights(this.handle);
    }
    heightfieldScale() {
      let t = this.colliderSet.raw.coHeightfieldScale(this.handle);
      return U.fromRaw(t);
    }
    parent() {
      return this._parent;
    }
    friction() {
      return this.colliderSet.raw.coFriction(this.handle);
    }
    restitution() {
      return this.colliderSet.raw.coRestitution(this.handle);
    }
    density() {
      return this.colliderSet.raw.coDensity(this.handle);
    }
    mass() {
      return this.colliderSet.raw.coMass(this.handle);
    }
    volume() {
      return this.colliderSet.raw.coVolume(this.handle);
    }
    collisionGroups() {
      return this.colliderSet.raw.coCollisionGroups(this.handle);
    }
    solverGroups() {
      return this.colliderSet.raw.coSolverGroups(this.handle);
    }
    containsPoint(t) {
      let e = U.intoRaw(t), r = this.colliderSet.raw.coContainsPoint(this.handle, e);
      return e.free(), r;
    }
    projectPoint(t, e) {
      let r = U.intoRaw(t), s = pn.fromRaw(this.colliderSet.raw.coProjectPoint(this.handle, r, e));
      return r.free(), s;
    }
    intersectsRay(t, e) {
      let r = U.intoRaw(t.origin), s = U.intoRaw(t.dir), n = this.colliderSet.raw.coIntersectsRay(this.handle, r, s, e);
      return r.free(), s.free(), n;
    }
    castShape(t, e, r, s, n, o, a, c) {
      let l = U.intoRaw(t), u = U.intoRaw(r), h = Ft.intoRaw(s), d = U.intoRaw(n), p = e.intoRaw(), g = Li.fromRaw(this.colliderSet, this.colliderSet.raw.coCastShape(this.handle, l, p, u, h, d, o, a, c));
      return l.free(), u.free(), h.free(), d.free(), p.free(), g;
    }
    castCollider(t, e, r, s, n, o) {
      let a = U.intoRaw(t), c = U.intoRaw(r), l = gn.fromRaw(this.colliderSet, this.colliderSet.raw.coCastCollider(this.handle, a, e.handle, c, s, n, o));
      return a.free(), c.free(), l;
    }
    intersectsShape(t, e, r) {
      let s = U.intoRaw(e), n = Ft.intoRaw(r), o = t.intoRaw(), a = this.colliderSet.raw.coIntersectsShape(this.handle, o, s, n);
      return s.free(), n.free(), o.free(), a;
    }
    contactShape(t, e, r, s) {
      let n = U.intoRaw(e), o = Ft.intoRaw(r), a = t.intoRaw(), c = Mi.fromRaw(this.colliderSet.raw.coContactShape(this.handle, a, n, o, s));
      return n.free(), o.free(), a.free(), c;
    }
    contactCollider(t, e) {
      return Mi.fromRaw(this.colliderSet.raw.coContactCollider(this.handle, t.handle, e));
    }
    castRay(t, e, r) {
      let s = U.intoRaw(t.origin), n = U.intoRaw(t.dir), o = this.colliderSet.raw.coCastRay(this.handle, s, n, e, r);
      return s.free(), n.free(), o;
    }
    castRayAndGetNormal(t, e, r) {
      let s = U.intoRaw(t.origin), n = U.intoRaw(t.dir), o = _n.fromRaw(this.colliderSet.raw.coCastRayAndGetNormal(this.handle, s, n, e, r));
      return s.free(), n.free(), o;
    }
  }
  var Wr;
  (function(i) {
    i[i.Density = 0] = "Density", i[i.Mass = 1] = "Mass", i[i.MassProps = 2] = "MassProps";
  })(Wr || (Wr = {}));
  class jt {
    constructor(t) {
      this.enabled = true, this.shape = t, this.massPropsMode = Wr.Density, this.density = 1, this.friction = 0.5, this.restitution = 0, this.rotation = Ft.identity(), this.translation = U.zeros(), this.isSensor = false, this.collisionGroups = 4294967295, this.solverGroups = 4294967295, this.frictionCombineRule = zs.Average, this.restitutionCombineRule = zs.Average, this.activeCollisionTypes = Jo.DEFAULT, this.activeEvents = Yo.NONE, this.activeHooks = Ko.NONE, this.mass = 0, this.centerOfMass = U.zeros(), this.contactForceEventThreshold = 0, this.contactSkin = 0, this.principalAngularInertia = 0, this.rotationsEnabled = true;
    }
    static ball(t) {
      const e = new np(t);
      return new jt(e);
    }
    static capsule(t, e) {
      const r = new up(t, e);
      return new jt(r);
    }
    static segment(t, e) {
      const r = new lp(t, e);
      return new jt(r);
    }
    static triangle(t, e, r) {
      const s = new hp(t, e, r);
      return new jt(s);
    }
    static roundTriangle(t, e, r, s) {
      const n = new dp(t, e, r, s);
      return new jt(n);
    }
    static polyline(t, e) {
      const r = new fp(t, e);
      return new jt(r);
    }
    static trimesh(t, e, r) {
      const s = new pp(t, e, r);
      return new jt(s);
    }
    static cuboid(t, e) {
      const r = new ap(t, e);
      return new jt(r);
    }
    static roundCuboid(t, e, r) {
      const s = new cp(t, e, r);
      return new jt(s);
    }
    static halfspace(t) {
      const e = new op(t);
      return new jt(e);
    }
    static heightfield(t, e) {
      const r = new _p(t, e);
      return new jt(r);
    }
    static convexHull(t) {
      const e = new qo(t, false);
      return new jt(e);
    }
    static convexPolyline(t) {
      const e = new qo(t, true);
      return new jt(e);
    }
    static roundConvexHull(t, e) {
      const r = new $o(t, e, false);
      return new jt(r);
    }
    static roundConvexPolyline(t, e) {
      const r = new $o(t, e, true);
      return new jt(r);
    }
    setTranslation(t, e) {
      if (typeof t != "number" || typeof e != "number") throw TypeError("The translation components must be numbers.");
      return this.translation = {
        x: t,
        y: e
      }, this;
    }
    setRotation(t) {
      return this.rotation = t, this;
    }
    setSensor(t) {
      return this.isSensor = t, this;
    }
    setEnabled(t) {
      return this.enabled = t, this;
    }
    setContactSkin(t) {
      return this.contactSkin = t, this;
    }
    setDensity(t) {
      return this.massPropsMode = Wr.Density, this.density = t, this;
    }
    setMass(t) {
      return this.massPropsMode = Wr.Mass, this.mass = t, this;
    }
    setMassProperties(t, e, r) {
      return this.massPropsMode = Wr.MassProps, this.mass = t, U.copy(this.centerOfMass, e), this.principalAngularInertia = r, this;
    }
    setRestitution(t) {
      return this.restitution = t, this;
    }
    setFriction(t) {
      return this.friction = t, this;
    }
    setFrictionCombineRule(t) {
      return this.frictionCombineRule = t, this;
    }
    setRestitutionCombineRule(t) {
      return this.restitutionCombineRule = t, this;
    }
    setCollisionGroups(t) {
      return this.collisionGroups = t, this;
    }
    setSolverGroups(t) {
      return this.solverGroups = t, this;
    }
    setActiveHooks(t) {
      return this.activeHooks = t, this;
    }
    setActiveEvents(t) {
      return this.activeEvents = t, this;
    }
    setActiveCollisionTypes(t) {
      return this.activeCollisionTypes = t, this;
    }
    setContactForceEventThreshold(t) {
      return this.contactForceEventThreshold = t, this;
    }
  }
  class H3 {
    constructor(t) {
      this.raw = t || new Nt(), this.map = new fn(), t && t.forEachColliderHandle((e) => {
        this.map.set(e, new Al(this, e, null));
      });
    }
    free() {
      this.raw && this.raw.free(), this.raw = void 0, this.map && this.map.clear(), this.map = void 0;
    }
    castClosure(t) {
      return (e) => {
        if (t) return t(this.get(e));
      };
    }
    finalizeDeserialization(t) {
      this.map.forEach((e) => e.finalizeDeserialization(t));
    }
    createCollider(t, e, r) {
      let s = r != null && r != null;
      if (s && isNaN(r)) throw Error("Cannot create a collider with a parent rigid-body handle that is not a number.");
      let n = e.shape.intoRaw(), o = U.intoRaw(e.translation), a = Ft.intoRaw(e.rotation), c = U.intoRaw(e.centerOfMass), l = this.raw.createCollider(e.enabled, n, o, a, e.massPropsMode, e.mass, c, e.principalAngularInertia, e.density, e.friction, e.restitution, e.frictionCombineRule, e.restitutionCombineRule, e.isSensor, e.collisionGroups, e.solverGroups, e.activeCollisionTypes, e.activeHooks, e.activeEvents, e.contactForceEventThreshold, e.contactSkin, s, s ? r : 0, t.raw);
      n.free(), o.free(), a.free(), c.free();
      let u = s ? t.get(r) : null, h = new Al(this, l, u, e.shape);
      return this.map.set(l, h), h;
    }
    remove(t, e, r, s) {
      this.raw.remove(t, e.raw, r.raw, s), this.unmap(t);
    }
    unmap(t) {
      this.map.delete(t);
    }
    get(t) {
      return this.map.get(t);
    }
    len() {
      return this.map.len();
    }
    contains(t) {
      return this.get(t) != null;
    }
    forEach(t) {
      this.map.forEach(t);
    }
    getAll() {
      return this.map.getAll();
    }
  }
  class z3 {
    constructor() {
    }
    createKinematicRectangle(t, e, r, s, n = true) {
      const o = {
        x: t.x,
        y: t.y,
        width: e,
        height: r,
        velocity: {
          x: 0,
          y: 0
        }
      }, a = fe.kinematicPositionBased().setTranslation(t.x, t.y);
      n && a.setCcdEnabled(n).setSoftCcdPrediction(0.5);
      const c = app.world.rapierWorld.createRigidBody(a), l = jt.cuboid(e / 2, r / 2).setFriction(0), u = app.world.rapierWorld.createCollider(l, c), h = new $e();
      return h.rect(0, 0, e * app.settings.ptom, r * app.settings.ptom).fill(s), h.x = app.settings.ptom * (t.x - e / 2), h.y = app.Papp.screen.height - app.settings.ptom * (t.y + r / 2), h.updatePosition = function() {
        h.x = app.settings.ptom * (c.translation().x - o.width / 2), h.y = app.Papp.screen.height - app.settings.ptom * (c.translation().y + o.height / 2);
      }, h.updateScale = function() {
        h.width = 2 * l.shape.halfExtents.x * app.settings.ptom, h.height = 2 * l.shape.halfExtents.y * app.settings.ptom;
      }, app.Papp.stage.addChild(h), {
        body: o,
        rigidBodyDesc: a,
        rigidBody: c,
        colliderDesc: l,
        collider: u,
        rendered: h
      };
    }
    createFixedRectangle(t, e, r, s) {
      const n = {
        x: t.x,
        y: t.y,
        width: e,
        height: r,
        velocity: {
          x: 0,
          y: 0
        }
      }, o = fe.fixed().setTranslation(t.x, t.y), a = app.world.rapierWorld.createRigidBody(o), c = jt.cuboid(e / 2, r / 2).setFriction(0), l = app.world.rapierWorld.createCollider(c, a), u = new $e();
      return u.rect(0, 0, e * app.settings.ptom, r * app.settings.ptom).fill(s), u.x = app.settings.ptom * (t.x - e / 2), u.y = app.Papp.screen.height - app.settings.ptom * (t.y + r / 2), u.updatePosition = function() {
        u.x = app.settings.ptom * (a.translation().x - e / 2), u.y = app.Papp.screen.height - app.settings.ptom * (a.translation().y + r / 2);
      }, u.updateScale = function() {
        u.width = 2 * c.shape.halfExtents.x * app.settings.ptom, u.height = 2 * c.shape.halfExtents.y * app.settings.ptom;
      }, app.Papp.stage.addChild(u), {
        body: n,
        rigidBodyDesc: o,
        rigidBody: a,
        colliderDesc: c,
        collider: l,
        rendered: u
      };
    }
    createDynamicRectangle(t, e, r, s, n = true, o = true) {
      let a = fe.dynamic().setTranslation(t.x, t.y);
      o && a.setCcdEnabled(o).setSoftCcdPrediction(1), n && a.lockRotations();
      let c = app.world.rapierWorld.createRigidBody(a), l = jt.cuboid(e / 2, r / 2).setFriction(0), u = app.world.rapierWorld.createCollider(l, c), h = new $e();
      return h.rect(0, 0, e * app.settings.ptom, r * app.settings.ptom).fill(s), h.x = app.settings.ptom * (t.x - e / 2), h.y = app.Papp.screen.height - app.settings.ptom * (t.y + r / 2), h.updatePosition = function() {
        h.x = app.settings.ptom * (c.translation().x - e / 2), h.y = app.Papp.screen.height - app.settings.ptom * (c.translation().y + r / 2);
      }, h.updateScale = function() {
        h.width = 2 * l.shape.halfExtents.x * app.settings.ptom, h.height = 2 * l.shape.halfExtents.y * app.settings.ptom;
      }, app.Papp.stage.addChild(h), {
        rigidBodyDesc: a,
        rigidBody: c,
        colliderDesc: l,
        collider: u,
        rendered: h
      };
    }
    createDynamicCircle(t, e, r, s = true) {
      let n = fe.dynamic().setTranslation(t.x, t.y);
      s && n.setCcdEnabled(s).setSoftCcdPrediction(0.5);
      let o = app.world.rapierWorld.createRigidBody(n), a = jt.ball(e).setFriction(0), c = app.world.rapierWorld.createCollider(a, o), l = new $e();
      return l.circle(0, 0, e * app.settings.ptom).fill(r), l.updatePosition = function() {
        l.x = app.settings.ptom * o.translation().x, l.y = app.Papp.screen.height - app.settings.ptom * o.translation().y;
      }, l.updateScale = function() {
        l.width = 2 * a.shape.radius * app.settings.ptom, l.height = 2 * a.shape.radius * app.settings.ptom;
      }, app.Papp.stage.addChild(l), {
        rigidBodyDesc: n,
        rigidBody: o,
        colliderDesc: a,
        collider: c,
        rendered: l
      };
    }
  }
  class j3 {
    constructor(t, e) {
      this.cellWidth = t, this.cellHeight = e, this.gridQuadrantI = [], this.gridQuadrantII = [], this.gridQuadrantIII = [], this.gridQuadrantIV = [];
    }
    getQuadrant(t, e) {
      if (t >= 0 && e >= 0) return 1;
      if (t < 0 && e >= 0) return 2;
      if (t < 0 && e < 0) return 3;
      if (t >= 0 && e < 0) return 4;
    }
    getGrid(t) {
      let e;
      switch (t) {
        case 1:
          e = this.gridQuadrantI;
          break;
        case 2:
          e = this.gridQuadrantII;
          break;
        case 3:
          e = this.gridQuadrantIII;
          break;
        case 4:
          e = this.gridQuadrantIV;
          break;
      }
      return e;
    }
    getCellCoordinates(t, e, r) {
      let s = t, n = e;
      r === 2 ? s = -t : r === 3 ? (s = -t, n = -e) : r === 4 && (n = -e);
      const o = Math.floor(s / this.cellWidth), a = Math.floor(n / this.cellHeight);
      return [
        o,
        a
      ];
    }
    getObjectBounds(t) {
      const e = t.x - t.width / 2, r = t.y - t.height / 2, s = t.x + t.width / 2, n = t.y + t.height / 2;
      return {
        x1: e,
        y1: r,
        x2: s,
        y2: n
      };
    }
    addObject(t) {
      this.getOccupiedCells(t).forEach((r) => {
        const s = r.quadrant;
        this.getGrid(s)[r.i][r.j].push(t);
      });
    }
    getObjectsInCell(t, e) {
      const r = this.getQuadrant(t, e), [s, n] = this.getCellCoordinates(t, e, r), o = this.getGrid(r);
      return o[s] && o[s][n] ? o[s][n] : [];
    }
    calculateCells(t) {
      let e = [];
      if (t.x1 < 0 && t.x2 > 0) e.push(...this.calculateCells({
        x1: t.x1,
        x2: 0,
        y1: t.y1,
        y2: t.y2
      })), e.push(...this.calculateCells({
        x1: 0,
        x2: t.x2,
        y1: t.y1,
        y2: t.y2
      }));
      else if (t.y1 < 0 && t.y2 > 0) e.push(...this.calculateCells({
        x1: t.x1,
        x2: t.x2,
        y1: t.y1,
        y2: 0
      })), e.push(...this.calculateCells({
        x1: t.x1,
        x2: t.x2,
        y1: 0,
        y2: t.y2
      }));
      else {
        const r = this.getQuadrant(t.x1, t.y1), s = this.getCellCoordinates(t.x1, t.y1, r), n = this.getCellCoordinates(t.x2, t.y2, r), o = Math.min(s[0], n[0]), a = Math.max(s[0], n[0]), c = Math.min(s[1], n[1]), l = Math.max(s[1], n[1]), u = this.getGrid(r);
        for (; u.length <= a; ) u.push([]);
        for (let h = o; h <= a; h++) {
          for (; u[h].length <= l; ) u[h].push([]);
          for (let d = c; d <= l; d++) e.push({
            quadrant: r,
            i: h,
            j: d
          });
        }
      }
      return e;
    }
    getOccupiedCells(t) {
      const e = this.getObjectBounds(t), r = [];
      return r.push(...this.calculateCells(e)), r;
    }
    checkIntersect(t, e) {
      return Math.abs(t.x - e.x) < 0.5 * (t.width + e.width) && Math.abs(t.y - e.y) < 0.5 * (t.height + e.height);
    }
    checkTouch(t, e) {
      return Math.abs(t.x - e.x) === 0.5 * (t.width + e.width) && Math.abs(t.y - e.y) === 0.5 * (t.height + e.height);
    }
    checkIntersectOrTouch(t, e) {
      return Math.abs(t.x - e.x) <= 0.5 * (t.width + e.width) && Math.abs(t.y - e.y) <= 0.5 * (t.height + e.height);
    }
    getIntersectingObjects(t) {
      const e = /* @__PURE__ */ new Set(), r = {
        x: t.x,
        y: t.y,
        width: t.width + 0.1,
        height: t.height + 0.1
      };
      return this.getOccupiedCells(r).forEach((s) => {
        this.getGrid(s.quadrant)[s.i][s.j].forEach((n) => {
          n in e || this.checkIntersect(t, n) && e.add(n);
        });
      }), Array.from(e);
    }
  }
  class W3 {
    constructor() {
      __publicField(this, "objects", []);
      __publicField(this, "partitioning");
      __publicField(this, "player");
      __publicField(this, "controls");
      __publicField(this, "playerConstants");
      this.partitioning = new j3(app.settings.partitionCellWidth, app.settings.partitionCellHeight);
    }
    setPlayer(t) {
      this.player = t.body, this.controls = t.controls, this.playerConstants = t.playerConstants, this.rawPlayer = t;
    }
    addObject(t) {
      this.objects.push(t), this.partitioning.addObject(t);
    }
    checkCornerClip(t, e, r, s, n, o, a, c, l, u, h, d, p, g) {
      if (a != Math.sign(r - t) || !(u * (p - r) + n <= 0)) return false;
      let y = true;
      return y = Math.abs(g - d * o - s) <= c, y && (y = h * (g - s) + o <= c), y ? true : Math.abs(e - d * o - s) <= l;
    }
    calcY(t, e, r, s, n, o, a) {
      let c = false;
      const l = s.x, u = s.y, h = u === 1 ? this.playerConstants.verticalClipThroughSpeedUp : this.playerConstants.verticalClipThroughSpeedDown;
      let d = Math.sign(this.player.x - t.x);
      d === 0 && (d = 1);
      let p = Math.abs(this.player.velocity.y) >= h;
      if (p && (p = this.player.lastYSurface != t.y + r || u === 1), p && (p = this.controls.left + this.controls.right != Math.sign(t.x - this.player.x)), p && (p = this.checkCornerClip(this.player.y, this.player.x, t.y, t.x, r, e, Math.sign(this.player.velocity.y), 0, this.playerConstants.verticalClipThrough, u, l, d, a, o)), p) this.player.x = t.x + d * e, c = true;
      else {
        const g = t.y - u * r;
        u * this.player.y > u * g && u * a <= u * g && (this.player.y = g, u === -1 && (this.controls.canJump = app.settings.playerConstants.coyoteJumpTime, this.player.lastYSurface = g), c = true, n.y = 0);
      }
      return c;
    }
    calcX(t, e, r, s, n, o, a) {
      let c = false;
      const l = s.x, u = s.y, h = Math.sign(this.player.y - t.y);
      let d = true;
      if (h === 0 ? d = false : d = this.checkCornerClip(this.player.x, this.player.y, t.x, t.y, e, r, app.player.controls.left + app.player.controls.right, this.playerConstants.horizontalCornerClip, this.playerConstants.horizontalClipThrough, l, u, h, o, a), d) this.player.y = t.y + h * r, c = true;
      else {
        const p = t.x - l * e;
        l * this.player.x > l * p && l * o <= l * p && (this.player.x = p, c = true, n.x = 0);
      }
      return c;
    }
    step() {
      this.player.velocity.y += app.settings.gravity, !this.controls.down || this.player.velocity.y === app.settings.gravity ? (this.player.width != app.settings.playerWidth && this.rawPlayer.lerpSize(this.playerConstants.lerpFastFall1, app.settings.playerWidth, app.settings.playerHeight), this.player.velocity.y = Math.max(this.player.velocity.y, this.playerConstants.maxFallSpeed)) : (this.player.width === app.settings.playerWidth && this.player.velocity.y < 0.75 * this.playerConstants.maxFallSpeed && this.rawPlayer.lerpSize(this.playerConstants.lerpFastFall2, this.playerConstants.fastFallWidth, this.playerConstants.fastFallHeight), this.player.velocity.y = Math.max(this.player.velocity.y, this.playerConstants.maxFastFallSpeed));
      const t = this.player.x, e = this.player.y;
      this.player.x += this.player.velocity.x, this.player.y += this.player.velocity.y;
      const r = Math.sign(this.player.velocity.y), n = {
        x: Math.sign(this.player.velocity.x),
        y: r
      };
      let o = this.partitioning.getIntersectingObjects(this.player), a = {
        x: this.player.velocity.x,
        y: this.player.velocity.y
      };
      for (; o.length > 0; ) {
        let l = false;
        for (; o.length > 0; ) {
          const u = o.pop(), h = 0.5 * (this.player.width + u.width), d = 0.5 * (this.player.height + u.height);
          let p = this.calcX.bind(this), g = this.calcY.bind(this);
          Math.abs(this.player.velocity.y) <= Math.abs(this.player.velocity.x) && (p = this.calcY.bind(this), g = this.calcX.bind(this)), l = p(u, h, d, n, a, t, e), this.partitioning.checkIntersect(u, this.player) && (l |= g(u, h, d, n, a, t, e));
        }
        l && (o = this.partitioning.getIntersectingObjects(this.player));
      }
      this.player.velocity = a;
      let c = this.player.x;
      this.player.x = Number(this.player.x.toFixed(3)), this.partitioning.getIntersectingObjects(this.player).length > 0 ? this.player.x = c : (c = this.player.x, this.player.velocity.x == 0 && (this.player.x = Number(this.player.x.toFixed(1))), this.partitioning.getIntersectingObjects(this.player).length > 0 && (this.player.x = c));
    }
  }
  class V3 {
    constructor(t, e) {
      __publicField(this, "customWorld");
      __publicField(this, "rapierWorld");
      __publicField(this, "pixiWorld");
      __publicField(this, "dynamicObjects", []);
      __publicField(this, "staticObjects", []);
      __publicField(this, "player");
      this.customWorld = new W3(), this.rapierWorld = t, this.pixiWorld = e;
    }
    setPlayer(t) {
      this.customWorld.setPlayer(t), this.player = t, this.dynamicObjects.push(t);
    }
    addObject(t) {
      return this.dynamicObjects.push(t), t;
    }
    addStaticObject(t) {
      return this.staticObjects.push(t), this.customWorld.addObject(t.body), t;
    }
    updatePosition() {
      this.dynamicObjects.forEach((t) => {
        t.rendered.updatePosition();
      });
    }
    updateScale() {
      this.dynamicObjects.forEach((t) => {
        t.rendered.updateScale();
      });
    }
    updateAll() {
      this.updatePosition(), this.updateScale(), this.staticObjects.forEach((t) => {
        t.rendered.updatePosition(), t.rendered.updateScale();
      });
    }
    step() {
      this.player.updateControls(), this.player.update(), this.customWorld.step(), this.player.rigidBody.setNextKinematicTranslation(this.player.body), this.rapierWorld.step();
    }
    getWorld() {
      return [
        ...this.world
      ];
    }
  }
  var mo, Rl;
  function X3() {
    if (Rl) return mo;
    Rl = 1;
    function i(t, e, r) {
      return t * (1 - r) + e * r;
    }
    return mo = i, mo;
  }
  var q3 = X3();
  const Pl = Vs(q3);
  class $3 {
    constructor(t) {
      __publicField(this, "body");
      __publicField(this, "rigidBodyDesc");
      __publicField(this, "rigidBody");
      __publicField(this, "colliderDesc");
      __publicField(this, "collider");
      __publicField(this, "rendered");
      __publicField(this, "keydown");
      __publicField(this, "keyup");
      __publicField(this, "controls");
      __publicField(this, "playerConstants");
      const e = app.entityFactory.createKinematicRectangle(t, app.settings.playerWidth, app.settings.playerHeight, app.settings.playerColour);
      this.body = e.body, this.body.lastYSurface = null, this.rigidBodyDesc = e.rigidBodyDesc, this.rigidBody = e.rigidBody, this.colliderDesc = e.colliderDesc, this.collider = e.collider, this.rendered = e.rendered, this.playerConstants = app.settings.playerConstants, this.controls = {
        left: 0,
        right: 0,
        jump: 0,
        canJump: 0,
        pressingJump: false,
        isJumping: 0,
        slowDownDisabled: 0,
        down: false
      }, this.keydown = (r) => {
        let s = r.key.toLowerCase();
        s == "a" || s == "arrowleft" ? this.controls.left = -1 : s == "d" || s == "arrowright" ? this.controls.right = 1 : (s == "w" || s == "arrowup" || s == " " || s == "c") && !this.controls.pressingJump ? (this.jump(), this.controls.pressingJump = true) : s == "x" ? (this.body.velocity.x *= 3, this.body.velocity.y *= 1.5) : (s == "s" || s == "arrowdown") && (this.controls.down = true);
      }, this.keyup = (r) => {
        let s = r.key.toLowerCase();
        s == "a" || s == "arrowleft" ? this.controls.left = 0 : s == "d" || s == "arrowright" ? this.controls.right = 0 : s == "w" || s == "arrowup" || s == " " || s == "c" ? this.controls.pressingJump = false : (s == "s" || s == "arrowdown") && (this.controls.down = false);
      }, window.addEventListener("keydown", this.keydown), window.addEventListener("keyup", this.keyup);
    }
    jump() {
      this.controls.jump = app.settings.playerConstants.inputBufferTime;
    }
    updatePosition() {
      this.rendered.updatePosition();
    }
    updateControls() {
      const t = app.settings.playerConstants;
      let e = this.controls.left + this.controls.right, r = this.body.velocity, s = r.x, n = Math.sign(s), o = s * n;
      e != n && (s -= n * Math.min(t.slowDown, n * s)), this.controls.slowDownDisabled != 0 ? e == n && o > t.maxSpeed ? (s -= t.weakSlowDown * n, o - t.weakSlowDown < t.maxSpeed && (s = t.maxSpeed * n)) : (s += t.speed * e, e != 0 && (s = e * Math.min(e * s, t.maxSpeed))) : this.controls.slowDownDisabled--;
      let a = r.y;
      this.controls.jump != 0 && this.controls.canJump != 0 ? (a = Math.max(a, 0) + t.jumpStrength, this.controls.jump = 0, this.controls.canJump = 0, this.controls.isJumping = t.additionalJumpTime + t.additionalJumpBuffer, e != 0 && (s += t.jumpSpeedBoost * e, this.controls.slowDownDisabled = 1)) : (this.controls.jump != 0 && (this.controls.jump -= 1), this.controls.canJump != 0 && (this.controls.canJump -= 1)), this.controls.pressingJump && this.controls.isJumping != 0 && this.controls.isJumping <= t.additionalJumpTime ? (a += t.additionalJumpStrength, this.controls.isJumping--) : this.controls.pressingJump == false ? this.controls.isJumping = 0 : this.controls.isJumping != 0 && this.controls.isJumping--, this.body.velocity = {
        x: s,
        y: a
      };
    }
    update() {
      this.lerp && (this.lerp.progress++, this.setSize(Math.round(Pl(this.lerp.oldWidth, this.lerp.width, this.lerp.delta * this.lerp.progress)), Math.round(Pl(this.lerp.oldHeight, this.lerp.height, this.lerp.delta * this.lerp.progress))) ? this.lerp.progress === this.lerp.frames && (this.lerp = false) : this.lerp.progress--);
    }
    lerpSize(t, e = -1, r = -1, s = true) {
      const n = this.body.width, o = this.body.height, a = n * o;
      s && (r === -1 ? r = a / e : e === -1 && (e = a / r)), this.lerp = {
        progress: 0,
        delta: 1 / t,
        frames: t,
        oldWidth: n,
        oldHeight: o,
        width: e,
        height: r
      };
    }
    setSize(t = -1, e = -1, r = true) {
      const s = this.body.x, n = this.body.y, o = this.body.width, a = this.body.height, c = o * a;
      return r && (e === -1 ? e = c / t : t === -1 && (t = c / e)), this.body.y = n + 0.5 * (-a + e), this.body.width = t, this.body.height = e, app.world.customWorld.partitioning.getIntersectingObjects(this.body).length > 0 ? (this.body.y = n, this.body.width = o, this.body.height = a, false) : (t *= 0.5, e *= 0.5, this.rigidBody.setNextKinematicTranslation(this.body), this.colliderDesc.shape.halfExtents.x = t, this.colliderDesc.shape.halfExtents.y = e, this.collider.setHalfExtents({
        x: t,
        y: e
      }), this.rendered.updatePosition(), this.rendered.updateScale(), true);
    }
  }
  const Ye = {
    playerWidth: 1e3,
    playerHeight: 1500,
    playerColour: 16776960,
    playerConstants: {
      speed: 80,
      maxSpeed: 150,
      slowDown: 50,
      weakSlowDown: 5,
      jumpStrength: 340,
      additionalJumpStrength: 30,
      additionalJumpTime: 8,
      additionalJumpBuffer: 2,
      jumpSpeedBoost: 10,
      inputBufferTime: 3,
      coyoteJumpTime: 8,
      maxFallSpeed: -600,
      maxFastFallSpeed: -1200,
      fastFallWidth: 800,
      fastFallHeight: 1800,
      lerpFastFall1: 2,
      lerpFastFall2: 5,
      horizontalCornerClip: 350,
      horizontalClipThrough: 200,
      verticalClipThroughSpeedUp: 150,
      verticalClipThroughSpeedDown: 300,
      verticalClipThrough: 200
    },
    gravity: -30,
    rapierGravity: -5e4,
    partitionCellWidth: 4e4,
    partitionCellHeight: 2e4,
    mtow: 4e4,
    ptom: 40
  };
  Ye.partitionCellWidth = Ye.mtow;
  Ye.partitionCellHeight = Ye.mtow * 1080 / 1920;
  window.innerWidth / window.innerHeight >= 1920 / 1080 ? Ye.ptom = window.innerWidth / Ye.mtow : Ye.ptom = window.innerHeight / (Ye.mtow * 1080 / 1920);
  class Y3 {
    constructor() {
      this.loops = [], this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.speed = 1, this.running = false, this.index = 0;
    }
    add(t, e = 1e3 / 60) {
      const r = new K3(t, e);
      this.loops.push(r);
    }
    get(t) {
      return this.loops[t];
    }
    tick(t) {
      if (this.running == true && (this.index = requestAnimationFrame(t), this.loops.length > 0)) for (var e = this.getDelta(), r = this.loops[0].sum / this.loops[0].rate, s = this.loops.length - 1; s >= 0; s--) this.loops[s].sum += e, (this.loops[s].sum >= this.loops[s].rate || this.loops[s].rate == -1) && (this.loops[s].sum %= this.loops[s].rate, this.loops[s].callback({
        delta: this.loops[s].rate == -1 ? e : this.loops[s].rate,
        alpha: s == 0 ? 0 : r,
        index: this.index
      }));
    }
    start() {
      this.reset();
      var t = (function() {
        this.tick(t);
      }).bind(this);
      t();
    }
    stop() {
      this.getElapsedTime(), this.running = false;
    }
    reset() {
      this.startTime = this.now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = true;
      for (var t = this.loops.length - 1; t >= 0; t--) this.loops[t].reset();
    }
    isRunning() {
      return this.running;
    }
    getElapsedTime() {
      return this.getDelta(), this.elapsedTime;
    }
    getDelta() {
      let t = 0;
      if (this.running) {
        const e = this.now();
        t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t;
      }
      return t * this.speed;
    }
    now() {
      return (typeof performance > "u" ? Date : performance).now();
    }
  }
  class K3 {
    constructor(t = () => {
    }, e) {
      this.rate = e / 1e3, this.sum = 0, this.alpha = 0, this.callback = t, e < 0 && (this.rate = -1);
    }
    reset() {
      this.sum = 0, this.alpha = 0;
    }
  }
  async function J3() {
    const i = {};
    window.app = i, i.settings = Ye, i.paused = false;
    const t = new bh();
    i.Papp = t, await t.init({
      width: window.innerWidth,
      height: window.innerHeight,
      backgroundColor: 1087931,
      resolution: window.devicePixelRatio || 1
    }), t.canvas.style.width = "100%", t.canvas.style.height = "100%";
    const e = new gp({
      x: 0,
      y: i.settings.rapierGravity
    });
    e.integrationParameters.normalizedPredictionDistance = 0.1;
    const r = new z3();
    i.entityFactory = r;
    const s = new V3(e, t);
    i.world = s, window.physicsTop = i.settings.mtow * 1080 / 1920, window.physicsRight = i.settings.mtow;
    const n = new $3({
      x: 3 * physicsRight / 4 + 2e3,
      y: i.settings.playerHeight / 2 + 500
    });
    i.player = n, s.setPlayer(n);
    for (let v = 1e3; v <= 4e3; v += 1e3) for (let S = 1e3 + v % 2e3 / 2; S <= 3 * physicsRight / 4 - 1e4; S += 1e3) s.addObject(r.createDynamicCircle({
      x: S,
      y: v
    }, 500, Math.round(Math.random() * 16777215))).collider.setDensity(0.05);
    const o = s.addStaticObject(r.createFixedRectangle({
      x: physicsRight / 2,
      y: 0
    }, physicsRight, 1e3, 0)), a = s.addStaticObject(r.createFixedRectangle({
      x: 0,
      y: physicsTop / 2
    }, 1e3, physicsTop, 0)), c = s.addStaticObject(r.createFixedRectangle({
      x: physicsRight,
      y: physicsTop / 2
    }, 1e3, physicsTop, 0)), l = s.addStaticObject(r.createFixedRectangle({
      x: 3 * physicsRight / 4,
      y: 1500
    }, 1e3, 2500, 0)), u = s.addStaticObject(r.createFixedRectangle({
      x: 3 * physicsRight / 4 - 8e3,
      y: 1500
    }, 1e3, 2500, 0)), h = s.addStaticObject(r.createFixedRectangle({
      x: physicsRight / 2,
      y: physicsTop
    }, physicsRight, 1e3, 0)), d = [
      [
        7 * physicsRight / 8,
        4e3
      ],
      [
        3 * physicsRight / 4 - 4e3,
        4e3
      ],
      [
        3 * physicsRight / 4 - 8e3,
        6500
      ],
      [
        3 * physicsRight / 4 - 3e3,
        9e3
      ],
      [
        3 * physicsRight / 4 - 12e3,
        9500
      ],
      [
        3 * physicsRight / 4 - 16e3,
        12500
      ],
      [
        3 * physicsRight / 4 - 17e3,
        13500
      ],
      [
        7 * physicsRight / 8 + 2500,
        7e3
      ],
      [
        physicsRight - 500,
        1e4
      ],
      [
        physicsRight - 4e3,
        12e3
      ],
      [
        physicsRight - 5100,
        12200
      ],
      [
        physicsRight - 6200,
        12400
      ],
      [
        physicsRight / 4 - 800,
        15500
      ],
      [
        physicsRight / 4 - 1800,
        9900
      ],
      [
        physicsRight / 4 - 8e3,
        17e3
      ],
      [
        physicsRight / 4 - 7800,
        7e3
      ]
    ];
    for (let v = 0; v <= 10; v++) d.push([
      physicsRight / 4 - 4e3 - 10 * v,
      9900 + 300 * v
    ]);
    d.forEach((v) => {
      s.addStaticObject(r.createFixedRectangle({
        x: v[0],
        y: v[1]
      }, 2e3, 2e3, 0));
    }), document.body.appendChild(t.canvas);
    const p = new Y3();
    window.addEventListener("keypress", (v) => {
      v.key == "p" && (i.paused = true);
    });
    const g = () => {
      const v = Date.now();
      i.paused || s.step();
      const S = Date.now();
      setTimeout(g, 1e3 / 60 - (S - v));
    }, y = () => {
      s.updatePosition();
    };
    setTimeout(g, 0), p.add(y, -1), p.start(), window.updatePhysics = g, window.updateRendered = y;
    function m() {
      window.innerWidth / window.innerHeight >= 1920 / 1080 ? (t.renderer.resize(window.innerHeight * 1920 / 1080, window.innerHeight), i.settings.ptom = window.innerHeight / (i.settings.mtow * 1080 / 1920), t.canvas.style.width = `${100 * 1920 / 1080}vh`, t.canvas.style.height = "100vh") : (t.renderer.resize(window.innerWidth, window.innerWidth * 1080 / 1920), i.settings.ptom = window.innerWidth / i.settings.mtow, t.canvas.style.width = "100vw", t.canvas.style.height = `${100 * 1080 / 1920}vw`), s.updateAll();
    }
    m(), window.addEventListener("resize", m);
  }
  J3();
})();
export {
  T_ as A,
  dx as B,
  Dt as C,
  dw as E,
  pR as F,
  X0 as G,
  Zf as H,
  K0 as M,
  Z0 as N,
  bg as R,
  wg as T,
  __tla,
  Q3 as a,
  Bh as b,
  Ex as c,
  vx as d,
  Mt as e,
  fx as f,
  ox as g,
  Dw as h,
  Aw as i
};
