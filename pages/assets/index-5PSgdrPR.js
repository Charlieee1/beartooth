const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./browserAll-DXYeSClV.js","./init-BXB-gCtc.js","./webworkerAll-Bjv_PYqo.js"])))=>i.map(i=>d[i]);
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
let v_, ux, Dt, uw, aR, j0, Yf, q0, Y0, _g, gg, X3, Ch, xx, wx, Mt, lx, ix, Pw, Ew;
let __tla = (async () => {
  (function() {
    const t = document.createElement("link").relList;
    if (t && t.supports && t.supports("modulepreload")) return;
    for (const n of document.querySelectorAll('link[rel="modulepreload"]')) r(n);
    new MutationObserver((n) => {
      for (const s of n) if (s.type === "childList") for (const o of s.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && r(o);
    }).observe(document, {
      childList: true,
      subtree: true
    });
    function e(n) {
      const s = {};
      return n.integrity && (s.integrity = n.integrity), n.referrerPolicy && (s.referrerPolicy = n.referrerPolicy), n.crossOrigin === "use-credentials" ? s.credentials = "include" : n.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin", s;
    }
    function r(n) {
      if (n.ep) return;
      n.ep = true;
      const s = e(n);
      fetch(n.href, s);
    }
  })();
  const bp = "modulepreload", wp = function(i, t) {
    return new URL(i, t).href;
  }, Qa = {}, Tn = function(t, e, r) {
    let n = Promise.resolve();
    if (e && e.length > 0) {
      const o = document.getElementsByTagName("link"), a = document.querySelector("meta[property=csp-nonce]"), c = (a == null ? void 0 : a.nonce) || (a == null ? void 0 : a.getAttribute("nonce"));
      n = Promise.allSettled(e.map((u) => {
        if (u = wp(u, r), u in Qa) return;
        Qa[u] = true;
        const l = u.endsWith(".css"), h = l ? '[rel="stylesheet"]' : "";
        if (!!r) for (let m = o.length - 1; m >= 0; m--) {
          const y = o[m];
          if (y.href === u && (!l || y.rel === "stylesheet")) return;
        }
        else if (document.querySelector(`link[href="${u}"]${h}`)) return;
        const p = document.createElement("link");
        if (p.rel = l ? "stylesheet" : bp, l || (p.as = "script"), p.crossOrigin = "", p.href = u, c && p.setAttribute("nonce", c), document.head.appendChild(p), l) return new Promise((m, y) => {
          p.addEventListener("load", m), p.addEventListener("error", () => y(new Error(`Unable to preload CSS for ${u}`)));
        });
      }));
    }
    function s(o) {
      const a = new Event("vite:preloadError", {
        cancelable: true
      });
      if (a.payload = o, window.dispatchEvent(a), !a.defaultPrevented) throw o;
    }
    return n.then((o) => {
      for (const a of o || []) a.status === "rejected" && s(a.reason);
      return t().catch(s);
    });
  };
  var P = ((i) => (i.Application = "application", i.WebGLPipes = "webgl-pipes", i.WebGLPipesAdaptor = "webgl-pipes-adaptor", i.WebGLSystem = "webgl-system", i.WebGPUPipes = "webgpu-pipes", i.WebGPUPipesAdaptor = "webgpu-pipes-adaptor", i.WebGPUSystem = "webgpu-system", i.CanvasSystem = "canvas-system", i.CanvasPipesAdaptor = "canvas-pipes-adaptor", i.CanvasPipes = "canvas-pipes", i.Asset = "asset", i.LoadParser = "load-parser", i.ResolveParser = "resolve-parser", i.CacheParser = "cache-parser", i.DetectionParser = "detection-parser", i.MaskEffect = "mask-effect", i.BlendMode = "blend-mode", i.TextureSource = "texture-source", i.Environment = "environment", i.ShapeBuilder = "shape-builder", i))(P || {});
  let _o, Wi, yp, xp;
  _o = (i) => {
    if (typeof i == "function" || typeof i == "object" && i.extension) {
      if (!i.extension) throw new Error("Extension class must have an extension object");
      i = {
        ...typeof i.extension != "object" ? {
          type: i.extension
        } : i.extension,
        ref: i
      };
    }
    if (typeof i == "object") i = {
      ...i
    };
    else throw new Error("Invalid extension type");
    return typeof i.type == "string" && (i.type = [
      i.type
    ]), i;
  };
  Wi = (i, t) => _o(i).priority ?? t;
  Mt = {
    _addHandlers: {},
    _removeHandlers: {},
    _queue: {},
    remove(...i) {
      return i.map(_o).forEach((t) => {
        t.type.forEach((e) => {
          var _a2, _b2;
          return (_b2 = (_a2 = this._removeHandlers)[e]) == null ? void 0 : _b2.call(_a2, t);
        });
      }), this;
    },
    add(...i) {
      return i.map(_o).forEach((t) => {
        t.type.forEach((e) => {
          var _a2, _b2;
          const r = this._addHandlers, n = this._queue;
          r[e] ? (_a2 = r[e]) == null ? void 0 : _a2.call(r, t) : (n[e] = n[e] || [], (_b2 = n[e]) == null ? void 0 : _b2.push(t));
        });
      }), this;
    },
    handle(i, t, e) {
      var _a2;
      const r = this._addHandlers, n = this._removeHandlers;
      if (r[i] || n[i]) throw new Error(`Extension type ${i} already has a handler`);
      r[i] = t, n[i] = e;
      const s = this._queue;
      return s[i] && ((_a2 = s[i]) == null ? void 0 : _a2.forEach((o) => t(o)), delete s[i]), this;
    },
    handleByMap(i, t) {
      return this.handle(i, (e) => {
        e.name && (t[e.name] = e.ref);
      }, (e) => {
        e.name && delete t[e.name];
      });
    },
    handleByNamedList(i, t, e = -1) {
      return this.handle(i, (r) => {
        t.findIndex((s) => s.name === r.name) >= 0 || (t.push({
          name: r.name,
          value: r.ref
        }), t.sort((s, o) => Wi(o.value, e) - Wi(s.value, e)));
      }, (r) => {
        const n = t.findIndex((s) => s.name === r.name);
        n !== -1 && t.splice(n, 1);
      });
    },
    handleByList(i, t, e = -1) {
      return this.handle(i, (r) => {
        t.includes(r.ref) || (t.push(r.ref), t.sort((n, s) => Wi(s, e) - Wi(n, e)));
      }, (r) => {
        const n = t.indexOf(r.ref);
        n !== -1 && t.splice(n, 1);
      });
    }
  };
  yp = {
    extension: {
      type: P.Environment,
      name: "browser",
      priority: -1
    },
    test: () => true,
    load: async () => {
      await Tn(() => import("./browserAll-DXYeSClV.js").then(async (m) => {
        await m.__tla;
        return m;
      }), __vite__mapDeps([0,1]), import.meta.url);
    }
  };
  xp = {
    extension: {
      type: P.Environment,
      name: "webworker",
      priority: 0
    },
    test: () => typeof self < "u" && self.WorkerGlobalScope !== void 0,
    load: async () => {
      await Tn(() => import("./webworkerAll-Bjv_PYqo.js").then(async (m) => {
        await m.__tla;
        return m;
      }), __vite__mapDeps([2,1]), import.meta.url);
    }
  };
  class Xt {
    constructor(t, e, r) {
      this._x = e || 0, this._y = r || 0, this._observer = t;
    }
    clone(t) {
      return new Xt(t ?? this._observer, this._x, this._y);
    }
    set(t = 0, e = t) {
      return (this._x !== t || this._y !== e) && (this._x = t, this._y = e, this._observer._onUpdate(this)), this;
    }
    copyFrom(t) {
      return (this._x !== t.x || this._y !== t.y) && (this._x = t.x, this._y = t.y, this._observer._onUpdate(this)), this;
    }
    copyTo(t) {
      return t.set(this._x, this._y), t;
    }
    equals(t) {
      return t.x === this._x && t.y === this._y;
    }
    toString() {
      return `[pixi.js/math:ObservablePoint x=0 y=0 scope=${this._observer}]`;
    }
    get x() {
      return this._x;
    }
    set x(t) {
      this._x !== t && (this._x = t, this._observer._onUpdate(this));
    }
    get y() {
      return this._y;
    }
    set y(t) {
      this._y !== t && (this._y = t, this._observer._onUpdate(this));
    }
  }
  function Ko(i) {
    return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
  }
  var xn = {
    exports: {}
  }, V3 = xn.exports, tc;
  function vp() {
    return tc || (tc = 1, function(i) {
      "use strict";
      var t = Object.prototype.hasOwnProperty, e = "~";
      function r() {
      }
      Object.create && (r.prototype = /* @__PURE__ */ Object.create(null), new r().__proto__ || (e = false));
      function n(c, u, l) {
        this.fn = c, this.context = u, this.once = l || false;
      }
      function s(c, u, l, h, f) {
        if (typeof l != "function") throw new TypeError("The listener must be a function");
        var p = new n(l, h || c, f), m = e ? e + u : u;
        return c._events[m] ? c._events[m].fn ? c._events[m] = [
          c._events[m],
          p
        ] : c._events[m].push(p) : (c._events[m] = p, c._eventsCount++), c;
      }
      function o(c, u) {
        --c._eventsCount === 0 ? c._events = new r() : delete c._events[u];
      }
      function a() {
        this._events = new r(), this._eventsCount = 0;
      }
      a.prototype.eventNames = function() {
        var u = [], l, h;
        if (this._eventsCount === 0) return u;
        for (h in l = this._events) t.call(l, h) && u.push(e ? h.slice(1) : h);
        return Object.getOwnPropertySymbols ? u.concat(Object.getOwnPropertySymbols(l)) : u;
      }, a.prototype.listeners = function(u) {
        var l = e ? e + u : u, h = this._events[l];
        if (!h) return [];
        if (h.fn) return [
          h.fn
        ];
        for (var f = 0, p = h.length, m = new Array(p); f < p; f++) m[f] = h[f].fn;
        return m;
      }, a.prototype.listenerCount = function(u) {
        var l = e ? e + u : u, h = this._events[l];
        return h ? h.fn ? 1 : h.length : 0;
      }, a.prototype.emit = function(u, l, h, f, p, m) {
        var y = e ? e + u : u;
        if (!this._events[y]) return false;
        var b = this._events[y], v = arguments.length, A, T;
        if (b.fn) {
          switch (b.once && this.removeListener(u, b.fn, void 0, true), v) {
            case 1:
              return b.fn.call(b.context), true;
            case 2:
              return b.fn.call(b.context, l), true;
            case 3:
              return b.fn.call(b.context, l, h), true;
            case 4:
              return b.fn.call(b.context, l, h, f), true;
            case 5:
              return b.fn.call(b.context, l, h, f, p), true;
            case 6:
              return b.fn.call(b.context, l, h, f, p, m), true;
          }
          for (T = 1, A = new Array(v - 1); T < v; T++) A[T - 1] = arguments[T];
          b.fn.apply(b.context, A);
        } else {
          var G = b.length, H;
          for (T = 0; T < G; T++) switch (b[T].once && this.removeListener(u, b[T].fn, void 0, true), v) {
            case 1:
              b[T].fn.call(b[T].context);
              break;
            case 2:
              b[T].fn.call(b[T].context, l);
              break;
            case 3:
              b[T].fn.call(b[T].context, l, h);
              break;
            case 4:
              b[T].fn.call(b[T].context, l, h, f);
              break;
            default:
              if (!A) for (H = 1, A = new Array(v - 1); H < v; H++) A[H - 1] = arguments[H];
              b[T].fn.apply(b[T].context, A);
          }
        }
        return true;
      }, a.prototype.on = function(u, l, h) {
        return s(this, u, l, h, false);
      }, a.prototype.once = function(u, l, h) {
        return s(this, u, l, h, true);
      }, a.prototype.removeListener = function(u, l, h, f) {
        var p = e ? e + u : u;
        if (!this._events[p]) return this;
        if (!l) return o(this, p), this;
        var m = this._events[p];
        if (m.fn) m.fn === l && (!f || m.once) && (!h || m.context === h) && o(this, p);
        else {
          for (var y = 0, b = [], v = m.length; y < v; y++) (m[y].fn !== l || f && !m[y].once || h && m[y].context !== h) && b.push(m[y]);
          b.length ? this._events[p] = b.length === 1 ? b[0] : b : o(this, p);
        }
        return this;
      }, a.prototype.removeAllListeners = function(u) {
        var l;
        return u ? (l = e ? e + u : u, this._events[l] && o(this, l)) : (this._events = new r(), this._eventsCount = 0), this;
      }, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = e, a.EventEmitter = a, i.exports = a;
    }(xn)), xn.exports;
  }
  var Sp = vp();
  const me = Ko(Sp), Ep = Math.PI * 2, Ap = 180 / Math.PI, Tp = Math.PI / 180;
  class Ct {
    constructor(t = 0, e = 0) {
      this.x = 0, this.y = 0, this.x = t, this.y = e;
    }
    clone() {
      return new Ct(this.x, this.y);
    }
    copyFrom(t) {
      return this.set(t.x, t.y), this;
    }
    copyTo(t) {
      return t.set(this.x, this.y), t;
    }
    equals(t) {
      return t.x === this.x && t.y === this.y;
    }
    set(t = 0, e = t) {
      return this.x = t, this.y = e, this;
    }
    toString() {
      return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;
    }
    static get shared() {
      return Ss.x = 0, Ss.y = 0, Ss;
    }
  }
  const Ss = new Ct();
  class nt {
    constructor(t = 1, e = 0, r = 0, n = 1, s = 0, o = 0) {
      this.array = null, this.a = t, this.b = e, this.c = r, this.d = n, this.tx = s, this.ty = o;
    }
    fromArray(t) {
      this.a = t[0], this.b = t[1], this.c = t[3], this.d = t[4], this.tx = t[2], this.ty = t[5];
    }
    set(t, e, r, n, s, o) {
      return this.a = t, this.b = e, this.c = r, this.d = n, this.tx = s, this.ty = o, this;
    }
    toArray(t, e) {
      this.array || (this.array = new Float32Array(9));
      const r = e || this.array;
      return t ? (r[0] = this.a, r[1] = this.b, r[2] = 0, r[3] = this.c, r[4] = this.d, r[5] = 0, r[6] = this.tx, r[7] = this.ty, r[8] = 1) : (r[0] = this.a, r[1] = this.c, r[2] = this.tx, r[3] = this.b, r[4] = this.d, r[5] = this.ty, r[6] = 0, r[7] = 0, r[8] = 1), r;
    }
    apply(t, e) {
      e = e || new Ct();
      const r = t.x, n = t.y;
      return e.x = this.a * r + this.c * n + this.tx, e.y = this.b * r + this.d * n + this.ty, e;
    }
    applyInverse(t, e) {
      e = e || new Ct();
      const r = this.a, n = this.b, s = this.c, o = this.d, a = this.tx, c = this.ty, u = 1 / (r * o + s * -n), l = t.x, h = t.y;
      return e.x = o * u * l + -s * u * h + (c * s - a * o) * u, e.y = r * u * h + -n * u * l + (-c * r + a * n) * u, e;
    }
    translate(t, e) {
      return this.tx += t, this.ty += e, this;
    }
    scale(t, e) {
      return this.a *= t, this.d *= e, this.c *= t, this.b *= e, this.tx *= t, this.ty *= e, this;
    }
    rotate(t) {
      const e = Math.cos(t), r = Math.sin(t), n = this.a, s = this.c, o = this.tx;
      return this.a = n * e - this.b * r, this.b = n * r + this.b * e, this.c = s * e - this.d * r, this.d = s * r + this.d * e, this.tx = o * e - this.ty * r, this.ty = o * r + this.ty * e, this;
    }
    append(t) {
      const e = this.a, r = this.b, n = this.c, s = this.d;
      return this.a = t.a * e + t.b * n, this.b = t.a * r + t.b * s, this.c = t.c * e + t.d * n, this.d = t.c * r + t.d * s, this.tx = t.tx * e + t.ty * n + this.tx, this.ty = t.tx * r + t.ty * s + this.ty, this;
    }
    appendFrom(t, e) {
      const r = t.a, n = t.b, s = t.c, o = t.d, a = t.tx, c = t.ty, u = e.a, l = e.b, h = e.c, f = e.d;
      return this.a = r * u + n * h, this.b = r * l + n * f, this.c = s * u + o * h, this.d = s * l + o * f, this.tx = a * u + c * h + e.tx, this.ty = a * l + c * f + e.ty, this;
    }
    setTransform(t, e, r, n, s, o, a, c, u) {
      return this.a = Math.cos(a + u) * s, this.b = Math.sin(a + u) * s, this.c = -Math.sin(a - c) * o, this.d = Math.cos(a - c) * o, this.tx = t - (r * this.a + n * this.c), this.ty = e - (r * this.b + n * this.d), this;
    }
    prepend(t) {
      const e = this.tx;
      if (t.a !== 1 || t.b !== 0 || t.c !== 0 || t.d !== 1) {
        const r = this.a, n = this.c;
        this.a = r * t.a + this.b * t.c, this.b = r * t.b + this.b * t.d, this.c = n * t.a + this.d * t.c, this.d = n * t.b + this.d * t.d;
      }
      return this.tx = e * t.a + this.ty * t.c + t.tx, this.ty = e * t.b + this.ty * t.d + t.ty, this;
    }
    decompose(t) {
      const e = this.a, r = this.b, n = this.c, s = this.d, o = t.pivot, a = -Math.atan2(-n, s), c = Math.atan2(r, e), u = Math.abs(a + c);
      return u < 1e-5 || Math.abs(Ep - u) < 1e-5 ? (t.rotation = c, t.skew.x = t.skew.y = 0) : (t.rotation = 0, t.skew.x = a, t.skew.y = c), t.scale.x = Math.sqrt(e * e + r * r), t.scale.y = Math.sqrt(n * n + s * s), t.position.x = this.tx + (o.x * e + o.y * n), t.position.y = this.ty + (o.x * r + o.y * s), t;
    }
    invert() {
      const t = this.a, e = this.b, r = this.c, n = this.d, s = this.tx, o = t * n - e * r;
      return this.a = n / o, this.b = -e / o, this.c = -r / o, this.d = t / o, this.tx = (r * this.ty - n * s) / o, this.ty = -(t * this.ty - e * s) / o, this;
    }
    isIdentity() {
      return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;
    }
    identity() {
      return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this;
    }
    clone() {
      const t = new nt();
      return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t;
    }
    copyTo(t) {
      return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t;
    }
    copyFrom(t) {
      return this.a = t.a, this.b = t.b, this.c = t.c, this.d = t.d, this.tx = t.tx, this.ty = t.ty, this;
    }
    equals(t) {
      return t.a === this.a && t.b === this.b && t.c === this.c && t.d === this.d && t.tx === this.tx && t.ty === this.ty;
    }
    toString() {
      return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
    }
    static get IDENTITY() {
      return Rp.identity();
    }
    static get shared() {
      return Cp.identity();
    }
  }
  const Cp = new nt(), Rp = new nt(), Sr = [
    1,
    1,
    0,
    -1,
    -1,
    -1,
    0,
    1,
    1,
    1,
    0,
    -1,
    -1,
    -1,
    0,
    1
  ], Er = [
    0,
    1,
    1,
    1,
    0,
    -1,
    -1,
    -1,
    0,
    1,
    1,
    1,
    0,
    -1,
    -1,
    -1
  ], Ar = [
    0,
    -1,
    -1,
    -1,
    0,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    0,
    -1,
    -1,
    -1
  ], Tr = [
    1,
    1,
    0,
    -1,
    -1,
    -1,
    0,
    1,
    -1,
    -1,
    0,
    1,
    1,
    1,
    0,
    -1
  ], go = [], Cl = [], Vi = Math.sign;
  function Pp() {
    for (let i = 0; i < 16; i++) {
      const t = [];
      go.push(t);
      for (let e = 0; e < 16; e++) {
        const r = Vi(Sr[i] * Sr[e] + Ar[i] * Er[e]), n = Vi(Er[i] * Sr[e] + Tr[i] * Er[e]), s = Vi(Sr[i] * Ar[e] + Ar[i] * Tr[e]), o = Vi(Er[i] * Ar[e] + Tr[i] * Tr[e]);
        for (let a = 0; a < 16; a++) if (Sr[a] === r && Er[a] === n && Ar[a] === s && Tr[a] === o) {
          t.push(a);
          break;
        }
      }
    }
    for (let i = 0; i < 16; i++) {
      const t = new nt();
      t.set(Sr[i], Er[i], Ar[i], Tr[i], 0, 0), Cl.push(t);
    }
  }
  Pp();
  const kt = {
    E: 0,
    SE: 1,
    S: 2,
    SW: 3,
    W: 4,
    NW: 5,
    N: 6,
    NE: 7,
    MIRROR_VERTICAL: 8,
    MAIN_DIAGONAL: 10,
    MIRROR_HORIZONTAL: 12,
    REVERSE_DIAGONAL: 14,
    uX: (i) => Sr[i],
    uY: (i) => Er[i],
    vX: (i) => Ar[i],
    vY: (i) => Tr[i],
    inv: (i) => i & 8 ? i & 15 : -i & 7,
    add: (i, t) => go[i][t],
    sub: (i, t) => go[i][kt.inv(t)],
    rotate180: (i) => i ^ 4,
    isVertical: (i) => (i & 3) === 2,
    byDirection: (i, t) => Math.abs(i) * 2 <= Math.abs(t) ? t >= 0 ? kt.S : kt.N : Math.abs(t) * 2 <= Math.abs(i) ? i > 0 ? kt.E : kt.W : t > 0 ? i > 0 ? kt.SE : kt.SW : i > 0 ? kt.NE : kt.NW,
    matrixAppendRotationInv: (i, t, e = 0, r = 0) => {
      const n = Cl[kt.inv(t)];
      n.tx = e, n.ty = r, i.append(n);
    }
  }, Xi = [
    new Ct(),
    new Ct(),
    new Ct(),
    new Ct()
  ];
  class Et {
    constructor(t = 0, e = 0, r = 0, n = 0) {
      this.type = "rectangle", this.x = Number(t), this.y = Number(e), this.width = Number(r), this.height = Number(n);
    }
    get left() {
      return this.x;
    }
    get right() {
      return this.x + this.width;
    }
    get top() {
      return this.y;
    }
    get bottom() {
      return this.y + this.height;
    }
    isEmpty() {
      return this.left === this.right || this.top === this.bottom;
    }
    static get EMPTY() {
      return new Et(0, 0, 0, 0);
    }
    clone() {
      return new Et(this.x, this.y, this.width, this.height);
    }
    copyFromBounds(t) {
      return this.x = t.minX, this.y = t.minY, this.width = t.maxX - t.minX, this.height = t.maxY - t.minY, this;
    }
    copyFrom(t) {
      return this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height, this;
    }
    copyTo(t) {
      return t.copyFrom(this), t;
    }
    contains(t, e) {
      return this.width <= 0 || this.height <= 0 ? false : t >= this.x && t < this.x + this.width && e >= this.y && e < this.y + this.height;
    }
    strokeContains(t, e, r) {
      const { width: n, height: s } = this;
      if (n <= 0 || s <= 0) return false;
      const o = this.x, a = this.y, c = o - r / 2, u = o + n + r / 2, l = a - r / 2, h = a + s + r / 2, f = o + r / 2, p = o + n - r / 2, m = a + r / 2, y = a + s - r / 2;
      return t >= c && t <= u && e >= l && e <= h && !(t > f && t < p && e > m && e < y);
    }
    intersects(t, e) {
      if (!e) {
        const W = this.x < t.x ? t.x : this.x;
        if ((this.right > t.right ? t.right : this.right) <= W) return false;
        const I = this.y < t.y ? t.y : this.y;
        return (this.bottom > t.bottom ? t.bottom : this.bottom) > I;
      }
      const r = this.left, n = this.right, s = this.top, o = this.bottom;
      if (n <= r || o <= s) return false;
      const a = Xi[0].set(t.left, t.top), c = Xi[1].set(t.left, t.bottom), u = Xi[2].set(t.right, t.top), l = Xi[3].set(t.right, t.bottom);
      if (u.x <= a.x || c.y <= a.y) return false;
      const h = Math.sign(e.a * e.d - e.b * e.c);
      if (h === 0 || (e.apply(a, a), e.apply(c, c), e.apply(u, u), e.apply(l, l), Math.max(a.x, c.x, u.x, l.x) <= r || Math.min(a.x, c.x, u.x, l.x) >= n || Math.max(a.y, c.y, u.y, l.y) <= s || Math.min(a.y, c.y, u.y, l.y) >= o)) return false;
      const f = h * (c.y - a.y), p = h * (a.x - c.x), m = f * r + p * s, y = f * n + p * s, b = f * r + p * o, v = f * n + p * o;
      if (Math.max(m, y, b, v) <= f * a.x + p * a.y || Math.min(m, y, b, v) >= f * l.x + p * l.y) return false;
      const A = h * (a.y - u.y), T = h * (u.x - a.x), G = A * r + T * s, H = A * n + T * s, Y = A * r + T * o, L = A * n + T * o;
      return !(Math.max(G, H, Y, L) <= A * a.x + T * a.y || Math.min(G, H, Y, L) >= A * l.x + T * l.y);
    }
    pad(t = 0, e = t) {
      return this.x -= t, this.y -= e, this.width += t * 2, this.height += e * 2, this;
    }
    fit(t) {
      const e = Math.max(this.x, t.x), r = Math.min(this.x + this.width, t.x + t.width), n = Math.max(this.y, t.y), s = Math.min(this.y + this.height, t.y + t.height);
      return this.x = e, this.width = Math.max(r - e, 0), this.y = n, this.height = Math.max(s - n, 0), this;
    }
    ceil(t = 1, e = 1e-3) {
      const r = Math.ceil((this.x + this.width - e) * t) / t, n = Math.ceil((this.y + this.height - e) * t) / t;
      return this.x = Math.floor((this.x + e) * t) / t, this.y = Math.floor((this.y + e) * t) / t, this.width = r - this.x, this.height = n - this.y, this;
    }
    enlarge(t) {
      const e = Math.min(this.x, t.x), r = Math.max(this.x + this.width, t.x + t.width), n = Math.min(this.y, t.y), s = Math.max(this.y + this.height, t.y + t.height);
      return this.x = e, this.width = r - e, this.y = n, this.height = s - n, this;
    }
    getBounds(t) {
      return t = t || new Et(), t.copyFrom(this), t;
    }
    toString() {
      return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
    }
  }
  const Es = {
    default: -1
  };
  function Ot(i = "default") {
    return Es[i] === void 0 && (Es[i] = -1), ++Es[i];
  }
  const ec = {}, dt = "8.0.0";
  function lt(i, t, e = 3) {
    if (ec[t]) return;
    let r = new Error().stack;
    typeof r > "u" ? console.warn("PixiJS Deprecation Warning: ", `${t}
Deprecated since v${i}`) : (r = r.split(`
`).splice(e).join(`
`), console.groupCollapsed ? (console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", `${t}
Deprecated since v${i}`), console.warn(r), console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", `${t}
Deprecated since v${i}`), console.warn(r))), ec[t] = true;
  }
  const Rl = () => {
  };
  function $r(i) {
    return i += i === 0 ? 1 : 0, --i, i |= i >>> 1, i |= i >>> 2, i |= i >>> 4, i |= i >>> 8, i |= i >>> 16, i + 1;
  }
  function rc(i) {
    return !(i & i - 1) && !!i;
  }
  function mo(i) {
    const t = {};
    for (const e in i) i[e] !== void 0 && (t[e] = i[e]);
    return t;
  }
  const ic = /* @__PURE__ */ Object.create(null);
  function Bp(i) {
    const t = ic[i];
    return t === void 0 && (ic[i] = Ot("resource")), t;
  }
  const Pl = class Bl extends me {
    constructor(t = {}) {
      super(), this._resourceType = "textureSampler", this._touched = 0, this._maxAnisotropy = 1, this.destroyed = false, t = {
        ...Bl.defaultOptions,
        ...t
      }, this.addressMode = t.addressMode, this.addressModeU = t.addressModeU ?? this.addressModeU, this.addressModeV = t.addressModeV ?? this.addressModeV, this.addressModeW = t.addressModeW ?? this.addressModeW, this.scaleMode = t.scaleMode, this.magFilter = t.magFilter ?? this.magFilter, this.minFilter = t.minFilter ?? this.minFilter, this.mipmapFilter = t.mipmapFilter ?? this.mipmapFilter, this.lodMinClamp = t.lodMinClamp, this.lodMaxClamp = t.lodMaxClamp, this.compare = t.compare, this.maxAnisotropy = t.maxAnisotropy ?? 1;
    }
    set addressMode(t) {
      this.addressModeU = t, this.addressModeV = t, this.addressModeW = t;
    }
    get addressMode() {
      return this.addressModeU;
    }
    set wrapMode(t) {
      lt(dt, "TextureStyle.wrapMode is now TextureStyle.addressMode"), this.addressMode = t;
    }
    get wrapMode() {
      return this.addressMode;
    }
    set scaleMode(t) {
      this.magFilter = t, this.minFilter = t, this.mipmapFilter = t;
    }
    get scaleMode() {
      return this.magFilter;
    }
    set maxAnisotropy(t) {
      this._maxAnisotropy = Math.min(t, 16), this._maxAnisotropy > 1 && (this.scaleMode = "linear");
    }
    get maxAnisotropy() {
      return this._maxAnisotropy;
    }
    get _resourceId() {
      return this._sharedResourceId || this._generateResourceId();
    }
    update() {
      this.emit("change", this), this._sharedResourceId = null;
    }
    _generateResourceId() {
      const t = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;
      return this._sharedResourceId = Bp(t), this._resourceId;
    }
    destroy() {
      this.destroyed = true, this.emit("destroy", this), this.emit("change", this), this.removeAllListeners();
    }
  };
  Pl.defaultOptions = {
    addressMode: "clamp-to-edge",
    scaleMode: "linear"
  };
  let Mp = Pl;
  const Ml = class Dl extends me {
    constructor(t = {}) {
      super(), this.options = t, this.uid = Ot("textureSource"), this._resourceType = "textureSource", this._resourceId = Ot("resource"), this.uploadMethodId = "unknown", this._resolution = 1, this.pixelWidth = 1, this.pixelHeight = 1, this.width = 1, this.height = 1, this.sampleCount = 1, this.mipLevelCount = 1, this.autoGenerateMipmaps = false, this.format = "rgba8unorm", this.dimension = "2d", this.antialias = false, this._touched = 0, this._batchTick = -1, this._textureBindLocation = -1, t = {
        ...Dl.defaultOptions,
        ...t
      }, this.label = t.label ?? "", this.resource = t.resource, this.autoGarbageCollect = t.autoGarbageCollect, this._resolution = t.resolution, t.width ? this.pixelWidth = t.width * this._resolution : this.pixelWidth = this.resource ? this.resourceWidth ?? 1 : 1, t.height ? this.pixelHeight = t.height * this._resolution : this.pixelHeight = this.resource ? this.resourceHeight ?? 1 : 1, this.width = this.pixelWidth / this._resolution, this.height = this.pixelHeight / this._resolution, this.format = t.format, this.dimension = t.dimensions, this.mipLevelCount = t.mipLevelCount, this.autoGenerateMipmaps = t.autoGenerateMipmaps, this.sampleCount = t.sampleCount, this.antialias = t.antialias, this.alphaMode = t.alphaMode, this.style = new Mp(mo(t)), this.destroyed = false, this._refreshPOT();
    }
    get source() {
      return this;
    }
    get style() {
      return this._style;
    }
    set style(t) {
      var _a2, _b2;
      this.style !== t && ((_a2 = this._style) == null ? void 0 : _a2.off("change", this._onStyleChange, this), this._style = t, (_b2 = this._style) == null ? void 0 : _b2.on("change", this._onStyleChange, this), this._onStyleChange());
    }
    get addressMode() {
      return this._style.addressMode;
    }
    set addressMode(t) {
      this._style.addressMode = t;
    }
    get repeatMode() {
      return this._style.addressMode;
    }
    set repeatMode(t) {
      this._style.addressMode = t;
    }
    get magFilter() {
      return this._style.magFilter;
    }
    set magFilter(t) {
      this._style.magFilter = t;
    }
    get minFilter() {
      return this._style.minFilter;
    }
    set minFilter(t) {
      this._style.minFilter = t;
    }
    get mipmapFilter() {
      return this._style.mipmapFilter;
    }
    set mipmapFilter(t) {
      this._style.mipmapFilter = t;
    }
    get lodMinClamp() {
      return this._style.lodMinClamp;
    }
    set lodMinClamp(t) {
      this._style.lodMinClamp = t;
    }
    get lodMaxClamp() {
      return this._style.lodMaxClamp;
    }
    set lodMaxClamp(t) {
      this._style.lodMaxClamp = t;
    }
    _onStyleChange() {
      this.emit("styleChange", this);
    }
    update() {
      if (this.resource) {
        const t = this._resolution;
        if (this.resize(this.resourceWidth / t, this.resourceHeight / t)) return;
      }
      this.emit("update", this);
    }
    destroy() {
      this.destroyed = true, this.emit("destroy", this), this.emit("change", this), this._style && (this._style.destroy(), this._style = null), this.uploadMethodId = null, this.resource = null, this.removeAllListeners();
    }
    unload() {
      this._resourceId = Ot("resource"), this.emit("change", this), this.emit("unload", this);
    }
    get resourceWidth() {
      const { resource: t } = this;
      return t.naturalWidth || t.videoWidth || t.displayWidth || t.width;
    }
    get resourceHeight() {
      const { resource: t } = this;
      return t.naturalHeight || t.videoHeight || t.displayHeight || t.height;
    }
    get resolution() {
      return this._resolution;
    }
    set resolution(t) {
      this._resolution !== t && (this._resolution = t, this.width = this.pixelWidth / t, this.height = this.pixelHeight / t);
    }
    resize(t, e, r) {
      r = r || this._resolution, t = t || this.width, e = e || this.height;
      const n = Math.round(t * r), s = Math.round(e * r);
      return this.width = n / r, this.height = s / r, this._resolution = r, this.pixelWidth === n && this.pixelHeight === s ? false : (this._refreshPOT(), this.pixelWidth = n, this.pixelHeight = s, this.emit("resize", this), this._resourceId = Ot("resource"), this.emit("change", this), true);
    }
    updateMipmaps() {
      this.autoGenerateMipmaps && this.mipLevelCount > 1 && this.emit("updateMipmaps", this);
    }
    set wrapMode(t) {
      this._style.wrapMode = t;
    }
    get wrapMode() {
      return this._style.wrapMode;
    }
    set scaleMode(t) {
      this._style.scaleMode = t;
    }
    get scaleMode() {
      return this._style.scaleMode;
    }
    _refreshPOT() {
      this.isPowerOfTwo = rc(this.pixelWidth) && rc(this.pixelHeight);
    }
    static test(t) {
      throw new Error("Unimplemented");
    }
  };
  Ml.defaultOptions = {
    resolution: 1,
    format: "bgra8unorm",
    alphaMode: "premultiply-alpha-on-upload",
    dimensions: "2d",
    mipLevelCount: 1,
    autoGenerateMipmaps: false,
    sampleCount: 1,
    antialias: false,
    autoGarbageCollect: false
  };
  let Ht = Ml;
  class Zo extends Ht {
    constructor(t) {
      const e = t.resource || new Float32Array(t.width * t.height * 4);
      let r = t.format;
      r || (e instanceof Float32Array ? r = "rgba32float" : e instanceof Int32Array || e instanceof Uint32Array ? r = "rgba32uint" : e instanceof Int16Array || e instanceof Uint16Array ? r = "rgba16uint" : (e instanceof Int8Array, r = "bgra8unorm")), super({
        ...t,
        resource: e,
        format: r
      }), this.uploadMethodId = "buffer";
    }
    static test(t) {
      return t instanceof Int8Array || t instanceof Uint8Array || t instanceof Uint8ClampedArray || t instanceof Int16Array || t instanceof Uint16Array || t instanceof Int32Array || t instanceof Uint32Array || t instanceof Float32Array;
    }
  }
  Zo.extension = P.TextureSource;
  const nc = new nt();
  class Il {
    constructor(t, e) {
      this.mapCoord = new nt(), this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, typeof e > "u" ? this.clampMargin = t.width < 10 ? 0 : 0.5 : this.clampMargin = e, this.isSimple = false, this.texture = t;
    }
    get texture() {
      return this._texture;
    }
    set texture(t) {
      var _a2;
      this.texture !== t && ((_a2 = this._texture) == null ? void 0 : _a2.removeListener("update", this.update, this), this._texture = t, this._texture.addListener("update", this.update, this), this.update());
    }
    multiplyUvs(t, e) {
      e === void 0 && (e = t);
      const r = this.mapCoord;
      for (let n = 0; n < t.length; n += 2) {
        const s = t[n], o = t[n + 1];
        e[n] = s * r.a + o * r.c + r.tx, e[n + 1] = s * r.b + o * r.d + r.ty;
      }
      return e;
    }
    update() {
      const t = this._texture;
      this._updateID++;
      const e = t.uvs;
      this.mapCoord.set(e.x1 - e.x0, e.y1 - e.y0, e.x3 - e.x0, e.y3 - e.y0, e.x0, e.y0);
      const r = t.orig, n = t.trim;
      n && (nc.set(r.width / n.width, 0, 0, r.height / n.height, -n.x / n.width, -n.y / n.height), this.mapCoord.append(nc));
      const s = t.source, o = this.uClampFrame, a = this.clampMargin / s._resolution, c = this.clampOffset;
      return o[0] = (t.frame.x + a + c) / s.width, o[1] = (t.frame.y + a + c) / s.height, o[2] = (t.frame.x + t.frame.width - a + c) / s.width, o[3] = (t.frame.y + t.frame.height - a + c) / s.height, this.uClampOffset[0] = c / s.pixelWidth, this.uClampOffset[1] = c / s.pixelHeight, this.isSimple = t.frame.width === s.width && t.frame.height === s.height && t.rotate === 0, true;
    }
  }
  class J extends me {
    constructor({ source: t, label: e, frame: r, orig: n, trim: s, defaultAnchor: o, defaultBorders: a, rotate: c, dynamic: u } = {}) {
      if (super(), this.uid = Ot("texture"), this.uvs = {
        x0: 0,
        y0: 0,
        x1: 0,
        y1: 0,
        x2: 0,
        y2: 0,
        x3: 0,
        y3: 0
      }, this.frame = new Et(), this.noFrame = false, this.dynamic = false, this.isTexture = true, this.label = e, this.source = (t == null ? void 0 : t.source) ?? new Ht(), this.noFrame = !r, r) this.frame.copyFrom(r);
      else {
        const { width: l, height: h } = this._source;
        this.frame.width = l, this.frame.height = h;
      }
      this.orig = n || this.frame, this.trim = s, this.rotate = c ?? 0, this.defaultAnchor = o, this.defaultBorders = a, this.destroyed = false, this.dynamic = u || false, this.updateUvs();
    }
    set source(t) {
      this._source && this._source.off("resize", this.update, this), this._source = t, t.on("resize", this.update, this), this.emit("update", this);
    }
    get source() {
      return this._source;
    }
    get textureMatrix() {
      return this._textureMatrix || (this._textureMatrix = new Il(this)), this._textureMatrix;
    }
    get width() {
      return this.orig.width;
    }
    get height() {
      return this.orig.height;
    }
    updateUvs() {
      const { uvs: t, frame: e } = this, { width: r, height: n } = this._source, s = e.x / r, o = e.y / n, a = e.width / r, c = e.height / n;
      let u = this.rotate;
      if (u) {
        const l = a / 2, h = c / 2, f = s + l, p = o + h;
        u = kt.add(u, kt.NW), t.x0 = f + l * kt.uX(u), t.y0 = p + h * kt.uY(u), u = kt.add(u, 2), t.x1 = f + l * kt.uX(u), t.y1 = p + h * kt.uY(u), u = kt.add(u, 2), t.x2 = f + l * kt.uX(u), t.y2 = p + h * kt.uY(u), u = kt.add(u, 2), t.x3 = f + l * kt.uX(u), t.y3 = p + h * kt.uY(u);
      } else t.x0 = s, t.y0 = o, t.x1 = s + a, t.y1 = o, t.x2 = s + a, t.y2 = o + c, t.x3 = s, t.y3 = o + c;
    }
    destroy(t = false) {
      this._source && t && (this._source.destroy(), this._source = null), this._textureMatrix = null, this.destroyed = true, this.emit("destroy", this), this.removeAllListeners();
    }
    update() {
      this.noFrame && (this.frame.width = this._source.width, this.frame.height = this._source.height), this.updateUvs(), this.emit("update", this);
    }
    get baseTexture() {
      return lt(dt, "Texture.baseTexture is now Texture.source"), this._source;
    }
  }
  J.EMPTY = new J({
    label: "EMPTY",
    source: new Ht({
      label: "EMPTY"
    })
  });
  J.EMPTY.destroy = Rl;
  J.WHITE = new J({
    source: new Zo({
      resource: new Uint8Array([
        255,
        255,
        255,
        255
      ]),
      width: 1,
      height: 1,
      alphaMode: "premultiply-alpha-on-upload",
      label: "WHITE"
    }),
    label: "WHITE"
  });
  J.WHITE.destroy = Rl;
  function Cn(i, t, e, r) {
    const { width: n, height: s } = e.orig, o = e.trim;
    if (o) {
      const a = o.width, c = o.height;
      i.minX = o.x - t._x * n - r, i.maxX = i.minX + a, i.minY = o.y - t._y * s - r, i.maxY = i.minY + c;
    } else i.minX = -t._x * n - r, i.maxX = i.minX + n, i.minY = -t._y * s - r, i.maxY = i.minY + s;
  }
  var Dp = {
    grad: 0.9,
    turn: 360,
    rad: 360 / (2 * Math.PI)
  }, We = function(i) {
    return typeof i == "string" ? i.length > 0 : typeof i == "number";
  }, Yt = function(i, t, e) {
    return t === void 0 && (t = 0), e === void 0 && (e = Math.pow(10, t)), Math.round(e * i) / e + 0;
  }, ye = function(i, t, e) {
    return t === void 0 && (t = 0), e === void 0 && (e = 1), i > e ? e : i > t ? i : t;
  }, Fl = function(i) {
    return (i = isFinite(i) ? i % 360 : 0) > 0 ? i : i + 360;
  }, sc = function(i) {
    return {
      r: ye(i.r, 0, 255),
      g: ye(i.g, 0, 255),
      b: ye(i.b, 0, 255),
      a: ye(i.a)
    };
  }, As = function(i) {
    return {
      r: Yt(i.r),
      g: Yt(i.g),
      b: Yt(i.b),
      a: Yt(i.a, 3)
    };
  }, Ip = /^#([0-9a-f]{3,8})$/i, qi = function(i) {
    var t = i.toString(16);
    return t.length < 2 ? "0" + t : t;
  }, Ul = function(i) {
    var t = i.r, e = i.g, r = i.b, n = i.a, s = Math.max(t, e, r), o = s - Math.min(t, e, r), a = o ? s === t ? (e - r) / o : s === e ? 2 + (r - t) / o : 4 + (t - e) / o : 0;
    return {
      h: 60 * (a < 0 ? a + 6 : a),
      s: s ? o / s * 100 : 0,
      v: s / 255 * 100,
      a: n
    };
  }, kl = function(i) {
    var t = i.h, e = i.s, r = i.v, n = i.a;
    t = t / 360 * 6, e /= 100, r /= 100;
    var s = Math.floor(t), o = r * (1 - e), a = r * (1 - (t - s) * e), c = r * (1 - (1 - t + s) * e), u = s % 6;
    return {
      r: 255 * [
        r,
        a,
        o,
        o,
        c,
        r
      ][u],
      g: 255 * [
        c,
        r,
        r,
        a,
        o,
        o
      ][u],
      b: 255 * [
        o,
        o,
        c,
        r,
        r,
        a
      ][u],
      a: n
    };
  }, oc = function(i) {
    return {
      h: Fl(i.h),
      s: ye(i.s, 0, 100),
      l: ye(i.l, 0, 100),
      a: ye(i.a)
    };
  }, ac = function(i) {
    return {
      h: Yt(i.h),
      s: Yt(i.s),
      l: Yt(i.l),
      a: Yt(i.a, 3)
    };
  }, cc = function(i) {
    return kl((e = (t = i).s, {
      h: t.h,
      s: (e *= ((r = t.l) < 50 ? r : 100 - r) / 100) > 0 ? 2 * e / (r + e) * 100 : 0,
      v: r + e,
      a: t.a
    }));
    var t, e, r;
  }, wi = function(i) {
    return {
      h: (t = Ul(i)).h,
      s: (n = (200 - (e = t.s)) * (r = t.v) / 100) > 0 && n < 200 ? e * r / 100 / (n <= 100 ? n : 200 - n) * 100 : 0,
      l: n / 2,
      a: t.a
    };
    var t, e, r, n;
  }, Fp = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, Up = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, kp = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, Gp = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, bo = {
    string: [
      [
        function(i) {
          var t = Ip.exec(i);
          return t ? (i = t[1]).length <= 4 ? {
            r: parseInt(i[0] + i[0], 16),
            g: parseInt(i[1] + i[1], 16),
            b: parseInt(i[2] + i[2], 16),
            a: i.length === 4 ? Yt(parseInt(i[3] + i[3], 16) / 255, 2) : 1
          } : i.length === 6 || i.length === 8 ? {
            r: parseInt(i.substr(0, 2), 16),
            g: parseInt(i.substr(2, 2), 16),
            b: parseInt(i.substr(4, 2), 16),
            a: i.length === 8 ? Yt(parseInt(i.substr(6, 2), 16) / 255, 2) : 1
          } : null : null;
        },
        "hex"
      ],
      [
        function(i) {
          var t = kp.exec(i) || Gp.exec(i);
          return t ? t[2] !== t[4] || t[4] !== t[6] ? null : sc({
            r: Number(t[1]) / (t[2] ? 100 / 255 : 1),
            g: Number(t[3]) / (t[4] ? 100 / 255 : 1),
            b: Number(t[5]) / (t[6] ? 100 / 255 : 1),
            a: t[7] === void 0 ? 1 : Number(t[7]) / (t[8] ? 100 : 1)
          }) : null;
        },
        "rgb"
      ],
      [
        function(i) {
          var t = Fp.exec(i) || Up.exec(i);
          if (!t) return null;
          var e, r, n = oc({
            h: (e = t[1], r = t[2], r === void 0 && (r = "deg"), Number(e) * (Dp[r] || 1)),
            s: Number(t[3]),
            l: Number(t[4]),
            a: t[5] === void 0 ? 1 : Number(t[5]) / (t[6] ? 100 : 1)
          });
          return cc(n);
        },
        "hsl"
      ]
    ],
    object: [
      [
        function(i) {
          var t = i.r, e = i.g, r = i.b, n = i.a, s = n === void 0 ? 1 : n;
          return We(t) && We(e) && We(r) ? sc({
            r: Number(t),
            g: Number(e),
            b: Number(r),
            a: Number(s)
          }) : null;
        },
        "rgb"
      ],
      [
        function(i) {
          var t = i.h, e = i.s, r = i.l, n = i.a, s = n === void 0 ? 1 : n;
          if (!We(t) || !We(e) || !We(r)) return null;
          var o = oc({
            h: Number(t),
            s: Number(e),
            l: Number(r),
            a: Number(s)
          });
          return cc(o);
        },
        "hsl"
      ],
      [
        function(i) {
          var t = i.h, e = i.s, r = i.v, n = i.a, s = n === void 0 ? 1 : n;
          if (!We(t) || !We(e) || !We(r)) return null;
          var o = function(a) {
            return {
              h: Fl(a.h),
              s: ye(a.s, 0, 100),
              v: ye(a.v, 0, 100),
              a: ye(a.a)
            };
          }({
            h: Number(t),
            s: Number(e),
            v: Number(r),
            a: Number(s)
          });
          return kl(o);
        },
        "hsv"
      ]
    ]
  }, uc = function(i, t) {
    for (var e = 0; e < t.length; e++) {
      var r = t[e][0](i);
      if (r) return [
        r,
        t[e][1]
      ];
    }
    return [
      null,
      void 0
    ];
  }, Op = function(i) {
    return typeof i == "string" ? uc(i.trim(), bo.string) : typeof i == "object" && i !== null ? uc(i, bo.object) : [
      null,
      void 0
    ];
  };
  var Ts = function(i, t) {
    var e = wi(i);
    return {
      h: e.h,
      s: ye(e.s + 100 * t, 0, 100),
      l: e.l,
      a: e.a
    };
  }, Cs = function(i) {
    return (299 * i.r + 587 * i.g + 114 * i.b) / 1e3 / 255;
  }, lc = function(i, t) {
    var e = wi(i);
    return {
      h: e.h,
      s: e.s,
      l: ye(e.l + 100 * t, 0, 100),
      a: e.a
    };
  }, wo = function() {
    function i(t) {
      this.parsed = Op(t)[0], this.rgba = this.parsed || {
        r: 0,
        g: 0,
        b: 0,
        a: 1
      };
    }
    return i.prototype.isValid = function() {
      return this.parsed !== null;
    }, i.prototype.brightness = function() {
      return Yt(Cs(this.rgba), 2);
    }, i.prototype.isDark = function() {
      return Cs(this.rgba) < 0.5;
    }, i.prototype.isLight = function() {
      return Cs(this.rgba) >= 0.5;
    }, i.prototype.toHex = function() {
      return t = As(this.rgba), e = t.r, r = t.g, n = t.b, o = (s = t.a) < 1 ? qi(Yt(255 * s)) : "", "#" + qi(e) + qi(r) + qi(n) + o;
      var t, e, r, n, s, o;
    }, i.prototype.toRgb = function() {
      return As(this.rgba);
    }, i.prototype.toRgbString = function() {
      return t = As(this.rgba), e = t.r, r = t.g, n = t.b, (s = t.a) < 1 ? "rgba(" + e + ", " + r + ", " + n + ", " + s + ")" : "rgb(" + e + ", " + r + ", " + n + ")";
      var t, e, r, n, s;
    }, i.prototype.toHsl = function() {
      return ac(wi(this.rgba));
    }, i.prototype.toHslString = function() {
      return t = ac(wi(this.rgba)), e = t.h, r = t.s, n = t.l, (s = t.a) < 1 ? "hsla(" + e + ", " + r + "%, " + n + "%, " + s + ")" : "hsl(" + e + ", " + r + "%, " + n + "%)";
      var t, e, r, n, s;
    }, i.prototype.toHsv = function() {
      return t = Ul(this.rgba), {
        h: Yt(t.h),
        s: Yt(t.s),
        v: Yt(t.v),
        a: Yt(t.a, 3)
      };
      var t;
    }, i.prototype.invert = function() {
      return Fe({
        r: 255 - (t = this.rgba).r,
        g: 255 - t.g,
        b: 255 - t.b,
        a: t.a
      });
      var t;
    }, i.prototype.saturate = function(t) {
      return t === void 0 && (t = 0.1), Fe(Ts(this.rgba, t));
    }, i.prototype.desaturate = function(t) {
      return t === void 0 && (t = 0.1), Fe(Ts(this.rgba, -t));
    }, i.prototype.grayscale = function() {
      return Fe(Ts(this.rgba, -1));
    }, i.prototype.lighten = function(t) {
      return t === void 0 && (t = 0.1), Fe(lc(this.rgba, t));
    }, i.prototype.darken = function(t) {
      return t === void 0 && (t = 0.1), Fe(lc(this.rgba, -t));
    }, i.prototype.rotate = function(t) {
      return t === void 0 && (t = 15), this.hue(this.hue() + t);
    }, i.prototype.alpha = function(t) {
      return typeof t == "number" ? Fe({
        r: (e = this.rgba).r,
        g: e.g,
        b: e.b,
        a: t
      }) : Yt(this.rgba.a, 3);
      var e;
    }, i.prototype.hue = function(t) {
      var e = wi(this.rgba);
      return typeof t == "number" ? Fe({
        h: t,
        s: e.s,
        l: e.l,
        a: e.a
      }) : Yt(e.h);
    }, i.prototype.isEqual = function(t) {
      return this.toHex() === Fe(t).toHex();
    }, i;
  }(), Fe = function(i) {
    return i instanceof wo ? i : new wo(i);
  }, hc = [], Np = function(i) {
    i.forEach(function(t) {
      hc.indexOf(t) < 0 && (t(wo, bo), hc.push(t));
    });
  };
  function Lp(i, t) {
    var e = {
      white: "#ffffff",
      bisque: "#ffe4c4",
      blue: "#0000ff",
      cadetblue: "#5f9ea0",
      chartreuse: "#7fff00",
      chocolate: "#d2691e",
      coral: "#ff7f50",
      antiquewhite: "#faebd7",
      aqua: "#00ffff",
      azure: "#f0ffff",
      whitesmoke: "#f5f5f5",
      papayawhip: "#ffefd5",
      plum: "#dda0dd",
      blanchedalmond: "#ffebcd",
      black: "#000000",
      gold: "#ffd700",
      goldenrod: "#daa520",
      gainsboro: "#dcdcdc",
      cornsilk: "#fff8dc",
      cornflowerblue: "#6495ed",
      burlywood: "#deb887",
      aquamarine: "#7fffd4",
      beige: "#f5f5dc",
      crimson: "#dc143c",
      cyan: "#00ffff",
      darkblue: "#00008b",
      darkcyan: "#008b8b",
      darkgoldenrod: "#b8860b",
      darkkhaki: "#bdb76b",
      darkgray: "#a9a9a9",
      darkgreen: "#006400",
      darkgrey: "#a9a9a9",
      peachpuff: "#ffdab9",
      darkmagenta: "#8b008b",
      darkred: "#8b0000",
      darkorchid: "#9932cc",
      darkorange: "#ff8c00",
      darkslateblue: "#483d8b",
      gray: "#808080",
      darkslategray: "#2f4f4f",
      darkslategrey: "#2f4f4f",
      deeppink: "#ff1493",
      deepskyblue: "#00bfff",
      wheat: "#f5deb3",
      firebrick: "#b22222",
      floralwhite: "#fffaf0",
      ghostwhite: "#f8f8ff",
      darkviolet: "#9400d3",
      magenta: "#ff00ff",
      green: "#008000",
      dodgerblue: "#1e90ff",
      grey: "#808080",
      honeydew: "#f0fff0",
      hotpink: "#ff69b4",
      blueviolet: "#8a2be2",
      forestgreen: "#228b22",
      lawngreen: "#7cfc00",
      indianred: "#cd5c5c",
      indigo: "#4b0082",
      fuchsia: "#ff00ff",
      brown: "#a52a2a",
      maroon: "#800000",
      mediumblue: "#0000cd",
      lightcoral: "#f08080",
      darkturquoise: "#00ced1",
      lightcyan: "#e0ffff",
      ivory: "#fffff0",
      lightyellow: "#ffffe0",
      lightsalmon: "#ffa07a",
      lightseagreen: "#20b2aa",
      linen: "#faf0e6",
      mediumaquamarine: "#66cdaa",
      lemonchiffon: "#fffacd",
      lime: "#00ff00",
      khaki: "#f0e68c",
      mediumseagreen: "#3cb371",
      limegreen: "#32cd32",
      mediumspringgreen: "#00fa9a",
      lightskyblue: "#87cefa",
      lightblue: "#add8e6",
      midnightblue: "#191970",
      lightpink: "#ffb6c1",
      mistyrose: "#ffe4e1",
      moccasin: "#ffe4b5",
      mintcream: "#f5fffa",
      lightslategray: "#778899",
      lightslategrey: "#778899",
      navajowhite: "#ffdead",
      navy: "#000080",
      mediumvioletred: "#c71585",
      powderblue: "#b0e0e6",
      palegoldenrod: "#eee8aa",
      oldlace: "#fdf5e6",
      paleturquoise: "#afeeee",
      mediumturquoise: "#48d1cc",
      mediumorchid: "#ba55d3",
      rebeccapurple: "#663399",
      lightsteelblue: "#b0c4de",
      mediumslateblue: "#7b68ee",
      thistle: "#d8bfd8",
      tan: "#d2b48c",
      orchid: "#da70d6",
      mediumpurple: "#9370db",
      purple: "#800080",
      pink: "#ffc0cb",
      skyblue: "#87ceeb",
      springgreen: "#00ff7f",
      palegreen: "#98fb98",
      red: "#ff0000",
      yellow: "#ffff00",
      slateblue: "#6a5acd",
      lavenderblush: "#fff0f5",
      peru: "#cd853f",
      palevioletred: "#db7093",
      violet: "#ee82ee",
      teal: "#008080",
      slategray: "#708090",
      slategrey: "#708090",
      aliceblue: "#f0f8ff",
      darkseagreen: "#8fbc8f",
      darkolivegreen: "#556b2f",
      greenyellow: "#adff2f",
      seagreen: "#2e8b57",
      seashell: "#fff5ee",
      tomato: "#ff6347",
      silver: "#c0c0c0",
      sienna: "#a0522d",
      lavender: "#e6e6fa",
      lightgreen: "#90ee90",
      orange: "#ffa500",
      orangered: "#ff4500",
      steelblue: "#4682b4",
      royalblue: "#4169e1",
      turquoise: "#40e0d0",
      yellowgreen: "#9acd32",
      salmon: "#fa8072",
      saddlebrown: "#8b4513",
      sandybrown: "#f4a460",
      rosybrown: "#bc8f8f",
      darksalmon: "#e9967a",
      lightgoldenrodyellow: "#fafad2",
      snow: "#fffafa",
      lightgrey: "#d3d3d3",
      lightgray: "#d3d3d3",
      dimgray: "#696969",
      dimgrey: "#696969",
      olivedrab: "#6b8e23",
      olive: "#808000"
    }, r = {};
    for (var n in e) r[e[n]] = n;
    var s = {};
    i.prototype.toName = function(o) {
      if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b)) return "transparent";
      var a, c, u = r[this.toHex()];
      if (u) return u;
      if (o == null ? void 0 : o.closest) {
        var l = this.toRgb(), h = 1 / 0, f = "black";
        if (!s.length) for (var p in e) s[p] = new i(e[p]).toRgb();
        for (var m in e) {
          var y = (a = l, c = s[m], Math.pow(a.r - c.r, 2) + Math.pow(a.g - c.g, 2) + Math.pow(a.b - c.b, 2));
          y < h && (h = y, f = m);
        }
        return f;
      }
    }, t.string.push([
      function(o) {
        var a = o.toLowerCase(), c = a === "transparent" ? "#0000" : e[a];
        return c ? new i(c).toRgb() : null;
      },
      "name"
    ]);
  }
  Np([
    Lp
  ]);
  const Yr = class _i {
    constructor(t = 16777215) {
      this._value = null, this._components = new Float32Array(4), this._components.fill(1), this._int = 16777215, this.value = t;
    }
    get red() {
      return this._components[0];
    }
    get green() {
      return this._components[1];
    }
    get blue() {
      return this._components[2];
    }
    get alpha() {
      return this._components[3];
    }
    setValue(t) {
      return this.value = t, this;
    }
    set value(t) {
      if (t instanceof _i) this._value = this._cloneSource(t._value), this._int = t._int, this._components.set(t._components);
      else {
        if (t === null) throw new Error("Cannot set Color#value to null");
        (this._value === null || !this._isSourceEqual(this._value, t)) && (this._normalize(t), this._value = this._cloneSource(t));
      }
    }
    get value() {
      return this._value;
    }
    _cloneSource(t) {
      return typeof t == "string" || typeof t == "number" || t instanceof Number || t === null ? t : Array.isArray(t) || ArrayBuffer.isView(t) ? t.slice(0) : typeof t == "object" && t !== null ? {
        ...t
      } : t;
    }
    _isSourceEqual(t, e) {
      const r = typeof t;
      if (r !== typeof e) return false;
      if (r === "number" || r === "string" || t instanceof Number) return t === e;
      if (Array.isArray(t) && Array.isArray(e) || ArrayBuffer.isView(t) && ArrayBuffer.isView(e)) return t.length !== e.length ? false : t.every((s, o) => s === e[o]);
      if (t !== null && e !== null) {
        const s = Object.keys(t), o = Object.keys(e);
        return s.length !== o.length ? false : s.every((a) => t[a] === e[a]);
      }
      return t === e;
    }
    toRgba() {
      const [t, e, r, n] = this._components;
      return {
        r: t,
        g: e,
        b: r,
        a: n
      };
    }
    toRgb() {
      const [t, e, r] = this._components;
      return {
        r: t,
        g: e,
        b: r
      };
    }
    toRgbaString() {
      const [t, e, r] = this.toUint8RgbArray();
      return `rgba(${t},${e},${r},${this.alpha})`;
    }
    toUint8RgbArray(t) {
      const [e, r, n] = this._components;
      return this._arrayRgb || (this._arrayRgb = []), t = t || this._arrayRgb, t[0] = Math.round(e * 255), t[1] = Math.round(r * 255), t[2] = Math.round(n * 255), t;
    }
    toArray(t) {
      this._arrayRgba || (this._arrayRgba = []), t = t || this._arrayRgba;
      const [e, r, n, s] = this._components;
      return t[0] = e, t[1] = r, t[2] = n, t[3] = s, t;
    }
    toRgbArray(t) {
      this._arrayRgb || (this._arrayRgb = []), t = t || this._arrayRgb;
      const [e, r, n] = this._components;
      return t[0] = e, t[1] = r, t[2] = n, t;
    }
    toNumber() {
      return this._int;
    }
    toBgrNumber() {
      const [t, e, r] = this.toUint8RgbArray();
      return (r << 16) + (e << 8) + t;
    }
    toLittleEndianNumber() {
      const t = this._int;
      return (t >> 16) + (t & 65280) + ((t & 255) << 16);
    }
    multiply(t) {
      const [e, r, n, s] = _i._temp.setValue(t)._components;
      return this._components[0] *= e, this._components[1] *= r, this._components[2] *= n, this._components[3] *= s, this._refreshInt(), this._value = null, this;
    }
    premultiply(t, e = true) {
      return e && (this._components[0] *= t, this._components[1] *= t, this._components[2] *= t), this._components[3] = t, this._refreshInt(), this._value = null, this;
    }
    toPremultiplied(t, e = true) {
      if (t === 1) return (255 << 24) + this._int;
      if (t === 0) return e ? 0 : this._int;
      let r = this._int >> 16 & 255, n = this._int >> 8 & 255, s = this._int & 255;
      return e && (r = r * t + 0.5 | 0, n = n * t + 0.5 | 0, s = s * t + 0.5 | 0), (t * 255 << 24) + (r << 16) + (n << 8) + s;
    }
    toHex() {
      const t = this._int.toString(16);
      return `#${"000000".substring(0, 6 - t.length) + t}`;
    }
    toHexa() {
      const e = Math.round(this._components[3] * 255).toString(16);
      return this.toHex() + "00".substring(0, 2 - e.length) + e;
    }
    setAlpha(t) {
      return this._components[3] = this._clamp(t), this;
    }
    _normalize(t) {
      let e, r, n, s;
      if ((typeof t == "number" || t instanceof Number) && t >= 0 && t <= 16777215) {
        const o = t;
        e = (o >> 16 & 255) / 255, r = (o >> 8 & 255) / 255, n = (o & 255) / 255, s = 1;
      } else if ((Array.isArray(t) || t instanceof Float32Array) && t.length >= 3 && t.length <= 4) t = this._clamp(t), [e, r, n, s = 1] = t;
      else if ((t instanceof Uint8Array || t instanceof Uint8ClampedArray) && t.length >= 3 && t.length <= 4) t = this._clamp(t, 0, 255), [e, r, n, s = 255] = t, e /= 255, r /= 255, n /= 255, s /= 255;
      else if (typeof t == "string" || typeof t == "object") {
        if (typeof t == "string") {
          const a = _i.HEX_PATTERN.exec(t);
          a && (t = `#${a[2]}`);
        }
        const o = Fe(t);
        o.isValid() && ({ r: e, g: r, b: n, a: s } = o.rgba, e /= 255, r /= 255, n /= 255);
      }
      if (e !== void 0) this._components[0] = e, this._components[1] = r, this._components[2] = n, this._components[3] = s, this._refreshInt();
      else throw new Error(`Unable to convert color ${t}`);
    }
    _refreshInt() {
      this._clamp(this._components);
      const [t, e, r] = this._components;
      this._int = (t * 255 << 16) + (e * 255 << 8) + (r * 255 | 0);
    }
    _clamp(t, e = 0, r = 1) {
      return typeof t == "number" ? Math.min(Math.max(t, e), r) : (t.forEach((n, s) => {
        t[s] = Math.min(Math.max(n, e), r);
      }), t);
    }
    static isColorLike(t) {
      return typeof t == "number" || typeof t == "string" || t instanceof Number || t instanceof _i || Array.isArray(t) || t instanceof Uint8Array || t instanceof Uint8ClampedArray || t instanceof Float32Array || t.r !== void 0 && t.g !== void 0 && t.b !== void 0 || t.r !== void 0 && t.g !== void 0 && t.b !== void 0 && t.a !== void 0 || t.h !== void 0 && t.s !== void 0 && t.l !== void 0 || t.h !== void 0 && t.s !== void 0 && t.l !== void 0 && t.a !== void 0 || t.h !== void 0 && t.s !== void 0 && t.v !== void 0 || t.h !== void 0 && t.s !== void 0 && t.v !== void 0 && t.a !== void 0;
    }
  };
  Yr.shared = new Yr();
  Yr._temp = new Yr();
  Yr.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;
  let At = Yr;
  const Hp = {
    cullArea: null,
    cullable: false,
    cullableChildren: true
  };
  class Jo {
    constructor(t, e) {
      this._pool = [], this._count = 0, this._index = 0, this._classType = t, e && this.prepopulate(e);
    }
    prepopulate(t) {
      for (let e = 0; e < t; e++) this._pool[this._index++] = new this._classType();
      this._count += t;
    }
    get(t) {
      var _a2;
      let e;
      return this._index > 0 ? e = this._pool[--this._index] : e = new this._classType(), (_a2 = e.init) == null ? void 0 : _a2.call(e, t), e;
    }
    return(t) {
      var _a2;
      (_a2 = t.reset) == null ? void 0 : _a2.call(t), this._pool[this._index++] = t;
    }
    get totalSize() {
      return this._count;
    }
    get totalFree() {
      return this._index;
    }
    get totalUsed() {
      return this._count - this._index;
    }
    clear() {
      this._pool.length = 0, this._index = 0;
    }
  }
  class zp {
    constructor() {
      this._poolsByClass = /* @__PURE__ */ new Map();
    }
    prepopulate(t, e) {
      this.getPool(t).prepopulate(e);
    }
    get(t, e) {
      return this.getPool(t).get(e);
    }
    return(t) {
      this.getPool(t.constructor).return(t);
    }
    getPool(t) {
      return this._poolsByClass.has(t) || this._poolsByClass.set(t, new Jo(t)), this._poolsByClass.get(t);
    }
    stats() {
      const t = {};
      return this._poolsByClass.forEach((e) => {
        const r = t[e._classType.name] ? e._classType.name + e._classType.ID : e._classType.name;
        t[r] = {
          free: e.totalFree,
          used: e.totalUsed,
          size: e.totalSize
        };
      }), t;
    }
  }
  const vt = new zp();
  function Gl(i, t, e) {
    const r = i.length;
    let n;
    if (t >= r || e === 0) return;
    e = t + e > r ? r - t : e;
    const s = r - e;
    for (n = t; n < s; ++n) i[n] = i[n + e];
    i.length = s;
  }
  const jp = {
    allowChildren: true,
    removeChildren(i = 0, t) {
      const e = t ?? this.children.length, r = e - i, n = [];
      if (r > 0 && r <= e) {
        for (let o = e - 1; o >= i; o--) {
          const a = this.children[o];
          a && (n.push(a), a.parent = null);
        }
        Gl(this.children, i, e);
        const s = this.renderGroup || this.parentRenderGroup;
        s && s.removeChildren(n);
        for (let o = 0; o < n.length; ++o) this.emit("childRemoved", n[o], this, o), n[o].emit("removed", this);
        return n;
      } else if (r === 0 && this.children.length === 0) return n;
      throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
    },
    removeChildAt(i) {
      const t = this.getChildAt(i);
      return this.removeChild(t);
    },
    getChildAt(i) {
      if (i < 0 || i >= this.children.length) throw new Error(`getChildAt: Index (${i}) does not exist.`);
      return this.children[i];
    },
    setChildIndex(i, t) {
      if (t < 0 || t >= this.children.length) throw new Error(`The index ${t} supplied is out of bounds ${this.children.length}`);
      this.getChildIndex(i), this.addChildAt(i, t);
    },
    getChildIndex(i) {
      const t = this.children.indexOf(i);
      if (t === -1) throw new Error("The supplied Container must be a child of the caller");
      return t;
    },
    addChildAt(i, t) {
      this.allowChildren || lt(dt, "addChildAt: Only Containers will be allowed to add children in v8.0.0");
      const { children: e } = this;
      if (t < 0 || t > e.length) throw new Error(`${i}addChildAt: The index ${t} supplied is out of bounds ${e.length}`);
      if (i.parent) {
        const n = i.parent.children.indexOf(i);
        if (i.parent === this && n === t) return i;
        n !== -1 && i.parent.children.splice(n, 1);
      }
      t === e.length ? e.push(i) : e.splice(t, 0, i), i.parent = this, i.didChange = true, i.didViewUpdate = false, i._updateFlags = 15;
      const r = this.renderGroup || this.parentRenderGroup;
      return r && r.addChild(i), this.sortableChildren && (this.sortDirty = true), this.emit("childAdded", i, this, t), i.emit("added", this), i;
    },
    swapChildren(i, t) {
      if (i === t) return;
      const e = this.getChildIndex(i), r = this.getChildIndex(t);
      this.children[e] = t, this.children[r] = i;
      const n = this.renderGroup || this.parentRenderGroup;
      n && (n.structureDidChange = true), this._didChangeId++;
    },
    removeFromParent() {
      var _a2;
      (_a2 = this.parent) == null ? void 0 : _a2.removeChild(this);
    },
    reparentChild(...i) {
      return i.length === 1 ? this.reparentChildAt(i[0], this.children.length) : (i.forEach((t) => this.reparentChildAt(t, this.children.length)), i[0]);
    },
    reparentChildAt(i, t) {
      if (i.parent === this) return this.setChildIndex(i, t), i;
      const e = i.worldTransform.clone();
      i.removeFromParent(), this.addChildAt(i, t);
      const r = this.worldTransform.clone();
      return r.invert(), e.prepend(r), i.setFromMatrix(e), i;
    }
  };
  class Rn {
    constructor() {
      this.pipe = "filter", this.priority = 1;
    }
    destroy() {
      for (let t = 0; t < this.filters.length; t++) this.filters[t].destroy();
      this.filters = null, this.filterArea = null;
    }
  }
  class Wp {
    constructor() {
      this._effectClasses = [], this._tests = [], this._initialized = false;
    }
    init() {
      this._initialized || (this._initialized = true, this._effectClasses.forEach((t) => {
        this.add({
          test: t.test,
          maskClass: t
        });
      }));
    }
    add(t) {
      this._tests.push(t);
    }
    getMaskEffect(t) {
      this._initialized || this.init();
      for (let e = 0; e < this._tests.length; e++) {
        const r = this._tests[e];
        if (r.test(t)) return vt.get(r.maskClass, t);
      }
      return t;
    }
    returnMaskEffect(t) {
      vt.return(t);
    }
  }
  const yo = new Wp();
  Mt.handleByList(P.MaskEffect, yo._effectClasses);
  const Vp = {
    _maskEffect: null,
    _filterEffect: null,
    effects: [],
    addEffect(i) {
      if (this.effects.indexOf(i) !== -1) return;
      this.effects.push(i), this.effects.sort((r, n) => r.priority - n.priority);
      const e = this.renderGroup || this.parentRenderGroup;
      e && (e.structureDidChange = true), this._updateIsSimple();
    },
    removeEffect(i) {
      const t = this.effects.indexOf(i);
      t !== -1 && (this.effects.splice(t, 1), this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = true), this._updateIsSimple());
    },
    set mask(i) {
      const t = this._maskEffect;
      (t == null ? void 0 : t.mask) !== i && (t && (this.removeEffect(t), yo.returnMaskEffect(t), this._maskEffect = null), i != null && (this._maskEffect = yo.getMaskEffect(i), this.addEffect(this._maskEffect)));
    },
    get mask() {
      var _a2;
      return (_a2 = this._maskEffect) == null ? void 0 : _a2.mask;
    },
    set filters(i) {
      var _a2;
      !Array.isArray(i) && i && (i = [
        i
      ]);
      const t = this._filterEffect || (this._filterEffect = new Rn());
      i = i;
      const e = (i == null ? void 0 : i.length) > 0, r = ((_a2 = t.filters) == null ? void 0 : _a2.length) > 0, n = e !== r;
      i = Array.isArray(i) ? i.slice(0) : i, t.filters = Object.freeze(i), n && (e ? this.addEffect(t) : (this.removeEffect(t), t.filters = i ?? null));
    },
    get filters() {
      var _a2;
      return (_a2 = this._filterEffect) == null ? void 0 : _a2.filters;
    },
    set filterArea(i) {
      this._filterEffect || (this._filterEffect = new Rn()), this._filterEffect.filterArea = i;
    },
    get filterArea() {
      var _a2;
      return (_a2 = this._filterEffect) == null ? void 0 : _a2.filterArea;
    }
  }, Xp = {
    label: null,
    get name() {
      return lt(dt, "Container.name property has been removed, use Container.label instead"), this.label;
    },
    set name(i) {
      lt(dt, "Container.name property has been removed, use Container.label instead"), this.label = i;
    },
    getChildByName(i, t = false) {
      return this.getChildByLabel(i, t);
    },
    getChildByLabel(i, t = false) {
      const e = this.children;
      for (let r = 0; r < e.length; r++) {
        const n = e[r];
        if (n.label === i || i instanceof RegExp && i.test(n.label)) return n;
      }
      if (t) for (let r = 0; r < e.length; r++) {
        const s = e[r].getChildByLabel(i, true);
        if (s) return s;
      }
      return null;
    },
    getChildrenByLabel(i, t = false, e = []) {
      const r = this.children;
      for (let n = 0; n < r.length; n++) {
        const s = r[n];
        (s.label === i || i instanceof RegExp && i.test(s.label)) && e.push(s);
      }
      if (t) for (let n = 0; n < r.length; n++) r[n].getChildrenByLabel(i, true, e);
      return e;
    }
  }, dc = new nt();
  class re {
    constructor(t = 1 / 0, e = 1 / 0, r = -1 / 0, n = -1 / 0) {
      this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.matrix = dc, this.minX = t, this.minY = e, this.maxX = r, this.maxY = n;
    }
    isEmpty() {
      return this.minX > this.maxX || this.minY > this.maxY;
    }
    get rectangle() {
      this._rectangle || (this._rectangle = new Et());
      const t = this._rectangle;
      return this.minX > this.maxX || this.minY > this.maxY ? (t.x = 0, t.y = 0, t.width = 0, t.height = 0) : t.copyFromBounds(this), t;
    }
    clear() {
      return this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.matrix = dc, this;
    }
    set(t, e, r, n) {
      this.minX = t, this.minY = e, this.maxX = r, this.maxY = n;
    }
    addFrame(t, e, r, n, s) {
      s || (s = this.matrix);
      const o = s.a, a = s.b, c = s.c, u = s.d, l = s.tx, h = s.ty;
      let f = this.minX, p = this.minY, m = this.maxX, y = this.maxY, b = o * t + c * e + l, v = a * t + u * e + h;
      b < f && (f = b), v < p && (p = v), b > m && (m = b), v > y && (y = v), b = o * r + c * e + l, v = a * r + u * e + h, b < f && (f = b), v < p && (p = v), b > m && (m = b), v > y && (y = v), b = o * t + c * n + l, v = a * t + u * n + h, b < f && (f = b), v < p && (p = v), b > m && (m = b), v > y && (y = v), b = o * r + c * n + l, v = a * r + u * n + h, b < f && (f = b), v < p && (p = v), b > m && (m = b), v > y && (y = v), this.minX = f, this.minY = p, this.maxX = m, this.maxY = y;
    }
    addRect(t, e) {
      this.addFrame(t.x, t.y, t.x + t.width, t.y + t.height, e);
    }
    addBounds(t, e) {
      this.addFrame(t.minX, t.minY, t.maxX, t.maxY, e);
    }
    addBoundsMask(t) {
      this.minX = this.minX > t.minX ? this.minX : t.minX, this.minY = this.minY > t.minY ? this.minY : t.minY, this.maxX = this.maxX < t.maxX ? this.maxX : t.maxX, this.maxY = this.maxY < t.maxY ? this.maxY : t.maxY;
    }
    applyMatrix(t) {
      const e = this.minX, r = this.minY, n = this.maxX, s = this.maxY, { a: o, b: a, c, d: u, tx: l, ty: h } = t;
      let f = o * e + c * r + l, p = a * e + u * r + h;
      this.minX = f, this.minY = p, this.maxX = f, this.maxY = p, f = o * n + c * r + l, p = a * n + u * r + h, this.minX = f < this.minX ? f : this.minX, this.minY = p < this.minY ? p : this.minY, this.maxX = f > this.maxX ? f : this.maxX, this.maxY = p > this.maxY ? p : this.maxY, f = o * e + c * s + l, p = a * e + u * s + h, this.minX = f < this.minX ? f : this.minX, this.minY = p < this.minY ? p : this.minY, this.maxX = f > this.maxX ? f : this.maxX, this.maxY = p > this.maxY ? p : this.maxY, f = o * n + c * s + l, p = a * n + u * s + h, this.minX = f < this.minX ? f : this.minX, this.minY = p < this.minY ? p : this.minY, this.maxX = f > this.maxX ? f : this.maxX, this.maxY = p > this.maxY ? p : this.maxY;
    }
    fit(t) {
      return this.minX < t.left && (this.minX = t.left), this.maxX > t.right && (this.maxX = t.right), this.minY < t.top && (this.minY = t.top), this.maxY > t.bottom && (this.maxY = t.bottom), this;
    }
    fitBounds(t, e, r, n) {
      return this.minX < t && (this.minX = t), this.maxX > e && (this.maxX = e), this.minY < r && (this.minY = r), this.maxY > n && (this.maxY = n), this;
    }
    pad(t, e = t) {
      return this.minX -= t, this.maxX += t, this.minY -= e, this.maxY += e, this;
    }
    ceil() {
      return this.minX = Math.floor(this.minX), this.minY = Math.floor(this.minY), this.maxX = Math.ceil(this.maxX), this.maxY = Math.ceil(this.maxY), this;
    }
    clone() {
      return new re(this.minX, this.minY, this.maxX, this.maxY);
    }
    scale(t, e = t) {
      return this.minX *= t, this.minY *= e, this.maxX *= t, this.maxY *= e, this;
    }
    get x() {
      return this.minX;
    }
    set x(t) {
      const e = this.maxX - this.minX;
      this.minX = t, this.maxX = t + e;
    }
    get y() {
      return this.minY;
    }
    set y(t) {
      const e = this.maxY - this.minY;
      this.minY = t, this.maxY = t + e;
    }
    get width() {
      return this.maxX - this.minX;
    }
    set width(t) {
      this.maxX = this.minX + t;
    }
    get height() {
      return this.maxY - this.minY;
    }
    set height(t) {
      this.maxY = this.minY + t;
    }
    get left() {
      return this.minX;
    }
    get right() {
      return this.maxX;
    }
    get top() {
      return this.minY;
    }
    get bottom() {
      return this.maxY;
    }
    get isPositive() {
      return this.maxX - this.minX > 0 && this.maxY - this.minY > 0;
    }
    get isValid() {
      return this.minX + this.minY !== 1 / 0;
    }
    addVertexData(t, e, r, n) {
      let s = this.minX, o = this.minY, a = this.maxX, c = this.maxY;
      n || (n = this.matrix);
      const u = n.a, l = n.b, h = n.c, f = n.d, p = n.tx, m = n.ty;
      for (let y = e; y < r; y += 2) {
        const b = t[y], v = t[y + 1], A = u * b + h * v + p, T = l * b + f * v + m;
        s = A < s ? A : s, o = T < o ? T : o, a = A > a ? A : a, c = T > c ? T : c;
      }
      this.minX = s, this.minY = o, this.maxX = a, this.maxY = c;
    }
    containsPoint(t, e) {
      return this.minX <= t && this.minY <= e && this.maxX >= t && this.maxY >= e;
    }
    toString() {
      return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;
    }
  }
  const Ye = new Jo(nt), Ke = new Jo(re);
  function Vn(i, t, e) {
    e.clear();
    let r, n;
    return i.parent ? t ? r = i.parent.worldTransform : (n = Ye.get().identity(), r = Pn(i, n)) : r = nt.IDENTITY, Ol(i, e, r, t), n && Ye.return(n), e.isValid || e.set(0, 0, 0, 0), e;
  }
  function Ol(i, t, e, r) {
    var _a2, _b2;
    if (!i.visible || !i.measurable) return;
    let n;
    r ? n = i.worldTransform : (i.updateLocalTransform(), n = Ye.get(), n.appendFrom(i.localTransform, e));
    const s = t, o = !!i.effects.length;
    if (o && (t = Ke.get().clear()), i.boundsArea) t.addRect(i.boundsArea, n);
    else {
      i.addBounds && (t.matrix = n, i.addBounds(t));
      for (let a = 0; a < i.children.length; a++) Ol(i.children[a], t, n, r);
    }
    if (o) {
      for (let a = 0; a < i.effects.length; a++) (_b2 = (_a2 = i.effects[a]).addBounds) == null ? void 0 : _b2.call(_a2, t);
      s.addBounds(t, nt.IDENTITY), Ke.return(t);
    }
    r || Ye.return(n);
  }
  function Pn(i, t) {
    const e = i.parent;
    return e && (Pn(e, t), e.updateLocalTransform(), t.append(e.localTransform)), t;
  }
  let Rs = 0;
  const fc = 500;
  function ut(...i) {
    Rs !== fc && (Rs++, Rs === fc ? console.warn("PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.") : console.warn("PixiJS Warning: ", ...i));
  }
  function Qo(i, t, e) {
    return t.clear(), e || (e = nt.IDENTITY), Nl(i, t, e, i, true), t.isValid || t.set(0, 0, 0, 0), t;
  }
  function Nl(i, t, e, r, n) {
    var _a2, _b2;
    let s;
    if (n) s = Ye.get(), s = e.copyTo(s);
    else {
      if (!i.visible || !i.measurable) return;
      i.updateLocalTransform();
      const c = i.localTransform;
      s = Ye.get(), s.appendFrom(c, e);
    }
    const o = t, a = !!i.effects.length;
    if (a && (t = Ke.get().clear()), i.boundsArea) t.addRect(i.boundsArea, s);
    else {
      i.renderPipeId && (t.matrix = s, i.addBounds(t));
      const c = i.children;
      for (let u = 0; u < c.length; u++) Nl(c[u], t, s, r, false);
    }
    if (a) {
      for (let c = 0; c < i.effects.length; c++) (_b2 = (_a2 = i.effects[c]).addLocalBounds) == null ? void 0 : _b2.call(_a2, t, r);
      o.addBounds(t, nt.IDENTITY), Ke.return(t);
    }
    Ye.return(s);
  }
  function Ll(i, t) {
    const e = i.children;
    for (let r = 0; r < e.length; r++) {
      const n = e[r], s = (n.uid & 255) << 24 | n._didChangeId & 16777215;
      t.data[t.index] !== s && (t.data[t.index] = s, t.didChange = true), t.index++, n.children.length && Ll(n, t);
    }
    return t.didChange;
  }
  const qp = new nt(), $p = {
    _localBoundsCacheId: -1,
    _localBoundsCacheData: null,
    _setWidth(i, t) {
      const e = Math.sign(this.scale.x) || 1;
      t !== 0 ? this.scale.x = i / t * e : this.scale.x = e;
    },
    _setHeight(i, t) {
      const e = Math.sign(this.scale.y) || 1;
      t !== 0 ? this.scale.y = i / t * e : this.scale.y = e;
    },
    getLocalBounds() {
      this._localBoundsCacheData || (this._localBoundsCacheData = {
        data: [],
        index: 1,
        didChange: false,
        localBounds: new re()
      });
      const i = this._localBoundsCacheData;
      return i.index = 1, i.didChange = false, i.data[0] !== this._didChangeId >> 12 && (i.didChange = true, i.data[0] = this._didChangeId >> 12), Ll(this, i), i.didChange && Qo(this, i.localBounds, qp), i.localBounds;
    },
    getBounds(i, t) {
      return Vn(this, i, t || new re());
    }
  }, Yp = {
    _onRender: null,
    set onRender(i) {
      const t = this.renderGroup || this.parentRenderGroup;
      if (!i) {
        this._onRender && (t == null ? void 0 : t.removeOnRender(this)), this._onRender = null;
        return;
      }
      this._onRender || (t == null ? void 0 : t.addOnRender(this)), this._onRender = i;
    },
    get onRender() {
      return this._onRender;
    }
  }, Kp = {
    _zIndex: 0,
    sortDirty: false,
    sortableChildren: false,
    get zIndex() {
      return this._zIndex;
    },
    set zIndex(i) {
      this._zIndex !== i && (this._zIndex = i, this.depthOfChildModified());
    },
    depthOfChildModified() {
      this.parent && (this.parent.sortableChildren = true, this.parent.sortDirty = true), this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = true);
    },
    sortChildren() {
      this.sortDirty && (this.sortDirty = false, this.children.sort(Zp));
    }
  };
  function Zp(i, t) {
    return i._zIndex - t._zIndex;
  }
  const Jp = {
    getGlobalPosition(i = new Ct(), t = false) {
      return this.parent ? this.parent.toGlobal(this._position, i, t) : (i.x = this._position.x, i.y = this._position.y), i;
    },
    toGlobal(i, t, e = false) {
      if (!e) {
        this.updateLocalTransform();
        const r = Pn(this, new nt());
        return r.append(this.localTransform), r.apply(i, t);
      }
      return this.worldTransform.apply(i, t);
    },
    toLocal(i, t, e, r) {
      if (t && (i = t.toGlobal(i, e, r)), !r) {
        this.updateLocalTransform();
        const n = Pn(this, new nt());
        return n.append(this.localTransform), n.applyInverse(i, e);
      }
      return this.worldTransform.applyInverse(i, e);
    }
  };
  class Hl {
    constructor() {
      this.uid = Ot("instructionSet"), this.instructions = [], this.instructionSize = 0;
    }
    reset() {
      this.instructionSize = 0;
    }
    add(t) {
      this.instructions[this.instructionSize++] = t;
    }
    log() {
      this.instructions.length = this.instructionSize, console.table(this.instructions, [
        "type",
        "action"
      ]);
    }
  }
  class Qp {
    constructor() {
      this.renderPipeId = "renderGroup", this.root = null, this.canBundle = false, this.renderGroupParent = null, this.renderGroupChildren = [], this.worldTransform = new nt(), this.worldColorAlpha = 4294967295, this.worldColor = 16777215, this.worldAlpha = 1, this.childrenToUpdate = /* @__PURE__ */ Object.create(null), this.updateTick = 0, this.childrenRenderablesToUpdate = {
        list: [],
        index: 0
      }, this.structureDidChange = true, this.instructionSet = new Hl(), this._onRenderContainers = [];
    }
    init(t) {
      this.root = t, t._onRender && this.addOnRender(t), t.didChange = true;
      const e = t.children;
      for (let r = 0; r < e.length; r++) this.addChild(e[r]);
    }
    reset() {
      this.renderGroupChildren.length = 0;
      for (const t in this.childrenToUpdate) {
        const e = this.childrenToUpdate[t];
        e.list.fill(null), e.index = 0;
      }
      this.childrenRenderablesToUpdate.index = 0, this.childrenRenderablesToUpdate.list.fill(null), this.root = null, this.updateTick = 0, this.structureDidChange = true, this._onRenderContainers.length = 0, this.renderGroupParent = null;
    }
    get localTransform() {
      return this.root.localTransform;
    }
    addRenderGroupChild(t) {
      t.renderGroupParent && t.renderGroupParent._removeRenderGroupChild(t), t.renderGroupParent = this, this.renderGroupChildren.push(t);
    }
    _removeRenderGroupChild(t) {
      const e = this.renderGroupChildren.indexOf(t);
      e > -1 && this.renderGroupChildren.splice(e, 1), t.renderGroupParent = null;
    }
    addChild(t) {
      if (this.structureDidChange = true, t.parentRenderGroup = this, t.updateTick = -1, t.parent === this.root ? t.relativeRenderGroupDepth = 1 : t.relativeRenderGroupDepth = t.parent.relativeRenderGroupDepth + 1, t.didChange = true, this.onChildUpdate(t), t.renderGroup) {
        this.addRenderGroupChild(t.renderGroup);
        return;
      }
      t._onRender && this.addOnRender(t);
      const e = t.children;
      for (let r = 0; r < e.length; r++) this.addChild(e[r]);
    }
    removeChild(t) {
      if (this.structureDidChange = true, t._onRender && (t.renderGroup || this.removeOnRender(t)), t.parentRenderGroup = null, t.renderGroup) {
        this._removeRenderGroupChild(t.renderGroup);
        return;
      }
      const e = t.children;
      for (let r = 0; r < e.length; r++) this.removeChild(e[r]);
    }
    removeChildren(t) {
      for (let e = 0; e < t.length; e++) this.removeChild(t[e]);
    }
    onChildUpdate(t) {
      let e = this.childrenToUpdate[t.relativeRenderGroupDepth];
      e || (e = this.childrenToUpdate[t.relativeRenderGroupDepth] = {
        index: 0,
        list: []
      }), e.list[e.index++] = t;
    }
    updateRenderable(t) {
      t.globalDisplayStatus < 7 || (t.didViewUpdate = false, this.instructionSet.renderPipes[t.renderPipeId].updateRenderable(t));
    }
    onChildViewUpdate(t) {
      this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = t;
    }
    get isRenderable() {
      return this.root.localDisplayStatus === 7 && this.worldAlpha > 0;
    }
    addOnRender(t) {
      this._onRenderContainers.push(t);
    }
    removeOnRender(t) {
      this._onRenderContainers.splice(this._onRenderContainers.indexOf(t), 1);
    }
    runOnRender() {
      for (let t = 0; t < this._onRenderContainers.length; t++) this._onRenderContainers[t]._onRender();
    }
    destroy() {
      this.renderGroupParent = null, this.root = null, this.childrenRenderablesToUpdate = null, this.childrenToUpdate = null, this.renderGroupChildren = null, this._onRenderContainers = null, this.instructionSet = null;
    }
    getChildren(t = []) {
      const e = this.root.children;
      for (let r = 0; r < e.length; r++) this._getChildren(e[r], t);
      return t;
    }
    _getChildren(t, e = []) {
      if (e.push(t), t.renderGroup) return e;
      const r = t.children;
      for (let n = 0; n < r.length; n++) this._getChildren(r[n], e);
      return e;
    }
  }
  function t_(i, t, e = {}) {
    for (const r in t) !e[r] && t[r] !== void 0 && (i[r] = t[r]);
  }
  const Ps = new Xt(null), Bs = new Xt(null), Ms = new Xt(null, 1, 1), Bn = 1, ta = 2, yi = 4;
  Dt = class extends me {
    constructor(t = {}) {
      var _a2, _b2;
      super(), this.uid = Ot("renderable"), this._updateFlags = 15, this.renderGroup = null, this.parentRenderGroup = null, this.parentRenderGroupIndex = 0, this.didChange = false, this.didViewUpdate = false, this.relativeRenderGroupDepth = 0, this.children = [], this.parent = null, this.includeInBuild = true, this.measurable = true, this.isSimple = true, this.updateTick = -1, this.localTransform = new nt(), this.relativeGroupTransform = new nt(), this.groupTransform = this.relativeGroupTransform, this.destroyed = false, this._position = new Xt(this, 0, 0), this._scale = Ms, this._pivot = Bs, this._skew = Ps, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._rotation = 0, this.localColor = 16777215, this.localAlpha = 1, this.groupAlpha = 1, this.groupColor = 16777215, this.groupColorAlpha = 4294967295, this.localBlendMode = "inherit", this.groupBlendMode = "normal", this.localDisplayStatus = 7, this.globalDisplayStatus = 7, this._didChangeId = 0, this._didLocalTransformChangeId = -1, t_(this, t, {
        children: true,
        parent: true,
        effects: true
      }), (_a2 = t.children) == null ? void 0 : _a2.forEach((e) => this.addChild(e)), this.effects = [], (_b2 = t.parent) == null ? void 0 : _b2.addChild(this);
    }
    static mixin(t) {
      Object.defineProperties(Dt.prototype, Object.getOwnPropertyDescriptors(t));
    }
    addChild(...t) {
      if (this.allowChildren || lt(dt, "addChild: Only Containers will be allowed to add children in v8.0.0"), t.length > 1) {
        for (let n = 0; n < t.length; n++) this.addChild(t[n]);
        return t[0];
      }
      const e = t[0];
      if (e.parent === this) return this.children.splice(this.children.indexOf(e), 1), this.children.push(e), this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = true), e;
      e.parent && e.parent.removeChild(e), this.children.push(e), this.sortableChildren && (this.sortDirty = true), e.parent = this, e.didChange = true, e.didViewUpdate = false, e._updateFlags = 15;
      const r = this.renderGroup || this.parentRenderGroup;
      return r && r.addChild(e), this.emit("childAdded", e, this, this.children.length - 1), e.emit("added", this), this._didChangeId += 4096, e._zIndex !== 0 && e.depthOfChildModified(), e;
    }
    removeChild(...t) {
      if (t.length > 1) {
        for (let n = 0; n < t.length; n++) this.removeChild(t[n]);
        return t[0];
      }
      const e = t[0], r = this.children.indexOf(e);
      return r > -1 && (this._didChangeId += 4096, this.children.splice(r, 1), this.renderGroup ? this.renderGroup.removeChild(e) : this.parentRenderGroup && this.parentRenderGroup.removeChild(e), e.parent = null, this.emit("childRemoved", e, this, r), e.emit("removed", this)), e;
    }
    _onUpdate(t) {
      t && t === this._skew && this._updateSkew(), this._didChangeId++, !this.didChange && (this.didChange = true, this.parentRenderGroup && this.parentRenderGroup.onChildUpdate(this));
    }
    set isRenderGroup(t) {
      !!this.renderGroup !== t && (t ? this.enableRenderGroup() : this.disableRenderGroup());
    }
    get isRenderGroup() {
      return !!this.renderGroup;
    }
    enableRenderGroup() {
      if (this.renderGroup) return;
      const t = this.parentRenderGroup;
      t == null ? void 0 : t.removeChild(this), this.renderGroup = vt.get(Qp, this), this.groupTransform = nt.IDENTITY, t == null ? void 0 : t.addChild(this), this._updateIsSimple();
    }
    disableRenderGroup() {
      if (!this.renderGroup) return;
      const t = this.parentRenderGroup;
      t == null ? void 0 : t.removeChild(this), vt.return(this.renderGroup), this.renderGroup = null, this.groupTransform = this.relativeGroupTransform, t == null ? void 0 : t.addChild(this), this._updateIsSimple();
    }
    _updateIsSimple() {
      this.isSimple = !this.renderGroup && this.effects.length === 0;
    }
    get worldTransform() {
      return this._worldTransform || (this._worldTransform = new nt()), this.renderGroup ? this._worldTransform.copyFrom(this.renderGroup.worldTransform) : this.parentRenderGroup && this._worldTransform.appendFrom(this.relativeGroupTransform, this.parentRenderGroup.worldTransform), this._worldTransform;
    }
    get x() {
      return this._position.x;
    }
    set x(t) {
      this._position.x = t;
    }
    get y() {
      return this._position.y;
    }
    set y(t) {
      this._position.y = t;
    }
    get position() {
      return this._position;
    }
    set position(t) {
      this._position.copyFrom(t);
    }
    get rotation() {
      return this._rotation;
    }
    set rotation(t) {
      this._rotation !== t && (this._rotation = t, this._onUpdate(this._skew));
    }
    get angle() {
      return this.rotation * Ap;
    }
    set angle(t) {
      this.rotation = t * Tp;
    }
    get pivot() {
      return this._pivot === Bs && (this._pivot = new Xt(this, 0, 0)), this._pivot;
    }
    set pivot(t) {
      this._pivot === Bs && (this._pivot = new Xt(this, 0, 0)), typeof t == "number" ? this._pivot.set(t) : this._pivot.copyFrom(t);
    }
    get skew() {
      return this._skew === Ps && (this._skew = new Xt(this, 0, 0)), this._skew;
    }
    set skew(t) {
      this._skew === Ps && (this._skew = new Xt(this, 0, 0)), this._skew.copyFrom(t);
    }
    get scale() {
      return this._scale === Ms && (this._scale = new Xt(this, 1, 1)), this._scale;
    }
    set scale(t) {
      this._scale === Ms && (this._scale = new Xt(this, 0, 0)), typeof t == "number" ? this._scale.set(t) : this._scale.copyFrom(t);
    }
    get width() {
      return Math.abs(this.scale.x * this.getLocalBounds().width);
    }
    set width(t) {
      const e = this.getLocalBounds().width;
      this._setWidth(t, e);
    }
    get height() {
      return Math.abs(this.scale.y * this.getLocalBounds().height);
    }
    set height(t) {
      const e = this.getLocalBounds().height;
      this._setHeight(t, e);
    }
    getSize(t) {
      t || (t = {});
      const e = this.getLocalBounds();
      return t.width = Math.abs(this.scale.x * e.width), t.height = Math.abs(this.scale.y * e.height), t;
    }
    setSize(t, e) {
      const r = this.getLocalBounds();
      let n, s;
      typeof t != "object" ? (n = t, s = e ?? t) : (n = t.width, s = t.height ?? t.width), n !== void 0 && this._setWidth(n, r.width), s !== void 0 && this._setHeight(s, r.height);
    }
    _updateSkew() {
      const t = this._rotation, e = this._skew;
      this._cx = Math.cos(t + e._y), this._sx = Math.sin(t + e._y), this._cy = -Math.sin(t - e._x), this._sy = Math.cos(t - e._x);
    }
    updateTransform(t) {
      return this.position.set(typeof t.x == "number" ? t.x : this.position.x, typeof t.y == "number" ? t.y : this.position.y), this.scale.set(typeof t.scaleX == "number" ? t.scaleX || 1 : this.scale.x, typeof t.scaleY == "number" ? t.scaleY || 1 : this.scale.y), this.rotation = typeof t.rotation == "number" ? t.rotation : this.rotation, this.skew.set(typeof t.skewX == "number" ? t.skewX : this.skew.x, typeof t.skewY == "number" ? t.skewY : this.skew.y), this.pivot.set(typeof t.pivotX == "number" ? t.pivotX : this.pivot.x, typeof t.pivotY == "number" ? t.pivotY : this.pivot.y), this;
    }
    setFromMatrix(t) {
      t.decompose(this);
    }
    updateLocalTransform() {
      const t = this._didChangeId & 4095;
      if (this._didLocalTransformChangeId === t) return;
      this._didLocalTransformChangeId = t;
      const e = this.localTransform, r = this._scale, n = this._pivot, s = this._position, o = r._x, a = r._y, c = n._x, u = n._y;
      e.a = this._cx * o, e.b = this._sx * o, e.c = this._cy * a, e.d = this._sy * a, e.tx = s._x - (c * e.a + u * e.c), e.ty = s._y - (c * e.b + u * e.d);
    }
    set alpha(t) {
      t !== this.localAlpha && (this.localAlpha = t, this._updateFlags |= Bn, this._onUpdate());
    }
    get alpha() {
      return this.localAlpha;
    }
    set tint(t) {
      const r = At.shared.setValue(t ?? 16777215).toBgrNumber();
      r !== this.localColor && (this.localColor = r, this._updateFlags |= Bn, this._onUpdate());
    }
    get tint() {
      const t = this.localColor;
      return ((t & 255) << 16) + (t & 65280) + (t >> 16 & 255);
    }
    set blendMode(t) {
      this.localBlendMode !== t && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = true), this._updateFlags |= ta, this.localBlendMode = t, this._onUpdate());
    }
    get blendMode() {
      return this.localBlendMode;
    }
    get visible() {
      return !!(this.localDisplayStatus & 2);
    }
    set visible(t) {
      const e = t ? 2 : 0;
      (this.localDisplayStatus & 2) !== e && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = true), this._updateFlags |= yi, this.localDisplayStatus ^= 2, this._onUpdate());
    }
    get culled() {
      return !(this.localDisplayStatus & 4);
    }
    set culled(t) {
      const e = t ? 0 : 4;
      (this.localDisplayStatus & 4) !== e && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = true), this._updateFlags |= yi, this.localDisplayStatus ^= 4, this._onUpdate());
    }
    get renderable() {
      return !!(this.localDisplayStatus & 1);
    }
    set renderable(t) {
      const e = t ? 1 : 0;
      (this.localDisplayStatus & 1) !== e && (this._updateFlags |= yi, this.localDisplayStatus ^= 1, this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = true), this._onUpdate());
    }
    get isRenderable() {
      return this.localDisplayStatus === 7 && this.groupAlpha > 0;
    }
    destroy(t = false) {
      var _a2;
      if (this.destroyed) return;
      this.destroyed = true;
      const e = this.removeChildren(0, this.children.length);
      if (this.removeFromParent(), this.parent = null, this._maskEffect = null, this._filterEffect = null, this.effects = null, this._position = null, this._scale = null, this._pivot = null, this._skew = null, this.emit("destroyed", this), this.removeAllListeners(), typeof t == "boolean" ? t : t == null ? void 0 : t.children) for (let n = 0; n < e.length; ++n) e[n].destroy(t);
      (_a2 = this.renderGroup) == null ? void 0 : _a2.destroy(), this.renderGroup = null;
    }
  };
  Dt.mixin(jp);
  Dt.mixin(Jp);
  Dt.mixin(Yp);
  Dt.mixin($p);
  Dt.mixin(Vp);
  Dt.mixin(Xp);
  Dt.mixin(Kp);
  Dt.mixin(Hp);
  class lr extends Dt {
    constructor(t = J.EMPTY) {
      t instanceof J && (t = {
        texture: t
      });
      const { texture: e = J.EMPTY, anchor: r, roundPixels: n, width: s, height: o, ...a } = t;
      super({
        label: "Sprite",
        ...a
      }), this.renderPipeId = "sprite", this.batched = true, this._didSpriteUpdate = false, this._bounds = {
        minX: 0,
        maxX: 1,
        minY: 0,
        maxY: 0
      }, this._sourceBounds = {
        minX: 0,
        maxX: 1,
        minY: 0,
        maxY: 0
      }, this._boundsDirty = true, this._sourceBoundsDirty = true, this._roundPixels = 0, this._anchor = new Xt({
        _onUpdate: () => {
          this.onViewUpdate();
        }
      }), r ? this.anchor = r : e.defaultAnchor && (this.anchor = e.defaultAnchor), this.texture = e, this.allowChildren = false, this.roundPixels = n ?? false, s !== void 0 && (this.width = s), o !== void 0 && (this.height = o);
    }
    static from(t, e = false) {
      return t instanceof J ? new lr(t) : new lr(J.from(t, e));
    }
    set texture(t) {
      t || (t = J.EMPTY);
      const e = this._texture;
      e !== t && (e && e.dynamic && e.off("update", this.onViewUpdate, this), t.dynamic && t.on("update", this.onViewUpdate, this), this._texture = t, this._width && this._setWidth(this._width, this._texture.orig.width), this._height && this._setHeight(this._height, this._texture.orig.height), this.onViewUpdate());
    }
    get texture() {
      return this._texture;
    }
    get bounds() {
      return this._boundsDirty && (this._updateBounds(), this._boundsDirty = false), this._bounds;
    }
    get sourceBounds() {
      return this._sourceBoundsDirty && (this._updateSourceBounds(), this._sourceBoundsDirty = false), this._sourceBounds;
    }
    containsPoint(t) {
      const e = this.sourceBounds;
      return t.x >= e.maxX && t.x <= e.minX && t.y >= e.maxY && t.y <= e.minY;
    }
    addBounds(t) {
      const e = this._texture.trim ? this.sourceBounds : this.bounds;
      t.addFrame(e.minX, e.minY, e.maxX, e.maxY);
    }
    onViewUpdate() {
      if (this._didChangeId += 4096, this._didSpriteUpdate = true, this._sourceBoundsDirty = this._boundsDirty = true, this.didViewUpdate) return;
      this.didViewUpdate = true;
      const t = this.renderGroup || this.parentRenderGroup;
      t && t.onChildViewUpdate(this);
    }
    _updateBounds() {
      Cn(this._bounds, this._anchor, this._texture, 0);
    }
    _updateSourceBounds() {
      const t = this._anchor, e = this._texture, r = this._sourceBounds, { width: n, height: s } = e.orig;
      r.maxX = -t._x * n, r.minX = r.maxX + n, r.maxY = -t._y * s, r.minY = r.maxY + s;
    }
    destroy(t = false) {
      if (super.destroy(t), typeof t == "boolean" ? t : t == null ? void 0 : t.texture) {
        const r = typeof t == "boolean" ? t : t == null ? void 0 : t.textureSource;
        this._texture.destroy(r);
      }
      this._texture = null, this._bounds = null, this._sourceBounds = null, this._anchor = null;
    }
    get anchor() {
      return this._anchor;
    }
    set anchor(t) {
      typeof t == "number" ? this._anchor.set(t) : this._anchor.copyFrom(t);
    }
    get roundPixels() {
      return !!this._roundPixels;
    }
    set roundPixels(t) {
      this._roundPixels = t ? 1 : 0;
    }
    get width() {
      return Math.abs(this.scale.x) * this._texture.orig.width;
    }
    set width(t) {
      this._setWidth(t, this._texture.orig.width), this._width = t;
    }
    get height() {
      return Math.abs(this.scale.y) * this._texture.orig.height;
    }
    set height(t) {
      this._setHeight(t, this._texture.orig.height), this._height = t;
    }
    getSize(t) {
      return t || (t = {}), t.width = Math.abs(this.scale.x) * this._texture.orig.width, t.height = Math.abs(this.scale.y) * this._texture.orig.height, t;
    }
    setSize(t, e) {
      let r, n;
      typeof t != "object" ? (r = t, n = e ?? t) : (r = t.width, n = t.height ?? t.width), r !== void 0 && this._setWidth(r, this._texture.orig.width), n !== void 0 && this._setHeight(n, this._texture.orig.height);
    }
  }
  const e_ = new re();
  function zl(i, t, e) {
    const r = e_;
    i.measurable = true, Vn(i, e, r), t.addBoundsMask(r), i.measurable = false;
  }
  function jl(i, t, e) {
    const r = Ke.get();
    i.measurable = true;
    const n = Ye.get().identity(), s = Wl(i, e, n);
    Qo(i, r, s), i.measurable = false, t.addBoundsMask(r), Ye.return(n), Ke.return(r);
  }
  function Wl(i, t, e) {
    return i ? (i !== t && (Wl(i.parent, t, e), i.updateLocalTransform(), e.append(i.localTransform)), e) : (ut("Mask bounds, renderable is not inside the root container"), e);
  }
  class Vl {
    constructor(t) {
      this.priority = 0, this.pipe = "alphaMask", (t == null ? void 0 : t.mask) && this.init(t.mask);
    }
    init(t) {
      this.mask = t, this.renderMaskToTexture = !(t instanceof lr), this.mask.renderable = this.renderMaskToTexture, this.mask.includeInBuild = !this.renderMaskToTexture, this.mask.measurable = false;
    }
    reset() {
      this.mask.measurable = true, this.mask = null;
    }
    addBounds(t, e) {
      zl(this.mask, t, e);
    }
    addLocalBounds(t, e) {
      jl(this.mask, t, e);
    }
    containsPoint(t, e) {
      const r = this.mask;
      return e(r, t);
    }
    destroy() {
      this.reset();
    }
    static test(t) {
      return t instanceof lr;
    }
  }
  Vl.extension = P.MaskEffect;
  class Xl {
    constructor(t) {
      this.priority = 0, this.pipe = "colorMask", (t == null ? void 0 : t.mask) && this.init(t.mask);
    }
    init(t) {
      this.mask = t;
    }
    destroy() {
    }
    static test(t) {
      return typeof t == "number";
    }
  }
  Xl.extension = P.MaskEffect;
  class ql {
    constructor(t) {
      this.priority = 0, this.pipe = "stencilMask", (t == null ? void 0 : t.mask) && this.init(t.mask);
    }
    init(t) {
      this.mask = t, this.mask.includeInBuild = false, this.mask.measurable = false;
    }
    reset() {
      this.mask.measurable = true, this.mask.includeInBuild = true, this.mask = null;
    }
    addBounds(t, e) {
      zl(this.mask, t, e);
    }
    addLocalBounds(t, e) {
      jl(this.mask, t, e);
    }
    containsPoint(t, e) {
      const r = this.mask;
      return e(r, t);
    }
    destroy() {
      this.reset();
    }
    static test(t) {
      return t instanceof Dt;
    }
  }
  ql.extension = P.MaskEffect;
  const r_ = {
    createCanvas: (i, t) => {
      const e = document.createElement("canvas");
      return e.width = i, e.height = t, e;
    },
    getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
    getWebGLRenderingContext: () => WebGLRenderingContext,
    getNavigator: () => navigator,
    getBaseUrl: () => document.baseURI ?? window.location.href,
    getFontFaceSet: () => document.fonts,
    fetch: (i, t) => fetch(i, t),
    parseXML: (i) => new DOMParser().parseFromString(i, "text/xml")
  };
  let pc = r_;
  const St = {
    get() {
      return pc;
    },
    set(i) {
      pc = i;
    }
  };
  class Kr extends Ht {
    constructor(t) {
      t.resource || (t.resource = St.get().createCanvas()), t.width || (t.width = t.resource.width, t.autoDensity || (t.width /= t.resolution)), t.height || (t.height = t.resource.height, t.autoDensity || (t.height /= t.resolution)), super(t), this.uploadMethodId = "image", this.autoDensity = t.autoDensity;
      const e = t.resource;
      (this.pixelWidth !== e.width || this.pixelWidth !== e.height) && this.resizeCanvas(), this.transparent = !!t.transparent;
    }
    resizeCanvas() {
      this.autoDensity && (this.resource.style.width = `${this.width}px`, this.resource.style.height = `${this.height}px`), (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight) && (this.resource.width = this.pixelWidth, this.resource.height = this.pixelHeight);
    }
    resize(t = this.width, e = this.height, r = this._resolution) {
      const n = super.resize(t, e, r);
      return n && this.resizeCanvas(), n;
    }
    static test(t) {
      return globalThis.HTMLCanvasElement && t instanceof HTMLCanvasElement || globalThis.OffscreenCanvas && t instanceof OffscreenCanvas;
    }
  }
  Kr.extension = P.TextureSource;
  class ti extends Ht {
    constructor(t) {
      if (t.resource && globalThis.HTMLImageElement && t.resource instanceof HTMLImageElement) {
        const e = St.get().createCanvas(t.resource.width, t.resource.height);
        e.getContext("2d").drawImage(t.resource, 0, 0, t.resource.width, t.resource.height), t.resource = e, ut("ImageSource: Image element passed, converting to canvas. Use CanvasSource instead.");
      }
      super(t), this.uploadMethodId = "image", this.autoGarbageCollect = true;
    }
    static test(t) {
      return globalThis.HTMLImageElement && t instanceof HTMLImageElement || typeof ImageBitmap < "u" && t instanceof ImageBitmap;
    }
  }
  ti.extension = P.TextureSource;
  var hr = ((i) => (i[i.INTERACTION = 50] = "INTERACTION", i[i.HIGH = 25] = "HIGH", i[i.NORMAL = 0] = "NORMAL", i[i.LOW = -25] = "LOW", i[i.UTILITY = -50] = "UTILITY", i))(hr || {});
  class Ds {
    constructor(t, e = null, r = 0, n = false) {
      this.next = null, this.previous = null, this._destroyed = false, this._fn = t, this._context = e, this.priority = r, this._once = n;
    }
    match(t, e = null) {
      return this._fn === t && this._context === e;
    }
    emit(t) {
      this._fn && (this._context ? this._fn.call(this._context, t) : this._fn(t));
      const e = this.next;
      return this._once && this.destroy(true), this._destroyed && (this.next = null), e;
    }
    connect(t) {
      this.previous = t, t.next && (t.next.previous = this), this.next = t.next, t.next = this;
    }
    destroy(t = false) {
      this._destroyed = true, this._fn = null, this._context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous);
      const e = this.next;
      return this.next = t ? null : e, this.previous = null, e;
    }
  }
  const $l = class le {
    constructor() {
      this.autoStart = false, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = false, this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this._protected = false, this._lastFrame = -1, this._head = new Ds(null, null, 1 / 0), this.deltaMS = 1 / le.targetFPMS, this.elapsedMS = 1 / le.targetFPMS, this._tick = (t) => {
        this._requestId = null, this.started && (this.update(t), this.started && this._requestId === null && this._head.next && (this._requestId = requestAnimationFrame(this._tick)));
      };
    }
    _requestIfNeeded() {
      this._requestId === null && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick));
    }
    _cancelIfNeeded() {
      this._requestId !== null && (cancelAnimationFrame(this._requestId), this._requestId = null);
    }
    _startIfPossible() {
      this.started ? this._requestIfNeeded() : this.autoStart && this.start();
    }
    add(t, e, r = hr.NORMAL) {
      return this._addListener(new Ds(t, e, r));
    }
    addOnce(t, e, r = hr.NORMAL) {
      return this._addListener(new Ds(t, e, r, true));
    }
    _addListener(t) {
      let e = this._head.next, r = this._head;
      if (!e) t.connect(r);
      else {
        for (; e; ) {
          if (t.priority > e.priority) {
            t.connect(r);
            break;
          }
          r = e, e = e.next;
        }
        t.previous || t.connect(r);
      }
      return this._startIfPossible(), this;
    }
    remove(t, e) {
      let r = this._head.next;
      for (; r; ) r.match(t, e) ? r = r.destroy() : r = r.next;
      return this._head.next || this._cancelIfNeeded(), this;
    }
    get count() {
      if (!this._head) return 0;
      let t = 0, e = this._head;
      for (; e = e.next; ) t++;
      return t;
    }
    start() {
      this.started || (this.started = true, this._requestIfNeeded());
    }
    stop() {
      this.started && (this.started = false, this._cancelIfNeeded());
    }
    destroy() {
      if (!this._protected) {
        this.stop();
        let t = this._head.next;
        for (; t; ) t = t.destroy(true);
        this._head.destroy(), this._head = null;
      }
    }
    update(t = performance.now()) {
      let e;
      if (t > this.lastTime) {
        if (e = this.elapsedMS = t - this.lastTime, e > this._maxElapsedMS && (e = this._maxElapsedMS), e *= this.speed, this._minElapsedMS) {
          const s = t - this._lastFrame | 0;
          if (s < this._minElapsedMS) return;
          this._lastFrame = t - s % this._minElapsedMS;
        }
        this.deltaMS = e, this.deltaTime = this.deltaMS * le.targetFPMS;
        const r = this._head;
        let n = r.next;
        for (; n; ) n = n.emit(this);
        r.next || this._cancelIfNeeded();
      } else this.deltaTime = this.deltaMS = this.elapsedMS = 0;
      this.lastTime = t;
    }
    get FPS() {
      return 1e3 / this.elapsedMS;
    }
    get minFPS() {
      return 1e3 / this._maxElapsedMS;
    }
    set minFPS(t) {
      const e = Math.min(this.maxFPS, t), r = Math.min(Math.max(0, e) / 1e3, le.targetFPMS);
      this._maxElapsedMS = 1 / r;
    }
    get maxFPS() {
      return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0;
    }
    set maxFPS(t) {
      if (t === 0) this._minElapsedMS = 0;
      else {
        const e = Math.max(this.minFPS, t);
        this._minElapsedMS = 1 / (e / 1e3);
      }
    }
    static get shared() {
      if (!le._shared) {
        const t = le._shared = new le();
        t.autoStart = true, t._protected = true;
      }
      return le._shared;
    }
    static get system() {
      if (!le._system) {
        const t = le._system = new le();
        t.autoStart = true, t._protected = true;
      }
      return le._system;
    }
  };
  $l.targetFPMS = 0.06;
  let ae = $l, Is;
  async function Yl() {
    return Is ?? (Is = (async () => {
      var _a2;
      const t = document.createElement("canvas").getContext("webgl");
      if (!t) return "premultiply-alpha-on-upload";
      const e = await new Promise((o) => {
        const a = document.createElement("video");
        a.onloadeddata = () => o(a), a.onerror = () => o(null), a.autoplay = false, a.crossOrigin = "anonymous", a.preload = "auto", a.src = "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=", a.load();
      });
      if (!e) return "premultiply-alpha-on-upload";
      const r = t.createTexture();
      t.bindTexture(t.TEXTURE_2D, r);
      const n = t.createFramebuffer();
      t.bindFramebuffer(t.FRAMEBUFFER, n), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, r, 0), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false), t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, t.NONE), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, e);
      const s = new Uint8Array(4);
      return t.readPixels(0, 0, 1, 1, t.RGBA, t.UNSIGNED_BYTE, s), t.deleteFramebuffer(n), t.deleteTexture(r), (_a2 = t.getExtension("WEBGL_lose_context")) == null ? void 0 : _a2.loseContext(), s[0] <= s[3] ? "premultiplied-alpha" : "premultiply-alpha-on-upload";
    })()), Is;
  }
  const Xn = class Kl extends Ht {
    constructor(t) {
      super(t), this.isReady = false, this.uploadMethodId = "video", t = {
        ...Kl.defaultOptions,
        ...t
      }, this._autoUpdate = true, this._isConnectedToTicker = false, this._updateFPS = t.updateFPS || 0, this._msToNextUpdate = 0, this.autoPlay = t.autoPlay !== false, this.alphaMode = t.alphaMode ?? "premultiply-alpha-on-upload", this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this), this._videoFrameRequestCallbackHandle = null, this._load = null, this._resolve = null, this._reject = null, this._onCanPlay = this._onCanPlay.bind(this), this._onCanPlayThrough = this._onCanPlayThrough.bind(this), this._onError = this._onError.bind(this), this._onPlayStart = this._onPlayStart.bind(this), this._onPlayStop = this._onPlayStop.bind(this), this._onSeeked = this._onSeeked.bind(this), t.autoLoad !== false && this.load();
    }
    updateFrame() {
      if (!this.destroyed) {
        if (this._updateFPS) {
          const t = ae.shared.elapsedMS * this.resource.playbackRate;
          this._msToNextUpdate = Math.floor(this._msToNextUpdate - t);
        }
        (!this._updateFPS || this._msToNextUpdate <= 0) && (this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0), this.isValid && this.update();
      }
    }
    _videoFrameRequestCallback() {
      this.updateFrame(), this.destroyed ? this._videoFrameRequestCallbackHandle = null : this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(this._videoFrameRequestCallback);
    }
    get isValid() {
      return !!this.resource.videoWidth && !!this.resource.videoHeight;
    }
    async load() {
      if (this._load) return this._load;
      const t = this.resource, e = this.options;
      return (t.readyState === t.HAVE_ENOUGH_DATA || t.readyState === t.HAVE_FUTURE_DATA) && t.width && t.height && (t.complete = true), t.addEventListener("play", this._onPlayStart), t.addEventListener("pause", this._onPlayStop), t.addEventListener("seeked", this._onSeeked), this._isSourceReady() ? this._mediaReady() : (e.preload || t.addEventListener("canplay", this._onCanPlay), t.addEventListener("canplaythrough", this._onCanPlayThrough), t.addEventListener("error", this._onError, true)), this.alphaMode = await Yl(), this._load = new Promise((r, n) => {
        this.isValid ? r(this) : (this._resolve = r, this._reject = n, e.preloadTimeoutMs !== void 0 && (this._preloadTimeout = setTimeout(() => {
          this._onError(new ErrorEvent(`Preload exceeded timeout of ${e.preloadTimeoutMs}ms`));
        })), t.load());
      }), this._load;
    }
    _onError(t) {
      this.resource.removeEventListener("error", this._onError, true), this.emit("error", t), this._reject && (this._reject(t), this._reject = null, this._resolve = null);
    }
    _isSourcePlaying() {
      const t = this.resource;
      return !t.paused && !t.ended;
    }
    _isSourceReady() {
      return this.resource.readyState > 2;
    }
    _onPlayStart() {
      this.isValid || this._mediaReady(), this._configureAutoUpdate();
    }
    _onPlayStop() {
      this._configureAutoUpdate();
    }
    _onSeeked() {
      this._autoUpdate && !this._isSourcePlaying() && (this._msToNextUpdate = 0, this.updateFrame(), this._msToNextUpdate = 0);
    }
    _onCanPlay() {
      this.resource.removeEventListener("canplay", this._onCanPlay), this._mediaReady();
    }
    _onCanPlayThrough() {
      this.resource.removeEventListener("canplaythrough", this._onCanPlay), this._preloadTimeout && (clearTimeout(this._preloadTimeout), this._preloadTimeout = void 0), this._mediaReady();
    }
    _mediaReady() {
      const t = this.resource;
      this.isValid && (this.isReady = true, this.resize(t.videoWidth, t.videoHeight)), this._msToNextUpdate = 0, this.updateFrame(), this._msToNextUpdate = 0, this._resolve && (this._resolve(this), this._resolve = null, this._reject = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && this.resource.play();
    }
    destroy() {
      this._configureAutoUpdate();
      const t = this.resource;
      t && (t.removeEventListener("play", this._onPlayStart), t.removeEventListener("pause", this._onPlayStop), t.removeEventListener("seeked", this._onSeeked), t.removeEventListener("canplay", this._onCanPlay), t.removeEventListener("canplaythrough", this._onCanPlayThrough), t.removeEventListener("error", this._onError, true), t.pause(), t.src = "", t.load()), super.destroy();
    }
    get autoUpdate() {
      return this._autoUpdate;
    }
    set autoUpdate(t) {
      t !== this._autoUpdate && (this._autoUpdate = t, this._configureAutoUpdate());
    }
    get updateFPS() {
      return this._updateFPS;
    }
    set updateFPS(t) {
      t !== this._updateFPS && (this._updateFPS = t, this._configureAutoUpdate());
    }
    _configureAutoUpdate() {
      this._autoUpdate && this._isSourcePlaying() ? !this._updateFPS && this.resource.requestVideoFrameCallback ? (this._isConnectedToTicker && (ae.shared.remove(this.updateFrame, this), this._isConnectedToTicker = false, this._msToNextUpdate = 0), this._videoFrameRequestCallbackHandle === null && (this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(this._videoFrameRequestCallback))) : (this._videoFrameRequestCallbackHandle !== null && (this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker || (ae.shared.add(this.updateFrame, this), this._isConnectedToTicker = true, this._msToNextUpdate = 0)) : (this._videoFrameRequestCallbackHandle !== null && (this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker && (ae.shared.remove(this.updateFrame, this), this._isConnectedToTicker = false, this._msToNextUpdate = 0));
    }
    static test(t) {
      return globalThis.HTMLVideoElement && t instanceof HTMLVideoElement || globalThis.VideoFrame && t instanceof VideoFrame;
    }
  };
  Xn.extension = P.TextureSource;
  Xn.defaultOptions = {
    ...Ht.defaultOptions,
    autoLoad: true,
    autoPlay: true,
    updateFPS: 0,
    crossorigin: true,
    loop: false,
    muted: true,
    playsinline: true,
    preload: false
  };
  Xn.MIME_TYPES = {
    ogv: "video/ogg",
    mov: "video/quicktime",
    m4v: "video/mp4"
  };
  let vn = Xn;
  const Re = (i, t, e = false) => (Array.isArray(i) || (i = [
    i
  ]), t ? i.map((r) => typeof r == "string" || e ? t(r) : r) : i);
  class i_ {
    constructor() {
      this._parsers = [], this._cache = /* @__PURE__ */ new Map(), this._cacheMap = /* @__PURE__ */ new Map();
    }
    reset() {
      this._cacheMap.clear(), this._cache.clear();
    }
    has(t) {
      return this._cache.has(t);
    }
    get(t) {
      const e = this._cache.get(t);
      return e || ut(`[Assets] Asset id ${t} was not found in the Cache`), e;
    }
    set(t, e) {
      const r = Re(t);
      let n;
      for (let c = 0; c < this.parsers.length; c++) {
        const u = this.parsers[c];
        if (u.test(e)) {
          n = u.getCacheableAssets(r, e);
          break;
        }
      }
      const s = new Map(Object.entries(n || {}));
      n || r.forEach((c) => {
        s.set(c, e);
      });
      const o = [
        ...s.keys()
      ], a = {
        cacheKeys: o,
        keys: r
      };
      r.forEach((c) => {
        this._cacheMap.set(c, a);
      }), o.forEach((c) => {
        const u = n ? n[c] : e;
        this._cache.has(c) && this._cache.get(c) !== u && ut("[Cache] already has key:", c), this._cache.set(c, s.get(c));
      });
    }
    remove(t) {
      if (!this._cacheMap.has(t)) {
        ut(`[Assets] Asset id ${t} was not found in the Cache`);
        return;
      }
      const e = this._cacheMap.get(t);
      e.cacheKeys.forEach((n) => {
        this._cache.delete(n);
      }), e.keys.forEach((n) => {
        this._cacheMap.delete(n);
      });
    }
    get parsers() {
      return this._parsers;
    }
  }
  const Tt = new i_(), xo = [];
  Mt.handleByList(P.TextureSource, xo);
  function Zl(i = {}) {
    const t = i && i.resource, e = t ? i.resource : i, r = t ? i : {
      resource: i
    };
    for (let n = 0; n < xo.length; n++) {
      const s = xo[n];
      if (s.test(e)) return new s(r);
    }
    throw new Error(`Could not find a source type for resource: ${r.resource}`);
  }
  function n_(i = {}, t = false) {
    const e = i && i.resource, r = e ? i.resource : i, n = e ? i : {
      resource: i
    };
    if (!t && Tt.has(r)) return Tt.get(r);
    const s = new J({
      source: Zl(n)
    });
    return s.on("destroy", () => {
      Tt.has(r) && Tt.remove(r);
    }), t || Tt.set(r, s), s;
  }
  function s_(i, t = false) {
    return typeof i == "string" ? Tt.get(i) : i instanceof Ht ? new J({
      source: i
    }) : n_(i, t);
  }
  J.from = s_;
  Ht.from = Zl;
  Mt.add(Vl, Xl, ql, vn, ti, Kr, Zo);
  var ve = ((i) => (i[i.Low = 0] = "Low", i[i.Normal = 1] = "Normal", i[i.High = 2] = "High", i))(ve || {});
  function Ae(i) {
    if (typeof i != "string") throw new TypeError(`Path must be a string. Received ${JSON.stringify(i)}`);
  }
  function si(i) {
    return i.split("?")[0].split("#")[0];
  }
  function o_(i) {
    return i.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  function a_(i, t, e) {
    return i.replace(new RegExp(o_(t), "g"), e);
  }
  function c_(i, t) {
    let e = "", r = 0, n = -1, s = 0, o = -1;
    for (let a = 0; a <= i.length; ++a) {
      if (a < i.length) o = i.charCodeAt(a);
      else {
        if (o === 47) break;
        o = 47;
      }
      if (o === 47) {
        if (!(n === a - 1 || s === 1)) if (n !== a - 1 && s === 2) {
          if (e.length < 2 || r !== 2 || e.charCodeAt(e.length - 1) !== 46 || e.charCodeAt(e.length - 2) !== 46) {
            if (e.length > 2) {
              const c = e.lastIndexOf("/");
              if (c !== e.length - 1) {
                c === -1 ? (e = "", r = 0) : (e = e.slice(0, c), r = e.length - 1 - e.lastIndexOf("/")), n = a, s = 0;
                continue;
              }
            } else if (e.length === 2 || e.length === 1) {
              e = "", r = 0, n = a, s = 0;
              continue;
            }
          }
          t && (e.length > 0 ? e += "/.." : e = "..", r = 2);
        } else e.length > 0 ? e += `/${i.slice(n + 1, a)}` : e = i.slice(n + 1, a), r = a - n - 1;
        n = a, s = 0;
      } else o === 46 && s !== -1 ? ++s : s = -1;
    }
    return e;
  }
  const _e = {
    toPosix(i) {
      return a_(i, "\\", "/");
    },
    isUrl(i) {
      return /^https?:/.test(this.toPosix(i));
    },
    isDataUrl(i) {
      return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(i);
    },
    isBlobUrl(i) {
      return i.startsWith("blob:");
    },
    hasProtocol(i) {
      return /^[^/:]+:/.test(this.toPosix(i));
    },
    getProtocol(i) {
      Ae(i), i = this.toPosix(i);
      const t = /^file:\/\/\//.exec(i);
      if (t) return t[0];
      const e = /^[^/:]+:\/{0,2}/.exec(i);
      return e ? e[0] : "";
    },
    toAbsolute(i, t, e) {
      if (Ae(i), this.isDataUrl(i) || this.isBlobUrl(i)) return i;
      const r = si(this.toPosix(t ?? St.get().getBaseUrl())), n = si(this.toPosix(e ?? this.rootname(r)));
      return i = this.toPosix(i), i.startsWith("/") ? _e.join(n, i.slice(1)) : this.isAbsolute(i) ? i : this.join(r, i);
    },
    normalize(i) {
      if (Ae(i), i.length === 0) return ".";
      if (this.isDataUrl(i) || this.isBlobUrl(i)) return i;
      i = this.toPosix(i);
      let t = "";
      const e = i.startsWith("/");
      this.hasProtocol(i) && (t = this.rootname(i), i = i.slice(t.length));
      const r = i.endsWith("/");
      return i = c_(i, false), i.length > 0 && r && (i += "/"), e ? `/${i}` : t + i;
    },
    isAbsolute(i) {
      return Ae(i), i = this.toPosix(i), this.hasProtocol(i) ? true : i.startsWith("/");
    },
    join(...i) {
      if (i.length === 0) return ".";
      let t;
      for (let e = 0; e < i.length; ++e) {
        const r = i[e];
        if (Ae(r), r.length > 0) if (t === void 0) t = r;
        else {
          const n = i[e - 1] ?? "";
          this.joinExtensions.includes(this.extname(n).toLowerCase()) ? t += `/../${r}` : t += `/${r}`;
        }
      }
      return t === void 0 ? "." : this.normalize(t);
    },
    dirname(i) {
      if (Ae(i), i.length === 0) return ".";
      i = this.toPosix(i);
      let t = i.charCodeAt(0);
      const e = t === 47;
      let r = -1, n = true;
      const s = this.getProtocol(i), o = i;
      i = i.slice(s.length);
      for (let a = i.length - 1; a >= 1; --a) if (t = i.charCodeAt(a), t === 47) {
        if (!n) {
          r = a;
          break;
        }
      } else n = false;
      return r === -1 ? e ? "/" : this.isUrl(o) ? s + i : s : e && r === 1 ? "//" : s + i.slice(0, r);
    },
    rootname(i) {
      Ae(i), i = this.toPosix(i);
      let t = "";
      if (i.startsWith("/") ? t = "/" : t = this.getProtocol(i), this.isUrl(i)) {
        const e = i.indexOf("/", t.length);
        e !== -1 ? t = i.slice(0, e) : t = i, t.endsWith("/") || (t += "/");
      }
      return t;
    },
    basename(i, t) {
      Ae(i), t && Ae(t), i = si(this.toPosix(i));
      let e = 0, r = -1, n = true, s;
      if (t !== void 0 && t.length > 0 && t.length <= i.length) {
        if (t.length === i.length && t === i) return "";
        let o = t.length - 1, a = -1;
        for (s = i.length - 1; s >= 0; --s) {
          const c = i.charCodeAt(s);
          if (c === 47) {
            if (!n) {
              e = s + 1;
              break;
            }
          } else a === -1 && (n = false, a = s + 1), o >= 0 && (c === t.charCodeAt(o) ? --o === -1 && (r = s) : (o = -1, r = a));
        }
        return e === r ? r = a : r === -1 && (r = i.length), i.slice(e, r);
      }
      for (s = i.length - 1; s >= 0; --s) if (i.charCodeAt(s) === 47) {
        if (!n) {
          e = s + 1;
          break;
        }
      } else r === -1 && (n = false, r = s + 1);
      return r === -1 ? "" : i.slice(e, r);
    },
    extname(i) {
      Ae(i), i = si(this.toPosix(i));
      let t = -1, e = 0, r = -1, n = true, s = 0;
      for (let o = i.length - 1; o >= 0; --o) {
        const a = i.charCodeAt(o);
        if (a === 47) {
          if (!n) {
            e = o + 1;
            break;
          }
          continue;
        }
        r === -1 && (n = false, r = o + 1), a === 46 ? t === -1 ? t = o : s !== 1 && (s = 1) : t !== -1 && (s = -1);
      }
      return t === -1 || r === -1 || s === 0 || s === 1 && t === r - 1 && t === e + 1 ? "" : i.slice(t, r);
    },
    parse(i) {
      Ae(i);
      const t = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
      };
      if (i.length === 0) return t;
      i = si(this.toPosix(i));
      let e = i.charCodeAt(0);
      const r = this.isAbsolute(i);
      let n;
      const s = "";
      t.root = this.rootname(i), r || this.hasProtocol(i) ? n = 1 : n = 0;
      let o = -1, a = 0, c = -1, u = true, l = i.length - 1, h = 0;
      for (; l >= n; --l) {
        if (e = i.charCodeAt(l), e === 47) {
          if (!u) {
            a = l + 1;
            break;
          }
          continue;
        }
        c === -1 && (u = false, c = l + 1), e === 46 ? o === -1 ? o = l : h !== 1 && (h = 1) : o !== -1 && (h = -1);
      }
      return o === -1 || c === -1 || h === 0 || h === 1 && o === c - 1 && o === a + 1 ? c !== -1 && (a === 0 && r ? t.base = t.name = i.slice(1, c) : t.base = t.name = i.slice(a, c)) : (a === 0 && r ? (t.name = i.slice(1, o), t.base = i.slice(1, c)) : (t.name = i.slice(a, o), t.base = i.slice(a, c)), t.ext = i.slice(o, c)), t.dir = this.dirname(i), s && (t.dir = s + t.dir), t;
    },
    sep: "/",
    delimiter: ":",
    joinExtensions: [
      ".html"
    ]
  };
  function Jl(i, t, e, r, n) {
    const s = t[e];
    for (let o = 0; o < s.length; o++) {
      const a = s[o];
      e < t.length - 1 ? Jl(i.replace(r[e], a), t, e + 1, r, n) : n.push(i.replace(r[e], a));
    }
  }
  function u_(i) {
    const t = /\{(.*?)\}/g, e = i.match(t), r = [];
    if (e) {
      const n = [];
      e.forEach((s) => {
        const o = s.substring(1, s.length - 1).split(",");
        n.push(o);
      }), Jl(i, n, 0, e, r);
    } else r.push(i);
    return r;
  }
  const Mn = (i) => !Array.isArray(i);
  class Dr {
    constructor() {
      this._defaultBundleIdentifierOptions = {
        connector: "-",
        createBundleAssetId: (t, e) => `${t}${this._bundleIdConnector}${e}`,
        extractAssetIdFromBundle: (t, e) => e.replace(`${t}${this._bundleIdConnector}`, "")
      }, this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector, this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId, this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle, this._assetMap = {}, this._preferredOrder = [], this._parsers = [], this._resolverHash = {}, this._bundles = {};
    }
    setBundleIdentifier(t) {
      if (this._bundleIdConnector = t.connector ?? this._bundleIdConnector, this._createBundleAssetId = t.createBundleAssetId ?? this._createBundleAssetId, this._extractAssetIdFromBundle = t.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle, this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar") throw new Error("[Resolver] GenerateBundleAssetId are not working correctly");
    }
    prefer(...t) {
      t.forEach((e) => {
        this._preferredOrder.push(e), e.priority || (e.priority = Object.keys(e.params));
      }), this._resolverHash = {};
    }
    set basePath(t) {
      this._basePath = t;
    }
    get basePath() {
      return this._basePath;
    }
    set rootPath(t) {
      this._rootPath = t;
    }
    get rootPath() {
      return this._rootPath;
    }
    get parsers() {
      return this._parsers;
    }
    reset() {
      this.setBundleIdentifier(this._defaultBundleIdentifierOptions), this._assetMap = {}, this._preferredOrder = [], this._resolverHash = {}, this._rootPath = null, this._basePath = null, this._manifest = null, this._bundles = {}, this._defaultSearchParams = null;
    }
    setDefaultSearchParams(t) {
      if (typeof t == "string") this._defaultSearchParams = t;
      else {
        const e = t;
        this._defaultSearchParams = Object.keys(e).map((r) => `${encodeURIComponent(r)}=${encodeURIComponent(e[r])}`).join("&");
      }
    }
    getAlias(t) {
      const { alias: e, src: r } = t;
      return Re(e || r, (s) => typeof s == "string" ? s : Array.isArray(s) ? s.map((o) => (o == null ? void 0 : o.src) ?? o) : (s == null ? void 0 : s.src) ? s.src : s, true);
    }
    addManifest(t) {
      this._manifest && ut("[Resolver] Manifest already exists, this will be overwritten"), this._manifest = t, t.bundles.forEach((e) => {
        this.addBundle(e.name, e.assets);
      });
    }
    addBundle(t, e) {
      const r = [];
      let n = e;
      Array.isArray(e) || (n = Object.entries(e).map(([s, o]) => typeof o == "string" || Array.isArray(o) ? {
        alias: s,
        src: o
      } : {
        alias: s,
        ...o
      })), n.forEach((s) => {
        const o = s.src, a = s.alias;
        let c;
        if (typeof a == "string") {
          const u = this._createBundleAssetId(t, a);
          r.push(u), c = [
            a,
            u
          ];
        } else {
          const u = a.map((l) => this._createBundleAssetId(t, l));
          r.push(...u), c = [
            ...a,
            ...u
          ];
        }
        this.add({
          ...s,
          alias: c,
          src: o
        });
      }), this._bundles[t] = r;
    }
    add(t) {
      const e = [];
      Array.isArray(t) ? e.push(...t) : e.push(t);
      let r;
      r = (s) => {
        this.hasKey(s) && ut(`[Resolver] already has key: ${s} overwriting`);
      }, Re(e).forEach((s) => {
        const { src: o } = s;
        let { data: a, format: c, loadParser: u } = s;
        const l = Re(o).map((p) => typeof p == "string" ? u_(p) : Array.isArray(p) ? p : [
          p
        ]), h = this.getAlias(s);
        Array.isArray(h) ? h.forEach(r) : r(h);
        const f = [];
        l.forEach((p) => {
          p.forEach((m) => {
            let y = {};
            if (typeof m != "object") {
              y.src = m;
              for (let b = 0; b < this._parsers.length; b++) {
                const v = this._parsers[b];
                if (v.test(m)) {
                  y = v.parse(m);
                  break;
                }
              }
            } else a = m.data ?? a, c = m.format ?? c, u = m.loadParser ?? u, y = {
              ...y,
              ...m
            };
            if (!h) throw new Error(`[Resolver] alias is undefined for this asset: ${y.src}`);
            y = this._buildResolvedAsset(y, {
              aliases: h,
              data: a,
              format: c,
              loadParser: u
            }), f.push(y);
          });
        }), h.forEach((p) => {
          this._assetMap[p] = f;
        });
      });
    }
    resolveBundle(t) {
      const e = Mn(t);
      t = Re(t);
      const r = {};
      return t.forEach((n) => {
        const s = this._bundles[n];
        if (s) {
          const o = this.resolve(s), a = {};
          for (const c in o) {
            const u = o[c];
            a[this._extractAssetIdFromBundle(n, c)] = u;
          }
          r[n] = a;
        }
      }), e ? r[t[0]] : r;
    }
    resolveUrl(t) {
      const e = this.resolve(t);
      if (typeof t != "string") {
        const r = {};
        for (const n in e) r[n] = e[n].src;
        return r;
      }
      return e.src;
    }
    resolve(t) {
      const e = Mn(t);
      t = Re(t);
      const r = {};
      return t.forEach((n) => {
        if (!this._resolverHash[n]) if (this._assetMap[n]) {
          let s = this._assetMap[n];
          const o = this._getPreferredOrder(s);
          o == null ? void 0 : o.priority.forEach((a) => {
            o.params[a].forEach((c) => {
              const u = s.filter((l) => l[a] ? l[a] === c : false);
              u.length && (s = u);
            });
          }), this._resolverHash[n] = s[0];
        } else this._resolverHash[n] = this._buildResolvedAsset({
          alias: [
            n
          ],
          src: n
        }, {});
        r[n] = this._resolverHash[n];
      }), e ? r[t[0]] : r;
    }
    hasKey(t) {
      return !!this._assetMap[t];
    }
    hasBundle(t) {
      return !!this._bundles[t];
    }
    _getPreferredOrder(t) {
      for (let e = 0; e < t.length; e++) {
        const r = t[0], n = this._preferredOrder.find((s) => s.params.format.includes(r.format));
        if (n) return n;
      }
      return this._preferredOrder[0];
    }
    _appendDefaultSearchParams(t) {
      if (!this._defaultSearchParams) return t;
      const e = /\?/.test(t) ? "&" : "?";
      return `${t}${e}${this._defaultSearchParams}`;
    }
    _buildResolvedAsset(t, e) {
      const { aliases: r, data: n, loadParser: s, format: o } = e;
      return (this._basePath || this._rootPath) && (t.src = _e.toAbsolute(t.src, this._basePath, this._rootPath)), t.alias = r ?? t.alias ?? [
        t.src
      ], t.src = this._appendDefaultSearchParams(t.src), t.data = {
        ...n || {},
        ...t.data
      }, t.loadParser = s ?? t.loadParser, t.format = o ?? t.format ?? l_(t.src), t;
    }
  }
  Dr.RETINA_PREFIX = /@([0-9\.]+)x/;
  function l_(i) {
    return i.split(".").pop().split("?").shift().split("#").shift();
  }
  const vo = (i, t) => {
    const e = t.split("?")[1];
    return e && (i += `?${e}`), i;
  }, Ql = class gi {
    constructor(t, e) {
      this.linkedSheets = [], this._texture = t instanceof J ? t : null, this.textureSource = t.source, this.textures = {}, this.animations = {}, this.data = e;
      const r = parseFloat(e.meta.scale);
      r ? (this.resolution = r, t.source.resolution = this.resolution) : this.resolution = t.source._resolution, this._frames = this.data.frames, this._frameKeys = Object.keys(this._frames), this._batchIndex = 0, this._callback = null;
    }
    parse() {
      return new Promise((t) => {
        this._callback = t, this._batchIndex = 0, this._frameKeys.length <= gi.BATCH_SIZE ? (this._processFrames(0), this._processAnimations(), this._parseComplete()) : this._nextBatch();
      });
    }
    _processFrames(t) {
      let e = t;
      const r = gi.BATCH_SIZE;
      for (; e - t < r && e < this._frameKeys.length; ) {
        const n = this._frameKeys[e], s = this._frames[n], o = s.frame;
        if (o) {
          let a = null, c = null;
          const u = s.trimmed !== false && s.sourceSize ? s.sourceSize : s.frame, l = new Et(0, 0, Math.floor(u.w) / this.resolution, Math.floor(u.h) / this.resolution);
          s.rotated ? a = new Et(Math.floor(o.x) / this.resolution, Math.floor(o.y) / this.resolution, Math.floor(o.h) / this.resolution, Math.floor(o.w) / this.resolution) : a = new Et(Math.floor(o.x) / this.resolution, Math.floor(o.y) / this.resolution, Math.floor(o.w) / this.resolution, Math.floor(o.h) / this.resolution), s.trimmed !== false && s.spriteSourceSize && (c = new Et(Math.floor(s.spriteSourceSize.x) / this.resolution, Math.floor(s.spriteSourceSize.y) / this.resolution, Math.floor(o.w) / this.resolution, Math.floor(o.h) / this.resolution)), this.textures[n] = new J({
            source: this.textureSource,
            frame: a,
            orig: l,
            trim: c,
            rotate: s.rotated ? 2 : 0,
            defaultAnchor: s.anchor,
            defaultBorders: s.borders,
            label: n.toString()
          });
        }
        e++;
      }
    }
    _processAnimations() {
      const t = this.data.animations || {};
      for (const e in t) {
        this.animations[e] = [];
        for (let r = 0; r < t[e].length; r++) {
          const n = t[e][r];
          this.animations[e].push(this.textures[n]);
        }
      }
    }
    _parseComplete() {
      const t = this._callback;
      this._callback = null, this._batchIndex = 0, t.call(this, this.textures);
    }
    _nextBatch() {
      this._processFrames(this._batchIndex * gi.BATCH_SIZE), this._batchIndex++, setTimeout(() => {
        this._batchIndex * gi.BATCH_SIZE < this._frameKeys.length ? this._nextBatch() : (this._processAnimations(), this._parseComplete());
      }, 0);
    }
    destroy(t = false) {
      var _a2;
      for (const e in this.textures) this.textures[e].destroy();
      this._frames = null, this._frameKeys = null, this.data = null, this.textures = null, t && ((_a2 = this._texture) == null ? void 0 : _a2.destroy(), this.textureSource.destroy()), this._texture = null, this.textureSource = null, this.linkedSheets = [];
    }
  };
  Ql.BATCH_SIZE = 1e3;
  let _c = Ql;
  const h_ = [
    "jpg",
    "png",
    "jpeg",
    "avif",
    "webp",
    "basis",
    "etc2",
    "bc7",
    "bc6h",
    "bc5",
    "bc4",
    "bc3",
    "bc2",
    "bc1",
    "eac",
    "astc"
  ];
  function th(i, t, e) {
    const r = {};
    if (i.forEach((n) => {
      r[n] = t;
    }), Object.keys(t.textures).forEach((n) => {
      r[n] = t.textures[n];
    }), !e) {
      const n = _e.dirname(i[0]);
      t.linkedSheets.forEach((s, o) => {
        const a = th([
          `${n}/${t.data.meta.related_multi_packs[o]}`
        ], s, true);
        Object.assign(r, a);
      });
    }
    return r;
  }
  const d_ = {
    extension: P.Asset,
    cache: {
      test: (i) => i instanceof _c,
      getCacheableAssets: (i, t) => th(i, t, false)
    },
    resolver: {
      extension: {
        type: P.ResolveParser,
        name: "resolveSpritesheet"
      },
      test: (i) => {
        const e = i.split("?")[0].split("."), r = e.pop(), n = e.pop();
        return r === "json" && h_.includes(n);
      },
      parse: (i) => {
        var _a2;
        const t = i.split(".");
        return {
          resolution: parseFloat(((_a2 = Dr.RETINA_PREFIX.exec(i)) == null ? void 0 : _a2[1]) ?? "1"),
          format: t[t.length - 2],
          src: i
        };
      }
    },
    loader: {
      name: "spritesheetLoader",
      extension: {
        type: P.LoadParser,
        priority: ve.Normal,
        name: "spritesheetLoader"
      },
      async testParse(i, t) {
        return _e.extname(t.src).toLowerCase() === ".json" && !!i.frames;
      },
      async parse(i, t, e) {
        var _a2, _b2;
        const { texture: r, imageFilename: n } = (t == null ? void 0 : t.data) ?? {};
        let s = _e.dirname(t.src);
        s && s.lastIndexOf("/") !== s.length - 1 && (s += "/");
        let o;
        if (r instanceof J) o = r;
        else {
          const u = vo(s + (n ?? i.meta.image), t.src);
          o = (await e.load([
            u
          ]))[u];
        }
        const a = new _c(o.source, i);
        await a.parse();
        const c = (_a2 = i == null ? void 0 : i.meta) == null ? void 0 : _a2.related_multi_packs;
        if (Array.isArray(c)) {
          const u = [];
          for (const h of c) {
            if (typeof h != "string") continue;
            let f = s + h;
            ((_b2 = t.data) == null ? void 0 : _b2.ignoreMultiPack) || (f = vo(f, t.src), u.push(e.load({
              src: f,
              data: {
                ignoreMultiPack: true
              }
            })));
          }
          const l = await Promise.all(u);
          a.linkedSheets = l, l.forEach((h) => {
            h.linkedSheets = [
              a
            ].concat(a.linkedSheets.filter((f) => f !== h));
          });
        }
        return a;
      },
      async unload(i, t, e) {
        await e.unload(i.textureSource._sourceOrigin), i.destroy(false);
      }
    }
  };
  Mt.add(d_);
  class Di {
    constructor(t) {
      this.bubbles = true, this.cancelBubble = true, this.cancelable = false, this.composed = false, this.defaultPrevented = false, this.eventPhase = Di.prototype.NONE, this.propagationStopped = false, this.propagationImmediatelyStopped = false, this.layer = new Ct(), this.page = new Ct(), this.NONE = 0, this.CAPTURING_PHASE = 1, this.AT_TARGET = 2, this.BUBBLING_PHASE = 3, this.manager = t;
    }
    get layerX() {
      return this.layer.x;
    }
    get layerY() {
      return this.layer.y;
    }
    get pageX() {
      return this.page.x;
    }
    get pageY() {
      return this.page.y;
    }
    get data() {
      return this;
    }
    composedPath() {
      return this.manager && (!this.path || this.path[this.path.length - 1] !== this.target) && (this.path = this.target ? this.manager.propagationPath(this.target) : []), this.path;
    }
    initEvent(t, e, r) {
      throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
    }
    initUIEvent(t, e, r, n, s) {
      throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
    }
    preventDefault() {
      this.nativeEvent instanceof Event && this.nativeEvent.cancelable && this.nativeEvent.preventDefault(), this.defaultPrevented = true;
    }
    stopImmediatePropagation() {
      this.propagationImmediatelyStopped = true;
    }
    stopPropagation() {
      this.propagationStopped = true;
    }
  }
  var Fs = /iPhone/i, gc = /iPod/i, mc = /iPad/i, bc = /\biOS-universal(?:.+)Mac\b/i, Us = /\bAndroid(?:.+)Mobile\b/i, wc = /Android/i, Or = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i, $i = /Silk/i, Ve = /Windows Phone/i, yc = /\bWindows(?:.+)ARM\b/i, xc = /BlackBerry/i, vc = /BB10/i, Sc = /Opera Mini/i, Ec = /\b(CriOS|Chrome)(?:.+)Mobile/i, Ac = /Mobile(?:.+)Firefox\b/i, Tc = function(i) {
    return typeof i < "u" && i.platform === "MacIntel" && typeof i.maxTouchPoints == "number" && i.maxTouchPoints > 1 && typeof MSStream > "u";
  };
  function f_(i) {
    return function(t) {
      return t.test(i);
    };
  }
  function Cc(i) {
    var t = {
      userAgent: "",
      platform: "",
      maxTouchPoints: 0
    };
    !i && typeof navigator < "u" ? t = {
      userAgent: navigator.userAgent,
      platform: navigator.platform,
      maxTouchPoints: navigator.maxTouchPoints || 0
    } : typeof i == "string" ? t.userAgent = i : i && i.userAgent && (t = {
      userAgent: i.userAgent,
      platform: i.platform,
      maxTouchPoints: i.maxTouchPoints || 0
    });
    var e = t.userAgent, r = e.split("[FBAN");
    typeof r[1] < "u" && (e = r[0]), r = e.split("Twitter"), typeof r[1] < "u" && (e = r[0]);
    var n = f_(e), s = {
      apple: {
        phone: n(Fs) && !n(Ve),
        ipod: n(gc),
        tablet: !n(Fs) && (n(mc) || Tc(t)) && !n(Ve),
        universal: n(bc),
        device: (n(Fs) || n(gc) || n(mc) || n(bc) || Tc(t)) && !n(Ve)
      },
      amazon: {
        phone: n(Or),
        tablet: !n(Or) && n($i),
        device: n(Or) || n($i)
      },
      android: {
        phone: !n(Ve) && n(Or) || !n(Ve) && n(Us),
        tablet: !n(Ve) && !n(Or) && !n(Us) && (n($i) || n(wc)),
        device: !n(Ve) && (n(Or) || n($i) || n(Us) || n(wc)) || n(/\bokhttp\b/i)
      },
      windows: {
        phone: n(Ve),
        tablet: n(yc),
        device: n(Ve) || n(yc)
      },
      other: {
        blackberry: n(xc),
        blackberry10: n(vc),
        opera: n(Sc),
        firefox: n(Ac),
        chrome: n(Ec),
        device: n(xc) || n(vc) || n(Sc) || n(Ac) || n(Ec)
      },
      any: false,
      phone: false,
      tablet: false
    };
    return s.any = s.apple.device || s.android.device || s.windows.device || s.other.device, s.phone = s.apple.phone || s.android.phone || s.windows.phone, s.tablet = s.apple.tablet || s.android.tablet || s.windows.tablet, s;
  }
  const p_ = Cc.default ?? Cc, __ = p_(globalThis.navigator), g_ = 9, Yi = 100, m_ = 0, b_ = 0, Rc = 2, Pc = 1, w_ = -1e3, y_ = -1e3, x_ = 2;
  v_ = class {
    constructor(t, e = __) {
      this._mobileInfo = e, this.debug = false, this._isActive = false, this._isMobileAccessibility = false, this._pool = [], this._renderId = 0, this._children = [], this._androidUpdateCount = 0, this._androidUpdateFrequency = 500, this._hookDiv = null, (e.tablet || e.phone) && this._createTouchHook();
      const r = document.createElement("div");
      r.style.width = `${Yi}px`, r.style.height = `${Yi}px`, r.style.position = "absolute", r.style.top = `${m_}px`, r.style.left = `${b_}px`, r.style.zIndex = Rc.toString(), this._div = r, this._renderer = t, this._onKeyDown = this._onKeyDown.bind(this), this._onMouseMove = this._onMouseMove.bind(this), globalThis.addEventListener("keydown", this._onKeyDown, false);
    }
    get isActive() {
      return this._isActive;
    }
    get isMobileAccessibility() {
      return this._isMobileAccessibility;
    }
    get hookDiv() {
      return this._hookDiv;
    }
    _createTouchHook() {
      const t = document.createElement("button");
      t.style.width = `${Pc}px`, t.style.height = `${Pc}px`, t.style.position = "absolute", t.style.top = `${w_}px`, t.style.left = `${y_}px`, t.style.zIndex = x_.toString(), t.style.backgroundColor = "#FF0000", t.title = "select to enable accessibility for this content", t.addEventListener("focus", () => {
        this._isMobileAccessibility = true, this._activate(), this._destroyTouchHook();
      }), document.body.appendChild(t), this._hookDiv = t;
    }
    _destroyTouchHook() {
      this._hookDiv && (document.body.removeChild(this._hookDiv), this._hookDiv = null);
    }
    _activate() {
      var _a2;
      this._isActive || (this._isActive = true, globalThis.document.addEventListener("mousemove", this._onMouseMove, true), globalThis.removeEventListener("keydown", this._onKeyDown, false), this._renderer.runners.postrender.add(this), (_a2 = this._renderer.view.canvas.parentNode) == null ? void 0 : _a2.appendChild(this._div));
    }
    _deactivate() {
      var _a2;
      !this._isActive || this._isMobileAccessibility || (this._isActive = false, globalThis.document.removeEventListener("mousemove", this._onMouseMove, true), globalThis.addEventListener("keydown", this._onKeyDown, false), this._renderer.runners.postrender.remove(this), (_a2 = this._div.parentNode) == null ? void 0 : _a2.removeChild(this._div));
    }
    _updateAccessibleObjects(t) {
      if (!t.visible || !t.accessibleChildren) return;
      t.accessible && t.isInteractive() && (t._accessibleActive || this._addChild(t), t._renderId = this._renderId);
      const e = t.children;
      if (e) for (let r = 0; r < e.length; r++) this._updateAccessibleObjects(e[r]);
    }
    init(t) {
      this.debug = (t == null ? void 0 : t.debug) ?? this.debug, this._renderer.runners.postrender.remove(this);
    }
    postrender() {
      const t = performance.now();
      if (this._mobileInfo.android.device && t < this._androidUpdateCount || (this._androidUpdateCount = t + this._androidUpdateFrequency, !this._renderer.renderingToScreen || !this._renderer.view.canvas)) return;
      this._renderer.lastObjectRendered && this._updateAccessibleObjects(this._renderer.lastObjectRendered);
      const { x: e, y: r, width: n, height: s } = this._renderer.view.canvas.getBoundingClientRect(), { width: o, height: a, resolution: c } = this._renderer, u = n / o * c, l = s / a * c;
      let h = this._div;
      h.style.left = `${e}px`, h.style.top = `${r}px`, h.style.width = `${o}px`, h.style.height = `${a}px`;
      for (let f = 0; f < this._children.length; f++) {
        const p = this._children[f];
        if (p._renderId !== this._renderId) p._accessibleActive = false, Gl(this._children, f, 1), this._div.removeChild(p._accessibleDiv), this._pool.push(p._accessibleDiv), p._accessibleDiv = null, f--;
        else {
          h = p._accessibleDiv;
          let m = p.hitArea;
          const y = p.worldTransform;
          p.hitArea ? (h.style.left = `${(y.tx + m.x * y.a) * u}px`, h.style.top = `${(y.ty + m.y * y.d) * l}px`, h.style.width = `${m.width * y.a * u}px`, h.style.height = `${m.height * y.d * l}px`) : (m = p.getBounds().rectangle, this._capHitArea(m), h.style.left = `${m.x * u}px`, h.style.top = `${m.y * l}px`, h.style.width = `${m.width * u}px`, h.style.height = `${m.height * l}px`, h.title !== p.accessibleTitle && p.accessibleTitle !== null && (h.title = p.accessibleTitle || ""), h.getAttribute("aria-label") !== p.accessibleHint && p.accessibleHint !== null && h.setAttribute("aria-label", p.accessibleHint || "")), (p.accessibleTitle !== h.title || p.tabIndex !== h.tabIndex) && (h.title = p.accessibleTitle || "", h.tabIndex = p.tabIndex, this.debug && this._updateDebugHTML(h));
        }
      }
      this._renderId++;
    }
    _updateDebugHTML(t) {
      t.innerHTML = `type: ${t.type}</br> title : ${t.title}</br> tabIndex: ${t.tabIndex}`;
    }
    _capHitArea(t) {
      t.x < 0 && (t.width += t.x, t.x = 0), t.y < 0 && (t.height += t.y, t.y = 0);
      const { width: e, height: r } = this._renderer;
      t.x + t.width > e && (t.width = e - t.x), t.y + t.height > r && (t.height = r - t.y);
    }
    _addChild(t) {
      let e = this._pool.pop();
      e || (e = document.createElement("button"), e.style.width = `${Yi}px`, e.style.height = `${Yi}px`, e.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent", e.style.position = "absolute", e.style.zIndex = Rc.toString(), e.style.borderStyle = "none", navigator.userAgent.toLowerCase().includes("chrome") ? e.setAttribute("aria-live", "off") : e.setAttribute("aria-live", "polite"), navigator.userAgent.match(/rv:.*Gecko\//) ? e.setAttribute("aria-relevant", "additions") : e.setAttribute("aria-relevant", "text"), e.addEventListener("click", this._onClick.bind(this)), e.addEventListener("focus", this._onFocus.bind(this)), e.addEventListener("focusout", this._onFocusOut.bind(this))), e.style.pointerEvents = t.accessiblePointerEvents, e.type = t.accessibleType, t.accessibleTitle && t.accessibleTitle !== null ? e.title = t.accessibleTitle : (!t.accessibleHint || t.accessibleHint === null) && (e.title = `container ${t.tabIndex}`), t.accessibleHint && t.accessibleHint !== null && e.setAttribute("aria-label", t.accessibleHint), this.debug && this._updateDebugHTML(e), t._accessibleActive = true, t._accessibleDiv = e, e.container = t, this._children.push(t), this._div.appendChild(t._accessibleDiv), t._accessibleDiv.tabIndex = t.tabIndex;
    }
    _dispatchEvent(t, e) {
      const { container: r } = t.target, n = this._renderer.events.rootBoundary, s = Object.assign(new Di(n), {
        target: r
      });
      n.rootTarget = this._renderer.lastObjectRendered, e.forEach((o) => n.dispatchEvent(s, o));
    }
    _onClick(t) {
      this._dispatchEvent(t, [
        "click",
        "pointertap",
        "tap"
      ]);
    }
    _onFocus(t) {
      t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "assertive"), this._dispatchEvent(t, [
        "mouseover"
      ]);
    }
    _onFocusOut(t) {
      t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "polite"), this._dispatchEvent(t, [
        "mouseout"
      ]);
    }
    _onKeyDown(t) {
      t.keyCode === g_ && this._activate();
    }
    _onMouseMove(t) {
      t.movementX === 0 && t.movementY === 0 || this._deactivate();
    }
    destroy() {
      this._destroyTouchHook(), this._div = null, globalThis.document.removeEventListener("mousemove", this._onMouseMove, true), globalThis.removeEventListener("keydown", this._onKeyDown), this._pool = null, this._children = null, this._renderer = null;
    }
  };
  v_.extension = {
    type: [
      P.WebGLSystem,
      P.WebGPUSystem
    ],
    name: "accessibility"
  };
  let ks, Bc;
  X3 = {
    accessible: false,
    accessibleTitle: null,
    accessibleHint: null,
    tabIndex: 0,
    _accessibleActive: false,
    _accessibleDiv: null,
    accessibleType: "button",
    accessiblePointerEvents: "auto",
    accessibleChildren: true,
    _renderId: -1
  };
  ks = /* @__PURE__ */ Object.create(null);
  Bc = /* @__PURE__ */ Object.create(null);
  function qn(i, t) {
    let e = Bc[i];
    return e === void 0 && (ks[t] === void 0 && (ks[t] = 1), Bc[i] = e = ks[t]++), e;
  }
  let Ki;
  function eh() {
    return (!Ki || (Ki == null ? void 0 : Ki.isContextLost())) && (Ki = St.get().createCanvas().getContext("webgl", {})), Ki;
  }
  let Zi;
  function S_() {
    if (!Zi) {
      Zi = "mediump";
      const i = eh();
      i && i.getShaderPrecisionFormat && (Zi = i.getShaderPrecisionFormat(i.FRAGMENT_SHADER, i.HIGH_FLOAT).precision ? "highp" : "mediump");
    }
    return Zi;
  }
  function E_(i, t, e) {
    return t ? i : e ? (i = i.replace("out vec4 finalColor;", ""), `
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in varying
        #define finalColor gl_FragColor
        #define texture texture2D
        #endif
        ${i}
        `) : `
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in attribute
        #define out varying
        #endif
        ${i}
        `;
  }
  function A_(i, t, e) {
    const r = e ? t.maxSupportedFragmentPrecision : t.maxSupportedVertexPrecision;
    if (i.substring(0, 9) !== "precision") {
      let n = e ? t.requestedFragmentPrecision : t.requestedVertexPrecision;
      return n === "highp" && r !== "highp" && (n = "mediump"), `precision ${n} float;
${i}`;
    } else if (r !== "highp" && i.substring(0, 15) === "precision highp") return i.replace("precision highp", "precision mediump");
    return i;
  }
  function T_(i, t) {
    return t ? `#version 300 es
${i}` : i;
  }
  const C_ = {}, R_ = {};
  function P_(i, { name: t = "pixi-program" }, e = true) {
    t = t.replace(/\s+/g, "-"), t += e ? "-fragment" : "-vertex";
    const r = e ? C_ : R_;
    return r[t] ? (r[t]++, t += `-${r[t]}`) : r[t] = 1, i.indexOf("#define SHADER_NAME") !== -1 ? i : `${`#define SHADER_NAME ${t}`}
${i}`;
  }
  function B_(i, t) {
    return t ? i.replace("#version 300 es", "") : i;
  }
  const Gs = {
    stripVersion: B_,
    ensurePrecision: A_,
    addProgramDefines: E_,
    setProgramName: P_,
    insertVersion: T_
  }, Os = /* @__PURE__ */ Object.create(null), rh = class So {
    constructor(t) {
      t = {
        ...So.defaultOptions,
        ...t
      };
      const e = t.fragment.indexOf("#version 300 es") !== -1, r = {
        stripVersion: e,
        ensurePrecision: {
          requestedFragmentPrecision: t.preferredFragmentPrecision,
          requestedVertexPrecision: t.preferredVertexPrecision,
          maxSupportedVertexPrecision: "highp",
          maxSupportedFragmentPrecision: S_()
        },
        setProgramName: {
          name: t.name
        },
        addProgramDefines: e,
        insertVersion: e
      };
      let n = t.fragment, s = t.vertex;
      Object.keys(Gs).forEach((o) => {
        const a = r[o];
        n = Gs[o](n, a, true), s = Gs[o](s, a, false);
      }), this.fragment = n, this.vertex = s, this._key = qn(`${this.vertex}:${this.fragment}`, "gl-program");
    }
    destroy() {
      this.fragment = null, this.vertex = null, this._attributeData = null, this._uniformData = null, this._uniformBlockData = null, this.transformFeedbackVaryings = null;
    }
    static from(t) {
      const e = `${t.vertex}:${t.fragment}`;
      return Os[e] || (Os[e] = new So(t)), Os[e];
    }
  };
  rh.defaultOptions = {
    preferredVertexPrecision: "highp",
    preferredFragmentPrecision: "mediump"
  };
  let rr = rh;
  const Mc = {
    uint8x2: {
      size: 2,
      stride: 2,
      normalised: false
    },
    uint8x4: {
      size: 4,
      stride: 4,
      normalised: false
    },
    sint8x2: {
      size: 2,
      stride: 2,
      normalised: false
    },
    sint8x4: {
      size: 4,
      stride: 4,
      normalised: false
    },
    unorm8x2: {
      size: 2,
      stride: 2,
      normalised: true
    },
    unorm8x4: {
      size: 4,
      stride: 4,
      normalised: true
    },
    snorm8x2: {
      size: 2,
      stride: 2,
      normalised: true
    },
    snorm8x4: {
      size: 4,
      stride: 4,
      normalised: true
    },
    uint16x2: {
      size: 2,
      stride: 4,
      normalised: false
    },
    uint16x4: {
      size: 4,
      stride: 8,
      normalised: false
    },
    sint16x2: {
      size: 2,
      stride: 4,
      normalised: false
    },
    sint16x4: {
      size: 4,
      stride: 8,
      normalised: false
    },
    unorm16x2: {
      size: 2,
      stride: 4,
      normalised: true
    },
    unorm16x4: {
      size: 4,
      stride: 8,
      normalised: true
    },
    snorm16x2: {
      size: 2,
      stride: 4,
      normalised: true
    },
    snorm16x4: {
      size: 4,
      stride: 8,
      normalised: true
    },
    float16x2: {
      size: 2,
      stride: 4,
      normalised: false
    },
    float16x4: {
      size: 4,
      stride: 8,
      normalised: false
    },
    float32: {
      size: 1,
      stride: 4,
      normalised: false
    },
    float32x2: {
      size: 2,
      stride: 8,
      normalised: false
    },
    float32x3: {
      size: 3,
      stride: 12,
      normalised: false
    },
    float32x4: {
      size: 4,
      stride: 16,
      normalised: false
    },
    uint32: {
      size: 1,
      stride: 4,
      normalised: false
    },
    uint32x2: {
      size: 2,
      stride: 8,
      normalised: false
    },
    uint32x3: {
      size: 3,
      stride: 12,
      normalised: false
    },
    uint32x4: {
      size: 4,
      stride: 16,
      normalised: false
    },
    sint32: {
      size: 1,
      stride: 4,
      normalised: false
    },
    sint32x2: {
      size: 2,
      stride: 8,
      normalised: false
    },
    sint32x3: {
      size: 3,
      stride: 12,
      normalised: false
    },
    sint32x4: {
      size: 4,
      stride: 16,
      normalised: false
    }
  };
  function Ti(i) {
    return Mc[i] ?? Mc.float32;
  }
  const M_ = {
    f32: "float32",
    "vec2<f32>": "float32x2",
    "vec3<f32>": "float32x3",
    "vec4<f32>": "float32x4",
    vec2f: "float32x2",
    vec3f: "float32x3",
    vec4f: "float32x4",
    i32: "sint32",
    "vec2<i32>": "sint32x2",
    "vec3<i32>": "sint32x3",
    "vec4<i32>": "sint32x4",
    u32: "uint32",
    "vec2<u32>": "uint32x2",
    "vec3<u32>": "uint32x3",
    "vec4<u32>": "uint32x4",
    bool: "uint32",
    "vec2<bool>": "uint32x2",
    "vec3<bool>": "uint32x3",
    "vec4<bool>": "uint32x4"
  };
  function D_({ source: i, entryPoint: t }) {
    const e = {}, r = i.indexOf(`fn ${t}`);
    if (r !== -1) {
      const n = i.indexOf("->", r);
      if (n !== -1) {
        const s = i.substring(r, n), o = /@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g;
        let a;
        for (; (a = o.exec(s)) !== null; ) {
          const c = M_[a[3]] ?? "float32";
          e[a[2]] = {
            location: parseInt(a[1], 10),
            format: c,
            stride: Ti(c).stride,
            offset: 0,
            instance: false,
            start: 0
          };
        }
      }
    }
    return e;
  }
  function Ns(i) {
    var _a2, _b2;
    const t = /(^|[^/])@(group|binding)\(\d+\)[^;]+;/g, e = /@group\((\d+)\)/, r = /@binding\((\d+)\)/, n = /var(<[^>]+>)? (\w+)/, s = /:\s*(\w+)/, o = /struct\s+(\w+)\s*{([^}]+)}/g, a = /(\w+)\s*:\s*([\w\<\>]+)/g, c = /struct\s+(\w+)/, u = (_a2 = i.match(t)) == null ? void 0 : _a2.map((h) => ({
      group: parseInt(h.match(e)[1], 10),
      binding: parseInt(h.match(r)[1], 10),
      name: h.match(n)[2],
      isUniform: h.match(n)[1] === "<uniform>",
      type: h.match(s)[1]
    }));
    if (!u) return {
      groups: [],
      structs: []
    };
    const l = ((_b2 = i.match(o)) == null ? void 0 : _b2.map((h) => {
      const f = h.match(c)[1], p = h.match(a).reduce((m, y) => {
        const [b, v] = y.split(":");
        return m[b.trim()] = v.trim(), m;
      }, {});
      return p ? {
        name: f,
        members: p
      } : null;
    }).filter(({ name: h }) => u.some((f) => f.type === h))) ?? [];
    return {
      groups: u,
      structs: l
    };
  }
  var mi = ((i) => (i[i.VERTEX = 1] = "VERTEX", i[i.FRAGMENT = 2] = "FRAGMENT", i[i.COMPUTE = 4] = "COMPUTE", i))(mi || {});
  function I_({ groups: i }) {
    const t = [];
    for (let e = 0; e < i.length; e++) {
      const r = i[e];
      t[r.group] || (t[r.group] = []), r.isUniform ? t[r.group].push({
        binding: r.binding,
        visibility: mi.VERTEX | mi.FRAGMENT,
        buffer: {
          type: "uniform"
        }
      }) : r.type === "sampler" ? t[r.group].push({
        binding: r.binding,
        visibility: mi.FRAGMENT,
        sampler: {
          type: "filtering"
        }
      }) : r.type === "texture_2d" && t[r.group].push({
        binding: r.binding,
        visibility: mi.FRAGMENT,
        texture: {
          sampleType: "float",
          viewDimension: "2d",
          multisampled: false
        }
      });
    }
    return t;
  }
  function F_({ groups: i }) {
    const t = [];
    for (let e = 0; e < i.length; e++) {
      const r = i[e];
      t[r.group] || (t[r.group] = {}), t[r.group][r.name] = r.binding;
    }
    return t;
  }
  function U_(i, t) {
    const e = /* @__PURE__ */ new Set(), r = /* @__PURE__ */ new Set(), n = [
      ...i.structs,
      ...t.structs
    ].filter((o) => e.has(o.name) ? false : (e.add(o.name), true)), s = [
      ...i.groups,
      ...t.groups
    ].filter((o) => {
      const a = `${o.name}-${o.binding}`;
      return r.has(a) ? false : (r.add(a), true);
    });
    return {
      structs: n,
      groups: s
    };
  }
  const Ls = /* @__PURE__ */ Object.create(null);
  class Ne {
    constructor(t) {
      var _a2, _b2;
      this._layoutKey = 0;
      const { fragment: e, vertex: r, layout: n, gpuLayout: s, name: o } = t;
      if (this.name = o, this.fragment = e, this.vertex = r, e.source === r.source) {
        const a = Ns(e.source);
        this.structsAndGroups = a;
      } else {
        const a = Ns(r.source), c = Ns(e.source);
        this.structsAndGroups = U_(a, c);
      }
      this.layout = n ?? F_(this.structsAndGroups), this.gpuLayout = s ?? I_(this.structsAndGroups), this.autoAssignGlobalUniforms = ((_a2 = this.layout[0]) == null ? void 0 : _a2.globalUniforms) !== void 0, this.autoAssignLocalUniforms = ((_b2 = this.layout[1]) == null ? void 0 : _b2.localUniforms) !== void 0, this._generateProgramKey();
    }
    _generateProgramKey() {
      const { vertex: t, fragment: e } = this, r = t.source + e.source + t.entryPoint + e.entryPoint;
      this._layoutKey = qn(r, "program");
    }
    get attributeData() {
      return this._attributeData ?? (this._attributeData = D_(this.vertex)), this._attributeData;
    }
    destroy() {
      this.gpuLayout = null, this.layout = null, this.structsAndGroups = null, this.fragment = null, this.vertex = null;
    }
    static from(t) {
      const e = `${t.vertex.source}:${t.fragment.source}:${t.fragment.entryPoint}:${t.vertex.entryPoint}`;
      return Ls[e] || (Ls[e] = new Ne(t)), Ls[e];
    }
  }
  const ih = [
    "f32",
    "i32",
    "vec2<f32>",
    "vec3<f32>",
    "vec4<f32>",
    "mat2x2<f32>",
    "mat3x3<f32>",
    "mat4x4<f32>",
    "mat3x2<f32>",
    "mat4x2<f32>",
    "mat2x3<f32>",
    "mat4x3<f32>",
    "mat2x4<f32>",
    "mat3x4<f32>"
  ], k_ = ih.reduce((i, t) => (i[t] = true, i), {});
  function G_(i, t) {
    switch (i) {
      case "f32":
        return 0;
      case "vec2<f32>":
        return new Float32Array(2 * t);
      case "vec3<f32>":
        return new Float32Array(3 * t);
      case "vec4<f32>":
        return new Float32Array(4 * t);
      case "mat2x2<f32>":
        return new Float32Array([
          1,
          0,
          0,
          1
        ]);
      case "mat3x3<f32>":
        return new Float32Array([
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1
        ]);
      case "mat4x4<f32>":
        return new Float32Array([
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1
        ]);
    }
    return null;
  }
  const nh = class sh {
    constructor(t, e) {
      this._touched = 0, this.uid = Ot("uniform"), this._resourceType = "uniformGroup", this._resourceId = Ot("resource"), this.isUniformGroup = true, this._dirtyId = 0, this.destroyed = false, e = {
        ...sh.defaultOptions,
        ...e
      }, this.uniformStructures = t;
      const r = {};
      for (const n in t) {
        const s = t[n];
        if (s.name = n, s.size = s.size ?? 1, !k_[s.type]) throw new Error(`Uniform type ${s.type} is not supported. Supported uniform types are: ${ih.join(", ")}`);
        s.value ?? (s.value = G_(s.type, s.size)), r[n] = s.value;
      }
      this.uniforms = r, this._dirtyId = 1, this.ubo = e.ubo, this.isStatic = e.isStatic, this._signature = qn(Object.keys(r).map((n) => `${n}-${t[n].type}`).join("-"), "uniform-group");
    }
    update() {
      this._dirtyId++;
    }
  };
  nh.defaultOptions = {
    ubo: false,
    isStatic: false
  };
  let Qt = nh;
  class Ze {
    constructor(t) {
      this.resources = /* @__PURE__ */ Object.create(null), this._dirty = true;
      let e = 0;
      for (const r in t) {
        const n = t[r];
        this.setResource(n, e++);
      }
      this._updateKey();
    }
    _updateKey() {
      if (!this._dirty) return;
      this._dirty = false;
      const t = [];
      let e = 0;
      for (const r in this.resources) t[e++] = this.resources[r]._resourceId;
      this._key = t.join("|");
    }
    setResource(t, e) {
      var _a2, _b2;
      const r = this.resources[e];
      t !== r && (r && ((_a2 = t.off) == null ? void 0 : _a2.call(t, "change", this.onResourceChange, this)), (_b2 = t.on) == null ? void 0 : _b2.call(t, "change", this.onResourceChange, this), this.resources[e] = t, this._dirty = true);
    }
    getResource(t) {
      return this.resources[t];
    }
    _touch(t) {
      const e = this.resources;
      for (const r in e) e[r]._touched = t;
    }
    destroy() {
      var _a2, _b2;
      const t = this.resources;
      for (const e in t) (_b2 = (_a2 = t[e]).off) == null ? void 0 : _b2.call(_a2, "change", this.onResourceChange, this);
      this.resources = null;
    }
    onResourceChange(t) {
      if (this._dirty = true, t.destroyed) {
        const e = this.resources;
        for (const r in e) e[r] === t && (e[r] = null);
      } else this._updateKey();
    }
  }
  var ge = ((i) => (i[i.WEBGL = 1] = "WEBGL", i[i.WEBGPU = 2] = "WEBGPU", i[i.BOTH = 3] = "BOTH", i))(ge || {});
  class Se extends me {
    constructor(t) {
      super(), this._uniformBindMap = /* @__PURE__ */ Object.create(null), this._ownedBindGroups = [];
      let { gpuProgram: e, glProgram: r, groups: n, resources: s, compatibleRenderers: o, groupMap: a } = t;
      this.gpuProgram = e, this.glProgram = r, o === void 0 && (o = 0, e && (o |= ge.WEBGPU), r && (o |= ge.WEBGL)), this.compatibleRenderers = o;
      const c = {};
      if (!s && !n && (s = {}), s && n) throw new Error("[Shader] Cannot have both resources and groups");
      if (!e && n && !a) throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");
      if (!e && n && a) for (const u in a) for (const l in a[u]) {
        const h = a[u][l];
        c[h] = {
          group: u,
          binding: l,
          name: h
        };
      }
      else if (e && n && !a) {
        const u = e.structsAndGroups.groups;
        a = {}, u.forEach((l) => {
          a[l.group] = a[l.group] || {}, a[l.group][l.binding] = l.name, c[l.name] = l;
        });
      } else if (s) {
        n = {}, a = {}, e && e.structsAndGroups.groups.forEach((h) => {
          a[h.group] = a[h.group] || {}, a[h.group][h.binding] = h.name, c[h.name] = h;
        });
        let u = 0;
        for (const l in s) c[l] || (n[99] || (n[99] = new Ze(), this._ownedBindGroups.push(n[99])), c[l] = {
          group: 99,
          binding: u,
          name: l
        }, a[99] = a[99] || {}, a[99][u] = l, u++);
        for (const l in s) {
          const h = l;
          let f = s[l];
          !f.source && !f._resourceType && (f = new Qt(f));
          const p = c[h];
          p && (n[p.group] || (n[p.group] = new Ze(), this._ownedBindGroups.push(n[p.group])), n[p.group].setResource(f, p.binding));
        }
      }
      this.groups = n, this._uniformBindMap = a, this.resources = this._buildResourceAccessor(n, c);
    }
    addResource(t, e, r) {
      var n, s;
      (n = this._uniformBindMap)[e] || (n[e] = {}), (s = this._uniformBindMap[e])[r] || (s[r] = t), this.groups[e] || (this.groups[e] = new Ze(), this._ownedBindGroups.push(this.groups[e]));
    }
    _buildResourceAccessor(t, e) {
      const r = {};
      for (const n in e) {
        const s = e[n];
        Object.defineProperty(r, s.name, {
          get() {
            return t[s.group].getResource(s.binding);
          },
          set(o) {
            t[s.group].setResource(o, s.binding);
          }
        });
      }
      return r;
    }
    destroy(t = false) {
      var _a2, _b2;
      this.emit("destroy", this), t && ((_a2 = this.gpuProgram) == null ? void 0 : _a2.destroy(), (_b2 = this.glProgram) == null ? void 0 : _b2.destroy()), this.gpuProgram = null, this.glProgram = null, this.removeAllListeners(), this._uniformBindMap = null, this._ownedBindGroups.forEach((e) => {
        e.destroy();
      }), this._ownedBindGroups = null, this.resources = null, this.groups = null;
    }
    static from(t) {
      const { gpu: e, gl: r, ...n } = t;
      let s, o;
      return e && (s = Ne.from(e)), r && (o = rr.from(r)), new Se({
        gpuProgram: s,
        glProgram: o,
        ...n
      });
    }
  }
  const O_ = {
    normal: 0,
    add: 1,
    multiply: 2,
    screen: 3,
    overlay: 4,
    erase: 5,
    "normal-npm": 6,
    "add-npm": 7,
    "screen-npm": 8
  }, Hs = 0, zs = 1, js = 2, Ws = 3, Vs = 4, Xs = 5, Eo = class oh {
    constructor() {
      this.data = 0, this.blendMode = "normal", this.polygonOffset = 0, this.blend = true, this.depthMask = true;
    }
    get blend() {
      return !!(this.data & 1 << Hs);
    }
    set blend(t) {
      !!(this.data & 1 << Hs) !== t && (this.data ^= 1 << Hs);
    }
    get offsets() {
      return !!(this.data & 1 << zs);
    }
    set offsets(t) {
      !!(this.data & 1 << zs) !== t && (this.data ^= 1 << zs);
    }
    set cullMode(t) {
      if (t === "none") {
        this.culling = false;
        return;
      }
      this.culling = true, this.clockwiseFrontFace = t === "front";
    }
    get cullMode() {
      return this.culling ? this.clockwiseFrontFace ? "front" : "back" : "none";
    }
    get culling() {
      return !!(this.data & 1 << js);
    }
    set culling(t) {
      !!(this.data & 1 << js) !== t && (this.data ^= 1 << js);
    }
    get depthTest() {
      return !!(this.data & 1 << Ws);
    }
    set depthTest(t) {
      !!(this.data & 1 << Ws) !== t && (this.data ^= 1 << Ws);
    }
    get depthMask() {
      return !!(this.data & 1 << Xs);
    }
    set depthMask(t) {
      !!(this.data & 1 << Xs) !== t && (this.data ^= 1 << Xs);
    }
    get clockwiseFrontFace() {
      return !!(this.data & 1 << Vs);
    }
    set clockwiseFrontFace(t) {
      !!(this.data & 1 << Vs) !== t && (this.data ^= 1 << Vs);
    }
    get blendMode() {
      return this._blendMode;
    }
    set blendMode(t) {
      this.blend = t !== "none", this._blendMode = t, this._blendModeId = O_[t] || 0;
    }
    get polygonOffset() {
      return this._polygonOffset;
    }
    set polygonOffset(t) {
      this.offsets = !!t, this._polygonOffset = t;
    }
    toString() {
      return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;
    }
    static for2d() {
      const t = new oh();
      return t.depthTest = false, t.blend = true, t;
    }
  };
  Eo.default2d = Eo.for2d();
  let Le = Eo;
  const ah = class Ao extends Se {
    constructor(t) {
      t = {
        ...Ao.defaultOptions,
        ...t
      }, super(t), this.enabled = true, this._state = Le.for2d(), this.blendMode = t.blendMode, this.padding = t.padding, typeof t.antialias == "boolean" ? this.antialias = t.antialias ? "on" : "off" : this.antialias = t.antialias, this.resolution = t.resolution, this.blendRequired = t.blendRequired, this.addResource("uTexture", 0, 1);
    }
    apply(t, e, r, n) {
      t.applyFilter(this, e, r, n);
    }
    get blendMode() {
      return this._state.blendMode;
    }
    set blendMode(t) {
      this._state.blendMode = t;
    }
    static from(t) {
      const { gpu: e, gl: r, ...n } = t;
      let s, o;
      return e && (s = Ne.from(e)), r && (o = rr.from(r)), new Ao({
        gpuProgram: s,
        glProgram: o,
        ...n
      });
    }
  };
  ah.defaultOptions = {
    blendMode: "normal",
    resolution: 1,
    padding: 0,
    antialias: "off",
    blendRequired: false
  };
  let ei = ah;
  var N_ = `
in vec2 vTextureCoord;
in vec4 vColor;

out vec4 finalColor;

uniform float uBlend;

uniform sampler2D uTexture;
uniform sampler2D uBackTexture;

{FUNCTIONS}

void main()
{ 
    vec4 back = texture(uBackTexture, vTextureCoord);
    vec4 front = texture(uTexture, vTextureCoord);

    {MAIN}
}
`, L_ = `in vec2 aPosition;
out vec2 vTextureCoord;
out vec2 backgroundUv;

uniform vec4 uInputSize;
uniform vec4 uOutputFrame;
uniform vec4 uOutputTexture;

vec4 filterVertexPosition( void )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
    
    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aPosition * (uOutputFrame.zw * uInputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`, H_ = `
struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

struct BlendUniforms {
  uBlend:f32,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler : sampler;
@group(0) @binding(3) var uBackTexture: texture_2d<f32>;

@group(1) @binding(0) var<uniform> blendUniforms : BlendUniforms;


struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>
  };

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  
}
  
@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>, 
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition)
  );
}

{FUNCTIONS}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>
) -> @location(0) vec4<f32> {


   var back =  textureSample(uBackTexture, uSampler, uv);
   var front = textureSample(uTexture, uSampler, uv);
   
   var out = vec4<f32>(0.0,0.0,0.0,0.0);

   {MAIN}

   return out;
}`;
  class zt extends ei {
    constructor(t) {
      const e = t.gpu, r = Dc({
        source: H_,
        ...e
      }), n = Ne.from({
        vertex: {
          source: r,
          entryPoint: "mainVertex"
        },
        fragment: {
          source: r,
          entryPoint: "mainFragment"
        }
      }), s = t.gl, o = Dc({
        source: N_,
        ...s
      }), a = rr.from({
        vertex: L_,
        fragment: o
      }), c = new Qt({
        uBlend: {
          value: 1,
          type: "f32"
        }
      });
      super({
        gpuProgram: n,
        glProgram: a,
        blendRequired: true,
        resources: {
          blendUniforms: c,
          uBackTexture: J.EMPTY
        }
      });
    }
  }
  function Dc(i) {
    const { source: t, functions: e, main: r } = i;
    return t.replace("{FUNCTIONS}", e).replace("{MAIN}", r);
  }
  const ea = `
	float getLuminosity(vec3 c) {
		return 0.3 * c.r + 0.59 * c.g + 0.11 * c.b;
	}

	vec3 setLuminosity(vec3 c, float lum) {
		float modLum = lum - getLuminosity(c);
		vec3 color = c.rgb + vec3(modLum);

		// clip back into legal range
		modLum = getLuminosity(color);
		vec3 modLumVec = vec3(modLum);

		float cMin = min(color.r, min(color.g, color.b));
		float cMax = max(color.r, max(color.g, color.b));

		if(cMin < 0.0) {
			color = mix(modLumVec, color, modLum / (modLum - cMin));
		}

		if(cMax > 1.0) {
			color = mix(modLumVec, color, (1.0 - modLum) / (cMax - modLum));
		}

		return color;
	}

	float getSaturation(vec3 c) {
		return max(c.r, max(c.g, c.b)) - min(c.r, min(c.g, c.b));
	}

	vec3 setSaturationMinMidMax(vec3 cSorted, float s) {
		vec3 colorSorted = cSorted;

		if(colorSorted.z > colorSorted.x) {
			colorSorted.y = (((colorSorted.y - colorSorted.x) * s) / (colorSorted.z - colorSorted.x));
			colorSorted.z = s;
		}
		else {
			colorSorted.y = 0.0;
			colorSorted.z = 0.0;
		}

		colorSorted.x = 0.0;

		return colorSorted;
	}

	vec3 setSaturation(vec3 c, float s) {
		vec3 color = c;

		if(color.r <= color.g && color.r <= color.b) {
			if(color.g <= color.b) {
				color = setSaturationMinMidMax(color.rgb, s).rgb;
			}
			else {
				color = setSaturationMinMidMax(color.rbg, s).rbg;
			}
		}
		else if(color.g <= color.r && color.g <= color.b) {
			if(color.r <= color.b) {
				color = setSaturationMinMidMax(color.grb, s).grb;
			}
			else {
				color = setSaturationMinMidMax(color.gbr, s).gbr;
			}
		}
		else {
			// Using bgr for both fixes part of hue
			if(color.r <= color.g) {
				color = setSaturationMinMidMax(color.brg, s).brg;
			}
			else {
				color = setSaturationMinMidMax(color.bgr, s).bgr;
			}
		}

		return color;
	}
    `, ra = `
	fn getLuminosity(c: vec3<f32>) -> f32
	{
		return 0.3*c.r + 0.59*c.g + 0.11*c.b;
	}

	fn setLuminosity(c: vec3<f32>, lum: f32) -> vec3<f32>
	{
		var modLum: f32 = lum - getLuminosity(c);
		var color: vec3<f32> = c.rgb + modLum;

		// clip back into legal range
		modLum = getLuminosity(color);
		let modLumVec = vec3<f32>(modLum);

		let cMin: f32 = min(color.r, min(color.g, color.b));
		let cMax: f32 = max(color.r, max(color.g, color.b));

		if(cMin < 0.0)
		{
			color = mix(modLumVec, color, modLum / (modLum - cMin));
		}

		if(cMax > 1.0)
		{
			color = mix(modLumVec, color, (1 - modLum) / (cMax - modLum));
		}

		return color;
	}

	fn getSaturation(c: vec3<f32>) -> f32
	{
		return max(c.r, max(c.g, c.b)) - min(c.r, min(c.g, c.b));
	}

	fn setSaturationMinMidMax(cSorted: vec3<f32>, s: f32) -> vec3<f32>
	{
		var colorSorted = cSorted;

		if(colorSorted.z > colorSorted.x)
		{
			colorSorted.y = (((colorSorted.y - colorSorted.x) * s) / (colorSorted.z - colorSorted.x));
			colorSorted.z = s;
		}
		else
		{
			colorSorted.y = 0;
			colorSorted.z = 0;
		}

		colorSorted.x = 0;

		return colorSorted;
	}

	fn setSaturation(c: vec3<f32>, s: f32) -> vec3<f32>
	{
		var color = c;

		if (color.r <= color.g && color.r <= color.b)
		{
			if (color.g <= color.b)
			{
				color = vec3<f32>(setSaturationMinMidMax(color.rgb, s)).rgb;
			}
			else
			{
				color = vec3<f32>(setSaturationMinMidMax(color.rbg, s)).rbg;
			}
		}
		else if (color.g <= color.r && color.g <= color.b)
		{
			if (color.r <= color.b)
			{
				color = vec3<f32>(setSaturationMinMidMax(color.grb, s)).grb;
			}
			else
			{
				color = vec3<f32>(setSaturationMinMidMax(color.gbr, s)).gbr;
			}
		}
		else
		{
			// Using bgr for both fixes part of hue
			if (color.r <= color.g)
			{
				color = vec3<f32>(setSaturationMinMidMax(color.brg, s)).brg;
			}
			else
			{
				color  = vec3<f32>(setSaturationMinMidMax(color.bgr, s)).bgr;
			}
		}

		return color;
	}
	`;
  class z_ extends zt {
    constructor() {
      super({
        gl: {
          functions: `
                ${ea}

                vec3 blendColor(vec3 base, vec3 blend,  float opacity)
                {
                    return (setLuminosity(blend, getLuminosity(base)) * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                finalColor = vec4(blendColor(back.rgb, front.rgb, front.a), uBlend);
                `
        },
        gpu: {
          functions: `
                ${ra}

                fn blendColorOpacity(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (setLuminosity(blend, getLuminosity(base)) * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                out = vec4<f32>(blendColorOpacity(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
        }
      });
    }
  }
  z_.extension = {
    name: "color",
    type: P.BlendMode
  };
  class j_ extends zt {
    constructor() {
      super({
        gl: {
          functions: `
                float colorBurn(float base, float blend)
                {
                    return max((1.0 - ((1.0 - base) / blend)), 0.0);
                }

                vec3 blendColorBurn(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        colorBurn(base.r, blend.r),
                        colorBurn(base.g, blend.g),
                        colorBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                finalColor = vec4(blendColorBurn(back.rgb, front.rgb, front.a), uBlend);
            `
        },
        gpu: {
          functions: `
                fn colorBurn(base:f32, blend:f32) -> f32
                {
                    return max((1.0-((1.0-base)/blend)),0.0);
                }

                fn blendColorBurn(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        colorBurn(base.r, blend.r),
                        colorBurn(base.g, blend.g),
                        colorBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                out = vec4<f32>(blendColorBurn(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
        }
      });
    }
  }
  j_.extension = {
    name: "color-burn",
    type: P.BlendMode
  };
  class W_ extends zt {
    constructor() {
      super({
        gl: {
          functions: `
                float colorDodge(float base, float blend)
                {
                    return base / (1.0 - blend);
                }

                vec3 blendColorDodge(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        colorDodge(base.r, blend.r),
                        colorDodge(base.g, blend.g),
                        colorDodge(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                finalColor = vec4(blendColorDodge(back.rgb, front.rgb, front.a), uBlend);
                `
        },
        gpu: {
          functions: `
                fn colorDodge(base: f32, blend: f32) -> f32
                {
                    return base / (1.0 - blend);
                }

                fn blendColorDodge(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        colorDodge(base.r, blend.r),
                        colorDodge(base.g, blend.g),
                        colorDodge(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                    out = vec4<f32>(blendColorDodge(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
        }
      });
    }
  }
  W_.extension = {
    name: "color-dodge",
    type: P.BlendMode
  };
  class V_ extends zt {
    constructor() {
      super({
        gl: {
          functions: `
                vec3 blendDarken(vec3 base, vec3 blend, float opacity)
                {
                    return (min(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                finalColor = vec4(blendDarken(back.rgb, front.rgb, front.a), uBlend);
                `
        },
        gpu: {
          functions: `
                fn blendDarken(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (min(blend,base) * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                out = vec4<f32>(blendDarken(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
        }
      });
    }
  }
  V_.extension = {
    name: "darken",
    type: P.BlendMode
  };
  class X_ extends zt {
    constructor() {
      super({
        gl: {
          functions: `
                vec3 blendDifference(vec3 base, vec3 blend,  float opacity)
                {
                    return (abs(blend - base) * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                finalColor = vec4(blendDifference(back.rgb, front.rgb, front.a), uBlend);
            `
        },
        gpu: {
          functions: `
                fn blendDifference(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (abs(blend - base) * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                out = vec4<f32>(blendDifference(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
        }
      });
    }
  }
  X_.extension = {
    name: "difference",
    type: P.BlendMode
  };
  class q_ extends zt {
    constructor() {
      super({
        gl: {
          functions: `
                float divide(float base, float blend)
                {
                    return (blend > 0.0) ? clamp(base / blend, 0.0, 1.0) : 1.0;
                }

                vec3 blendDivide(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        divide(base.r, blend.r),
                        divide(base.g, blend.g),
                        divide(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                finalColor = vec4(blendDivide(back.rgb, front.rgb, front.a), uBlend);
                `
        },
        gpu: {
          functions: `
                fn divide(base: f32, blend: f32) -> f32
                {
                    return select(1.0, clamp(base / blend, 0.0, 1.0), blend > 0.0);
                }

                fn blendDivide(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        divide(base.r, blend.r),
                        divide(base.g, blend.g),
                        divide(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                out = vec4<f32>(blendDivide(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
        }
      });
    }
  }
  q_.extension = {
    name: "divide",
    type: P.BlendMode
  };
  class $_ extends zt {
    constructor() {
      super({
        gl: {
          functions: `
                vec3 exclusion(vec3 base, vec3 blend)
                {
                    return base + blend - 2.0 * base * blend;
                }

                vec3 blendExclusion(vec3 base, vec3 blend, float opacity)
                {
                    return (exclusion(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                finalColor = vec4(blendExclusion(back.rgb, front.rgb, front.a), uBlend);
                `
        },
        gpu: {
          functions: `
                fn exclusion(base: vec3<f32>, blend: vec3<f32>) -> vec3<f32>
                {
                    return base+blend-2.0*base*blend;
                }

                fn blendExclusion(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    return (exclusion(base, blend) * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                out = vec4<f32>(blendExclusion(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
        }
      });
    }
  }
  $_.extension = {
    name: "exclusion",
    type: P.BlendMode
  };
  class Y_ extends zt {
    constructor() {
      super({
        gl: {
          functions: `
                float hardLight(float base, float blend)
                {
                    return (blend < 0.5) ? 2.0 * base * blend : 1.0 - 2.0 * (1.0 - base) * (1.0 - blend);
                }

                vec3 blendHardLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        hardLight(base.r, blend.r),
                        hardLight(base.g, blend.g),
                        hardLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                finalColor = vec4(blendHardLight(back.rgb, front.rgb, front.a), uBlend);
            `
        },
        gpu: {
          functions: `
                fn hardLight(base: f32, blend: f32) -> f32
                {
                    return select(1.0 - 2.0 * (1.0 - base) * (1.0 - blend), 2.0 * base * blend, blend < 0.5);
                }

                fn blendHardLight(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        hardLight(base.r, blend.r),
                        hardLight(base.g, blend.g),
                        hardLight(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                out = vec4<f32>(blendHardLight(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
        }
      });
    }
  }
  Y_.extension = {
    name: "hard-light",
    type: P.BlendMode
  };
  class K_ extends zt {
    constructor() {
      super({
        gl: {
          functions: `
                float hardMix(float base, float blend)
                {
                    return (base + blend >= 1.0) ? 1.0 : 0.0;
                }

                vec3 blendHardMix(vec3 base, vec3 blend,  float opacity)
                {
                    vec3 blended = vec3(
                        hardMix(base.r, blend.r),
                        hardMix(base.g, blend.g),
                        hardMix(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                finalColor = vec4(blendHardMix(back.rgb, front.rgb, front.a), uBlend);
            `
        },
        gpu: {
          functions: `
                fn hardMix(base: f32, blend: f32) -> f32
                {
                    return select(0.0, 1.0, base + blend >= 1.0);
                }

                fn blendHardMix(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended: vec3<f32> = vec3<f32>(
                        hardMix(base.r, blend.r),
                        hardMix(base.g, blend.g),
                        hardMix(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                out = vec4<f32>(blendHardMix(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
        }
      });
    }
  }
  K_.extension = {
    name: "hard-mix",
    type: P.BlendMode
  };
  class Z_ extends zt {
    constructor() {
      super({
        gl: {
          functions: `
                vec3 blendLighten(vec3 base, vec3 blend, float opacity)
                {
                    return (max(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                finalColor = vec4(blendLighten(back.rgb, front.rgb, front.a), uBlend);
                `
        },
        gpu: {
          functions: `
                fn blendLighten(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (max(base, blend) * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                out = vec4<f32>(blendLighten(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
        }
      });
    }
  }
  Z_.extension = {
    name: "lighten",
    type: P.BlendMode
  };
  class J_ extends zt {
    constructor() {
      super({
        gl: {
          functions: `
                float linearBurn(float base, float blend)
                {
                    return max(0.0, base + blend - 1.0);
                }

                vec3 blendLinearBurn(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        linearBurn(base.r, blend.r),
                        linearBurn(base.g, blend.g),
                        linearBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                finalColor = vec4(blendLinearBurn(back.rgb, front.rgb, front.a), uBlend);
                `
        },
        gpu: {
          functions: `
                fn linearBurn(base: f32, blend: f32) -> f32
                {
                    return max(0.0, base + blend - 1.0);
                }

                fn blendLinearBurn(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        linearBurn(base.r, blend.r),
                        linearBurn(base.g, blend.g),
                        linearBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                out = vec4<f32>(blendLinearBurn(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
        }
      });
    }
  }
  J_.extension = {
    name: "linear-burn",
    type: P.BlendMode
  };
  class Q_ extends zt {
    constructor() {
      super({
        gl: {
          functions: `
                float linearDodge(float base, float blend) {
                    return min(1.0, base + blend);
                }

                vec3 blendLinearDodge(vec3 base, vec3 blend, float opacity) {
                    vec3 blended = vec3(
                        linearDodge(base.r, blend.r),
                        linearDodge(base.g, blend.g),
                        linearDodge(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                finalColor = vec4(blendLinearDodge(back.rgb, front.rgb, front.a), uBlend);
                `
        },
        gpu: {
          functions: `
                fn linearDodge(base: f32, blend: f32) -> f32
                {
                    return min(1, base + blend);
                }

                fn blendLinearDodge(base:vec3<f32>, blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        linearDodge(base.r, blend.r),
                        linearDodge(base.g, blend.g),
                        linearDodge(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                out = vec4<f32>(blendLinearDodge(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
        }
      });
    }
  }
  Q_.extension = {
    name: "linear-dodge",
    type: P.BlendMode
  };
  class tg extends zt {
    constructor() {
      super({
        gl: {
          functions: `
                float linearBurn(float base, float blend) {
                    return max(0.0, base + blend - 1.0);
                }

                float linearDodge(float base, float blend) {
                    return min(1.0, base + blend);
                }

                float linearLight(float base, float blend) {
                    return (blend <= 0.5) ? linearBurn(base,2.0*blend) : linearBurn(base,2.0*(blend-0.5));
                }

                vec3 blendLinearLight(vec3 base, vec3 blend, float opacity) {
                    vec3 blended = vec3(
                        linearLight(base.r, blend.r),
                        linearLight(base.g, blend.g),
                        linearLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                finalColor = vec4(blendLinearLight(back.rgb, front.rgb, front.a), uBlend);
                `
        },
        gpu: {
          functions: `
                fn linearBurn(base: f32, blend: f32) -> f32
                {
                    return max(0.0, base + blend - 1.0);
                }

                fn linearDodge(base: f32, blend: f32) -> f32
                {
                    return min(1.0, base + blend);
                }

                fn linearLight(base: f32, blend: f32) -> f32
                {
                    return select(linearBurn(base,2.0*(blend-0.5)), linearBurn(base,2.0*blend), blend <= 0.5);
                }

                fn blendLinearLightOpacity(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        linearLight(base.r, blend.r),
                        linearLight(base.g, blend.g),
                        linearLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                out = vec4<f32>(blendLinearLightOpacity(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
        }
      });
    }
  }
  tg.extension = {
    name: "linear-light",
    type: P.BlendMode
  };
  class eg extends zt {
    constructor() {
      super({
        gl: {
          functions: `
                ${ea}

                vec3 blendLuminosity(vec3 base, vec3 blend,  float opacity)
                {
                    vec3 blendLuminosity = setLuminosity(base, getLuminosity(blend));
                    return (blendLuminosity * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                finalColor = vec4(blendLuminosity(back.rgb, front.rgb, front.a), uBlend);
                `
        },
        gpu: {
          functions: `
                ${ra}

                fn blendLuminosity(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blendLuminosity: vec3<f32> = setLuminosity(base, getLuminosity(blend));
                    return (blendLuminosity * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                out = vec4<f32>(blendLuminosity(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
        }
      });
    }
  }
  eg.extension = {
    name: "luminosity",
    type: P.BlendMode
  };
  class rg extends zt {
    constructor() {
      super({
        gl: {
          functions: `
                vec3 negation(vec3 base, vec3 blend)
                {
                    return 1.0-abs(1.0-base-blend);
                }

                vec3 blendNegation(vec3 base, vec3 blend, float opacity)
                {
                    return (negation(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                finalColor = vec4(blendNegation(back.rgb, front.rgb, front.a), uBlend);
                `
        },
        gpu: {
          functions: `
                fn blendNegation(base: vec3<f32>, blend: vec3<f32>) -> vec3<f32>
                {
                    return 1.0-abs(1.0-base-blend);
                }

                fn blendNegationOpacity(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    return (blendNegation(base, blend) * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                out = vec4<f32>(blendNegationOpacity(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
        }
      });
    }
  }
  rg.extension = {
    name: "negation",
    type: P.BlendMode
  };
  class ig extends zt {
    constructor() {
      super({
        gl: {
          functions: `
                float overlay(float base, float blend)
                {
                    return (base < 0.5) ? (2.0*base*blend) : (1.0-2.0*(1.0-base)*(1.0-blend));
                }

                vec3 blendOverlay(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        overlay(base.r, blend.r),
                        overlay(base.g, blend.g),
                        overlay(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                finalColor = vec4(blendOverlay(back.rgb, front.rgb, front.a), uBlend);
                `
        },
        gpu: {
          functions: `
                fn overlay(base: f32, blend: f32) -> f32
                {
                    return select((1.0-2.0*(1.0-base)*(1.0-blend)), (2.0*base*blend), base < 0.5);
                }

                fn blendOverlay(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        overlay(base.r, blend.r),
                        overlay(base.g, blend.g),
                        overlay(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                out = vec4<f32>(blendOverlay(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
        }
      });
    }
  }
  ig.extension = {
    name: "overlay",
    type: P.BlendMode
  };
  class ng extends zt {
    constructor() {
      super({
        gl: {
          functions: `
                float pinLight(float base, float blend)
                {
                    return (blend <= 0.5) ? min(base, 2.0 * blend) : max(base, 2.0 * (blend - 0.5));
                }

                vec3 blendPinLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        pinLight(base.r, blend.r),
                        pinLight(base.g, blend.g),
                        pinLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                finalColor = vec4(blendPinLight(back.rgb, front.rgb, front.a), uBlend);
                `
        },
        gpu: {
          functions: `
                fn pinLight(base: f32, blend: f32) -> f32
                {
                    return select(max(base,2.0*(blend-0.5)), min(base,2.0*blend), blend <= 0.5);
                }

                fn blendPinLight(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        pinLight(base.r, blend.r),
                        pinLight(base.g, blend.g),
                        pinLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                out = vec4<f32>(blendPinLight(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
        }
      });
    }
  }
  ng.extension = {
    name: "pin-light",
    type: P.BlendMode
  };
  class sg extends zt {
    constructor() {
      super({
        gl: {
          functions: `
                ${ea}

                vec3 blendSaturation(vec3 base, vec3 blend,  float opacity)
                {
                    vec3 blendSaturation = setLuminosity(setSaturation(base, getSaturation(blend)), getLuminosity(base));
                    return (blendSaturation * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                finalColor = vec4(blendSaturation(back.rgb, front.rgb, front.a), uBlend);
            `
        },
        gpu: {
          functions: `
                ${ra}

                fn blendSaturation(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blendSaturation = setLuminosity(setSaturation(base, getSaturation(blend)), getLuminosity(base));
                    return (blendSaturation * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                out = vec4<f32>(blendSaturation(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
        }
      });
    }
  }
  sg.extension = {
    name: "saturation",
    type: P.BlendMode
  };
  class og extends zt {
    constructor() {
      super({
        gl: {
          functions: `
                float softLight(float base, float blend)
                {
                    return (blend < 0.5) ? (2.0 * base * blend + base * base * (1.0 - 2.0 * blend)) : (sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend));
                }

                vec3 blendSoftLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        softLight(base.r, blend.r),
                        softLight(base.g, blend.g),
                        softLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                finalColor = vec4(blendSoftLight(back.rgb, front.rgb, front.a), uBlend);
                `
        },
        gpu: {
          functions: `
                fn softLight(base: f32, blend: f32) -> f32
                {
                    return select(2.0 * base * blend + base * base * (1.0 - 2.0 * blend), sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend), blend < 0.5);
                }

                fn blendSoftLight(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended: vec3<f32> = vec3<f32>(
                        softLight(base.r, blend.r),
                        softLight(base.g, blend.g),
                        softLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                out = vec4<f32>(blendSoftLight(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
        }
      });
    }
  }
  og.extension = {
    name: "soft-light",
    type: P.BlendMode
  };
  class ag extends zt {
    constructor() {
      super({
        gl: {
          functions: `
                float subtract(float base, float blend)
                {
                    return max(0.0, base - blend);
                }

                vec3 blendSubtract(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        subtract(base.r, blend.r),
                        subtract(base.g, blend.g),
                        subtract(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                finalColor = vec4(blendSubtract(back.rgb, front.rgb, front.a), uBlend);
                `
        },
        gpu: {
          functions: `
                fn subtract(base: f32, blend: f32) -> f32
                {
                    return max(0, base - blend);
                }

                fn blendSubtract(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        subtract(base.r, blend.r),
                        subtract(base.g, blend.g),
                        subtract(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                out = vec4<f32>(blendSubtract(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
        }
      });
    }
  }
  ag.extension = {
    name: "subtract",
    type: P.BlendMode
  };
  class cg extends zt {
    constructor() {
      super({
        gl: {
          functions: `
                float colorBurn(float base, float blend)
                {
                    return max((1.0-((1.0-base)/blend)),0.0);
                }

                float colorDodge(float base, float blend)
                {
                    return min(1.0, base / (1.0-blend));
                }

                float vividLight(float base, float blend)
                {
                    return (blend < 0.5) ? colorBurn(base,(2.0*blend)) : colorDodge(base,(2.0*(blend-0.5)));
                }

                vec3 blendVividLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        vividLight(base.r, blend.r),
                        vividLight(base.g, blend.g),
                        vividLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                finalColor = vec4(blendVividLight(back.rgb, front.rgb, front.a), uBlend);
            `
        },
        gpu: {
          functions: `
                fn colorBurn(base:f32, blend:f32) -> f32
                {
                    return max((1.0-((1.0-base)/blend)),0.0);
                }

                fn colorDodge(base: f32, blend: f32) -> f32
                {
                    return min(1.0, base / (1.0-blend));
                }

                fn vividLight(base: f32, blend: f32) -> f32
                {
                    return select(colorDodge(base,(2.0*(blend-0.5))), colorBurn(base,(2.0*blend)), blend<0.5);
                }

                fn blendVividLight(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended: vec3<f32> = vec3<f32>(
                        vividLight(base.r, blend.r),
                        vividLight(base.g, blend.g),
                        vividLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                out = vec4<f32>(blendVividLight(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
        }
      });
    }
  }
  cg.extension = {
    name: "vivid-light",
    type: P.BlendMode
  };
  const To = [];
  Mt.handleByNamedList(P.Environment, To);
  async function ug(i) {
    if (!i) for (let t = 0; t < To.length; t++) {
      const e = To[t];
      if (e.value.test()) {
        await e.value.load();
        return;
      }
    }
  }
  let oi;
  function ch() {
    if (typeof oi == "boolean") return oi;
    try {
      oi = new Function("param1", "param2", "param3", "return param1[param2] === param3;")({
        a: "b"
      }, "a", "b") === true;
    } catch {
      oi = false;
    }
    return oi;
  }
  var bi = {
    exports: {}
  }, q3 = bi.exports, Ic;
  function lg() {
    if (Ic) return bi.exports;
    Ic = 1, bi.exports = i, bi.exports.default = i;
    function i(x, R, S) {
      S = S || 2;
      var B = R && R.length, D = B ? R[0] * S : x.length, N = t(x, 0, D, S, true), O = [];
      if (!N || N.next === N.prev) return O;
      var q, V, $, ft, pt, it, gt;
      if (B && (N = c(x, R, N, S)), x.length > 80 * S) {
        q = $ = x[0], V = ft = x[1];
        for (var _t = S; _t < D; _t += S) pt = x[_t], it = x[_t + 1], pt < q && (q = pt), it < V && (V = it), pt > $ && ($ = pt), it > ft && (ft = it);
        gt = Math.max($ - q, ft - V), gt = gt !== 0 ? 32767 / gt : 0;
      }
      return r(N, O, S, q, V, gt, 0), O;
    }
    function t(x, R, S, B, D) {
      var N, O;
      if (D === Q(x, R, S, B) > 0) for (N = R; N < S; N += B) O = Z(N, x[N], x[N + 1], O);
      else for (N = S - B; N >= R; N -= B) O = Z(N, x[N], x[N + 1], O);
      return O && G(O, O.next) && (j(O), O = O.next), O;
    }
    function e(x, R) {
      if (!x) return x;
      R || (R = x);
      var S = x, B;
      do
        if (B = false, !S.steiner && (G(S, S.next) || T(S.prev, S, S.next) === 0)) {
          if (j(S), S = R = S.prev, S === S.next) break;
          B = true;
        } else S = S.next;
      while (B || S !== R);
      return R;
    }
    function r(x, R, S, B, D, N, O) {
      if (x) {
        !O && N && p(x, B, D, N);
        for (var q = x, V, $; x.prev !== x.next; ) {
          if (V = x.prev, $ = x.next, N ? s(x, B, D, N) : n(x)) {
            R.push(V.i / S | 0), R.push(x.i / S | 0), R.push($.i / S | 0), j(x), x = $.next, q = $.next;
            continue;
          }
          if (x = $, x === q) {
            O ? O === 1 ? (x = o(e(x), R, S), r(x, R, S, B, D, N, 2)) : O === 2 && a(x, R, S, B, D, N) : r(e(x), R, S, B, D, N, 1);
            break;
          }
        }
      }
    }
    function n(x) {
      var R = x.prev, S = x, B = x.next;
      if (T(R, S, B) >= 0) return false;
      for (var D = R.x, N = S.x, O = B.x, q = R.y, V = S.y, $ = B.y, ft = D < N ? D < O ? D : O : N < O ? N : O, pt = q < V ? q < $ ? q : $ : V < $ ? V : $, it = D > N ? D > O ? D : O : N > O ? N : O, gt = q > V ? q > $ ? q : $ : V > $ ? V : $, _t = B.next; _t !== R; ) {
        if (_t.x >= ft && _t.x <= it && _t.y >= pt && _t.y <= gt && v(D, q, N, V, O, $, _t.x, _t.y) && T(_t.prev, _t, _t.next) >= 0) return false;
        _t = _t.next;
      }
      return true;
    }
    function s(x, R, S, B) {
      var D = x.prev, N = x, O = x.next;
      if (T(D, N, O) >= 0) return false;
      for (var q = D.x, V = N.x, $ = O.x, ft = D.y, pt = N.y, it = O.y, gt = q < V ? q < $ ? q : $ : V < $ ? V : $, _t = ft < pt ? ft < it ? ft : it : pt < it ? pt : it, ne = q > V ? q > $ ? q : $ : V > $ ? V : $, te = ft > pt ? ft > it ? ft : it : pt > it ? pt : it, ht = y(gt, _t, R, S, B), Ut = y(ne, te, R, S, B), st = x.prevZ, tt = x.nextZ; st && st.z >= ht && tt && tt.z <= Ut; ) {
        if (st.x >= gt && st.x <= ne && st.y >= _t && st.y <= te && st !== D && st !== O && v(q, ft, V, pt, $, it, st.x, st.y) && T(st.prev, st, st.next) >= 0 || (st = st.prevZ, tt.x >= gt && tt.x <= ne && tt.y >= _t && tt.y <= te && tt !== D && tt !== O && v(q, ft, V, pt, $, it, tt.x, tt.y) && T(tt.prev, tt, tt.next) >= 0)) return false;
        tt = tt.nextZ;
      }
      for (; st && st.z >= ht; ) {
        if (st.x >= gt && st.x <= ne && st.y >= _t && st.y <= te && st !== D && st !== O && v(q, ft, V, pt, $, it, st.x, st.y) && T(st.prev, st, st.next) >= 0) return false;
        st = st.prevZ;
      }
      for (; tt && tt.z <= Ut; ) {
        if (tt.x >= gt && tt.x <= ne && tt.y >= _t && tt.y <= te && tt !== D && tt !== O && v(q, ft, V, pt, $, it, tt.x, tt.y) && T(tt.prev, tt, tt.next) >= 0) return false;
        tt = tt.nextZ;
      }
      return true;
    }
    function o(x, R, S) {
      var B = x;
      do {
        var D = B.prev, N = B.next.next;
        !G(D, N) && H(D, B, B.next, N) && C(D, N) && C(N, D) && (R.push(D.i / S | 0), R.push(B.i / S | 0), R.push(N.i / S | 0), j(B), j(B.next), B = x = N), B = B.next;
      } while (B !== x);
      return e(B);
    }
    function a(x, R, S, B, D, N) {
      var O = x;
      do {
        for (var q = O.next.next; q !== O.prev; ) {
          if (O.i !== q.i && A(O, q)) {
            var V = z(O, q);
            O = e(O, O.next), V = e(V, V.next), r(O, R, S, B, D, N, 0), r(V, R, S, B, D, N, 0);
            return;
          }
          q = q.next;
        }
        O = O.next;
      } while (O !== x);
    }
    function c(x, R, S, B) {
      var D = [], N, O, q, V, $;
      for (N = 0, O = R.length; N < O; N++) q = R[N] * B, V = N < O - 1 ? R[N + 1] * B : x.length, $ = t(x, q, V, B, false), $ === $.next && ($.steiner = true), D.push(b($));
      for (D.sort(u), N = 0; N < D.length; N++) S = l(D[N], S);
      return S;
    }
    function u(x, R) {
      return x.x - R.x;
    }
    function l(x, R) {
      var S = h(x, R);
      if (!S) return R;
      var B = z(S, x);
      return e(B, B.next), e(S, S.next);
    }
    function h(x, R) {
      var S = R, B = x.x, D = x.y, N = -1 / 0, O;
      do {
        if (D <= S.y && D >= S.next.y && S.next.y !== S.y) {
          var q = S.x + (D - S.y) * (S.next.x - S.x) / (S.next.y - S.y);
          if (q <= B && q > N && (N = q, O = S.x < S.next.x ? S : S.next, q === B)) return O;
        }
        S = S.next;
      } while (S !== R);
      if (!O) return null;
      var V = O, $ = O.x, ft = O.y, pt = 1 / 0, it;
      S = O;
      do
        B >= S.x && S.x >= $ && B !== S.x && v(D < ft ? B : N, D, $, ft, D < ft ? N : B, D, S.x, S.y) && (it = Math.abs(D - S.y) / (B - S.x), C(S, x) && (it < pt || it === pt && (S.x > O.x || S.x === O.x && f(O, S))) && (O = S, pt = it)), S = S.next;
      while (S !== V);
      return O;
    }
    function f(x, R) {
      return T(x.prev, x, R.prev) < 0 && T(R.next, x, x.next) < 0;
    }
    function p(x, R, S, B) {
      var D = x;
      do
        D.z === 0 && (D.z = y(D.x, D.y, R, S, B)), D.prevZ = D.prev, D.nextZ = D.next, D = D.next;
      while (D !== x);
      D.prevZ.nextZ = null, D.prevZ = null, m(D);
    }
    function m(x) {
      var R, S, B, D, N, O, q, V, $ = 1;
      do {
        for (S = x, x = null, N = null, O = 0; S; ) {
          for (O++, B = S, q = 0, R = 0; R < $ && (q++, B = B.nextZ, !!B); R++) ;
          for (V = $; q > 0 || V > 0 && B; ) q !== 0 && (V === 0 || !B || S.z <= B.z) ? (D = S, S = S.nextZ, q--) : (D = B, B = B.nextZ, V--), N ? N.nextZ = D : x = D, D.prevZ = N, N = D;
          S = B;
        }
        N.nextZ = null, $ *= 2;
      } while (O > 1);
      return x;
    }
    function y(x, R, S, B, D) {
      return x = (x - S) * D | 0, R = (R - B) * D | 0, x = (x | x << 8) & 16711935, x = (x | x << 4) & 252645135, x = (x | x << 2) & 858993459, x = (x | x << 1) & 1431655765, R = (R | R << 8) & 16711935, R = (R | R << 4) & 252645135, R = (R | R << 2) & 858993459, R = (R | R << 1) & 1431655765, x | R << 1;
    }
    function b(x) {
      var R = x, S = x;
      do
        (R.x < S.x || R.x === S.x && R.y < S.y) && (S = R), R = R.next;
      while (R !== x);
      return S;
    }
    function v(x, R, S, B, D, N, O, q) {
      return (D - O) * (R - q) >= (x - O) * (N - q) && (x - O) * (B - q) >= (S - O) * (R - q) && (S - O) * (N - q) >= (D - O) * (B - q);
    }
    function A(x, R) {
      return x.next.i !== R.i && x.prev.i !== R.i && !W(x, R) && (C(x, R) && C(R, x) && I(x, R) && (T(x.prev, x, R.prev) || T(x, R.prev, R)) || G(x, R) && T(x.prev, x, x.next) > 0 && T(R.prev, R, R.next) > 0);
    }
    function T(x, R, S) {
      return (R.y - x.y) * (S.x - R.x) - (R.x - x.x) * (S.y - R.y);
    }
    function G(x, R) {
      return x.x === R.x && x.y === R.y;
    }
    function H(x, R, S, B) {
      var D = L(T(x, R, S)), N = L(T(x, R, B)), O = L(T(S, B, x)), q = L(T(S, B, R));
      return !!(D !== N && O !== q || D === 0 && Y(x, S, R) || N === 0 && Y(x, B, R) || O === 0 && Y(S, x, B) || q === 0 && Y(S, R, B));
    }
    function Y(x, R, S) {
      return R.x <= Math.max(x.x, S.x) && R.x >= Math.min(x.x, S.x) && R.y <= Math.max(x.y, S.y) && R.y >= Math.min(x.y, S.y);
    }
    function L(x) {
      return x > 0 ? 1 : x < 0 ? -1 : 0;
    }
    function W(x, R) {
      var S = x;
      do {
        if (S.i !== x.i && S.next.i !== x.i && S.i !== R.i && S.next.i !== R.i && H(S, S.next, x, R)) return true;
        S = S.next;
      } while (S !== x);
      return false;
    }
    function C(x, R) {
      return T(x.prev, x, x.next) < 0 ? T(x, R, x.next) >= 0 && T(x, x.prev, R) >= 0 : T(x, R, x.prev) < 0 || T(x, x.next, R) < 0;
    }
    function I(x, R) {
      var S = x, B = false, D = (x.x + R.x) / 2, N = (x.y + R.y) / 2;
      do
        S.y > N != S.next.y > N && S.next.y !== S.y && D < (S.next.x - S.x) * (N - S.y) / (S.next.y - S.y) + S.x && (B = !B), S = S.next;
      while (S !== x);
      return B;
    }
    function z(x, R) {
      var S = new X(x.i, x.x, x.y), B = new X(R.i, R.x, R.y), D = x.next, N = R.prev;
      return x.next = R, R.prev = x, S.next = D, D.prev = S, B.next = S, S.prev = B, N.next = B, B.prev = N, B;
    }
    function Z(x, R, S, B) {
      var D = new X(x, R, S);
      return B ? (D.next = B.next, D.prev = B, B.next.prev = D, B.next = D) : (D.prev = D, D.next = D), D;
    }
    function j(x) {
      x.next.prev = x.prev, x.prev.next = x.next, x.prevZ && (x.prevZ.nextZ = x.nextZ), x.nextZ && (x.nextZ.prevZ = x.prevZ);
    }
    function X(x, R, S) {
      this.i = x, this.x = R, this.y = S, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = false;
    }
    i.deviation = function(x, R, S, B) {
      var D = R && R.length, N = D ? R[0] * S : x.length, O = Math.abs(Q(x, 0, N, S));
      if (D) for (var q = 0, V = R.length; q < V; q++) {
        var $ = R[q] * S, ft = q < V - 1 ? R[q + 1] * S : x.length;
        O -= Math.abs(Q(x, $, ft, S));
      }
      var pt = 0;
      for (q = 0; q < B.length; q += 3) {
        var it = B[q] * S, gt = B[q + 1] * S, _t = B[q + 2] * S;
        pt += Math.abs((x[it] - x[_t]) * (x[gt + 1] - x[it + 1]) - (x[it] - x[gt]) * (x[_t + 1] - x[it + 1]));
      }
      return O === 0 && pt === 0 ? 0 : Math.abs((pt - O) / O);
    };
    function Q(x, R, S, B) {
      for (var D = 0, N = R, O = S - B; N < S; N += B) D += (x[O] - x[N]) * (x[N + 1] + x[O + 1]), O = N;
      return D;
    }
    return i.flatten = function(x) {
      for (var R = x[0][0].length, S = {
        vertices: [],
        holes: [],
        dimensions: R
      }, B = 0, D = 0; D < x.length; D++) {
        for (var N = 0; N < x[D].length; N++) for (var O = 0; O < R; O++) S.vertices.push(x[D][N][O]);
        D > 0 && (B += x[D - 1].length, S.holes.push(B));
      }
      return S;
    }, bi.exports;
  }
  var hg = lg();
  const dg = Ko(hg);
  var pe = ((i) => (i[i.NONE = 0] = "NONE", i[i.COLOR = 16384] = "COLOR", i[i.STENCIL = 1024] = "STENCIL", i[i.DEPTH = 256] = "DEPTH", i[i.COLOR_DEPTH = 16640] = "COLOR_DEPTH", i[i.COLOR_STENCIL = 17408] = "COLOR_STENCIL", i[i.DEPTH_STENCIL = 1280] = "DEPTH_STENCIL", i[i.ALL = 17664] = "ALL", i))(pe || {});
  class uh {
    constructor(t) {
      this.items = [], this._name = t;
    }
    emit(t, e, r, n, s, o, a, c) {
      const { name: u, items: l } = this;
      for (let h = 0, f = l.length; h < f; h++) l[h][u](t, e, r, n, s, o, a, c);
      return this;
    }
    add(t) {
      return t[this._name] && (this.remove(t), this.items.push(t)), this;
    }
    remove(t) {
      const e = this.items.indexOf(t);
      return e !== -1 && this.items.splice(e, 1), this;
    }
    contains(t) {
      return this.items.indexOf(t) !== -1;
    }
    removeAll() {
      return this.items.length = 0, this;
    }
    destroy() {
      this.removeAll(), this.items = null, this._name = null;
    }
    get empty() {
      return this.items.length === 0;
    }
    get name() {
      return this._name;
    }
  }
  const fg = [
    "init",
    "destroy",
    "contextChange",
    "resolutionChange",
    "reset",
    "renderEnd",
    "renderStart",
    "render",
    "update",
    "postrender",
    "prerender"
  ], lh = class hh extends me {
    constructor(t) {
      super(), this.runners = /* @__PURE__ */ Object.create(null), this.renderPipes = /* @__PURE__ */ Object.create(null), this._initOptions = {}, this._systemsHash = /* @__PURE__ */ Object.create(null), this.type = t.type, this.name = t.name, this.config = t;
      const e = [
        ...fg,
        ...this.config.runners ?? []
      ];
      this._addRunners(...e), this._unsafeEvalCheck();
    }
    async init(t = {}) {
      const e = t.skipExtensionImports === true ? true : t.manageImports === false;
      await ug(e), this._addSystems(this.config.systems), this._addPipes(this.config.renderPipes, this.config.renderPipeAdaptors);
      for (const r in this._systemsHash) t = {
        ...this._systemsHash[r].constructor.defaultOptions,
        ...t
      };
      t = {
        ...hh.defaultOptions,
        ...t
      }, this._roundPixels = t.roundPixels ? 1 : 0;
      for (let r = 0; r < this.runners.init.items.length; r++) await this.runners.init.items[r].init(t);
      this._initOptions = t;
    }
    render(t, e) {
      let r = t;
      if (r instanceof Dt && (r = {
        container: r
      }, e && (lt(dt, "passing a second argument is deprecated, please use render options instead"), r.target = e.renderTexture)), r.target || (r.target = this.view.renderTarget), r.target === this.view.renderTarget && (this._lastObjectRendered = r.container, r.clearColor = this.background.colorRgba), r.clearColor) {
        const n = Array.isArray(r.clearColor) && r.clearColor.length === 4;
        r.clearColor = n ? r.clearColor : At.shared.setValue(r.clearColor).toArray();
      }
      r.transform || (r.container.updateLocalTransform(), r.transform = r.container.localTransform), this.runners.prerender.emit(r), this.runners.renderStart.emit(r), this.runners.render.emit(r), this.runners.renderEnd.emit(r), this.runners.postrender.emit(r);
    }
    resize(t, e, r) {
      this.view.resize(t, e, r), this.emit("resize", this.view.screen.width, this.view.screen.height);
    }
    clear(t = {}) {
      const e = this;
      t.target || (t.target = e.renderTarget.renderTarget), t.clearColor || (t.clearColor = this.background.colorRgba), t.clear ?? (t.clear = pe.ALL);
      const { clear: r, clearColor: n, target: s } = t;
      At.shared.setValue(n ?? this.background.colorRgba), e.renderTarget.clear(s, r, At.shared.toArray());
    }
    get resolution() {
      return this.view.resolution;
    }
    set resolution(t) {
      this.view.resolution = t, this.runners.resolutionChange.emit(t);
    }
    get width() {
      return this.view.texture.frame.width;
    }
    get height() {
      return this.view.texture.frame.height;
    }
    get canvas() {
      return this.view.canvas;
    }
    get lastObjectRendered() {
      return this._lastObjectRendered;
    }
    get renderingToScreen() {
      return this.renderTarget.renderingToScreen;
    }
    get screen() {
      return this.view.screen;
    }
    _addRunners(...t) {
      t.forEach((e) => {
        this.runners[e] = new uh(e);
      });
    }
    _addSystems(t) {
      let e;
      for (e in t) {
        const r = t[e];
        this._addSystem(r.value, r.name);
      }
    }
    _addSystem(t, e) {
      const r = new t(this);
      if (this[e]) throw new Error(`Whoops! The name "${e}" is already in use`);
      this[e] = r, this._systemsHash[e] = r;
      for (const n in this.runners) this.runners[n].add(r);
      return this;
    }
    _addPipes(t, e) {
      const r = e.reduce((n, s) => (n[s.name] = s.value, n), {});
      t.forEach((n) => {
        const s = n.value, o = n.name, a = r[o];
        this.renderPipes[o] = new s(this, a ? new a() : null);
      });
    }
    destroy(t = false) {
      this.runners.destroy.items.reverse(), this.runners.destroy.emit(t), Object.values(this.runners).forEach((e) => {
        e.destroy();
      }), this._systemsHash = null, this.renderPipes = null;
    }
    generateTexture(t) {
      return this.textureGenerator.generateTexture(t);
    }
    get roundPixels() {
      return !!this._roundPixels;
    }
    _unsafeEvalCheck() {
      if (!ch()) throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");
    }
  };
  lh.defaultOptions = {
    resolution: 1,
    failIfMajorPerformanceCaveat: false,
    roundPixels: false
  };
  let $n = lh, Ji;
  function Yn(i) {
    return Ji !== void 0 || (Ji = (() => {
      var _a2;
      const t = {
        stencil: true,
        failIfMajorPerformanceCaveat: i ?? $n.defaultOptions.failIfMajorPerformanceCaveat
      };
      try {
        if (!St.get().getWebGLRenderingContext()) return false;
        let r = St.get().createCanvas().getContext("webgl", t);
        const n = !!((_a2 = r == null ? void 0 : r.getContextAttributes()) == null ? void 0 : _a2.stencil);
        if (r) {
          const s = r.getExtension("WEBGL_lose_context");
          s && s.loseContext();
        }
        return r = null, n;
      } catch {
        return false;
      }
    })()), Ji;
  }
  let Qi;
  async function Kn(i = {}) {
    return Qi !== void 0 || (Qi = await (async () => {
      if (!St.get().getNavigator().gpu) return false;
      try {
        return await (await navigator.gpu.requestAdapter(i)).requestDevice(), true;
      } catch {
        return false;
      }
    })()), Qi;
  }
  const Fc = [
    "webgl",
    "webgpu",
    "canvas"
  ];
  async function pg(i) {
    let t = [];
    i.preference ? (t.push(i.preference), Fc.forEach((s) => {
      s !== i.preference && t.push(s);
    })) : t = Fc.slice();
    let e, r = {};
    for (let s = 0; s < t.length; s++) {
      const o = t[s];
      if (o === "webgpu" && await Kn()) {
        const { WebGPURenderer: a } = await Tn(async () => {
          const { WebGPURenderer: c } = await Promise.resolve().then(() => z0);
          return {
            WebGPURenderer: c
          };
        }, void 0, import.meta.url);
        e = a, r = {
          ...i,
          ...i.webgpu
        };
        break;
      } else if (o === "webgl" && Yn(i.failIfMajorPerformanceCaveat ?? $n.defaultOptions.failIfMajorPerformanceCaveat)) {
        const { WebGLRenderer: a } = await Tn(async () => {
          const { WebGLRenderer: c } = await Promise.resolve().then(() => S0);
          return {
            WebGLRenderer: c
          };
        }, void 0, import.meta.url);
        e = a, r = {
          ...i,
          ...i.webgl
        };
        break;
      } else if (o === "canvas") throw r = {
        ...i
      }, new Error("CanvasRenderer is not yet implemented");
    }
    if (delete r.webgpu, delete r.webgl, !e) throw new Error("No available renderer for the current environment");
    const n = new e();
    return await n.init(r), n;
  }
  class dh {
    static init() {
      var _a2;
      (_a2 = globalThis.__PIXI_APP_INIT__) == null ? void 0 : _a2.call(globalThis, this);
    }
    static destroy() {
    }
  }
  dh.extension = P.Application;
  class fh {
    constructor(t) {
      this._renderer = t;
    }
    init() {
      var _a2;
      (_a2 = globalThis.__PIXI_RENDERER_INIT__) == null ? void 0 : _a2.call(globalThis, this._renderer);
    }
    destroy() {
      this._renderer = null;
    }
  }
  fh.extension = {
    type: [
      P.WebGLSystem,
      P.WebGPUSystem
    ],
    name: "initHook",
    priority: -10
  };
  const ph = class Co {
    constructor(...t) {
      this.stage = new Dt(), t[0] !== void 0 && lt(dt, "Application constructor options are deprecated, please use Application.init() instead.");
    }
    async init(t) {
      t = {
        ...t
      }, this.renderer = await pg(t), Co._plugins.forEach((e) => {
        e.init.call(this, t);
      });
    }
    render() {
      this.renderer.render({
        container: this.stage
      });
    }
    get canvas() {
      return this.renderer.canvas;
    }
    get view() {
      return lt(dt, "Application.view is deprecated, please use Application.canvas instead."), this.renderer.canvas;
    }
    get screen() {
      return this.renderer.screen;
    }
    destroy(t = false, e = false) {
      const r = Co._plugins.slice(0);
      r.reverse(), r.forEach((n) => {
        n.destroy.call(this);
      }), this.stage.destroy(e), this.stage = null, this.renderer.destroy(t), this.renderer = null;
    }
  };
  ph._plugins = [];
  let _h = ph;
  Mt.handleByList(P.Application, _h._plugins);
  Mt.add(dh);
  _g = class {
    static init(t) {
      Object.defineProperty(this, "resizeTo", {
        set(e) {
          globalThis.removeEventListener("resize", this.queueResize), this._resizeTo = e, e && (globalThis.addEventListener("resize", this.queueResize), this.resize());
        },
        get() {
          return this._resizeTo;
        }
      }), this.queueResize = () => {
        this._resizeTo && (this._cancelResize(), this._resizeId = requestAnimationFrame(() => this.resize()));
      }, this._cancelResize = () => {
        this._resizeId && (cancelAnimationFrame(this._resizeId), this._resizeId = null);
      }, this.resize = () => {
        if (!this._resizeTo) return;
        this._cancelResize();
        let e, r;
        if (this._resizeTo === globalThis.window) e = globalThis.innerWidth, r = globalThis.innerHeight;
        else {
          const { clientWidth: n, clientHeight: s } = this._resizeTo;
          e = n, r = s;
        }
        this.renderer.resize(e, r), this.render();
      }, this._resizeId = null, this._resizeTo = null, this.resizeTo = t.resizeTo || null;
    }
    static destroy() {
      globalThis.removeEventListener("resize", this.queueResize), this._cancelResize(), this._cancelResize = null, this.queueResize = null, this.resizeTo = null, this.resize = null;
    }
  };
  _g.extension = P.Application;
  gg = class {
    static init(t) {
      t = Object.assign({
        autoStart: true,
        sharedTicker: false
      }, t), Object.defineProperty(this, "ticker", {
        set(e) {
          this._ticker && this._ticker.remove(this.render, this), this._ticker = e, e && e.add(this.render, this, hr.LOW);
        },
        get() {
          return this._ticker;
        }
      }), this.stop = () => {
        this._ticker.stop();
      }, this.start = () => {
        this._ticker.start();
      }, this._ticker = null, this.ticker = t.sharedTicker ? ae.shared : new ae(), t.autoStart && this.start();
    }
    static destroy() {
      if (this._ticker) {
        const t = this._ticker;
        this.ticker = null, t.destroy();
      }
    }
  };
  gg.extension = P.Application;
  class gh extends me {
    constructor() {
      super(...arguments), this.chars = /* @__PURE__ */ Object.create(null), this.lineHeight = 0, this.fontFamily = "", this.fontMetrics = {
        fontSize: 0,
        ascent: 0,
        descent: 0
      }, this.baseLineOffset = 0, this.distanceField = {
        type: "none",
        range: 0
      }, this.pages = [], this.applyFillAsTint = true, this.baseMeasurementFontSize = 100, this.baseRenderedFontSize = 100;
    }
    get font() {
      return lt(dt, "BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead."), this.fontFamily;
    }
    get pageTextures() {
      return lt(dt, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."), this.pages;
    }
    get size() {
      return lt(dt, "BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead."), this.fontMetrics.fontSize;
    }
    get distanceFieldRange() {
      return lt(dt, "BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead."), this.distanceField.range;
    }
    get distanceFieldType() {
      return lt(dt, "BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead."), this.distanceField.type;
    }
    destroy(t = false) {
      var _a2;
      this.emit("destroy", this), this.removeAllListeners();
      for (const e in this.chars) (_a2 = this.chars[e].texture) == null ? void 0 : _a2.destroy();
      this.chars = null, t && (this.pages.forEach((e) => e.texture.destroy(true)), this.pages = null);
    }
  }
  const mh = class Ro {
    constructor(t, e, r, n) {
      this.uid = Ot("fillGradient"), this.type = "linear", this.gradientStops = [], this._styleKey = null, this.x0 = t, this.y0 = e, this.x1 = r, this.y1 = n;
    }
    addColorStop(t, e) {
      return this.gradientStops.push({
        offset: t,
        color: At.shared.setValue(e).toHexa()
      }), this._styleKey = null, this;
    }
    buildLinearGradient() {
      const t = Ro.defaultTextureSize, { gradientStops: e } = this, r = St.get().createCanvas();
      r.width = t, r.height = t;
      const n = r.getContext("2d"), s = n.createLinearGradient(0, 0, Ro.defaultTextureSize, 1);
      for (let y = 0; y < e.length; y++) {
        const b = e[y];
        s.addColorStop(b.offset, b.color);
      }
      n.fillStyle = s, n.fillRect(0, 0, t, t), this.texture = new J({
        source: new ti({
          resource: r,
          addressModeU: "clamp-to-edge",
          addressModeV: "repeat"
        })
      });
      const { x0: o, y0: a, x1: c, y1: u } = this, l = new nt(), h = c - o, f = u - a, p = Math.sqrt(h * h + f * f), m = Math.atan2(f, h);
      l.translate(-o, -a), l.scale(1 / t, 1 / t), l.rotate(-m), l.scale(256 / p, 1), this.transform = l, this._styleKey = null;
    }
    get styleKey() {
      if (this._styleKey) return this._styleKey;
      const t = this.gradientStops.map((n) => `${n.offset}-${n.color}`).join("-"), e = this.texture.uid, r = this.transform.toArray().join("-");
      return `fill-gradient-${this.uid}-${t}-${e}-${r}-${this.x0}-${this.y0}-${this.x1}-${this.y1}`;
    }
  };
  mh.defaultTextureSize = 256;
  let Ci = mh;
  const Uc = {
    repeat: {
      addressModeU: "repeat",
      addressModeV: "repeat"
    },
    "repeat-x": {
      addressModeU: "repeat",
      addressModeV: "clamp-to-edge"
    },
    "repeat-y": {
      addressModeU: "clamp-to-edge",
      addressModeV: "repeat"
    },
    "no-repeat": {
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge"
    }
  };
  class Zn {
    constructor(t, e) {
      this.uid = Ot("fillPattern"), this.transform = new nt(), this._styleKey = null, this.texture = t, this.transform.scale(1 / t.frame.width, 1 / t.frame.height), e && (t.source.style.addressModeU = Uc[e].addressModeU, t.source.style.addressModeV = Uc[e].addressModeV);
    }
    setTransform(t) {
      const e = this.texture;
      this.transform.copyFrom(t), this.transform.invert(), this.transform.scale(1 / e.frame.width, 1 / e.frame.height), this._styleKey = null;
    }
    get styleKey() {
      return this._styleKey ? this._styleKey : (this._styleKey = `fill-pattern-${this.uid}-${this.texture.uid}-${this.transform.toArray().join("-")}`, this._styleKey);
    }
  }
  var qs, kc;
  function mg() {
    if (kc) return qs;
    kc = 1, qs = e;
    var i = {
      a: 7,
      c: 6,
      h: 1,
      l: 2,
      m: 2,
      q: 4,
      s: 4,
      t: 2,
      v: 1,
      z: 0
    }, t = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
    function e(s) {
      var o = [];
      return s.replace(t, function(a, c, u) {
        var l = c.toLowerCase();
        for (u = n(u), l == "m" && u.length > 2 && (o.push([
          c
        ].concat(u.splice(0, 2))), l = "l", c = c == "m" ? "l" : "L"); ; ) {
          if (u.length == i[l]) return u.unshift(c), o.push(u);
          if (u.length < i[l]) throw new Error("malformed path data");
          o.push([
            c
          ].concat(u.splice(0, i[l])));
        }
      }), o;
    }
    var r = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
    function n(s) {
      var o = s.match(r);
      return o ? o.map(Number) : [];
    }
    return qs;
  }
  var bg = mg();
  const wg = Ko(bg);
  function yg(i, t) {
    const e = wg(i), r = [];
    let n = null, s = 0, o = 0;
    for (let a = 0; a < e.length; a++) {
      const c = e[a], u = c[0], l = c;
      switch (u) {
        case "M":
          s = l[1], o = l[2], t.moveTo(s, o);
          break;
        case "m":
          s += l[1], o += l[2], t.moveTo(s, o);
          break;
        case "H":
          s = l[1], t.lineTo(s, o);
          break;
        case "h":
          s += l[1], t.lineTo(s, o);
          break;
        case "V":
          o = l[1], t.lineTo(s, o);
          break;
        case "v":
          o += l[1], t.lineTo(s, o);
          break;
        case "L":
          s = l[1], o = l[2], t.lineTo(s, o);
          break;
        case "l":
          s += l[1], o += l[2], t.lineTo(s, o);
          break;
        case "C":
          s = l[5], o = l[6], t.bezierCurveTo(l[1], l[2], l[3], l[4], s, o);
          break;
        case "c":
          t.bezierCurveTo(s + l[1], o + l[2], s + l[3], o + l[4], s + l[5], o + l[6]), s += l[5], o += l[6];
          break;
        case "S":
          s = l[3], o = l[4], t.bezierCurveToShort(l[1], l[2], s, o);
          break;
        case "s":
          t.bezierCurveToShort(s + l[1], o + l[2], s + l[3], o + l[4]), s += l[3], o += l[4];
          break;
        case "Q":
          s = l[3], o = l[4], t.quadraticCurveTo(l[1], l[2], s, o);
          break;
        case "q":
          t.quadraticCurveTo(s + l[1], o + l[2], s + l[3], o + l[4]), s += l[3], o += l[4];
          break;
        case "T":
          s = l[1], o = l[2], t.quadraticCurveToShort(s, o);
          break;
        case "t":
          s += l[1], o += l[2], t.quadraticCurveToShort(s, o);
          break;
        case "A":
          s = l[6], o = l[7], t.arcToSvg(l[1], l[2], l[3], l[4], l[5], s, o);
          break;
        case "a":
          s += l[6], o += l[7], t.arcToSvg(l[1], l[2], l[3], l[4], l[5], s, o);
          break;
        case "Z":
        case "z":
          t.closePath(), r.length > 0 && (n = r.pop(), n ? (s = n.startX, o = n.startY) : (s = 0, o = 0)), n = null;
          break;
        default:
          ut(`Unknown SVG path command: ${u}`);
      }
      u !== "Z" && u !== "z" && n === null && (n = {
        startX: s,
        startY: o
      }, r.push(n));
    }
    return t;
  }
  class ia {
    constructor(t = 0, e = 0, r = 0) {
      this.type = "circle", this.x = t, this.y = e, this.radius = r;
    }
    clone() {
      return new ia(this.x, this.y, this.radius);
    }
    contains(t, e) {
      if (this.radius <= 0) return false;
      const r = this.radius * this.radius;
      let n = this.x - t, s = this.y - e;
      return n *= n, s *= s, n + s <= r;
    }
    strokeContains(t, e, r) {
      if (this.radius === 0) return false;
      const n = this.x - t, s = this.y - e, o = this.radius, a = r / 2, c = Math.sqrt(n * n + s * s);
      return c < o + a && c > o - a;
    }
    getBounds(t) {
      return t = t || new Et(), t.x = this.x - this.radius, t.y = this.y - this.radius, t.width = this.radius * 2, t.height = this.radius * 2, t;
    }
    copyFrom(t) {
      return this.x = t.x, this.y = t.y, this.radius = t.radius, this;
    }
    copyTo(t) {
      return t.copyFrom(this), t;
    }
    toString() {
      return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
    }
  }
  class na {
    constructor(t = 0, e = 0, r = 0, n = 0) {
      this.type = "ellipse", this.x = t, this.y = e, this.halfWidth = r, this.halfHeight = n;
    }
    clone() {
      return new na(this.x, this.y, this.halfWidth, this.halfHeight);
    }
    contains(t, e) {
      if (this.halfWidth <= 0 || this.halfHeight <= 0) return false;
      let r = (t - this.x) / this.halfWidth, n = (e - this.y) / this.halfHeight;
      return r *= r, n *= n, r + n <= 1;
    }
    strokeContains(t, e, r) {
      const { halfWidth: n, halfHeight: s } = this;
      if (n <= 0 || s <= 0) return false;
      const o = r / 2, a = n - o, c = s - o, u = n + o, l = s + o, h = t - this.x, f = e - this.y, p = h * h / (a * a) + f * f / (c * c), m = h * h / (u * u) + f * f / (l * l);
      return p > 1 && m <= 1;
    }
    getBounds(t) {
      return t = t || new Et(), t.x = this.x - this.halfWidth, t.y = this.y - this.halfHeight, t.width = this.halfWidth * 2, t.height = this.halfHeight * 2, t;
    }
    copyFrom(t) {
      return this.x = t.x, this.y = t.y, this.halfWidth = t.halfWidth, this.halfHeight = t.halfHeight, this;
    }
    copyTo(t) {
      return t.copyFrom(this), t;
    }
    toString() {
      return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;
    }
  }
  function xg(i, t, e, r, n, s) {
    const o = i - e, a = t - r, c = n - e, u = s - r, l = o * c + a * u, h = c * c + u * u;
    let f = -1;
    h !== 0 && (f = l / h);
    let p, m;
    f < 0 ? (p = e, m = r) : f > 1 ? (p = n, m = s) : (p = e + f * c, m = r + f * u);
    const y = i - p, b = t - m;
    return y * y + b * b;
  }
  class xi {
    constructor(...t) {
      this.type = "polygon";
      let e = Array.isArray(t[0]) ? t[0] : t;
      if (typeof e[0] != "number") {
        const r = [];
        for (let n = 0, s = e.length; n < s; n++) r.push(e[n].x, e[n].y);
        e = r;
      }
      this.points = e, this.closePath = true;
    }
    clone() {
      const t = this.points.slice(), e = new xi(t);
      return e.closePath = this.closePath, e;
    }
    contains(t, e) {
      let r = false;
      const n = this.points.length / 2;
      for (let s = 0, o = n - 1; s < n; o = s++) {
        const a = this.points[s * 2], c = this.points[s * 2 + 1], u = this.points[o * 2], l = this.points[o * 2 + 1];
        c > e != l > e && t < (u - a) * ((e - c) / (l - c)) + a && (r = !r);
      }
      return r;
    }
    strokeContains(t, e, r) {
      const n = r / 2, s = n * n, { points: o } = this, a = o.length - (this.closePath ? 0 : 2);
      for (let c = 0; c < a; c += 2) {
        const u = o[c], l = o[c + 1], h = o[(c + 2) % o.length], f = o[(c + 3) % o.length];
        if (xg(t, e, u, l, h, f) <= s) return true;
      }
      return false;
    }
    getBounds(t) {
      t = t || new Et();
      const e = this.points;
      let r = 1 / 0, n = -1 / 0, s = 1 / 0, o = -1 / 0;
      for (let a = 0, c = e.length; a < c; a += 2) {
        const u = e[a], l = e[a + 1];
        r = u < r ? u : r, n = u > n ? u : n, s = l < s ? l : s, o = l > o ? l : o;
      }
      return t.x = r, t.width = n - r, t.y = s, t.height = o - s, t;
    }
    copyFrom(t) {
      return this.points = t.points.slice(), this.closePath = t.closePath, this;
    }
    copyTo(t) {
      return t.copyFrom(this), t;
    }
    toString() {
      return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((t, e) => `${t}, ${e}`, "")}]`;
    }
    get lastX() {
      return this.points[this.points.length - 2];
    }
    get lastY() {
      return this.points[this.points.length - 1];
    }
    get x() {
      return this.points[this.points.length - 2];
    }
    get y() {
      return this.points[this.points.length - 1];
    }
  }
  const tn = (i, t, e, r, n, s) => {
    const o = i - e, a = t - r, c = Math.sqrt(o * o + a * a);
    return c >= n - s && c <= n + s;
  };
  class sa {
    constructor(t = 0, e = 0, r = 0, n = 0, s = 20) {
      this.type = "roundedRectangle", this.x = t, this.y = e, this.width = r, this.height = n, this.radius = s;
    }
    getBounds(t) {
      return t = t || new Et(), t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t;
    }
    clone() {
      return new sa(this.x, this.y, this.width, this.height, this.radius);
    }
    copyFrom(t) {
      return this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height, this;
    }
    copyTo(t) {
      return t.copyFrom(this), t;
    }
    contains(t, e) {
      if (this.width <= 0 || this.height <= 0) return false;
      if (t >= this.x && t <= this.x + this.width && e >= this.y && e <= this.y + this.height) {
        const r = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
        if (e >= this.y + r && e <= this.y + this.height - r || t >= this.x + r && t <= this.x + this.width - r) return true;
        let n = t - (this.x + r), s = e - (this.y + r);
        const o = r * r;
        if (n * n + s * s <= o || (n = t - (this.x + this.width - r), n * n + s * s <= o) || (s = e - (this.y + this.height - r), n * n + s * s <= o) || (n = t - (this.x + r), n * n + s * s <= o)) return true;
      }
      return false;
    }
    strokeContains(t, e, r) {
      const { x: n, y: s, width: o, height: a, radius: c } = this, u = r / 2, l = n + c, h = s + c, f = o - c * 2, p = a - c * 2, m = n + o, y = s + a;
      return (t >= n - u && t <= n + u || t >= m - u && t <= m + u) && e >= h && e <= h + p || (e >= s - u && e <= s + u || e >= y - u && e <= y + u) && t >= l && t <= l + f ? true : t < l && e < h && tn(t, e, l, h, c, u) || t > m - c && e < h && tn(t, e, m - c, h, c, u) || t > m - c && e > y - c && tn(t, e, m - c, y - c, c, u) || t < l && e > y - c && tn(t, e, l, y - c, c, u);
    }
    toString() {
      return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
    }
  }
  const vg = [
    "precision mediump float;",
    "void main(void){",
    "float test = 0.1;",
    "%forloop%",
    "gl_FragColor = vec4(0.0);",
    "}"
  ].join(`
`);
  function Sg(i) {
    let t = "";
    for (let e = 0; e < i; ++e) e > 0 && (t += `
else `), e < i - 1 && (t += `if(test == ${e}.0){}`);
    return t;
  }
  function Eg(i, t) {
    if (i === 0) throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
    const e = t.createShader(t.FRAGMENT_SHADER);
    for (; ; ) {
      const r = vg.replace(/%forloop%/gi, Sg(i));
      if (t.shaderSource(e, r), t.compileShader(e), !t.getShaderParameter(e, t.COMPILE_STATUS)) i = i / 2 | 0;
      else break;
    }
    return i;
  }
  let Nr = null;
  function Ir() {
    if (Nr) return Nr;
    const i = eh();
    return Nr = i.getParameter(i.MAX_TEXTURE_IMAGE_UNITS), Nr = Eg(Nr, i), Nr;
  }
  const bh = {};
  function oa(i, t) {
    let e = 0;
    for (let r = 0; r < t; r++) e = e * 31 + i[r].uid >>> 0;
    return bh[e] || Ag(i, t, e);
  }
  let $s = 0;
  function Ag(i, t, e) {
    const r = {};
    let n = 0;
    $s || ($s = Ir());
    for (let o = 0; o < $s; o++) {
      const a = o < t ? i[o] : J.EMPTY.source;
      r[n++] = a.source, r[n++] = a.style;
    }
    const s = new Ze(r);
    return bh[e] = s, s;
  }
  class Gc {
    constructor(t) {
      typeof t == "number" ? this.rawBinaryData = new ArrayBuffer(t) : t instanceof Uint8Array ? this.rawBinaryData = t.buffer : this.rawBinaryData = t, this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData), this.size = this.rawBinaryData.byteLength;
    }
    get int8View() {
      return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View;
    }
    get uint8View() {
      return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View;
    }
    get int16View() {
      return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View;
    }
    get int32View() {
      return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View;
    }
    get float64View() {
      return this._float64Array || (this._float64Array = new Float64Array(this.rawBinaryData)), this._float64Array;
    }
    get bigUint64View() {
      return this._bigUint64Array || (this._bigUint64Array = new BigUint64Array(this.rawBinaryData)), this._bigUint64Array;
    }
    view(t) {
      return this[`${t}View`];
    }
    destroy() {
      this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this.uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null;
    }
    static sizeOf(t) {
      switch (t) {
        case "int8":
        case "uint8":
          return 1;
        case "int16":
        case "uint16":
          return 2;
        case "int32":
        case "uint32":
        case "float32":
          return 4;
        default:
          throw new Error(`${t} isn't a valid view type`);
      }
    }
  }
  function Po(i, t) {
    const e = i.byteLength / 8 | 0, r = new Float64Array(i, 0, e);
    new Float64Array(t, 0, e).set(r);
    const s = i.byteLength - e * 8;
    if (s > 0) {
      const o = new Uint8Array(i, e * 8, s);
      new Uint8Array(t, e * 8, s).set(o);
    }
  }
  const Tg = {
    normal: "normal-npm",
    add: "add-npm",
    screen: "screen-npm"
  };
  var Kt = ((i) => (i[i.DISABLED = 0] = "DISABLED", i[i.RENDERING_MASK_ADD = 1] = "RENDERING_MASK_ADD", i[i.MASK_ACTIVE = 2] = "MASK_ACTIVE", i[i.RENDERING_MASK_REMOVE = 3] = "RENDERING_MASK_REMOVE", i[i.NONE = 4] = "NONE", i))(Kt || {});
  function Dn(i, t) {
    return t.alphaMode === "no-premultiply-alpha" && Tg[i] || i;
  }
  class Cg {
    constructor() {
      this.ids = /* @__PURE__ */ Object.create(null), this.textures = [], this.count = 0;
    }
    clear() {
      for (let t = 0; t < this.count; t++) {
        const e = this.textures[t];
        this.textures[t] = null, this.ids[e.uid] = null;
      }
      this.count = 0;
    }
  }
  class Rg {
    constructor() {
      this.renderPipeId = "batch", this.action = "startBatch", this.start = 0, this.size = 0, this.textures = new Cg(), this.blendMode = "normal", this.canBundle = true;
    }
    destroy() {
      this.textures = null, this.gpuBindGroup = null, this.bindGroup = null, this.batcher = null;
    }
  }
  const wh = [];
  let Bo = 0;
  function Oc() {
    return Bo > 0 ? wh[--Bo] : new Rg();
  }
  function Nc(i) {
    wh[Bo++] = i;
  }
  let ai = 0;
  const yh = class xh {
    constructor(t = {}) {
      this.uid = Ot("batcher"), this.dirty = true, this.batchIndex = 0, this.batches = [], this._vertexSize = 6, this._elements = [], t = {
        ...xh.defaultOptions,
        ...t
      };
      const { vertexSize: e, indexSize: r } = t;
      this.attributeBuffer = new Gc(e * this._vertexSize * 4), this.indexBuffer = new Uint16Array(r), this._maxTextures = Ir();
    }
    begin() {
      this.elementSize = 0, this.elementStart = 0, this.indexSize = 0, this.attributeSize = 0;
      for (let t = 0; t < this.batchIndex; t++) Nc(this.batches[t]);
      this.batchIndex = 0, this._batchIndexStart = 0, this._batchIndexSize = 0, this.dirty = true;
    }
    add(t) {
      this._elements[this.elementSize++] = t, t.indexStart = this.indexSize, t.location = this.attributeSize, t.batcher = this, this.indexSize += t.indexSize, this.attributeSize += t.vertexSize * this._vertexSize;
    }
    checkAndUpdateTexture(t, e) {
      const r = t.batch.textures.ids[e._source.uid];
      return !r && r !== 0 ? false : (t.textureId = r, t.texture = e, true);
    }
    updateElement(t) {
      this.dirty = true, t.packAttributes(this.attributeBuffer.float32View, this.attributeBuffer.uint32View, t.location, t.textureId);
    }
    break(t) {
      const e = this._elements;
      if (!e[this.elementStart]) return;
      let r = Oc(), n = r.textures;
      n.clear();
      const s = e[this.elementStart];
      let o = Dn(s.blendMode, s.texture._source);
      this.attributeSize * 4 > this.attributeBuffer.size && this._resizeAttributeBuffer(this.attributeSize * 4), this.indexSize > this.indexBuffer.length && this._resizeIndexBuffer(this.indexSize);
      const a = this.attributeBuffer.float32View, c = this.attributeBuffer.uint32View, u = this.indexBuffer;
      let l = this._batchIndexSize, h = this._batchIndexStart, f = "startBatch";
      const p = this._maxTextures;
      for (let m = this.elementStart; m < this.elementSize; ++m) {
        const y = e[m];
        e[m] = null;
        const v = y.texture._source, A = Dn(y.blendMode, v), T = o !== A;
        if (v._batchTick === ai && !T) {
          y.textureId = v._textureBindLocation, l += y.indexSize, y.packAttributes(a, c, y.location, y.textureId), y.packIndex(u, y.indexStart, y.location / this._vertexSize), y.batch = r;
          continue;
        }
        v._batchTick = ai, (n.count >= p || T) && (this._finishBatch(r, h, l - h, n, o, t, f), f = "renderBatch", h = l, o = A, r = Oc(), n = r.textures, n.clear(), ++ai), y.textureId = v._textureBindLocation = n.count, n.ids[v.uid] = n.count, n.textures[n.count++] = v, y.batch = r, l += y.indexSize, y.packAttributes(a, c, y.location, y.textureId), y.packIndex(u, y.indexStart, y.location / this._vertexSize);
      }
      n.count > 0 && (this._finishBatch(r, h, l - h, n, o, t, f), h = l, ++ai), this.elementStart = this.elementSize, this._batchIndexStart = h, this._batchIndexSize = l;
    }
    _finishBatch(t, e, r, n, s, o, a) {
      t.gpuBindGroup = null, t.bindGroup = null, t.action = a, t.batcher = this, t.textures = n, t.blendMode = s, t.start = e, t.size = r, ++ai, this.batches[this.batchIndex++] = t, o.add(t);
    }
    finish(t) {
      this.break(t);
    }
    ensureAttributeBuffer(t) {
      t * 4 <= this.attributeBuffer.size || this._resizeAttributeBuffer(t * 4);
    }
    ensureIndexBuffer(t) {
      t <= this.indexBuffer.length || this._resizeIndexBuffer(t);
    }
    _resizeAttributeBuffer(t) {
      const e = Math.max(t, this.attributeBuffer.size * 2), r = new Gc(e);
      Po(this.attributeBuffer.rawBinaryData, r.rawBinaryData), this.attributeBuffer = r;
    }
    _resizeIndexBuffer(t) {
      const e = this.indexBuffer;
      let r = Math.max(t, e.length * 1.5);
      r += r % 2;
      const n = r > 65535 ? new Uint32Array(r) : new Uint16Array(r);
      if (n.BYTES_PER_ELEMENT !== e.BYTES_PER_ELEMENT) for (let s = 0; s < e.length; s++) n[s] = e[s];
      else Po(e.buffer, n.buffer);
      this.indexBuffer = n;
    }
    destroy() {
      for (let t = 0; t < this.batches.length; t++) Nc(this.batches[t]);
      this.batches = null;
      for (let t = 0; t < this._elements.length; t++) this._elements[t].batch = null;
      this._elements = null, this.indexBuffer = null, this.attributeBuffer.destroy(), this.attributeBuffer = null;
    }
  };
  yh.defaultOptions = {
    vertexSize: 4,
    indexSize: 6
  };
  let vh = yh;
  var yt = ((i) => (i[i.MAP_READ = 1] = "MAP_READ", i[i.MAP_WRITE = 2] = "MAP_WRITE", i[i.COPY_SRC = 4] = "COPY_SRC", i[i.COPY_DST = 8] = "COPY_DST", i[i.INDEX = 16] = "INDEX", i[i.VERTEX = 32] = "VERTEX", i[i.UNIFORM = 64] = "UNIFORM", i[i.STORAGE = 128] = "STORAGE", i[i.INDIRECT = 256] = "INDIRECT", i[i.QUERY_RESOLVE = 512] = "QUERY_RESOLVE", i[i.STATIC = 1024] = "STATIC", i))(yt || {});
  let Pe = class extends me {
    constructor(t) {
      let { data: e, size: r } = t;
      const { usage: n, label: s, shrinkToFit: o } = t;
      super(), this.uid = Ot("buffer"), this._resourceType = "buffer", this._resourceId = Ot("resource"), this._touched = 0, this._updateID = 1, this.shrinkToFit = true, this.destroyed = false, e instanceof Array && (e = new Float32Array(e)), this._data = e, r = r ?? (e == null ? void 0 : e.byteLength);
      const a = !!e;
      this.descriptor = {
        size: r,
        usage: n,
        mappedAtCreation: a,
        label: s
      }, this.shrinkToFit = o ?? true;
    }
    get data() {
      return this._data;
    }
    set data(t) {
      this.setDataWithSize(t, t.length, true);
    }
    get static() {
      return !!(this.descriptor.usage & yt.STATIC);
    }
    set static(t) {
      t ? this.descriptor.usage |= yt.STATIC : this.descriptor.usage &= ~yt.STATIC;
    }
    setDataWithSize(t, e, r) {
      if (this._updateID++, this._updateSize = e * t.BYTES_PER_ELEMENT, this._data === t) {
        r && this.emit("update", this);
        return;
      }
      const n = this._data;
      if (this._data = t, n.length !== t.length) {
        !this.shrinkToFit && t.byteLength < n.byteLength ? r && this.emit("update", this) : (this.descriptor.size = t.byteLength, this._resourceId = Ot("resource"), this.emit("change", this));
        return;
      }
      r && this.emit("update", this);
    }
    update(t) {
      this._updateSize = t ?? this._updateSize, this._updateID++, this.emit("update", this);
    }
    destroy() {
      this.destroyed = true, this.emit("destroy", this), this.emit("change", this), this._data = null, this.descriptor = null, this.removeAllListeners();
    }
  };
  function Sh(i, t) {
    if (!(i instanceof Pe)) {
      let e = t ? yt.INDEX : yt.VERTEX;
      i instanceof Array && (t ? (i = new Uint32Array(i), e = yt.INDEX | yt.COPY_DST) : (i = new Float32Array(i), e = yt.VERTEX | yt.COPY_DST)), i = new Pe({
        data: i,
        label: t ? "index-mesh-buffer" : "vertex-mesh-buffer",
        usage: e
      });
    }
    return i;
  }
  function Pg(i, t, e) {
    const r = i.getAttribute(t);
    if (!r) return e.minX = 0, e.minY = 0, e.maxX = 0, e.maxY = 0, e;
    const n = r.buffer.data;
    let s = 1 / 0, o = 1 / 0, a = -1 / 0, c = -1 / 0;
    const u = n.BYTES_PER_ELEMENT, l = (r.offset || 0) / u, h = (r.stride || 2 * 4) / u;
    for (let f = l; f < n.length; f += h) {
      const p = n[f], m = n[f + 1];
      p > a && (a = p), m > c && (c = m), p < s && (s = p), m < o && (o = m);
    }
    return e.minX = s, e.minY = o, e.maxX = a, e.maxY = c, e;
  }
  function Bg(i) {
    return (i instanceof Pe || Array.isArray(i) || i.BYTES_PER_ELEMENT) && (i = {
      buffer: i
    }), i.buffer = Sh(i.buffer, false), i;
  }
  class Ii extends me {
    constructor(t) {
      const { attributes: e, indexBuffer: r, topology: n } = t;
      super(), this.uid = Ot("geometry"), this._layoutKey = 0, this.instanceCount = 1, this._bounds = new re(), this._boundsDirty = true, this.attributes = e, this.buffers = [], this.instanceCount = t.instanceCount || 1;
      for (const s in e) {
        const o = e[s] = Bg(e[s]);
        this.buffers.indexOf(o.buffer) === -1 && (this.buffers.push(o.buffer), o.buffer.on("update", this.onBufferUpdate, this), o.buffer.on("change", this.onBufferUpdate, this));
      }
      r && (this.indexBuffer = Sh(r, true), this.buffers.push(this.indexBuffer)), this.topology = n || "triangle-list";
    }
    onBufferUpdate() {
      this._boundsDirty = true, this.emit("update", this);
    }
    getAttribute(t) {
      return this.attributes[t];
    }
    getIndex() {
      return this.indexBuffer;
    }
    getBuffer(t) {
      return this.getAttribute(t).buffer;
    }
    getSize() {
      for (const t in this.attributes) {
        const e = this.attributes[t];
        return e.buffer.data.length / (e.stride / 4 || e.size);
      }
      return 0;
    }
    get bounds() {
      return this._boundsDirty ? (this._boundsDirty = false, Pg(this, "aPosition", this._bounds)) : this._bounds;
    }
    destroy(t = false) {
      this.emit("destroy", this), this.removeAllListeners(), t && this.buffers.forEach((e) => e.destroy()), this.attributes = null, this.buffers = null, this.indexBuffer = null, this._bounds = null;
    }
  }
  const Mg = new Float32Array(1), Dg = new Uint32Array(1);
  class Eh extends Ii {
    constructor() {
      const e = new Pe({
        data: Mg,
        label: "attribute-batch-buffer",
        usage: yt.VERTEX | yt.COPY_DST,
        shrinkToFit: false
      }), r = new Pe({
        data: Dg,
        label: "index-batch-buffer",
        usage: yt.INDEX | yt.COPY_DST,
        shrinkToFit: false
      }), n = 6 * 4;
      super({
        attributes: {
          aPosition: {
            buffer: e,
            format: "float32x2",
            stride: n,
            offset: 0,
            location: 1
          },
          aUV: {
            buffer: e,
            format: "float32x2",
            stride: n,
            offset: 2 * 4,
            location: 3
          },
          aColor: {
            buffer: e,
            format: "unorm8x4",
            stride: n,
            offset: 4 * 4,
            location: 0
          },
          aTextureIdAndRound: {
            buffer: e,
            format: "uint16x2",
            stride: n,
            offset: 5 * 4,
            location: 2
          }
        },
        indexBuffer: r
      });
    }
  }
  function Ig(i, t, e, r, n, s, o, a = null) {
    let c = 0;
    e *= t, n *= s;
    const u = a.a, l = a.b, h = a.c, f = a.d, p = a.tx, m = a.ty;
    for (; c < o; ) {
      const y = i[e], b = i[e + 1];
      r[n] = u * y + h * b + p, r[n + 1] = l * y + f * b + m, n += s, e += t, c++;
    }
  }
  function Fg(i, t, e, r) {
    let n = 0;
    for (t *= e; n < r; ) i[t] = 0, i[t + 1] = 0, t += e, n++;
  }
  function Ah(i, t, e, r, n) {
    const s = t.a, o = t.b, a = t.c, c = t.d, u = t.tx, l = t.ty;
    e = e || 0, r = r || 2, n = n || i.length / r - e;
    let h = e * r;
    for (let f = 0; f < n; f++) {
      const p = i[h], m = i[h + 1];
      i[h] = s * p + a * m + u, i[h + 1] = o * p + c * m + l, h += r;
    }
  }
  function Ug(i, t) {
    if (i === 16777215 || !t) return t;
    if (t === 16777215 || !i) return i;
    const e = i >> 16 & 255, r = i >> 8 & 255, n = i & 255, s = t >> 16 & 255, o = t >> 8 & 255, a = t & 255, c = e * s / 255, u = r * o / 255, l = n * a / 255;
    return (c << 16) + (u << 8) + l;
  }
  class aa {
    constructor() {
      this.batcher = null, this.batch = null, this.applyTransform = true, this.roundPixels = 0;
    }
    get blendMode() {
      return this.applyTransform ? this.renderable.groupBlendMode : "normal";
    }
    packIndex(t, e, r) {
      const n = this.geometryData.indices;
      for (let s = 0; s < this.indexSize; s++) t[e++] = n[s + this.indexOffset] + r - this.vertexOffset;
    }
    packAttributes(t, e, r, n) {
      const s = this.geometryData, o = this.renderable, a = s.vertices, c = s.uvs, u = this.vertexOffset * 2, l = (this.vertexOffset + this.vertexSize) * 2, h = this.color, f = h >> 16 | h & 65280 | (h & 255) << 16;
      if (this.applyTransform) {
        const p = Ug(f, o.groupColor) + (this.alpha * o.groupAlpha * 255 << 24), m = o.groupTransform, y = n << 16 | this.roundPixels & 65535, b = m.a, v = m.b, A = m.c, T = m.d, G = m.tx, H = m.ty;
        for (let Y = u; Y < l; Y += 2) {
          const L = a[Y], W = a[Y + 1];
          t[r] = b * L + A * W + G, t[r + 1] = v * L + T * W + H, t[r + 2] = c[Y], t[r + 3] = c[Y + 1], e[r + 4] = p, e[r + 5] = y, r += 6;
        }
      } else {
        const p = f + (this.alpha * 255 << 24);
        for (let m = u; m < l; m += 2) t[r] = a[m], t[r + 1] = a[m + 1], t[r + 2] = c[m], t[r + 3] = c[m + 1], e[r + 4] = p, e[r + 5] = n << 16, r += 6;
      }
    }
    get vertSize() {
      return this.vertexSize;
    }
    copyTo(t) {
      t.indexOffset = this.indexOffset, t.indexSize = this.indexSize, t.vertexOffset = this.vertexOffset, t.vertexSize = this.vertexSize, t.color = this.color, t.alpha = this.alpha, t.texture = this.texture, t.geometryData = this.geometryData;
    }
    reset() {
      this.applyTransform = true;
    }
  }
  const Ri = {
    extension: {
      type: P.ShapeBuilder,
      name: "circle"
    },
    build(i, t) {
      let e, r, n, s, o, a;
      if (i.type === "circle") {
        const G = i;
        e = G.x, r = G.y, o = a = G.radius, n = s = 0;
      } else if (i.type === "ellipse") {
        const G = i;
        e = G.x, r = G.y, o = G.halfWidth, a = G.halfHeight, n = s = 0;
      } else {
        const G = i, H = G.width / 2, Y = G.height / 2;
        e = G.x + H, r = G.y + Y, o = a = Math.max(0, Math.min(G.radius, Math.min(H, Y))), n = H - o, s = Y - a;
      }
      if (!(o >= 0 && a >= 0 && n >= 0 && s >= 0)) return t;
      const c = Math.ceil(2.3 * Math.sqrt(o + a)), u = c * 8 + (n ? 4 : 0) + (s ? 4 : 0);
      if (u === 0) return t;
      if (c === 0) return t[0] = t[6] = e + n, t[1] = t[3] = r + s, t[2] = t[4] = e - n, t[5] = t[7] = r - s, t;
      let l = 0, h = c * 4 + (n ? 2 : 0) + 2, f = h, p = u, m = n + o, y = s, b = e + m, v = e - m, A = r + y;
      if (t[l++] = b, t[l++] = A, t[--h] = A, t[--h] = v, s) {
        const G = r - y;
        t[f++] = v, t[f++] = G, t[--p] = G, t[--p] = b;
      }
      for (let G = 1; G < c; G++) {
        const H = Math.PI / 2 * (G / c), Y = n + Math.cos(H) * o, L = s + Math.sin(H) * a, W = e + Y, C = e - Y, I = r + L, z = r - L;
        t[l++] = W, t[l++] = I, t[--h] = I, t[--h] = C, t[f++] = C, t[f++] = z, t[--p] = z, t[--p] = W;
      }
      m = n, y = s + a, b = e + m, v = e - m, A = r + y;
      const T = r - y;
      return t[l++] = b, t[l++] = A, t[--p] = T, t[--p] = b, n && (t[l++] = v, t[l++] = A, t[--p] = T, t[--p] = v), t;
    },
    triangulate(i, t, e, r, n, s) {
      if (i.length === 0) return;
      let o = 0, a = 0;
      for (let l = 0; l < i.length; l += 2) o += i[l], a += i[l + 1];
      o /= i.length / 2, a /= i.length / 2;
      let c = r;
      t[c * e] = o, t[c * e + 1] = a;
      const u = c++;
      for (let l = 0; l < i.length; l += 2) t[c * e] = i[l], t[c * e + 1] = i[l + 1], l > 0 && (n[s++] = c, n[s++] = u, n[s++] = c - 1), c++;
      n[s++] = u + 1, n[s++] = u, n[s++] = c - 1;
    }
  }, kg = {
    ...Ri,
    extension: {
      ...Ri.extension,
      name: "ellipse"
    }
  }, Gg = {
    ...Ri,
    extension: {
      ...Ri.extension,
      name: "roundedRectangle"
    }
  }, Og = 1e-4, Lc = 1e-4;
  function Ng(i) {
    const t = i.length;
    if (t < 6) return 1;
    let e = 0;
    for (let r = 0, n = i[t - 2], s = i[t - 1]; r < t; r += 2) {
      const o = i[r], a = i[r + 1];
      e += (o - n) * (a + s), n = o, s = a;
    }
    return e < 0 ? -1 : 1;
  }
  function Hc(i, t, e, r, n, s, o, a) {
    const c = i - e * n, u = t - r * n, l = i + e * s, h = t + r * s;
    let f, p;
    o ? (f = r, p = -e) : (f = -r, p = e);
    const m = c + f, y = u + p, b = l + f, v = h + p;
    return a.push(m, y), a.push(b, v), 2;
  }
  function wr(i, t, e, r, n, s, o, a) {
    const c = e - i, u = r - t;
    let l = Math.atan2(c, u), h = Math.atan2(n - i, s - t);
    a && l < h ? l += Math.PI * 2 : !a && l > h && (h += Math.PI * 2);
    let f = l;
    const p = h - l, m = Math.abs(p), y = Math.sqrt(c * c + u * u), b = (15 * m * Math.sqrt(y) / Math.PI >> 0) + 1, v = p / b;
    if (f += v, a) {
      o.push(i, t), o.push(e, r);
      for (let A = 1, T = f; A < b; A++, T += v) o.push(i, t), o.push(i + Math.sin(T) * y, t + Math.cos(T) * y);
      o.push(i, t), o.push(n, s);
    } else {
      o.push(e, r), o.push(i, t);
      for (let A = 1, T = f; A < b; A++, T += v) o.push(i + Math.sin(T) * y, t + Math.cos(T) * y), o.push(i, t);
      o.push(n, s), o.push(i, t);
    }
    return b * 2;
  }
  function Lg(i, t, e, r, n, s, o, a, c) {
    const u = Og;
    if (i.length === 0) return;
    const l = t;
    let h = l.alignment;
    if (t.alignment !== 0.5) {
      let O = Ng(i);
      e && (O *= -1), h = (h - 0.5) * O + 0.5;
    }
    const f = new Ct(i[0], i[1]), p = new Ct(i[i.length - 2], i[i.length - 1]), m = r, y = Math.abs(f.x - p.x) < u && Math.abs(f.y - p.y) < u;
    if (m) {
      i = i.slice(), y && (i.pop(), i.pop(), p.set(i[i.length - 2], i[i.length - 1]));
      const O = (f.x + p.x) * 0.5, q = (p.y + f.y) * 0.5;
      i.unshift(O, q), i.push(O, q);
    }
    const b = n, v = i.length / 2;
    let A = i.length;
    const T = b.length / 2, G = l.width / 2, H = G * G, Y = l.miterLimit * l.miterLimit;
    let L = i[0], W = i[1], C = i[2], I = i[3], z = 0, Z = 0, j = -(W - I), X = L - C, Q = 0, x = 0, R = Math.sqrt(j * j + X * X);
    j /= R, X /= R, j *= G, X *= G;
    const S = h, B = (1 - S) * 2, D = S * 2;
    m || (l.cap === "round" ? A += wr(L - j * (B - D) * 0.5, W - X * (B - D) * 0.5, L - j * B, W - X * B, L + j * D, W + X * D, b, true) + 2 : l.cap === "square" && (A += Hc(L, W, j, X, B, D, true, b))), b.push(L - j * B, W - X * B), b.push(L + j * D, W + X * D);
    for (let O = 1; O < v - 1; ++O) {
      L = i[(O - 1) * 2], W = i[(O - 1) * 2 + 1], C = i[O * 2], I = i[O * 2 + 1], z = i[(O + 1) * 2], Z = i[(O + 1) * 2 + 1], j = -(W - I), X = L - C, R = Math.sqrt(j * j + X * X), j /= R, X /= R, j *= G, X *= G, Q = -(I - Z), x = C - z, R = Math.sqrt(Q * Q + x * x), Q /= R, x /= R, Q *= G, x *= G;
      const q = C - L, V = W - I, $ = C - z, ft = Z - I, pt = q * $ + V * ft, it = V * $ - ft * q, gt = it < 0;
      if (Math.abs(it) < 1e-3 * Math.abs(pt)) {
        b.push(C - j * B, I - X * B), b.push(C + j * D, I + X * D), pt >= 0 && (l.join === "round" ? A += wr(C, I, C - j * B, I - X * B, C - Q * B, I - x * B, b, false) + 4 : A += 2, b.push(C - Q * D, I - x * D), b.push(C + Q * B, I + x * B));
        continue;
      }
      const _t = (-j + L) * (-X + I) - (-j + C) * (-X + W), ne = (-Q + z) * (-x + I) - (-Q + C) * (-x + Z), te = (q * ne - $ * _t) / it, ht = (ft * _t - V * ne) / it, Ut = (te - C) * (te - C) + (ht - I) * (ht - I), st = C + (te - C) * B, tt = I + (ht - I) * B, be = C - (te - C) * D, we = I - (ht - I) * D, He = Math.min(q * q + V * V, $ * $ + ft * ft), ir = gt ? B : D, Pt = He + ir * ir * H;
      Ut <= Pt ? l.join === "bevel" || Ut / H > Y ? (gt ? (b.push(st, tt), b.push(C + j * D, I + X * D), b.push(st, tt), b.push(C + Q * D, I + x * D)) : (b.push(C - j * B, I - X * B), b.push(be, we), b.push(C - Q * B, I - x * B), b.push(be, we)), A += 2) : l.join === "round" ? gt ? (b.push(st, tt), b.push(C + j * D, I + X * D), A += wr(C, I, C + j * D, I + X * D, C + Q * D, I + x * D, b, true) + 4, b.push(st, tt), b.push(C + Q * D, I + x * D)) : (b.push(C - j * B, I - X * B), b.push(be, we), A += wr(C, I, C - j * B, I - X * B, C - Q * B, I - x * B, b, false) + 4, b.push(C - Q * B, I - x * B), b.push(be, we)) : (b.push(st, tt), b.push(be, we)) : (b.push(C - j * B, I - X * B), b.push(C + j * D, I + X * D), l.join === "round" ? gt ? A += wr(C, I, C + j * D, I + X * D, C + Q * D, I + x * D, b, true) + 2 : A += wr(C, I, C - j * B, I - X * B, C - Q * B, I - x * B, b, false) + 2 : l.join === "miter" && Ut / H <= Y && (gt ? (b.push(be, we), b.push(be, we)) : (b.push(st, tt), b.push(st, tt)), A += 2), b.push(C - Q * B, I - x * B), b.push(C + Q * D, I + x * D), A += 2);
    }
    L = i[(v - 2) * 2], W = i[(v - 2) * 2 + 1], C = i[(v - 1) * 2], I = i[(v - 1) * 2 + 1], j = -(W - I), X = L - C, R = Math.sqrt(j * j + X * X), j /= R, X /= R, j *= G, X *= G, b.push(C - j * B, I - X * B), b.push(C + j * D, I + X * D), m || (l.cap === "round" ? A += wr(C - j * (B - D) * 0.5, I - X * (B - D) * 0.5, C - j * B, I - X * B, C + j * D, I + X * D, b, false) + 2 : l.cap === "square" && (A += Hc(C, I, j, X, B, D, false, b)));
    const N = Lc * Lc;
    for (let O = T; O < A + T - 2; ++O) L = b[O * 2], W = b[O * 2 + 1], C = b[(O + 1) * 2], I = b[(O + 1) * 2 + 1], z = b[(O + 2) * 2], Z = b[(O + 2) * 2 + 1], !(Math.abs(L * (I - Z) + C * (Z - W) + z * (W - I)) < N) && a.push(O, O + 1, O + 2);
  }
  function Th(i, t, e, r, n, s, o) {
    const a = dg(i, t, 2);
    if (!a) return;
    for (let u = 0; u < a.length; u += 3) s[o++] = a[u] + n, s[o++] = a[u + 1] + n, s[o++] = a[u + 2] + n;
    let c = n * r;
    for (let u = 0; u < i.length; u += 2) e[c] = i[u], e[c + 1] = i[u + 1], c += r;
  }
  const Hg = [], zg = {
    extension: {
      type: P.ShapeBuilder,
      name: "polygon"
    },
    build(i, t) {
      for (let e = 0; e < i.points.length; e++) t[e] = i.points[e];
      return t;
    },
    triangulate(i, t, e, r, n, s) {
      Th(i, Hg, t, e, r, n, s);
    }
  }, jg = {
    extension: {
      type: P.ShapeBuilder,
      name: "rectangle"
    },
    build(i, t) {
      const e = i, r = e.x, n = e.y, s = e.width, o = e.height;
      return s >= 0 && o >= 0 && (t[0] = r, t[1] = n, t[2] = r + s, t[3] = n, t[4] = r + s, t[5] = n + o, t[6] = r, t[7] = n + o), t;
    },
    triangulate(i, t, e, r, n, s) {
      let o = 0;
      r *= e, t[r + o] = i[0], t[r + o + 1] = i[1], o += e, t[r + o] = i[2], t[r + o + 1] = i[3], o += e, t[r + o] = i[6], t[r + o + 1] = i[7], o += e, t[r + o] = i[4], t[r + o + 1] = i[5], o += e;
      const a = r / e;
      n[s++] = a, n[s++] = a + 1, n[s++] = a + 2, n[s++] = a + 1, n[s++] = a + 3, n[s++] = a + 2;
    }
  }, Wg = {
    extension: {
      type: P.ShapeBuilder,
      name: "triangle"
    },
    build(i, t) {
      return t[0] = i.x, t[1] = i.y, t[2] = i.x2, t[3] = i.y2, t[4] = i.x3, t[5] = i.y3, t;
    },
    triangulate(i, t, e, r, n, s) {
      let o = 0;
      r *= e, t[r + o] = i[0], t[r + o + 1] = i[1], o += e, t[r + o] = i[2], t[r + o + 1] = i[3], o += e, t[r + o] = i[4], t[r + o + 1] = i[5];
      const a = r / e;
      n[s++] = a, n[s++] = a + 1, n[s++] = a + 2;
    }
  }, Jn = {};
  Mt.handleByMap(P.ShapeBuilder, Jn);
  Mt.add(jg, zg, Wg, Ri, kg, Gg);
  const Vg = new Et();
  function Xg(i, t) {
    const { geometryData: e, batches: r } = t;
    r.length = 0, e.indices.length = 0, e.vertices.length = 0, e.uvs.length = 0;
    for (let n = 0; n < i.instructions.length; n++) {
      const s = i.instructions[n];
      if (s.action === "texture") qg(s.data, r, e);
      else if (s.action === "fill" || s.action === "stroke") {
        const o = s.action === "stroke", a = s.data.path.shapePath, c = s.data.style, u = s.data.hole;
        o && u && zc(u.shapePath, c, null, true, r, e), zc(a, c, u, o, r, e);
      }
    }
  }
  function qg(i, t, e) {
    const { vertices: r, uvs: n, indices: s } = e, o = s.length, a = r.length / 2, c = [], u = Jn.rectangle, l = Vg, h = i.image;
    l.x = i.dx, l.y = i.dy, l.width = i.dw, l.height = i.dh;
    const f = i.transform;
    u.build(l, c), f && Ah(c, f), u.triangulate(c, r, 2, a, s, o);
    const p = h.uvs;
    n.push(p.x0, p.y0, p.x1, p.y1, p.x3, p.y3, p.x2, p.y2);
    const m = vt.get(aa);
    m.indexOffset = o, m.indexSize = s.length - o, m.vertexOffset = a, m.vertexSize = r.length / 2 - a, m.color = i.style, m.alpha = i.alpha, m.texture = h, m.geometryData = e, t.push(m);
  }
  function zc(i, t, e, r, n, s) {
    const { vertices: o, uvs: a, indices: c } = s, u = i.shapePrimitives.length - 1;
    i.shapePrimitives.forEach(({ shape: l, transform: h }, f) => {
      const p = c.length, m = o.length / 2, y = [], b = Jn[l.type];
      if (b.build(l, y), h && Ah(y, h), r) {
        const G = l.closePath ?? true;
        Lg(y, t, false, G, o, 2, m, c, p);
      } else if (e && u === f) {
        u !== 0 && console.warn("[Pixi Graphics] only the last shape have be cut out");
        const G = [], H = y.slice();
        $g(e.shapePath).forEach((L) => {
          G.push(H.length / 2), H.push(...L);
        }), Th(H, G, o, 2, m, c, p);
      } else b.triangulate(y, o, 2, m, c, p);
      const v = a.length / 2, A = t.texture;
      if (A !== J.WHITE) {
        const G = t.matrix;
        G && (h && G.append(h.clone().invert()), Ig(o, 2, m, a, v, 2, o.length / 2 - m, G));
      } else Fg(a, v, 2, o.length / 2 - m);
      const T = vt.get(aa);
      T.indexOffset = p, T.indexSize = c.length - p, T.vertexOffset = m, T.vertexSize = o.length / 2 - m, T.color = t.color, T.alpha = t.alpha, T.texture = A, T.geometryData = s, n.push(T);
    });
  }
  function $g(i) {
    if (!i) return [];
    const t = i.shapePrimitives, e = [];
    for (let r = 0; r < t.length; r++) {
      const n = t[r].shape, s = [];
      Jn[n.type].build(n, s), e.push(s);
    }
    return e;
  }
  class Yg {
    constructor() {
      this.batcher = new vh(), this.batches = [], this.geometryData = {
        vertices: [],
        uvs: [],
        indices: []
      };
    }
  }
  class Kg {
    constructor() {
      this.geometry = new Eh(), this.instructions = new Hl();
    }
    init() {
      this.instructions.reset();
    }
  }
  const ca = class Mo {
    constructor() {
      this._gpuContextHash = {}, this._graphicsDataContextHash = /* @__PURE__ */ Object.create(null);
    }
    init(t) {
      Mo.defaultOptions.bezierSmoothness = (t == null ? void 0 : t.bezierSmoothness) ?? Mo.defaultOptions.bezierSmoothness;
    }
    getContextRenderData(t) {
      return this._graphicsDataContextHash[t.uid] || this._initContextRenderData(t);
    }
    updateGpuContext(t) {
      let e = this._gpuContextHash[t.uid] || this._initContext(t);
      if (t.dirty) {
        e ? this._cleanGraphicsContextData(t) : e = this._initContext(t), Xg(t, e);
        const r = t.batchMode;
        t.customShader || r === "no-batch" ? e.isBatchable = false : r === "auto" && (e.isBatchable = e.geometryData.vertices.length < 400), t.dirty = false;
      }
      return e;
    }
    getGpuContext(t) {
      return this._gpuContextHash[t.uid] || this._initContext(t);
    }
    _initContextRenderData(t) {
      const e = vt.get(Kg), { batches: r, geometryData: n, batcher: s } = this._gpuContextHash[t.uid], o = n.vertices.length, a = n.indices.length;
      for (let l = 0; l < r.length; l++) r[l].applyTransform = false;
      s.ensureAttributeBuffer(o), s.ensureIndexBuffer(a), s.begin();
      for (let l = 0; l < r.length; l++) {
        const h = r[l];
        s.add(h);
      }
      s.finish(e.instructions);
      const c = e.geometry;
      c.indexBuffer.setDataWithSize(s.indexBuffer, s.indexSize, true), c.buffers[0].setDataWithSize(s.attributeBuffer.float32View, s.attributeSize, true);
      const u = s.batches;
      for (let l = 0; l < u.length; l++) {
        const h = u[l];
        h.bindGroup = oa(h.textures.textures, h.textures.count);
      }
      return this._graphicsDataContextHash[t.uid] = e, e;
    }
    _initContext(t) {
      const e = new Yg();
      return e.context = t, this._gpuContextHash[t.uid] = e, t.on("destroy", this.onGraphicsContextDestroy, this), this._gpuContextHash[t.uid];
    }
    onGraphicsContextDestroy(t) {
      this._cleanGraphicsContextData(t), t.off("destroy", this.onGraphicsContextDestroy, this), this._gpuContextHash[t.uid] = null;
    }
    _cleanGraphicsContextData(t) {
      const e = this._gpuContextHash[t.uid];
      e.isBatchable || this._graphicsDataContextHash[t.uid] && (vt.return(this.getContextRenderData(t)), this._graphicsDataContextHash[t.uid] = null), e.batches && e.batches.forEach((r) => {
        vt.return(r);
      });
    }
    destroy() {
      for (const t in this._gpuContextHash) this._gpuContextHash[t] && this.onGraphicsContextDestroy(this._gpuContextHash[t].context);
    }
  };
  ca.extension = {
    type: [
      P.WebGLSystem,
      P.WebGPUSystem,
      P.CanvasSystem
    ],
    name: "graphicsContext"
  };
  ca.defaultOptions = {
    bezierSmoothness: 0.5
  };
  Ch = ca;
  const Zg = 8, en = 11920929e-14, Jg = 1, Ys = 0.01, Lr = 0, yr = 0;
  function Rh(i, t, e, r, n, s, o, a, c, u) {
    const h = Math.min(0.99, Math.max(0, u ?? Ch.defaultOptions.bezierSmoothness));
    let f = (Jg - h) / 1;
    return f *= f, Qg(t, e, r, n, s, o, a, c, i, f), i;
  }
  function Qg(i, t, e, r, n, s, o, a, c, u) {
    Do(i, t, e, r, n, s, o, a, c, u, 0), c.push(o, a);
  }
  function Do(i, t, e, r, n, s, o, a, c, u, l) {
    if (l > Zg) return;
    const h = Math.PI, f = (i + e) / 2, p = (t + r) / 2, m = (e + n) / 2, y = (r + s) / 2, b = (n + o) / 2, v = (s + a) / 2, A = (f + m) / 2, T = (p + y) / 2, G = (m + b) / 2, H = (y + v) / 2, Y = (A + G) / 2, L = (T + H) / 2;
    if (l > 0) {
      let W = o - i, C = a - t;
      const I = Math.abs((e - o) * C - (r - a) * W), z = Math.abs((n - o) * C - (s - a) * W);
      let Z, j;
      if (I > en && z > en) {
        if ((I + z) * (I + z) <= u * (W * W + C * C)) {
          if (Lr < Ys) {
            c.push(Y, L);
            return;
          }
          const X = Math.atan2(s - r, n - e);
          if (Z = Math.abs(X - Math.atan2(r - t, e - i)), j = Math.abs(Math.atan2(a - s, o - n) - X), Z >= h && (Z = 2 * h - Z), j >= h && (j = 2 * h - j), Z + j < Lr) {
            c.push(Y, L);
            return;
          }
          if (yr !== 0) {
            if (Z > yr) {
              c.push(e, r);
              return;
            }
            if (j > yr) {
              c.push(n, s);
              return;
            }
          }
        }
      } else if (I > en) {
        if (I * I <= u * (W * W + C * C)) {
          if (Lr < Ys) {
            c.push(Y, L);
            return;
          }
          if (Z = Math.abs(Math.atan2(s - r, n - e) - Math.atan2(r - t, e - i)), Z >= h && (Z = 2 * h - Z), Z < Lr) {
            c.push(e, r), c.push(n, s);
            return;
          }
          if (yr !== 0 && Z > yr) {
            c.push(e, r);
            return;
          }
        }
      } else if (z > en) {
        if (z * z <= u * (W * W + C * C)) {
          if (Lr < Ys) {
            c.push(Y, L);
            return;
          }
          if (Z = Math.abs(Math.atan2(a - s, o - n) - Math.atan2(s - r, n - e)), Z >= h && (Z = 2 * h - Z), Z < Lr) {
            c.push(e, r), c.push(n, s);
            return;
          }
          if (yr !== 0 && Z > yr) {
            c.push(n, s);
            return;
          }
        }
      } else if (W = Y - (i + o) / 2, C = L - (t + a) / 2, W * W + C * C <= u) {
        c.push(Y, L);
        return;
      }
    }
    Do(i, t, f, p, A, T, Y, L, c, u, l + 1), Do(Y, L, G, H, b, v, o, a, c, u, l + 1);
  }
  const tm = 8, em = 11920929e-14, rm = 1, im = 0.01, jc = 0;
  function nm(i, t, e, r, n, s, o, a) {
    const u = Math.min(0.99, Math.max(0, a ?? Ch.defaultOptions.bezierSmoothness));
    let l = (rm - u) / 1;
    return l *= l, sm(t, e, r, n, s, o, i, l), i;
  }
  function sm(i, t, e, r, n, s, o, a) {
    Io(o, i, t, e, r, n, s, a, 0), o.push(n, s);
  }
  function Io(i, t, e, r, n, s, o, a, c) {
    if (c > tm) return;
    const u = Math.PI, l = (t + r) / 2, h = (e + n) / 2, f = (r + s) / 2, p = (n + o) / 2, m = (l + f) / 2, y = (h + p) / 2;
    let b = s - t, v = o - e;
    const A = Math.abs((r - s) * v - (n - o) * b);
    if (A > em) {
      if (A * A <= a * (b * b + v * v)) {
        if (jc < im) {
          i.push(m, y);
          return;
        }
        let T = Math.abs(Math.atan2(o - n, s - r) - Math.atan2(n - e, r - t));
        if (T >= u && (T = 2 * u - T), T < jc) {
          i.push(m, y);
          return;
        }
      }
    } else if (b = m - (t + s) / 2, v = y - (e + o) / 2, b * b + v * v <= a) {
      i.push(m, y);
      return;
    }
    Io(i, t, e, l, h, m, y, a, c + 1), Io(i, m, y, f, p, s, o, a, c + 1);
  }
  function Ph(i, t, e, r, n, s, o, a) {
    let c = Math.abs(n - s);
    (!o && n > s || o && s > n) && (c = 2 * Math.PI - c), a = a || Math.max(6, Math.floor(6 * Math.pow(r, 1 / 3) * (c / Math.PI))), a = Math.max(a, 3);
    let u = c / a, l = n;
    u *= o ? -1 : 1;
    for (let h = 0; h < a + 1; h++) {
      const f = Math.cos(l), p = Math.sin(l), m = t + f * r, y = e + p * r;
      i.push(m, y), l += u;
    }
  }
  function om(i, t, e, r, n, s) {
    const o = i[i.length - 2], c = i[i.length - 1] - e, u = o - t, l = n - e, h = r - t, f = Math.abs(c * h - u * l);
    if (f < 1e-8 || s === 0) {
      (i[i.length - 2] !== t || i[i.length - 1] !== e) && i.push(t, e);
      return;
    }
    const p = c * c + u * u, m = l * l + h * h, y = c * l + u * h, b = s * Math.sqrt(p) / f, v = s * Math.sqrt(m) / f, A = b * y / p, T = v * y / m, G = b * h + v * u, H = b * l + v * c, Y = u * (v + A), L = c * (v + A), W = h * (b + T), C = l * (b + T), I = Math.atan2(L - H, Y - G), z = Math.atan2(C - H, W - G);
    Ph(i, G + t, H + e, s, I, z, u * l > h * c);
  }
  const vi = Math.PI * 2, Ks = {
    centerX: 0,
    centerY: 0,
    ang1: 0,
    ang2: 0
  }, Zs = ({ x: i, y: t }, e, r, n, s, o, a, c) => {
    i *= e, t *= r;
    const u = n * i - s * t, l = s * i + n * t;
    return c.x = u + o, c.y = l + a, c;
  };
  function am(i, t) {
    const e = t === -1.5707963267948966 ? -0.551915024494 : 1.3333333333333333 * Math.tan(t / 4), r = t === 1.5707963267948966 ? 0.551915024494 : e, n = Math.cos(i), s = Math.sin(i), o = Math.cos(i + t), a = Math.sin(i + t);
    return [
      {
        x: n - s * r,
        y: s + n * r
      },
      {
        x: o + a * r,
        y: a - o * r
      },
      {
        x: o,
        y: a
      }
    ];
  }
  const Wc = (i, t, e, r) => {
    const n = i * r - t * e < 0 ? -1 : 1;
    let s = i * e + t * r;
    return s > 1 && (s = 1), s < -1 && (s = -1), n * Math.acos(s);
  }, cm = (i, t, e, r, n, s, o, a, c, u, l, h, f) => {
    const p = Math.pow(n, 2), m = Math.pow(s, 2), y = Math.pow(l, 2), b = Math.pow(h, 2);
    let v = p * m - p * b - m * y;
    v < 0 && (v = 0), v /= p * b + m * y, v = Math.sqrt(v) * (o === a ? -1 : 1);
    const A = v * n / s * h, T = v * -s / n * l, G = u * A - c * T + (i + e) / 2, H = c * A + u * T + (t + r) / 2, Y = (l - A) / n, L = (h - T) / s, W = (-l - A) / n, C = (-h - T) / s, I = Wc(1, 0, Y, L);
    let z = Wc(Y, L, W, C);
    a === 0 && z > 0 && (z -= vi), a === 1 && z < 0 && (z += vi), f.centerX = G, f.centerY = H, f.ang1 = I, f.ang2 = z;
  };
  function um(i, t, e, r, n, s, o, a = 0, c = 0, u = 0) {
    if (s === 0 || o === 0) return;
    const l = Math.sin(a * vi / 360), h = Math.cos(a * vi / 360), f = h * (t - r) / 2 + l * (e - n) / 2, p = -l * (t - r) / 2 + h * (e - n) / 2;
    if (f === 0 && p === 0) return;
    s = Math.abs(s), o = Math.abs(o);
    const m = Math.pow(f, 2) / Math.pow(s, 2) + Math.pow(p, 2) / Math.pow(o, 2);
    m > 1 && (s *= Math.sqrt(m), o *= Math.sqrt(m)), cm(t, e, r, n, s, o, c, u, l, h, f, p, Ks);
    let { ang1: y, ang2: b } = Ks;
    const { centerX: v, centerY: A } = Ks;
    let T = Math.abs(b) / (vi / 4);
    Math.abs(1 - T) < 1e-7 && (T = 1);
    const G = Math.max(Math.ceil(T), 1);
    b /= G;
    let H = i[i.length - 2], Y = i[i.length - 1];
    const L = {
      x: 0,
      y: 0
    };
    for (let W = 0; W < G; W++) {
      const C = am(y, b), { x: I, y: z } = Zs(C[0], s, o, h, l, v, A, L), { x: Z, y: j } = Zs(C[1], s, o, h, l, v, A, L), { x: X, y: Q } = Zs(C[2], s, o, h, l, v, A, L);
      Rh(i, H, Y, I, z, Z, j, X, Q), H = X, Y = Q, y += b;
    }
  }
  function lm(i, t, e) {
    const r = (o, a) => {
      const c = a.x - o.x, u = a.y - o.y, l = Math.sqrt(c * c + u * u), h = c / l, f = u / l;
      return {
        len: l,
        nx: h,
        ny: f
      };
    }, n = (o, a) => {
      o === 0 ? i.moveTo(a.x, a.y) : i.lineTo(a.x, a.y);
    };
    let s = t[t.length - 1];
    for (let o = 0; o < t.length; o++) {
      const a = t[o % t.length], c = a.radius ?? e;
      if (c <= 0) {
        n(o, a), s = a;
        continue;
      }
      const u = t[(o + 1) % t.length], l = r(a, s), h = r(a, u);
      if (l.len < 1e-4 || h.len < 1e-4) {
        n(o, a), s = a;
        continue;
      }
      let f = Math.asin(l.nx * h.ny - l.ny * h.nx), p = 1, m = false;
      l.nx * h.nx - l.ny * -h.ny < 0 ? f < 0 ? f = Math.PI + f : (f = Math.PI - f, p = -1, m = true) : f > 0 && (p = -1, m = true);
      const y = f / 2;
      let b, v = Math.abs(Math.cos(y) * c / Math.sin(y));
      v > Math.min(l.len / 2, h.len / 2) ? (v = Math.min(l.len / 2, h.len / 2), b = Math.abs(v * Math.sin(y) / Math.cos(y))) : b = c;
      const A = a.x + h.nx * v + -h.ny * b * p, T = a.y + h.ny * v + h.nx * b * p, G = Math.atan2(l.ny, l.nx) + Math.PI / 2 * p, H = Math.atan2(h.ny, h.nx) - Math.PI / 2 * p;
      o === 0 && i.moveTo(A + Math.cos(G) * b, T + Math.sin(G) * b), i.arc(A, T, b, G, H, m), s = a;
    }
  }
  function hm(i, t, e, r) {
    const n = (a, c) => Math.sqrt((a.x - c.x) ** 2 + (a.y - c.y) ** 2), s = (a, c, u) => ({
      x: a.x + (c.x - a.x) * u,
      y: a.y + (c.y - a.y) * u
    }), o = t.length;
    for (let a = 0; a < o; a++) {
      const c = t[(a + 1) % o], u = c.radius ?? e;
      if (u <= 0) {
        a === 0 ? i.moveTo(c.x, c.y) : i.lineTo(c.x, c.y);
        continue;
      }
      const l = t[a], h = t[(a + 2) % o], f = n(l, c);
      let p;
      if (f < 1e-4) p = c;
      else {
        const b = Math.min(f / 2, u);
        p = s(c, l, b / f);
      }
      const m = n(h, c);
      let y;
      if (m < 1e-4) y = c;
      else {
        const b = Math.min(m / 2, u);
        y = s(c, h, b / m);
      }
      a === 0 ? i.moveTo(p.x, p.y) : i.lineTo(p.x, p.y), i.quadraticCurveTo(c.x, c.y, y.x, y.y, r);
    }
  }
  const dm = new Et();
  class fm {
    constructor(t) {
      this.shapePrimitives = [], this._currentPoly = null, this._bounds = new re(), this._graphicsPath2D = t;
    }
    moveTo(t, e) {
      return this.startPoly(t, e), this;
    }
    lineTo(t, e) {
      this._ensurePoly();
      const r = this._currentPoly.points, n = r[r.length - 2], s = r[r.length - 1];
      return (n !== t || s !== e) && r.push(t, e), this;
    }
    arc(t, e, r, n, s, o) {
      this._ensurePoly(false);
      const a = this._currentPoly.points;
      return Ph(a, t, e, r, n, s, o), this;
    }
    arcTo(t, e, r, n, s) {
      this._ensurePoly();
      const o = this._currentPoly.points;
      return om(o, t, e, r, n, s), this;
    }
    arcToSvg(t, e, r, n, s, o, a) {
      const c = this._currentPoly.points;
      return um(c, this._currentPoly.lastX, this._currentPoly.lastY, o, a, t, e, r, n, s), this;
    }
    bezierCurveTo(t, e, r, n, s, o, a) {
      this._ensurePoly();
      const c = this._currentPoly;
      return Rh(this._currentPoly.points, c.lastX, c.lastY, t, e, r, n, s, o, a), this;
    }
    quadraticCurveTo(t, e, r, n, s) {
      this._ensurePoly();
      const o = this._currentPoly;
      return nm(this._currentPoly.points, o.lastX, o.lastY, t, e, r, n, s), this;
    }
    closePath() {
      return this.endPoly(true), this;
    }
    addPath(t, e) {
      this.endPoly(), e && !e.isIdentity() && (t = t.clone(true), t.transform(e));
      for (let r = 0; r < t.instructions.length; r++) {
        const n = t.instructions[r];
        this[n.action](...n.data);
      }
      return this;
    }
    finish(t = false) {
      this.endPoly(t);
    }
    rect(t, e, r, n, s) {
      return this.drawShape(new Et(t, e, r, n), s), this;
    }
    circle(t, e, r, n) {
      return this.drawShape(new ia(t, e, r), n), this;
    }
    poly(t, e, r) {
      const n = new xi(t);
      return n.closePath = e, this.drawShape(n, r), this;
    }
    regularPoly(t, e, r, n, s = 0, o) {
      n = Math.max(n | 0, 3);
      const a = -1 * Math.PI / 2 + s, c = Math.PI * 2 / n, u = [];
      for (let l = 0; l < n; l++) {
        const h = l * c + a;
        u.push(t + r * Math.cos(h), e + r * Math.sin(h));
      }
      return this.poly(u, true, o), this;
    }
    roundPoly(t, e, r, n, s, o = 0, a) {
      if (n = Math.max(n | 0, 3), s <= 0) return this.regularPoly(t, e, r, n, o);
      const c = r * Math.sin(Math.PI / n) - 1e-3;
      s = Math.min(s, c);
      const u = -1 * Math.PI / 2 + o, l = Math.PI * 2 / n, h = (n - 2) * Math.PI / n / 2;
      for (let f = 0; f < n; f++) {
        const p = f * l + u, m = t + r * Math.cos(p), y = e + r * Math.sin(p), b = p + Math.PI + h, v = p - Math.PI - h, A = m + s * Math.cos(b), T = y + s * Math.sin(b), G = m + s * Math.cos(v), H = y + s * Math.sin(v);
        f === 0 ? this.moveTo(A, T) : this.lineTo(A, T), this.quadraticCurveTo(m, y, G, H, a);
      }
      return this.closePath();
    }
    roundShape(t, e, r = false, n) {
      return t.length < 3 ? this : (r ? hm(this, t, e, n) : lm(this, t, e), this.closePath());
    }
    filletRect(t, e, r, n, s) {
      if (s === 0) return this.rect(t, e, r, n);
      const o = Math.min(r, n) / 2, a = Math.min(o, Math.max(-o, s)), c = t + r, u = e + n, l = a < 0 ? -a : 0, h = Math.abs(a);
      return this.moveTo(t, e + h).arcTo(t + l, e + l, t + h, e, h).lineTo(c - h, e).arcTo(c - l, e + l, c, e + h, h).lineTo(c, u - h).arcTo(c - l, u - l, t + r - h, u, h).lineTo(t + h, u).arcTo(t + l, u - l, t, u - h, h).closePath();
    }
    chamferRect(t, e, r, n, s, o) {
      if (s <= 0) return this.rect(t, e, r, n);
      const a = Math.min(s, Math.min(r, n) / 2), c = t + r, u = e + n, l = [
        t + a,
        e,
        c - a,
        e,
        c,
        e + a,
        c,
        u - a,
        c - a,
        u,
        t + a,
        u,
        t,
        u - a,
        t,
        e + a
      ];
      for (let h = l.length - 1; h >= 2; h -= 2) l[h] === l[h - 2] && l[h - 1] === l[h - 3] && l.splice(h - 1, 2);
      return this.poly(l, true, o);
    }
    ellipse(t, e, r, n, s) {
      return this.drawShape(new na(t, e, r, n), s), this;
    }
    roundRect(t, e, r, n, s, o) {
      return this.drawShape(new sa(t, e, r, n, s), o), this;
    }
    drawShape(t, e) {
      return this.endPoly(), this.shapePrimitives.push({
        shape: t,
        transform: e
      }), this;
    }
    startPoly(t, e) {
      let r = this._currentPoly;
      return r && this.endPoly(), r = new xi(), r.points.push(t, e), this._currentPoly = r, this;
    }
    endPoly(t = false) {
      const e = this._currentPoly;
      return e && e.points.length > 2 && (e.closePath = t, this.shapePrimitives.push({
        shape: e
      })), this._currentPoly = null, this;
    }
    _ensurePoly(t = true) {
      if (!this._currentPoly && (this._currentPoly = new xi(), t)) {
        const e = this.shapePrimitives[this.shapePrimitives.length - 1];
        if (e) {
          let r = e.shape.x, n = e.shape.y;
          if (e.transform && !e.transform.isIdentity()) {
            const s = e.transform, o = r;
            r = s.a * r + s.c * n + s.tx, n = s.b * o + s.d * n + s.ty;
          }
          this._currentPoly.points.push(r, n);
        } else this._currentPoly.points.push(0, 0);
      }
    }
    buildPath() {
      const t = this._graphicsPath2D;
      this.shapePrimitives.length = 0, this._currentPoly = null;
      for (let e = 0; e < t.instructions.length; e++) {
        const r = t.instructions[e];
        this[r.action](...r.data);
      }
      this.finish();
    }
    get bounds() {
      const t = this._bounds;
      t.clear();
      const e = this.shapePrimitives;
      for (let r = 0; r < e.length; r++) {
        const n = e[r], s = n.shape.getBounds(dm);
        n.transform ? t.addRect(s, n.transform) : t.addRect(s);
      }
      return t;
    }
  }
  class Zr {
    constructor(t) {
      this.instructions = [], this.uid = Ot("graphicsPath"), this._dirty = true, typeof t == "string" ? yg(t, this) : this.instructions = (t == null ? void 0 : t.slice()) ?? [];
    }
    get shapePath() {
      return this._shapePath || (this._shapePath = new fm(this)), this._dirty && (this._dirty = false, this._shapePath.buildPath()), this._shapePath;
    }
    addPath(t, e) {
      return t = t.clone(), this.instructions.push({
        action: "addPath",
        data: [
          t,
          e
        ]
      }), this._dirty = true, this;
    }
    arc(...t) {
      return this.instructions.push({
        action: "arc",
        data: t
      }), this._dirty = true, this;
    }
    arcTo(...t) {
      return this.instructions.push({
        action: "arcTo",
        data: t
      }), this._dirty = true, this;
    }
    arcToSvg(...t) {
      return this.instructions.push({
        action: "arcToSvg",
        data: t
      }), this._dirty = true, this;
    }
    bezierCurveTo(...t) {
      return this.instructions.push({
        action: "bezierCurveTo",
        data: t
      }), this._dirty = true, this;
    }
    bezierCurveToShort(t, e, r, n, s) {
      const o = this.instructions[this.instructions.length - 1], a = this.getLastPoint(Ct.shared);
      let c = 0, u = 0;
      if (!o || o.action !== "bezierCurveTo") c = a.x, u = a.y;
      else {
        c = o.data[2], u = o.data[3];
        const l = a.x, h = a.y;
        c = l + (l - c), u = h + (h - u);
      }
      return this.instructions.push({
        action: "bezierCurveTo",
        data: [
          c,
          u,
          t,
          e,
          r,
          n,
          s
        ]
      }), this._dirty = true, this;
    }
    closePath() {
      return this.instructions.push({
        action: "closePath",
        data: []
      }), this._dirty = true, this;
    }
    ellipse(...t) {
      return this.instructions.push({
        action: "ellipse",
        data: t
      }), this._dirty = true, this;
    }
    lineTo(...t) {
      return this.instructions.push({
        action: "lineTo",
        data: t
      }), this._dirty = true, this;
    }
    moveTo(...t) {
      return this.instructions.push({
        action: "moveTo",
        data: t
      }), this;
    }
    quadraticCurveTo(...t) {
      return this.instructions.push({
        action: "quadraticCurveTo",
        data: t
      }), this._dirty = true, this;
    }
    quadraticCurveToShort(t, e, r) {
      const n = this.instructions[this.instructions.length - 1], s = this.getLastPoint(Ct.shared);
      let o = 0, a = 0;
      if (!n || n.action !== "quadraticCurveTo") o = s.x, a = s.y;
      else {
        o = n.data[0], a = n.data[1];
        const c = s.x, u = s.y;
        o = c + (c - o), a = u + (u - a);
      }
      return this.instructions.push({
        action: "quadraticCurveTo",
        data: [
          o,
          a,
          t,
          e,
          r
        ]
      }), this._dirty = true, this;
    }
    rect(t, e, r, n, s) {
      return this.instructions.push({
        action: "rect",
        data: [
          t,
          e,
          r,
          n,
          s
        ]
      }), this._dirty = true, this;
    }
    circle(t, e, r, n) {
      return this.instructions.push({
        action: "circle",
        data: [
          t,
          e,
          r,
          n
        ]
      }), this._dirty = true, this;
    }
    roundRect(...t) {
      return this.instructions.push({
        action: "roundRect",
        data: t
      }), this._dirty = true, this;
    }
    poly(...t) {
      return this.instructions.push({
        action: "poly",
        data: t
      }), this._dirty = true, this;
    }
    regularPoly(...t) {
      return this.instructions.push({
        action: "regularPoly",
        data: t
      }), this._dirty = true, this;
    }
    roundPoly(...t) {
      return this.instructions.push({
        action: "roundPoly",
        data: t
      }), this._dirty = true, this;
    }
    roundShape(...t) {
      return this.instructions.push({
        action: "roundShape",
        data: t
      }), this._dirty = true, this;
    }
    filletRect(...t) {
      return this.instructions.push({
        action: "filletRect",
        data: t
      }), this._dirty = true, this;
    }
    chamferRect(...t) {
      return this.instructions.push({
        action: "chamferRect",
        data: t
      }), this._dirty = true, this;
    }
    star(t, e, r, n, s, o, a) {
      s = s || n / 2;
      const c = -1 * Math.PI / 2 + o, u = r * 2, l = Math.PI * 2 / u, h = [];
      for (let f = 0; f < u; f++) {
        const p = f % 2 ? s : n, m = f * l + c;
        h.push(t + p * Math.cos(m), e + p * Math.sin(m));
      }
      return this.poly(h, true, a), this;
    }
    clone(t = false) {
      const e = new Zr();
      if (!t) e.instructions = this.instructions.slice();
      else for (let r = 0; r < this.instructions.length; r++) {
        const n = this.instructions[r];
        e.instructions.push({
          action: n.action,
          data: n.data.slice()
        });
      }
      return e;
    }
    clear() {
      return this.instructions.length = 0, this._dirty = true, this;
    }
    transform(t) {
      if (t.isIdentity()) return this;
      const e = t.a, r = t.b, n = t.c, s = t.d, o = t.tx, a = t.ty;
      let c = 0, u = 0, l = 0, h = 0, f = 0, p = 0, m = 0, y = 0;
      for (let b = 0; b < this.instructions.length; b++) {
        const v = this.instructions[b], A = v.data;
        switch (v.action) {
          case "moveTo":
          case "lineTo":
            c = A[0], u = A[1], A[0] = e * c + n * u + o, A[1] = r * c + s * u + a;
            break;
          case "bezierCurveTo":
            l = A[0], h = A[1], f = A[2], p = A[3], c = A[4], u = A[5], A[0] = e * l + n * h + o, A[1] = r * l + s * h + a, A[2] = e * f + n * p + o, A[3] = r * f + s * p + a, A[4] = e * c + n * u + o, A[5] = r * c + s * u + a;
            break;
          case "quadraticCurveTo":
            l = A[0], h = A[1], c = A[2], u = A[3], A[0] = e * l + n * h + o, A[1] = r * l + s * h + a, A[2] = e * c + n * u + o, A[3] = r * c + s * u + a;
            break;
          case "arcToSvg":
            c = A[5], u = A[6], m = A[0], y = A[1], A[0] = e * m + n * y, A[1] = r * m + s * y, A[5] = e * c + n * u + o, A[6] = r * c + s * u + a;
            break;
          case "circle":
            A[4] = ci(A[3], t);
            break;
          case "rect":
            A[4] = ci(A[4], t);
            break;
          case "ellipse":
            A[8] = ci(A[8], t);
            break;
          case "roundRect":
            A[5] = ci(A[5], t);
            break;
          case "addPath":
            A[0].transform(t);
            break;
          case "poly":
            A[2] = ci(A[2], t);
            break;
          default:
            ut("unknown transform action", v.action);
            break;
        }
      }
      return this._dirty = true, this;
    }
    get bounds() {
      return this.shapePath.bounds;
    }
    getLastPoint(t) {
      let e = this.instructions.length - 1, r = this.instructions[e];
      if (!r) return t.x = 0, t.y = 0, t;
      for (; r.action === "closePath"; ) {
        if (e--, e < 0) return t.x = 0, t.y = 0, t;
        r = this.instructions[e];
      }
      switch (r.action) {
        case "moveTo":
        case "lineTo":
          t.x = r.data[0], t.y = r.data[1];
          break;
        case "quadraticCurveTo":
          t.x = r.data[2], t.y = r.data[3];
          break;
        case "bezierCurveTo":
          t.x = r.data[4], t.y = r.data[5];
          break;
        case "arc":
        case "arcToSvg":
          t.x = r.data[5], t.y = r.data[6];
          break;
        case "addPath":
          r.data[0].getLastPoint(t);
          break;
      }
      return t;
    }
  }
  function ci(i, t) {
    return i ? i.prepend(t) : t.clone();
  }
  function pm(i, t) {
    if (typeof i == "string") {
      const r = document.createElement("div");
      r.innerHTML = i.trim(), i = r.querySelector("svg");
    }
    const e = {
      context: t,
      path: new Zr()
    };
    return Bh(i, e, null, null), t;
  }
  function Bh(i, t, e, r) {
    const n = i.children, { fillStyle: s, strokeStyle: o } = _m(i);
    s && e ? e = {
      ...e,
      ...s
    } : s && (e = s), o && r ? r = {
      ...r,
      ...o
    } : o && (r = o), t.context.fillStyle = e, t.context.strokeStyle = r;
    let a, c, u, l, h, f, p, m, y, b, v, A, T, G, H, Y, L;
    switch (i.nodeName.toLowerCase()) {
      case "path":
        G = i.getAttribute("d"), H = new Zr(G), t.context.path(H), e && t.context.fill(), r && t.context.stroke();
        break;
      case "circle":
        p = $t(i, "cx", 0), m = $t(i, "cy", 0), y = $t(i, "r", 0), t.context.ellipse(p, m, y, y), e && t.context.fill(), r && t.context.stroke();
        break;
      case "rect":
        a = $t(i, "x", 0), c = $t(i, "y", 0), Y = $t(i, "width", 0), L = $t(i, "height", 0), b = $t(i, "rx", 0), v = $t(i, "ry", 0), b || v ? t.context.roundRect(a, c, Y, L, b || v) : t.context.rect(a, c, Y, L), e && t.context.fill(), r && t.context.stroke();
        break;
      case "ellipse":
        p = $t(i, "cx", 0), m = $t(i, "cy", 0), b = $t(i, "rx", 0), v = $t(i, "ry", 0), t.context.beginPath(), t.context.ellipse(p, m, b, v), e && t.context.fill(), r && t.context.stroke();
        break;
      case "line":
        u = $t(i, "x1", 0), l = $t(i, "y1", 0), h = $t(i, "x2", 0), f = $t(i, "y2", 0), t.context.beginPath(), t.context.moveTo(u, l), t.context.lineTo(h, f), r && t.context.stroke();
        break;
      case "polygon":
        T = i.getAttribute("points"), A = T.match(/\d+/g).map((W) => parseInt(W, 10)), t.context.poly(A, true), e && t.context.fill(), r && t.context.stroke();
        break;
      case "polyline":
        T = i.getAttribute("points"), A = T.match(/\d+/g).map((W) => parseInt(W, 10)), t.context.poly(A, false), r && t.context.stroke();
        break;
      case "g":
      case "svg":
        break;
      default: {
        console.info(`[SVG parser] <${i.nodeName}> elements unsupported`);
        break;
      }
    }
    for (let W = 0; W < n.length; W++) Bh(n[W], t, e, r);
  }
  function $t(i, t, e) {
    const r = i.getAttribute(t);
    return r ? Number(r) : e;
  }
  function _m(i) {
    const t = i.getAttribute("style"), e = {}, r = {};
    let n = false, s = false;
    if (t) {
      const o = t.split(";");
      for (let a = 0; a < o.length; a++) {
        const c = o[a], [u, l] = c.split(":");
        switch (u) {
          case "stroke":
            l !== "none" && (e.color = At.shared.setValue(l).toNumber(), s = true);
            break;
          case "stroke-width":
            e.width = Number(l);
            break;
          case "fill":
            l !== "none" && (n = true, r.color = At.shared.setValue(l).toNumber());
            break;
          case "fill-opacity":
            r.alpha = Number(l);
            break;
          case "stroke-opacity":
            e.alpha = Number(l);
            break;
          case "opacity":
            r.alpha = Number(l), e.alpha = Number(l);
            break;
        }
      }
    } else {
      const o = i.getAttribute("stroke");
      o && o !== "none" && (s = true, e.color = At.shared.setValue(o).toNumber(), e.width = $t(i, "stroke-width", 1));
      const a = i.getAttribute("fill");
      a && a !== "none" && (n = true, r.color = At.shared.setValue(a).toNumber());
    }
    return {
      strokeStyle: s ? e : null,
      fillStyle: n ? r : null
    };
  }
  function gm(i) {
    return At.isColorLike(i);
  }
  function Vc(i) {
    return i instanceof Zn;
  }
  function Xc(i) {
    return i instanceof Ci;
  }
  function mm(i, t, e) {
    const r = At.shared.setValue(t ?? 0);
    return i.color = r.toNumber(), i.alpha = r.alpha === 1 ? e.alpha : r.alpha, i.texture = J.WHITE, {
      ...e,
      ...i
    };
  }
  function qc(i, t, e) {
    return i.fill = t, i.color = 16777215, i.texture = t.texture, i.matrix = t.transform, {
      ...e,
      ...i
    };
  }
  function $c(i, t, e) {
    return t.buildLinearGradient(), i.fill = t, i.color = 16777215, i.texture = t.texture, i.matrix = t.transform, {
      ...e,
      ...i
    };
  }
  function bm(i, t) {
    var _a2;
    const e = {
      ...t,
      ...i
    };
    if (e.texture) {
      if (e.texture !== J.WHITE) {
        const s = ((_a2 = e.matrix) == null ? void 0 : _a2.invert()) || new nt();
        s.translate(e.texture.frame.x, e.texture.frame.y), s.scale(1 / e.texture.source.width, 1 / e.texture.source.height), e.matrix = s;
      }
      const n = e.texture.source.style;
      n.addressMode === "clamp-to-edge" && (n.addressMode = "repeat", n.update());
    }
    const r = At.shared.setValue(e.color);
    return e.alpha *= r.alpha, e.color = r.toNumber(), e.matrix = e.matrix ? e.matrix.clone() : null, e;
  }
  function Rr(i, t) {
    if (i == null) return null;
    const e = {}, r = i;
    return gm(i) ? mm(e, i, t) : Vc(i) ? qc(e, i, t) : Xc(i) ? $c(e, i, t) : r.fill && Vc(r.fill) ? qc(r, r.fill, t) : r.fill && Xc(r.fill) ? $c(r, r.fill, t) : bm(r, t);
  }
  function In(i, t) {
    const { width: e, alignment: r, miterLimit: n, cap: s, join: o, ...a } = t, c = Rr(i, a);
    return c ? {
      width: e,
      alignment: r,
      miterLimit: n,
      cap: s,
      join: o,
      ...c
    } : null;
  }
  const wm = new Ct(), Yc = new nt(), ua = class Ue extends me {
    constructor() {
      super(...arguments), this.uid = Ot("graphicsContext"), this.dirty = true, this.batchMode = "auto", this.instructions = [], this._activePath = new Zr(), this._transform = new nt(), this._fillStyle = {
        ...Ue.defaultFillStyle
      }, this._strokeStyle = {
        ...Ue.defaultStrokeStyle
      }, this._stateStack = [], this._tick = 0, this._bounds = new re(), this._boundsDirty = true;
    }
    clone() {
      const t = new Ue();
      return t.batchMode = this.batchMode, t.instructions = this.instructions.slice(), t._activePath = this._activePath.clone(), t._transform = this._transform.clone(), t._fillStyle = {
        ...this._fillStyle
      }, t._strokeStyle = {
        ...this._strokeStyle
      }, t._stateStack = this._stateStack.slice(), t._bounds = this._bounds.clone(), t._boundsDirty = true, t;
    }
    get fillStyle() {
      return this._fillStyle;
    }
    set fillStyle(t) {
      this._fillStyle = Rr(t, Ue.defaultFillStyle);
    }
    get strokeStyle() {
      return this._strokeStyle;
    }
    set strokeStyle(t) {
      this._strokeStyle = In(t, Ue.defaultStrokeStyle);
    }
    setFillStyle(t) {
      return this._fillStyle = Rr(t, Ue.defaultFillStyle), this;
    }
    setStrokeStyle(t) {
      return this._strokeStyle = Rr(t, Ue.defaultStrokeStyle), this;
    }
    texture(t, e, r, n, s, o) {
      return this.instructions.push({
        action: "texture",
        data: {
          image: t,
          dx: r || 0,
          dy: n || 0,
          dw: s || t.frame.width,
          dh: o || t.frame.height,
          transform: this._transform.clone(),
          alpha: this._fillStyle.alpha,
          style: e ? At.shared.setValue(e).toNumber() : 16777215
        }
      }), this.onUpdate(), this;
    }
    beginPath() {
      return this._activePath = new Zr(), this;
    }
    fill(t, e) {
      let r;
      const n = this.instructions[this.instructions.length - 1];
      return this._tick === 0 && n && n.action === "stroke" ? r = n.data.path : r = this._activePath.clone(), r ? (t != null && (e !== void 0 && typeof t == "number" && (lt(dt, "GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead"), t = {
        color: t,
        alpha: e
      }), this._fillStyle = Rr(t, Ue.defaultFillStyle)), this.instructions.push({
        action: "fill",
        data: {
          style: this.fillStyle,
          path: r
        }
      }), this.onUpdate(), this._initNextPathLocation(), this._tick = 0, this) : this;
    }
    _initNextPathLocation() {
      const { x: t, y: e } = this._activePath.getLastPoint(Ct.shared);
      this._activePath.clear(), this._activePath.moveTo(t, e);
    }
    stroke(t) {
      let e;
      const r = this.instructions[this.instructions.length - 1];
      return this._tick === 0 && r && r.action === "fill" ? e = r.data.path : e = this._activePath.clone(), e ? (t != null && (this._strokeStyle = In(t, Ue.defaultStrokeStyle)), this.instructions.push({
        action: "stroke",
        data: {
          style: this.strokeStyle,
          path: e
        }
      }), this.onUpdate(), this._initNextPathLocation(), this._tick = 0, this) : this;
    }
    cut() {
      for (let t = 0; t < 2; t++) {
        const e = this.instructions[this.instructions.length - 1 - t], r = this._activePath.clone();
        if (e && (e.action === "stroke" || e.action === "fill")) if (e.data.hole) e.data.hole.addPath(r);
        else {
          e.data.hole = r;
          break;
        }
      }
      return this._initNextPathLocation(), this;
    }
    arc(t, e, r, n, s, o) {
      this._tick++;
      const a = this._transform;
      return this._activePath.arc(a.a * t + a.c * e + a.tx, a.b * t + a.d * e + a.ty, r, n, s, o), this;
    }
    arcTo(t, e, r, n, s) {
      this._tick++;
      const o = this._transform;
      return this._activePath.arcTo(o.a * t + o.c * e + o.tx, o.b * t + o.d * e + o.ty, o.a * r + o.c * n + o.tx, o.b * r + o.d * n + o.ty, s), this;
    }
    arcToSvg(t, e, r, n, s, o, a) {
      this._tick++;
      const c = this._transform;
      return this._activePath.arcToSvg(t, e, r, n, s, c.a * o + c.c * a + c.tx, c.b * o + c.d * a + c.ty), this;
    }
    bezierCurveTo(t, e, r, n, s, o, a) {
      this._tick++;
      const c = this._transform;
      return this._activePath.bezierCurveTo(c.a * t + c.c * e + c.tx, c.b * t + c.d * e + c.ty, c.a * r + c.c * n + c.tx, c.b * r + c.d * n + c.ty, c.a * s + c.c * o + c.tx, c.b * s + c.d * o + c.ty, a), this;
    }
    closePath() {
      var _a2;
      return this._tick++, (_a2 = this._activePath) == null ? void 0 : _a2.closePath(), this;
    }
    ellipse(t, e, r, n) {
      return this._tick++, this._activePath.ellipse(t, e, r, n, this._transform.clone()), this;
    }
    circle(t, e, r) {
      return this._tick++, this._activePath.circle(t, e, r, this._transform.clone()), this;
    }
    path(t) {
      return this._tick++, this._activePath.addPath(t, this._transform.clone()), this;
    }
    lineTo(t, e) {
      this._tick++;
      const r = this._transform;
      return this._activePath.lineTo(r.a * t + r.c * e + r.tx, r.b * t + r.d * e + r.ty), this;
    }
    moveTo(t, e) {
      this._tick++;
      const r = this._transform, n = this._activePath.instructions, s = r.a * t + r.c * e + r.tx, o = r.b * t + r.d * e + r.ty;
      return n.length === 1 && n[0].action === "moveTo" ? (n[0].data[0] = s, n[0].data[1] = o, this) : (this._activePath.moveTo(s, o), this);
    }
    quadraticCurveTo(t, e, r, n, s) {
      this._tick++;
      const o = this._transform;
      return this._activePath.quadraticCurveTo(o.a * t + o.c * e + o.tx, o.b * t + o.d * e + o.ty, o.a * r + o.c * n + o.tx, o.b * r + o.d * n + o.ty, s), this;
    }
    rect(t, e, r, n) {
      return this._tick++, this._activePath.rect(t, e, r, n, this._transform.clone()), this;
    }
    roundRect(t, e, r, n, s) {
      return this._tick++, this._activePath.roundRect(t, e, r, n, s, this._transform.clone()), this;
    }
    poly(t, e) {
      return this._tick++, this._activePath.poly(t, e, this._transform.clone()), this;
    }
    regularPoly(t, e, r, n, s = 0, o) {
      return this._tick++, this._activePath.regularPoly(t, e, r, n, s, o), this;
    }
    roundPoly(t, e, r, n, s, o) {
      return this._tick++, this._activePath.roundPoly(t, e, r, n, s, o), this;
    }
    roundShape(t, e, r, n) {
      return this._tick++, this._activePath.roundShape(t, e, r, n), this;
    }
    filletRect(t, e, r, n, s) {
      return this._tick++, this._activePath.filletRect(t, e, r, n, s), this;
    }
    chamferRect(t, e, r, n, s, o) {
      return this._tick++, this._activePath.chamferRect(t, e, r, n, s, o), this;
    }
    star(t, e, r, n, s = 0, o = 0) {
      return this._tick++, this._activePath.star(t, e, r, n, s, o, this._transform.clone()), this;
    }
    svg(t) {
      return this._tick++, pm(t, this), this;
    }
    restore() {
      const t = this._stateStack.pop();
      return t && (this._transform = t.transform, this._fillStyle = t.fillStyle, this._strokeStyle = t.strokeStyle), this;
    }
    save() {
      return this._stateStack.push({
        transform: this._transform.clone(),
        fillStyle: {
          ...this._fillStyle
        },
        strokeStyle: {
          ...this._strokeStyle
        }
      }), this;
    }
    getTransform() {
      return this._transform;
    }
    resetTransform() {
      return this._transform.identity(), this;
    }
    rotate(t) {
      return this._transform.rotate(t), this;
    }
    scale(t, e = t) {
      return this._transform.scale(t, e), this;
    }
    setTransform(t, e, r, n, s, o) {
      return t instanceof nt ? (this._transform.set(t.a, t.b, t.c, t.d, t.tx, t.ty), this) : (this._transform.set(t, e, r, n, s, o), this);
    }
    transform(t, e, r, n, s, o) {
      return t instanceof nt ? (this._transform.append(t), this) : (Yc.set(t, e, r, n, s, o), this._transform.append(Yc), this);
    }
    translate(t, e = t) {
      return this._transform.translate(t, e), this;
    }
    clear() {
      return this._activePath.clear(), this.instructions.length = 0, this.resetTransform(), this.onUpdate(), this;
    }
    onUpdate() {
      this.dirty || (this.emit("update", this, 16), this.dirty = true, this._boundsDirty = true);
    }
    get bounds() {
      if (!this._boundsDirty) return this._bounds;
      const t = this._bounds;
      t.clear();
      for (let e = 0; e < this.instructions.length; e++) {
        const r = this.instructions[e], n = r.action;
        if (n === "fill") {
          const s = r.data;
          t.addBounds(s.path.bounds);
        } else if (n === "texture") {
          const s = r.data;
          t.addFrame(s.dx, s.dy, s.dx + s.dw, s.dy + s.dh, s.transform);
        }
        if (n === "stroke") {
          const s = r.data, o = s.style.width / 2, a = s.path.bounds;
          t.addFrame(a.minX - o, a.minY - o, a.maxX + o, a.maxY + o);
        }
      }
      return t;
    }
    containsPoint(t) {
      var _a2;
      if (!this.bounds.containsPoint(t.x, t.y)) return false;
      const e = this.instructions;
      let r = false;
      for (let n = 0; n < e.length; n++) {
        const s = e[n], o = s.data, a = o.path;
        if (!s.action || !a) continue;
        const c = o.style, u = a.shapePath.shapePrimitives;
        for (let l = 0; l < u.length; l++) {
          const h = u[l].shape;
          if (!c || !h) continue;
          const f = u[l].transform, p = f ? f.applyInverse(t, wm) : t;
          s.action === "fill" ? r = h.contains(p.x, p.y) : r = h.strokeContains(p.x, p.y, c.width);
          const m = o.hole;
          if (m) {
            const y = (_a2 = m.shapePath) == null ? void 0 : _a2.shapePrimitives;
            if (y) for (let b = 0; b < y.length; b++) y[b].shape.contains(p.x, p.y) && (r = false);
          }
          if (r) return true;
        }
      }
      return r;
    }
    destroy(t = false) {
      if (this._stateStack.length = 0, this._transform = null, this.emit("destroy", this), this.removeAllListeners(), typeof t == "boolean" ? t : t == null ? void 0 : t.texture) {
        const r = typeof t == "boolean" ? t : t == null ? void 0 : t.textureSource;
        this._fillStyle.texture && this._fillStyle.texture.destroy(r), this._strokeStyle.texture && this._strokeStyle.texture.destroy(r);
      }
      this._fillStyle = null, this._strokeStyle = null, this.instructions = null, this._activePath = null, this._bounds = null, this._stateStack = null, this.customShader = null, this._transform = null;
    }
  };
  ua.defaultFillStyle = {
    color: 16777215,
    alpha: 1,
    texture: J.WHITE,
    matrix: null,
    fill: null
  };
  ua.defaultStrokeStyle = {
    width: 1,
    color: 16777215,
    alpha: 1,
    alignment: 0.5,
    miterLimit: 10,
    cap: "butt",
    join: "miter",
    texture: J.WHITE,
    matrix: null,
    fill: null
  };
  let oe = ua;
  const Kc = [
    "align",
    "breakWords",
    "cssOverrides",
    "fontVariant",
    "fontWeight",
    "leading",
    "letterSpacing",
    "lineHeight",
    "padding",
    "textBaseline",
    "trim",
    "whiteSpace",
    "wordWrap",
    "wordWrapWidth",
    "fontFamily",
    "fontStyle",
    "fontSize"
  ];
  function Mh(i) {
    const t = [];
    let e = 0;
    for (let r = 0; r < Kc.length; r++) {
      const n = `_${Kc[r]}`;
      t[e++] = i[n];
    }
    return e = Dh(i._fill, t, e), e = ym(i._stroke, t, e), e = xm(i.dropShadow, t, e), t.join("-");
  }
  function Dh(i, t, e) {
    var _a2;
    return i && (t[e++] = i.color, t[e++] = i.alpha, t[e++] = (_a2 = i.fill) == null ? void 0 : _a2.styleKey), e;
  }
  function ym(i, t, e) {
    return i && (e = Dh(i, t, e), t[e++] = i.width, t[e++] = i.alignment, t[e++] = i.cap, t[e++] = i.join, t[e++] = i.miterLimit), e;
  }
  function xm(i, t, e) {
    return i && (t[e++] = i.alpha, t[e++] = i.angle, t[e++] = i.blur, t[e++] = i.distance, t[e++] = At.shared.setValue(i.color).toNumber()), e;
  }
  const la = class zr extends me {
    constructor(t = {}) {
      super(), vm(t);
      const e = {
        ...zr.defaultTextStyle,
        ...t
      };
      for (const r in e) {
        const n = r;
        this[n] = e[r];
      }
      this.update();
    }
    get align() {
      return this._align;
    }
    set align(t) {
      this._align = t, this.update();
    }
    get breakWords() {
      return this._breakWords;
    }
    set breakWords(t) {
      this._breakWords = t, this.update();
    }
    get dropShadow() {
      return this._dropShadow;
    }
    set dropShadow(t) {
      t !== null && typeof t == "object" ? this._dropShadow = this._createProxy({
        ...zr.defaultDropShadow,
        ...t
      }) : this._dropShadow = t ? this._createProxy({
        ...zr.defaultDropShadow
      }) : null, this.update();
    }
    get fontFamily() {
      return this._fontFamily;
    }
    set fontFamily(t) {
      this._fontFamily = t, this.update();
    }
    get fontSize() {
      return this._fontSize;
    }
    set fontSize(t) {
      typeof t == "string" ? this._fontSize = parseInt(t, 10) : this._fontSize = t, this.update();
    }
    get fontStyle() {
      return this._fontStyle;
    }
    set fontStyle(t) {
      this._fontStyle = t, this.update();
    }
    get fontVariant() {
      return this._fontVariant;
    }
    set fontVariant(t) {
      this._fontVariant = t, this.update();
    }
    get fontWeight() {
      return this._fontWeight;
    }
    set fontWeight(t) {
      this._fontWeight = t, this.update();
    }
    get leading() {
      return this._leading;
    }
    set leading(t) {
      this._leading = t, this.update();
    }
    get letterSpacing() {
      return this._letterSpacing;
    }
    set letterSpacing(t) {
      this._letterSpacing = t, this.update();
    }
    get lineHeight() {
      return this._lineHeight;
    }
    set lineHeight(t) {
      this._lineHeight = t, this.update();
    }
    get padding() {
      return this._padding;
    }
    set padding(t) {
      this._padding = t, this.update();
    }
    get trim() {
      return this._trim;
    }
    set trim(t) {
      this._trim = t, this.update();
    }
    get textBaseline() {
      return this._textBaseline;
    }
    set textBaseline(t) {
      this._textBaseline = t, this.update();
    }
    get whiteSpace() {
      return this._whiteSpace;
    }
    set whiteSpace(t) {
      this._whiteSpace = t, this.update();
    }
    get wordWrap() {
      return this._wordWrap;
    }
    set wordWrap(t) {
      this._wordWrap = t, this.update();
    }
    get wordWrapWidth() {
      return this._wordWrapWidth;
    }
    set wordWrapWidth(t) {
      this._wordWrapWidth = t, this.update();
    }
    get fill() {
      return this._originalFill;
    }
    set fill(t) {
      t !== this._originalFill && (this._originalFill = t, this._isFillStyle(t) && (this._originalFill = this._createProxy({
        ...oe.defaultFillStyle,
        ...t
      }, () => {
        this._fill = Rr({
          ...this._originalFill
        }, oe.defaultFillStyle);
      })), this._fill = Rr(t === 0 ? "black" : t, oe.defaultFillStyle), this.update());
    }
    get stroke() {
      return this._originalStroke;
    }
    set stroke(t) {
      t !== this._originalStroke && (this._originalStroke = t, this._isFillStyle(t) && (this._originalStroke = this._createProxy({
        ...oe.defaultStrokeStyle,
        ...t
      }, () => {
        this._stroke = In({
          ...this._originalStroke
        }, oe.defaultStrokeStyle);
      })), this._stroke = In(t, oe.defaultStrokeStyle), this.update());
    }
    _generateKey() {
      return this._styleKey = Mh(this), this._styleKey;
    }
    update() {
      this._styleKey = null, this.emit("update", this);
    }
    reset() {
      const t = zr.defaultTextStyle;
      for (const e in t) this[e] = t[e];
    }
    get styleKey() {
      return this._styleKey || this._generateKey();
    }
    clone() {
      return new zr({
        align: this.align,
        breakWords: this.breakWords,
        dropShadow: this._dropShadow ? {
          ...this._dropShadow
        } : null,
        fill: this._fill,
        fontFamily: this.fontFamily,
        fontSize: this.fontSize,
        fontStyle: this.fontStyle,
        fontVariant: this.fontVariant,
        fontWeight: this.fontWeight,
        leading: this.leading,
        letterSpacing: this.letterSpacing,
        lineHeight: this.lineHeight,
        padding: this.padding,
        stroke: this._stroke,
        textBaseline: this.textBaseline,
        whiteSpace: this.whiteSpace,
        wordWrap: this.wordWrap,
        wordWrapWidth: this.wordWrapWidth
      });
    }
    destroy(t = false) {
      var _a2, _b2, _c2, _d2;
      if (this.removeAllListeners(), typeof t == "boolean" ? t : t == null ? void 0 : t.texture) {
        const r = typeof t == "boolean" ? t : t == null ? void 0 : t.textureSource;
        ((_a2 = this._fill) == null ? void 0 : _a2.texture) && this._fill.texture.destroy(r), ((_b2 = this._originalFill) == null ? void 0 : _b2.texture) && this._originalFill.texture.destroy(r), ((_c2 = this._stroke) == null ? void 0 : _c2.texture) && this._stroke.texture.destroy(r), ((_d2 = this._originalStroke) == null ? void 0 : _d2.texture) && this._originalStroke.texture.destroy(r);
      }
      this._fill = null, this._stroke = null, this.dropShadow = null, this._originalStroke = null, this._originalFill = null;
    }
    _createProxy(t, e) {
      return new Proxy(t, {
        set: (r, n, s) => (r[n] = s, e == null ? void 0 : e(n, s), this.update(), true)
      });
    }
    _isFillStyle(t) {
      return (t ?? null) !== null && !(At.isColorLike(t) || t instanceof Ci || t instanceof Zn);
    }
  };
  la.defaultDropShadow = {
    alpha: 1,
    angle: Math.PI / 6,
    blur: 0,
    color: "black",
    distance: 5
  };
  la.defaultTextStyle = {
    align: "left",
    breakWords: false,
    dropShadow: null,
    fill: "black",
    fontFamily: "Arial",
    fontSize: 26,
    fontStyle: "normal",
    fontVariant: "normal",
    fontWeight: "normal",
    leading: 0,
    letterSpacing: 0,
    lineHeight: 0,
    padding: 0,
    stroke: null,
    textBaseline: "alphabetic",
    trim: false,
    whiteSpace: "pre",
    wordWrap: false,
    wordWrapWidth: 100
  };
  let Oe = la;
  function vm(i) {
    const t = i;
    if (typeof t.dropShadow == "boolean" && t.dropShadow) {
      const e = Oe.defaultDropShadow;
      i.dropShadow = {
        alpha: t.dropShadowAlpha ?? e.alpha,
        angle: t.dropShadowAngle ?? e.angle,
        blur: t.dropShadowBlur ?? e.blur,
        color: t.dropShadowColor ?? e.color,
        distance: t.dropShadowDistance ?? e.distance
      };
    }
    if (t.strokeThickness !== void 0) {
      lt(dt, "strokeThickness is now a part of stroke");
      const e = t.stroke;
      let r = {};
      if (At.isColorLike(e)) r.color = e;
      else if (e instanceof Ci || e instanceof Zn) r.fill = e;
      else if (Object.hasOwnProperty.call(e, "color") || Object.hasOwnProperty.call(e, "fill")) r = e;
      else throw new Error("Invalid stroke value.");
      i.stroke = {
        ...r,
        width: t.strokeThickness
      };
    }
    if (Array.isArray(t.fillGradientStops)) {
      lt(dt, "gradient fill is now a fill pattern: `new FillGradient(...)`");
      let e;
      i.fontSize == null ? i.fontSize = Oe.defaultTextStyle.fontSize : typeof i.fontSize == "string" ? e = parseInt(i.fontSize, 10) : e = i.fontSize;
      const r = new Ci(0, 0, 0, e * 1.7), n = t.fillGradientStops.map((s) => At.shared.setValue(s).toNumber());
      n.forEach((s, o) => {
        const a = o / (n.length - 1);
        r.addColorStop(a, s);
      }), i.fill = {
        fill: r
      };
    }
  }
  class Sm {
    constructor(t) {
      this._canvasPool = /* @__PURE__ */ Object.create(null), this.canvasOptions = t || {}, this.enableFullScreen = false;
    }
    _createCanvasAndContext(t, e) {
      const r = St.get().createCanvas();
      r.width = t, r.height = e;
      const n = r.getContext("2d");
      return {
        canvas: r,
        context: n
      };
    }
    getOptimalCanvasAndContext(t, e, r = 1) {
      t = Math.ceil(t * r - 1e-6), e = Math.ceil(e * r - 1e-6), t = $r(t), e = $r(e);
      const n = (t << 17) + (e << 1);
      this._canvasPool[n] || (this._canvasPool[n] = []);
      let s = this._canvasPool[n].pop();
      return s || (s = this._createCanvasAndContext(t, e)), s;
    }
    returnCanvasAndContext(t) {
      const e = t.canvas, { width: r, height: n } = e, s = (r << 17) + (n << 1);
      this._canvasPool[s].push(t);
    }
    clear() {
      this._canvasPool = {};
    }
  }
  const Je = new Sm(), Em = [
    "serif",
    "sans-serif",
    "monospace",
    "cursive",
    "fantasy",
    "system-ui"
  ];
  function Fn(i) {
    const t = typeof i.fontSize == "number" ? `${i.fontSize}px` : i.fontSize;
    let e = i.fontFamily;
    Array.isArray(i.fontFamily) || (e = i.fontFamily.split(","));
    for (let r = e.length - 1; r >= 0; r--) {
      let n = e[r].trim();
      !/([\"\'])[^\'\"]+\1/.test(n) && !Em.includes(n) && (n = `"${n}"`), e[r] = n;
    }
    return `${i.fontStyle} ${i.fontVariant} ${i.fontWeight} ${t} ${e.join(",")}`;
  }
  const Js = {
    willReadFrequently: true
  }, Be = class rt {
    static get experimentalLetterSpacingSupported() {
      let t = rt._experimentalLetterSpacingSupported;
      if (t !== void 0) {
        const e = St.get().getCanvasRenderingContext2D().prototype;
        t = rt._experimentalLetterSpacingSupported = "letterSpacing" in e || "textLetterSpacing" in e;
      }
      return t;
    }
    constructor(t, e, r, n, s, o, a, c, u) {
      this.text = t, this.style = e, this.width = r, this.height = n, this.lines = s, this.lineWidths = o, this.lineHeight = a, this.maxLineWidth = c, this.fontProperties = u;
    }
    static measureText(t = " ", e, r = rt._canvas, n = e.wordWrap) {
      var _a2;
      const s = `${t}:${e.styleKey}`;
      if (rt._measurementCache[s]) return rt._measurementCache[s];
      const o = Fn(e), a = rt.measureFont(o);
      a.fontSize === 0 && (a.fontSize = e.fontSize, a.ascent = e.fontSize);
      const c = rt.__context;
      c.font = o;
      const l = (n ? rt._wordWrap(t, e, r) : t).split(/(?:\r\n|\r|\n)/), h = new Array(l.length);
      let f = 0;
      for (let A = 0; A < l.length; A++) {
        const T = rt._measureText(l[A], e.letterSpacing, c);
        h[A] = T, f = Math.max(f, T);
      }
      const p = ((_a2 = e._stroke) == null ? void 0 : _a2.width) || 0;
      let m = f + p;
      e.dropShadow && (m += e.dropShadow.distance);
      const y = e.lineHeight || a.fontSize;
      let b = Math.max(y, a.fontSize + p) + (l.length - 1) * (y + e.leading);
      return e.dropShadow && (b += e.dropShadow.distance), new rt(t, e, m, b, l, h, y + e.leading, f, a);
    }
    static _measureText(t, e, r) {
      let n = false;
      rt.experimentalLetterSpacingSupported && (rt.experimentalLetterSpacing ? (r.letterSpacing = `${e}px`, r.textLetterSpacing = `${e}px`, n = true) : (r.letterSpacing = "0px", r.textLetterSpacing = "0px"));
      let s = r.measureText(t).width;
      return s > 0 && (n ? s -= e : s += (rt.graphemeSegmenter(t).length - 1) * e), s;
    }
    static _wordWrap(t, e, r = rt._canvas) {
      const n = r.getContext("2d", Js);
      let s = 0, o = "", a = "";
      const c = /* @__PURE__ */ Object.create(null), { letterSpacing: u, whiteSpace: l } = e, h = rt._collapseSpaces(l), f = rt._collapseNewlines(l);
      let p = !h;
      const m = e.wordWrapWidth + u, y = rt._tokenize(t);
      for (let b = 0; b < y.length; b++) {
        let v = y[b];
        if (rt._isNewline(v)) {
          if (!f) {
            a += rt._addLine(o), p = !h, o = "", s = 0;
            continue;
          }
          v = " ";
        }
        if (h) {
          const T = rt.isBreakingSpace(v), G = rt.isBreakingSpace(o[o.length - 1]);
          if (T && G) continue;
        }
        const A = rt._getFromCache(v, u, c, n);
        if (A > m) if (o !== "" && (a += rt._addLine(o), o = "", s = 0), rt.canBreakWords(v, e.breakWords)) {
          const T = rt.wordWrapSplit(v);
          for (let G = 0; G < T.length; G++) {
            let H = T[G], Y = H, L = 1;
            for (; T[G + L]; ) {
              const C = T[G + L];
              if (!rt.canBreakChars(Y, C, v, G, e.breakWords)) H += C;
              else break;
              Y = C, L++;
            }
            G += L - 1;
            const W = rt._getFromCache(H, u, c, n);
            W + s > m && (a += rt._addLine(o), p = false, o = "", s = 0), o += H, s += W;
          }
        } else {
          o.length > 0 && (a += rt._addLine(o), o = "", s = 0);
          const T = b === y.length - 1;
          a += rt._addLine(v, !T), p = false, o = "", s = 0;
        }
        else A + s > m && (p = false, a += rt._addLine(o), o = "", s = 0), (o.length > 0 || !rt.isBreakingSpace(v) || p) && (o += v, s += A);
      }
      return a += rt._addLine(o, false), a;
    }
    static _addLine(t, e = true) {
      return t = rt._trimRight(t), t = e ? `${t}
` : t, t;
    }
    static _getFromCache(t, e, r, n) {
      let s = r[t];
      return typeof s != "number" && (s = rt._measureText(t, e, n) + e, r[t] = s), s;
    }
    static _collapseSpaces(t) {
      return t === "normal" || t === "pre-line";
    }
    static _collapseNewlines(t) {
      return t === "normal";
    }
    static _trimRight(t) {
      if (typeof t != "string") return "";
      for (let e = t.length - 1; e >= 0; e--) {
        const r = t[e];
        if (!rt.isBreakingSpace(r)) break;
        t = t.slice(0, -1);
      }
      return t;
    }
    static _isNewline(t) {
      return typeof t != "string" ? false : rt._newlines.includes(t.charCodeAt(0));
    }
    static isBreakingSpace(t, e) {
      return typeof t != "string" ? false : rt._breakingSpaces.includes(t.charCodeAt(0));
    }
    static _tokenize(t) {
      const e = [];
      let r = "";
      if (typeof t != "string") return e;
      for (let n = 0; n < t.length; n++) {
        const s = t[n], o = t[n + 1];
        if (rt.isBreakingSpace(s, o) || rt._isNewline(s)) {
          r !== "" && (e.push(r), r = ""), e.push(s);
          continue;
        }
        r += s;
      }
      return r !== "" && e.push(r), e;
    }
    static canBreakWords(t, e) {
      return e;
    }
    static canBreakChars(t, e, r, n, s) {
      return true;
    }
    static wordWrapSplit(t) {
      return rt.graphemeSegmenter(t);
    }
    static measureFont(t) {
      if (rt._fonts[t]) return rt._fonts[t];
      const e = rt._context;
      e.font = t;
      const r = e.measureText(rt.METRICS_STRING + rt.BASELINE_SYMBOL), n = {
        ascent: r.actualBoundingBoxAscent,
        descent: r.actualBoundingBoxDescent,
        fontSize: r.actualBoundingBoxAscent + r.actualBoundingBoxDescent
      };
      return rt._fonts[t] = n, n;
    }
    static clearMetrics(t = "") {
      t ? delete rt._fonts[t] : rt._fonts = {};
    }
    static get _canvas() {
      var _a2;
      if (!rt.__canvas) {
        let t;
        try {
          const e = new OffscreenCanvas(0, 0);
          if ((_a2 = e.getContext("2d", Js)) == null ? void 0 : _a2.measureText) return rt.__canvas = e, e;
          t = St.get().createCanvas();
        } catch {
          t = St.get().createCanvas();
        }
        t.width = t.height = 10, rt.__canvas = t;
      }
      return rt.__canvas;
    }
    static get _context() {
      return rt.__context || (rt.__context = rt._canvas.getContext("2d", Js)), rt.__context;
    }
  };
  Be.METRICS_STRING = "|\xC9q\xC5";
  Be.BASELINE_SYMBOL = "M";
  Be.BASELINE_MULTIPLIER = 1.4;
  Be.HEIGHT_MULTIPLIER = 2;
  Be.graphemeSegmenter = (() => {
    if (typeof (Intl == null ? void 0 : Intl.Segmenter) == "function") {
      const i = new Intl.Segmenter();
      return (t) => [
        ...i.segment(t)
      ].map((e) => e.segment);
    }
    return (i) => [
      ...i
    ];
  })();
  Be.experimentalLetterSpacing = false;
  Be._fonts = {};
  Be._newlines = [
    10,
    13
  ];
  Be._breakingSpaces = [
    9,
    32,
    8192,
    8193,
    8194,
    8195,
    8196,
    8197,
    8198,
    8200,
    8201,
    8202,
    8287,
    12288
  ];
  Be._measurementCache = {};
  let Ge = Be;
  function Un(i, t) {
    if (i.texture === J.WHITE && !i.fill) return At.shared.setValue(i.color).toHex();
    if (i.fill) {
      if (i.fill instanceof Zn) {
        const e = i.fill, r = t.createPattern(e.texture.source.resource, "repeat"), n = e.transform.copyTo(nt.shared);
        return n.scale(e.texture.frame.width, e.texture.frame.height), r.setTransform(n), r;
      } else if (i.fill instanceof Ci) {
        const e = i.fill;
        if (e.type === "linear") {
          const r = t.createLinearGradient(e.x0, e.y0, e.x1, e.y1);
          return e.gradientStops.forEach((n) => {
            r.addColorStop(n.offset, At.shared.setValue(n.color).toHex());
          }), r;
        }
      }
    } else {
      const e = t.createPattern(i.texture.source.resource, "repeat"), r = i.matrix.copyTo(nt.shared);
      return r.scale(i.texture.frame.width, i.texture.frame.height), e.setTransform(r), e;
    }
    return ut("FillStyle not recognised", i), "red";
  }
  function Ih(i) {
    if (i === "") return [];
    typeof i == "string" && (i = [
      i
    ]);
    const t = [];
    for (let e = 0, r = i.length; e < r; e++) {
      const n = i[e];
      if (Array.isArray(n)) {
        if (n.length !== 2) throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${n.length}.`);
        if (n[0].length === 0 || n[1].length === 0) throw new Error("[BitmapFont]: Invalid character delimiter.");
        const s = n[0].charCodeAt(0), o = n[1].charCodeAt(0);
        if (o < s) throw new Error("[BitmapFont]: Invalid character range.");
        for (let a = s, c = o; a <= c; a++) t.push(String.fromCharCode(a));
      } else t.push(...Array.from(n));
    }
    if (t.length === 0) throw new Error("[BitmapFont]: Empty set when resolving characters.");
    return t;
  }
  const Fh = class Uh extends gh {
    constructor(t) {
      super(), this.resolution = 1, this.pages = [], this._padding = 0, this._measureCache = /* @__PURE__ */ Object.create(null), this._currentChars = [], this._currentX = 0, this._currentY = 0, this._currentPageIndex = -1, this._skipKerning = false;
      const e = {
        ...Uh.defaultOptions,
        ...t
      };
      this._textureSize = e.textureSize, this._mipmap = e.mipmap;
      const r = e.style.clone();
      e.overrideFill && (r._fill.color = 16777215, r._fill.alpha = 1, r._fill.texture = J.WHITE, r._fill.fill = null), this.applyFillAsTint = e.overrideFill;
      const n = r.fontSize;
      r.fontSize = this.baseMeasurementFontSize;
      const s = Fn(r);
      e.overrideSize ? r._stroke && (r._stroke.width *= this.baseRenderedFontSize / n) : r.fontSize = this.baseRenderedFontSize = n, this._style = r, this._skipKerning = e.skipKerning ?? false, this.resolution = e.resolution ?? 1, this._padding = e.padding ?? 4, this.fontMetrics = Ge.measureFont(s), this.lineHeight = r.lineHeight || this.fontMetrics.fontSize || r.fontSize;
    }
    ensureCharacters(t) {
      var _a2, _b2;
      const e = Ih(t).filter((y) => !this._currentChars.includes(y)).filter((y, b, v) => v.indexOf(y) === b);
      if (!e.length) return;
      this._currentChars = [
        ...this._currentChars,
        ...e
      ];
      let r;
      this._currentPageIndex === -1 ? r = this._nextPage() : r = this.pages[this._currentPageIndex];
      let { canvas: n, context: s } = r.canvasAndContext, o = r.texture.source;
      const a = this._style;
      let c = this._currentX, u = this._currentY;
      const l = this.baseRenderedFontSize / this.baseMeasurementFontSize, h = this._padding * l, f = a.fontStyle === "italic" ? 2 : 1;
      let p = 0, m = false;
      for (let y = 0; y < e.length; y++) {
        const b = e[y], v = Ge.measureText(b, a, n, false);
        v.lineHeight = v.height;
        const A = f * v.width * l, T = v.height * l, G = A + h * 2, H = T + h * 2;
        if (m = false, b !== `
` && b !== "\r" && b !== "	" && b !== " " && (m = true, p = Math.ceil(Math.max(H, p))), c + G > this._textureSize && (u += p, p = H, c = 0, u + p > this._textureSize)) {
          o.update();
          const L = this._nextPage();
          n = L.canvasAndContext.canvas, s = L.canvasAndContext.context, o = L.texture.source, u = 0;
        }
        const Y = A / l - (((_a2 = a.dropShadow) == null ? void 0 : _a2.distance) ?? 0) - (((_b2 = a._stroke) == null ? void 0 : _b2.width) ?? 0);
        if (this.chars[b] = {
          id: b.codePointAt(0),
          xOffset: -this._padding,
          yOffset: -this._padding,
          xAdvance: Y,
          kerning: {}
        }, m) {
          this._drawGlyph(s, v, c + h, u + h, l, a);
          const L = o.width * l, W = o.height * l, C = new Et(c / L * o.width, u / W * o.height, G / L * o.width, H / W * o.height);
          this.chars[b].texture = new J({
            source: o,
            frame: C
          }), c += Math.ceil(G);
        }
      }
      o.update(), this._currentX = c, this._currentY = u, this._skipKerning && this._applyKerning(e, s);
    }
    get pageTextures() {
      return lt(dt, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."), this.pages;
    }
    _applyKerning(t, e) {
      const r = this._measureCache;
      for (let n = 0; n < t.length; n++) {
        const s = t[n];
        for (let o = 0; o < this._currentChars.length; o++) {
          const a = this._currentChars[o];
          let c = r[s];
          c || (c = r[s] = e.measureText(s).width);
          let u = r[a];
          u || (u = r[a] = e.measureText(a).width);
          let l = e.measureText(s + a).width, h = l - (c + u);
          h && (this.chars[s].kerning[a] = h), l = e.measureText(s + a).width, h = l - (c + u), h && (this.chars[a].kerning[s] = h);
        }
      }
    }
    _nextPage() {
      this._currentPageIndex++;
      const t = this.resolution, e = Je.getOptimalCanvasAndContext(this._textureSize, this._textureSize, t);
      this._setupContext(e.context, this._style, t);
      const r = t * (this.baseRenderedFontSize / this.baseMeasurementFontSize), n = new J({
        source: new ti({
          resource: e.canvas,
          resolution: r,
          alphaMode: "premultiply-alpha-on-upload",
          autoGenerateMipmaps: this._mipmap
        })
      }), s = {
        canvasAndContext: e,
        texture: n
      };
      return this.pages[this._currentPageIndex] = s, s;
    }
    _setupContext(t, e, r) {
      e.fontSize = this.baseRenderedFontSize, t.scale(r, r), t.font = Fn(e), e.fontSize = this.baseMeasurementFontSize, t.textBaseline = e.textBaseline;
      const n = e._stroke, s = (n == null ? void 0 : n.width) ?? 0;
      if (n && (t.lineWidth = s, t.lineJoin = n.join, t.miterLimit = n.miterLimit, t.strokeStyle = Un(n, t)), e._fill && (t.fillStyle = Un(e._fill, t)), e.dropShadow) {
        const o = e.dropShadow, a = At.shared.setValue(o.color).toArray(), c = o.blur * r, u = o.distance * r;
        t.shadowColor = `rgba(${a[0] * 255},${a[1] * 255},${a[2] * 255},${o.alpha})`, t.shadowBlur = c, t.shadowOffsetX = Math.cos(o.angle) * u, t.shadowOffsetY = Math.sin(o.angle) * u;
      } else t.shadowColor = "black", t.shadowBlur = 0, t.shadowOffsetX = 0, t.shadowOffsetY = 0;
    }
    _drawGlyph(t, e, r, n, s, o) {
      var _a2;
      const a = e.text, c = e.fontProperties, l = (((_a2 = o._stroke) == null ? void 0 : _a2.width) ?? 0) * s, h = r + l / 2, f = n - l / 2, p = c.descent * s, m = e.lineHeight * s;
      o.stroke && l && t.strokeText(a, h, f + m - p), o._fill && t.fillText(a, h, f + m - p);
    }
    destroy() {
      super.destroy();
      for (let t = 0; t < this.pages.length; t++) {
        const { canvasAndContext: e, texture: r } = this.pages[t];
        e.canvas.width = e.canvas.width, Je.returnCanvasAndContext(e), r.destroy(true);
      }
      this.pages = null;
    }
  };
  Fh.defaultOptions = {
    textureSize: 512,
    style: new Oe(),
    mipmap: true
  };
  let Zc = Fh;
  function kh(i, t, e) {
    const r = {
      width: 0,
      height: 0,
      offsetY: 0,
      scale: t.fontSize / e.baseMeasurementFontSize,
      lines: [
        {
          width: 0,
          charPositions: [],
          spaceWidth: 0,
          spacesIndex: [],
          chars: []
        }
      ]
    };
    r.offsetY = e.baseLineOffset;
    let n = r.lines[0], s = null, o = true;
    const a = {
      spaceWord: false,
      width: 0,
      start: 0,
      index: 0,
      positions: [],
      chars: []
    }, c = (p) => {
      const m = n.width;
      for (let y = 0; y < a.index; y++) {
        const b = p.positions[y];
        n.chars.push(p.chars[y]), n.charPositions.push(b + m);
      }
      n.width += p.width, o = false, a.width = 0, a.index = 0, a.chars.length = 0;
    }, u = () => {
      let p = n.chars.length - 1, m = n.chars[p];
      for (; m === " "; ) n.width -= e.chars[m].xAdvance, m = n.chars[--p];
      r.width = Math.max(r.width, n.width), n = {
        width: 0,
        charPositions: [],
        chars: [],
        spaceWidth: 0,
        spacesIndex: []
      }, o = true, r.lines.push(n), r.height += e.lineHeight;
    }, l = e.baseMeasurementFontSize / t.fontSize, h = t.letterSpacing * l, f = t.wordWrapWidth * l;
    for (let p = 0; p < i.length + 1; p++) {
      let m;
      const y = p === i.length;
      y || (m = i[p]);
      const b = e.chars[m] || e.chars[" "];
      if (/(?:\s)/.test(m) || m === "\r" || m === `
` || y) {
        if (!o && t.wordWrap && n.width + a.width - h > f ? (u(), c(a), y || n.charPositions.push(0)) : (a.start = n.width, c(a), y || n.charPositions.push(0)), m === "\r" || m === `
`) n.width !== 0 && u();
        else if (!y) {
          const G = b.xAdvance + (b.kerning[s] || 0) + h;
          n.width += G, n.spaceWidth = G, n.spacesIndex.push(n.charPositions.length), n.chars.push(m);
        }
      } else {
        const T = b.kerning[s] || 0, G = b.xAdvance + T + h;
        a.positions[a.index++] = a.width + T, a.chars.push(m), a.width += G;
      }
      s = m;
    }
    return u(), t.align === "center" ? Am(r) : t.align === "right" ? Tm(r) : t.align === "justify" && Cm(r), r;
  }
  function Am(i) {
    for (let t = 0; t < i.lines.length; t++) {
      const e = i.lines[t], r = i.width / 2 - e.width / 2;
      for (let n = 0; n < e.charPositions.length; n++) e.charPositions[n] += r;
    }
  }
  function Tm(i) {
    for (let t = 0; t < i.lines.length; t++) {
      const e = i.lines[t], r = i.width - e.width;
      for (let n = 0; n < e.charPositions.length; n++) e.charPositions[n] += r;
    }
  }
  function Cm(i) {
    const t = i.width;
    for (let e = 0; e < i.lines.length; e++) {
      const r = i.lines[e];
      let n = 0, s = r.spacesIndex[n++], o = 0;
      const a = r.spacesIndex.length, u = (t - r.width) / a;
      for (let l = 0; l < r.charPositions.length; l++) l === s && (s = r.spacesIndex[n++], o += u), r.charPositions[l] += o;
    }
  }
  let rn = 0;
  class Rm {
    constructor() {
      this.ALPHA = [
        [
          "a",
          "z"
        ],
        [
          "A",
          "Z"
        ],
        " "
      ], this.NUMERIC = [
        [
          "0",
          "9"
        ]
      ], this.ALPHANUMERIC = [
        [
          "a",
          "z"
        ],
        [
          "A",
          "Z"
        ],
        [
          "0",
          "9"
        ],
        " "
      ], this.ASCII = [
        [
          " ",
          "~"
        ]
      ], this.defaultOptions = {
        chars: this.ALPHANUMERIC,
        resolution: 1,
        padding: 4,
        skipKerning: false
      };
    }
    getFont(t, e) {
      var _a2;
      let r = `${e.fontFamily}-bitmap`, n = true;
      if (e._fill.fill && !e._stroke) r += e._fill.fill.styleKey, n = false;
      else if (e._stroke || e.dropShadow) {
        let o = e.styleKey;
        o = o.substring(0, o.lastIndexOf("-")), r = `${o}-bitmap`, n = false;
      }
      if (!Tt.has(r)) {
        const o = new Zc({
          style: e,
          overrideFill: n,
          overrideSize: true,
          ...this.defaultOptions
        });
        rn++, rn > 50 && ut("BitmapText", `You have dynamically created ${rn} bitmap fonts, this can be inefficient. Try pre installing your font styles using \`BitmapFont.install({name:"style1", style})\``), o.once("destroy", () => {
          rn--, Tt.remove(r);
        }), Tt.set(r, o);
      }
      const s = Tt.get(r);
      return (_a2 = s.ensureCharacters) == null ? void 0 : _a2.call(s, t), s;
    }
    getLayout(t, e) {
      const r = this.getFont(t, e);
      return kh([
        ...t
      ], e, r);
    }
    measureText(t, e) {
      return this.getLayout(t, e);
    }
    install(...t) {
      var _a2, _b2, _c2, _d2;
      let e = t[0];
      typeof e == "string" && (e = {
        name: e,
        style: t[1],
        chars: (_a2 = t[2]) == null ? void 0 : _a2.chars,
        resolution: (_b2 = t[2]) == null ? void 0 : _b2.resolution,
        padding: (_c2 = t[2]) == null ? void 0 : _c2.padding,
        skipKerning: (_d2 = t[2]) == null ? void 0 : _d2.skipKerning
      }, lt(dt, "BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})"));
      const r = e == null ? void 0 : e.name;
      if (!r) throw new Error("[BitmapFontManager] Property `name` is required.");
      e = {
        ...this.defaultOptions,
        ...e
      };
      const n = e.style, s = n instanceof Oe ? n : new Oe(n), o = s._fill.fill !== null && s._fill.fill !== void 0, a = new Zc({
        style: s,
        overrideFill: o,
        skipKerning: e.skipKerning,
        padding: e.padding,
        resolution: e.resolution,
        overrideSize: false
      }), c = Ih(e.chars);
      return a.ensureCharacters(c.join("")), Tt.set(`${r}-bitmap`, a), a.once("destroy", () => Tt.remove(`${r}-bitmap`)), a;
    }
    uninstall(t) {
      const e = `${t}-bitmap`, r = Tt.get(e);
      r && (Tt.remove(e), r.destroy());
    }
  }
  const kn = new Rm();
  class Gh extends gh {
    constructor(t, e) {
      super();
      const { textures: r, data: n } = t;
      Object.keys(n.pages).forEach((s) => {
        const o = n.pages[parseInt(s, 10)], a = r[o.id];
        this.pages.push({
          texture: a
        });
      }), Object.keys(n.chars).forEach((s) => {
        const o = n.chars[s], { frame: a, source: c } = r[o.page], u = new Et(o.x + a.x, o.y + a.y, o.width, o.height), l = new J({
          source: c,
          frame: u
        });
        this.chars[s] = {
          id: s.codePointAt(0),
          xOffset: o.xOffset,
          yOffset: o.yOffset,
          xAdvance: o.xAdvance,
          kerning: o.kerning ?? {},
          texture: l
        };
      }), this.baseRenderedFontSize = n.fontSize, this.baseMeasurementFontSize = n.fontSize, this.fontMetrics = {
        ascent: 0,
        descent: 0,
        fontSize: n.fontSize
      }, this.baseLineOffset = n.baseLineOffset, this.lineHeight = n.lineHeight, this.fontFamily = n.fontFamily, this.distanceField = n.distanceField ?? {
        type: "none",
        range: 0
      }, this.url = e;
    }
    destroy() {
      super.destroy();
      for (let t = 0; t < this.pages.length; t++) {
        const { texture: e } = this.pages[t];
        e.destroy(true);
      }
      this.pages = null;
    }
    static install(t) {
      kn.install(t);
    }
    static uninstall(t) {
      kn.uninstall(t);
    }
  }
  const Qs = {
    test(i) {
      return typeof i == "string" && i.startsWith("info face=");
    },
    parse(i) {
      const t = i.match(/^[a-z]+\s+.+$/gm), e = {
        info: [],
        common: [],
        page: [],
        char: [],
        chars: [],
        kerning: [],
        kernings: [],
        distanceField: []
      };
      for (const h in t) {
        const f = t[h].match(/^[a-z]+/gm)[0], p = t[h].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm), m = {};
        for (const y in p) {
          const b = p[y].split("="), v = b[0], A = b[1].replace(/"/gm, ""), T = parseFloat(A), G = isNaN(T) ? A : T;
          m[v] = G;
        }
        e[f].push(m);
      }
      const r = {
        chars: {},
        pages: [],
        lineHeight: 0,
        fontSize: 0,
        fontFamily: "",
        distanceField: null,
        baseLineOffset: 0
      }, [n] = e.info, [s] = e.common, [o] = e.distanceField ?? [];
      o && (r.distanceField = {
        range: parseInt(o.distanceRange, 10),
        type: o.fieldType
      }), r.fontSize = parseInt(n.size, 10), r.fontFamily = n.face, r.lineHeight = parseInt(s.lineHeight, 10);
      const a = e.page;
      for (let h = 0; h < a.length; h++) r.pages.push({
        id: parseInt(a[h].id, 10) || 0,
        file: a[h].file
      });
      const c = {};
      r.baseLineOffset = r.lineHeight - parseInt(s.base, 10);
      const u = e.char;
      for (let h = 0; h < u.length; h++) {
        const f = u[h], p = parseInt(f.id, 10);
        let m = f.letter ?? f.char ?? String.fromCharCode(p);
        m === "space" && (m = " "), c[p] = m, r.chars[m] = {
          id: p,
          page: parseInt(f.page, 10) || 0,
          x: parseInt(f.x, 10),
          y: parseInt(f.y, 10),
          width: parseInt(f.width, 10),
          height: parseInt(f.height, 10),
          xOffset: parseInt(f.xoffset, 10),
          yOffset: parseInt(f.yoffset, 10),
          xAdvance: parseInt(f.xadvance, 10),
          kerning: {}
        };
      }
      const l = e.kerning || [];
      for (let h = 0; h < l.length; h++) {
        const f = parseInt(l[h].first, 10), p = parseInt(l[h].second, 10), m = parseInt(l[h].amount, 10);
        r.chars[c[p]].kerning[c[f]] = m;
      }
      return r;
    }
  }, Jc = {
    test(i) {
      const t = i;
      return typeof t != "string" && "getElementsByTagName" in t && t.getElementsByTagName("page").length && t.getElementsByTagName("info")[0].getAttribute("face") !== null;
    },
    parse(i) {
      const t = {
        chars: {},
        pages: [],
        lineHeight: 0,
        fontSize: 0,
        fontFamily: "",
        distanceField: null,
        baseLineOffset: 0
      }, e = i.getElementsByTagName("info")[0], r = i.getElementsByTagName("common")[0], n = i.getElementsByTagName("distanceField")[0];
      n && (t.distanceField = {
        type: n.getAttribute("fieldType"),
        range: parseInt(n.getAttribute("distanceRange"), 10)
      });
      const s = i.getElementsByTagName("page"), o = i.getElementsByTagName("char"), a = i.getElementsByTagName("kerning");
      t.fontSize = parseInt(e.getAttribute("size"), 10), t.fontFamily = e.getAttribute("face"), t.lineHeight = parseInt(r.getAttribute("lineHeight"), 10);
      for (let u = 0; u < s.length; u++) t.pages.push({
        id: parseInt(s[u].getAttribute("id"), 10) || 0,
        file: s[u].getAttribute("file")
      });
      const c = {};
      t.baseLineOffset = t.lineHeight - parseInt(r.getAttribute("base"), 10);
      for (let u = 0; u < o.length; u++) {
        const l = o[u], h = parseInt(l.getAttribute("id"), 10);
        let f = l.getAttribute("letter") ?? l.getAttribute("char") ?? String.fromCharCode(h);
        f === "space" && (f = " "), c[h] = f, t.chars[f] = {
          id: h,
          page: parseInt(l.getAttribute("page"), 10) || 0,
          x: parseInt(l.getAttribute("x"), 10),
          y: parseInt(l.getAttribute("y"), 10),
          width: parseInt(l.getAttribute("width"), 10),
          height: parseInt(l.getAttribute("height"), 10),
          xOffset: parseInt(l.getAttribute("xoffset"), 10),
          yOffset: parseInt(l.getAttribute("yoffset"), 10),
          xAdvance: parseInt(l.getAttribute("xadvance"), 10),
          kerning: {}
        };
      }
      for (let u = 0; u < a.length; u++) {
        const l = parseInt(a[u].getAttribute("first"), 10), h = parseInt(a[u].getAttribute("second"), 10), f = parseInt(a[u].getAttribute("amount"), 10);
        t.chars[c[h]].kerning[c[l]] = f;
      }
      return t;
    }
  }, Qc = {
    test(i) {
      return typeof i == "string" && i.includes("<font>") ? Jc.test(St.get().parseXML(i)) : false;
    },
    parse(i) {
      return Jc.parse(St.get().parseXML(i));
    }
  }, Pm = [
    ".xml",
    ".fnt"
  ], Bm = {
    extension: {
      type: P.CacheParser,
      name: "cacheBitmapFont"
    },
    test: (i) => i instanceof Gh,
    getCacheableAssets(i, t) {
      const e = {};
      return i.forEach((r) => {
        e[r] = t, e[`${r}-bitmap`] = t;
      }), e[`${t.fontFamily}-bitmap`] = t, e;
    }
  }, Mm = {
    extension: {
      type: P.LoadParser,
      priority: ve.Normal
    },
    name: "loadBitmapFont",
    test(i) {
      return Pm.includes(_e.extname(i).toLowerCase());
    },
    async testParse(i) {
      return Qs.test(i) || Qc.test(i);
    },
    async parse(i, t, e) {
      const r = Qs.test(i) ? Qs.parse(i) : Qc.parse(i), { src: n } = t, { pages: s } = r, o = [], a = r.distanceField ? {
        scaleMode: "linear",
        alphaMode: "premultiply-alpha-on-upload",
        autoGenerateMipmaps: false,
        resolution: 1
      } : {};
      for (let h = 0; h < s.length; ++h) {
        const f = s[h].file;
        let p = _e.join(_e.dirname(n), f);
        p = vo(p, n), o.push({
          src: p,
          data: a
        });
      }
      const c = await e.load(o), u = o.map((h) => c[h.src]);
      return new Gh({
        data: r,
        textures: u
      }, n);
    },
    async load(i, t) {
      return await (await St.get().fetch(i)).text();
    },
    async unload(i, t, e) {
      await Promise.all(i.pages.map((r) => e.unload(r.texture.source._sourceOrigin))), i.destroy();
    }
  };
  class Dm {
    constructor(t, e = false) {
      this._loader = t, this._assetList = [], this._isLoading = false, this._maxConcurrent = 1, this.verbose = e;
    }
    add(t) {
      t.forEach((e) => {
        this._assetList.push(e);
      }), this.verbose && console.log("[BackgroundLoader] assets: ", this._assetList), this._isActive && !this._isLoading && this._next();
    }
    async _next() {
      if (this._assetList.length && this._isActive) {
        this._isLoading = true;
        const t = [], e = Math.min(this._assetList.length, this._maxConcurrent);
        for (let r = 0; r < e; r++) t.push(this._assetList.pop());
        await this._loader.load(t), this._isLoading = false, this._next();
      }
    }
    get active() {
      return this._isActive;
    }
    set active(t) {
      this._isActive !== t && (this._isActive = t, t && !this._isLoading && this._next());
    }
  }
  const Im = {
    extension: {
      type: P.CacheParser,
      name: "cacheTextureArray"
    },
    test: (i) => Array.isArray(i) && i.every((t) => t instanceof J),
    getCacheableAssets: (i, t) => {
      const e = {};
      return i.forEach((r) => {
        t.forEach((n, s) => {
          e[r + (s === 0 ? "" : s + 1)] = n;
        });
      }), e;
    }
  };
  async function Oh(i) {
    if ("Image" in globalThis) return new Promise((t) => {
      const e = new Image();
      e.onload = () => {
        t(true);
      }, e.onerror = () => {
        t(false);
      }, e.src = i;
    });
    if ("createImageBitmap" in globalThis && "fetch" in globalThis) {
      try {
        const t = await (await fetch(i)).blob();
        await createImageBitmap(t);
      } catch {
        return false;
      }
      return true;
    }
    return false;
  }
  const Fm = {
    extension: {
      type: P.DetectionParser,
      priority: 1
    },
    test: async () => Oh("data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A="),
    add: async (i) => [
      ...i,
      "avif"
    ],
    remove: async (i) => i.filter((t) => t !== "avif")
  }, tu = [
    "png",
    "jpg",
    "jpeg"
  ], Um = {
    extension: {
      type: P.DetectionParser,
      priority: -1
    },
    test: () => Promise.resolve(true),
    add: async (i) => [
      ...i,
      ...tu
    ],
    remove: async (i) => i.filter((t) => !tu.includes(t))
  }, km = "WorkerGlobalScope" in globalThis && globalThis instanceof globalThis.WorkerGlobalScope;
  function ha(i) {
    return km ? false : document.createElement("video").canPlayType(i) !== "";
  }
  const Gm = {
    extension: {
      type: P.DetectionParser,
      priority: 0
    },
    test: async () => ha("video/mp4"),
    add: async (i) => [
      ...i,
      "mp4",
      "m4v"
    ],
    remove: async (i) => i.filter((t) => t !== "mp4" && t !== "m4v")
  }, Om = {
    extension: {
      type: P.DetectionParser,
      priority: 0
    },
    test: async () => ha("video/ogg"),
    add: async (i) => [
      ...i,
      "ogv"
    ],
    remove: async (i) => i.filter((t) => t !== "ogv")
  }, Nm = {
    extension: {
      type: P.DetectionParser,
      priority: 0
    },
    test: async () => ha("video/webm"),
    add: async (i) => [
      ...i,
      "webm"
    ],
    remove: async (i) => i.filter((t) => t !== "webm")
  }, Lm = {
    extension: {
      type: P.DetectionParser,
      priority: 0
    },
    test: async () => Oh("data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA="),
    add: async (i) => [
      ...i,
      "webp"
    ],
    remove: async (i) => i.filter((t) => t !== "webp")
  };
  class Hm {
    constructor() {
      this._parsers = [], this._parsersValidated = false, this.parsers = new Proxy(this._parsers, {
        set: (t, e, r) => (this._parsersValidated = false, t[e] = r, true)
      }), this.promiseCache = {};
    }
    reset() {
      this._parsersValidated = false, this.promiseCache = {};
    }
    _getLoadPromiseAndParser(t, e) {
      const r = {
        promise: null,
        parser: null
      };
      return r.promise = (async () => {
        var _a2, _b2;
        let n = null, s = null;
        if (e.loadParser && (s = this._parserHash[e.loadParser], s || ut(`[Assets] specified load parser "${e.loadParser}" not found while loading ${t}`)), !s) {
          for (let o = 0; o < this.parsers.length; o++) {
            const a = this.parsers[o];
            if (a.load && ((_a2 = a.test) == null ? void 0 : _a2.call(a, t, e, this))) {
              s = a;
              break;
            }
          }
          if (!s) return ut(`[Assets] ${t} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`), null;
        }
        n = await s.load(t, e, this), r.parser = s;
        for (let o = 0; o < this.parsers.length; o++) {
          const a = this.parsers[o];
          a.parse && a.parse && await ((_b2 = a.testParse) == null ? void 0 : _b2.call(a, n, e, this)) && (n = await a.parse(n, e, this) || n, r.parser = a);
        }
        return n;
      })(), r;
    }
    async load(t, e) {
      this._parsersValidated || this._validateParsers();
      let r = 0;
      const n = {}, s = Mn(t), o = Re(t, (u) => ({
        alias: [
          u
        ],
        src: u,
        data: {}
      })), a = o.length, c = o.map(async (u) => {
        const l = _e.toAbsolute(u.src);
        if (!n[u.src]) try {
          this.promiseCache[l] || (this.promiseCache[l] = this._getLoadPromiseAndParser(l, u)), n[u.src] = await this.promiseCache[l].promise, e && e(++r / a);
        } catch (h) {
          throw delete this.promiseCache[l], delete n[u.src], new Error(`[Loader.load] Failed to load ${l}.
${h}`);
        }
      });
      return await Promise.all(c), s ? n[o[0].src] : n;
    }
    async unload(t) {
      const r = Re(t, (n) => ({
        alias: [
          n
        ],
        src: n
      })).map(async (n) => {
        var _a2, _b2;
        const s = _e.toAbsolute(n.src), o = this.promiseCache[s];
        if (o) {
          const a = await o.promise;
          delete this.promiseCache[s], await ((_b2 = (_a2 = o.parser) == null ? void 0 : _a2.unload) == null ? void 0 : _b2.call(_a2, a, n, this));
        }
      });
      await Promise.all(r);
    }
    _validateParsers() {
      this._parsersValidated = true, this._parserHash = this._parsers.filter((t) => t.name).reduce((t, e) => (e.name ? t[e.name] && ut(`[Assets] loadParser name conflict "${e.name}"`) : ut("[Assets] loadParser should have a name"), {
        ...t,
        [e.name]: e
      }), {});
    }
  }
  function ri(i, t) {
    if (Array.isArray(t)) {
      for (const e of t) if (i.startsWith(`data:${e}`)) return true;
      return false;
    }
    return i.startsWith(`data:${t}`);
  }
  function Me(i, t) {
    const e = i.split("?")[0], r = _e.extname(e).toLowerCase();
    return Array.isArray(t) ? t.includes(r) : r === t;
  }
  const zm = ".json", jm = "application/json", Wm = {
    extension: {
      type: P.LoadParser,
      priority: ve.Low
    },
    name: "loadJson",
    test(i) {
      return ri(i, jm) || Me(i, zm);
    },
    async load(i) {
      return await (await St.get().fetch(i)).json();
    }
  }, Vm = ".txt", Xm = "text/plain", qm = {
    name: "loadTxt",
    extension: {
      type: P.LoadParser,
      priority: ve.Low,
      name: "loadTxt"
    },
    test(i) {
      return ri(i, Xm) || Me(i, Vm);
    },
    async load(i) {
      return await (await St.get().fetch(i)).text();
    }
  }, $m = [
    "normal",
    "bold",
    "100",
    "200",
    "300",
    "400",
    "500",
    "600",
    "700",
    "800",
    "900"
  ], Ym = [
    ".ttf",
    ".otf",
    ".woff",
    ".woff2"
  ], Km = [
    "font/ttf",
    "font/otf",
    "font/woff",
    "font/woff2"
  ], Zm = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;
  function Jm(i) {
    const t = _e.extname(i), n = _e.basename(i, t).replace(/(-|_)/g, " ").toLowerCase().split(" ").map((a) => a.charAt(0).toUpperCase() + a.slice(1));
    let s = n.length > 0;
    for (const a of n) if (!a.match(Zm)) {
      s = false;
      break;
    }
    let o = n.join(" ");
    return s || (o = `"${o.replace(/[\\"]/g, "\\$&")}"`), o;
  }
  const Qm = /^[0-9A-Za-z%:/?#\[\]@!\$&'()\*\+,;=\-._~]*$/;
  function tb(i) {
    return Qm.test(i) ? i : encodeURI(i);
  }
  const eb = {
    extension: {
      type: P.LoadParser,
      priority: ve.Low
    },
    name: "loadWebFont",
    test(i) {
      return ri(i, Km) || Me(i, Ym);
    },
    async load(i, t) {
      var _a2, _b2, _c2;
      const e = St.get().getFontFaceSet();
      if (e) {
        const r = [], n = ((_a2 = t.data) == null ? void 0 : _a2.family) ?? Jm(i), s = ((_c2 = (_b2 = t.data) == null ? void 0 : _b2.weights) == null ? void 0 : _c2.filter((a) => $m.includes(a))) ?? [
          "normal"
        ], o = t.data ?? {};
        for (let a = 0; a < s.length; a++) {
          const c = s[a], u = new FontFace(n, `url(${tb(i)})`, {
            ...o,
            weight: c
          });
          await u.load(), e.add(u), r.push(u);
        }
        return Tt.set(`${n}-and-url`, {
          url: i,
          fontFaces: r
        }), r.length === 1 ? r[0] : r;
      }
      return ut("[loadWebFont] FontFace API is not supported. Skipping loading font"), null;
    },
    unload(i) {
      (Array.isArray(i) ? i : [
        i
      ]).forEach((t) => {
        Tt.remove(t.family), St.get().getFontFaceSet().delete(t);
      });
    }
  };
  function da(i, t = 1) {
    var _a2;
    const e = (_a2 = Dr.RETINA_PREFIX) == null ? void 0 : _a2.exec(i);
    return e ? parseFloat(e[1]) : t;
  }
  function Fr(i, t, e) {
    i.label = e, i._sourceOrigin = e;
    const r = new J({
      source: i,
      label: e
    }), n = () => {
      delete t.promiseCache[e], Tt.has(e) && Tt.remove(e);
    };
    return r.source.once("destroy", () => {
      t.promiseCache[e] && (ut("[Assets] A TextureSource managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the TextureSource."), n());
    }), r.once("destroy", () => {
      i.destroyed || (ut("[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture."), n());
    }), r;
  }
  const rb = ".svg", ib = "image/svg+xml", nb = {
    extension: {
      type: P.LoadParser,
      priority: ve.Low,
      name: "loadSVG"
    },
    name: "loadSVG",
    config: {
      crossOrigin: "anonymous",
      parseAsGraphicsContext: false
    },
    test(i) {
      return ri(i, ib) || Me(i, rb);
    },
    async load(i, t, e) {
      return t.data.parseAsGraphicsContext ?? this.config.parseAsGraphicsContext ? ob(i) : sb(i, t, e, this.config.crossOrigin);
    },
    unload(i) {
      i.destroy(true);
    }
  };
  async function sb(i, t, e, r) {
    var _a2, _b2, _c2;
    const s = await (await St.get().fetch(i)).blob(), o = URL.createObjectURL(s), a = new Image();
    a.src = o, a.crossOrigin = r, await a.decode(), URL.revokeObjectURL(o);
    const c = document.createElement("canvas"), u = c.getContext("2d"), l = ((_a2 = t.data) == null ? void 0 : _a2.resolution) || da(i), h = ((_b2 = t.data) == null ? void 0 : _b2.width) ?? a.width, f = ((_c2 = t.data) == null ? void 0 : _c2.height) ?? a.height;
    c.width = h * l, c.height = f * l, u.drawImage(a, 0, 0, h * l, f * l);
    const { parseAsGraphicsContext: p, ...m } = t.data, y = new ti({
      resource: c,
      alphaMode: "premultiply-alpha-on-upload",
      resolution: l,
      ...m
    });
    return Fr(y, e, i);
  }
  async function ob(i) {
    const e = await (await St.get().fetch(i)).text(), r = new oe();
    return r.svg(e), r;
  }
  const ab = `(function () {
    'use strict';

    const WHITE_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";
    async function checkImageBitmap() {
      try {
        if (typeof createImageBitmap !== "function")
          return false;
        const response = await fetch(WHITE_PNG);
        const imageBlob = await response.blob();
        const imageBitmap = await createImageBitmap(imageBlob);
        return imageBitmap.width === 1 && imageBitmap.height === 1;
      } catch (e) {
        return false;
      }
    }
    void checkImageBitmap().then((result) => {
      self.postMessage(result);
    });

})();
`;
  let Wr = null, Fo = class {
    constructor() {
      Wr || (Wr = URL.createObjectURL(new Blob([
        ab
      ], {
        type: "application/javascript"
      }))), this.worker = new Worker(Wr);
    }
  };
  Fo.revokeObjectURL = function() {
    Wr && (URL.revokeObjectURL(Wr), Wr = null);
  };
  const cb = `(function () {
    'use strict';

    async function loadImageBitmap(url) {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(\`[WorkerManager.loadImageBitmap] Failed to fetch \${url}: \${response.status} \${response.statusText}\`);
      }
      const imageBlob = await response.blob();
      const imageBitmap = await createImageBitmap(imageBlob);
      return imageBitmap;
    }
    self.onmessage = async (event) => {
      try {
        const imageBitmap = await loadImageBitmap(event.data.data[0]);
        self.postMessage({
          data: imageBitmap,
          uuid: event.data.uuid,
          id: event.data.id
        }, [imageBitmap]);
      } catch (e) {
        self.postMessage({
          error: e,
          uuid: event.data.uuid,
          id: event.data.id
        });
      }
    };

})();
`;
  let Vr = null, Nh = class {
    constructor() {
      Vr || (Vr = URL.createObjectURL(new Blob([
        cb
      ], {
        type: "application/javascript"
      }))), this.worker = new Worker(Vr);
    }
  };
  Nh.revokeObjectURL = function() {
    Vr && (URL.revokeObjectURL(Vr), Vr = null);
  };
  let eu = 0, to;
  class ub {
    constructor() {
      this._initialized = false, this._createdWorkers = 0, this._workerPool = [], this._queue = [], this._resolveHash = {};
    }
    isImageBitmapSupported() {
      return this._isImageBitmapSupported !== void 0 ? this._isImageBitmapSupported : (this._isImageBitmapSupported = new Promise((t) => {
        const { worker: e } = new Fo();
        e.addEventListener("message", (r) => {
          e.terminate(), Fo.revokeObjectURL(), t(r.data);
        });
      }), this._isImageBitmapSupported);
    }
    loadImageBitmap(t) {
      return this._run("loadImageBitmap", [
        t
      ]);
    }
    async _initWorkers() {
      this._initialized || (this._initialized = true);
    }
    _getWorker() {
      to === void 0 && (to = navigator.hardwareConcurrency || 4);
      let t = this._workerPool.pop();
      return !t && this._createdWorkers < to && (this._createdWorkers++, t = new Nh().worker, t.addEventListener("message", (e) => {
        this._complete(e.data), this._returnWorker(e.target), this._next();
      })), t;
    }
    _returnWorker(t) {
      this._workerPool.push(t);
    }
    _complete(t) {
      t.error !== void 0 ? this._resolveHash[t.uuid].reject(t.error) : this._resolveHash[t.uuid].resolve(t.data), this._resolveHash[t.uuid] = null;
    }
    async _run(t, e) {
      await this._initWorkers();
      const r = new Promise((n, s) => {
        this._queue.push({
          id: t,
          arguments: e,
          resolve: n,
          reject: s
        });
      });
      return this._next(), r;
    }
    _next() {
      if (!this._queue.length) return;
      const t = this._getWorker();
      if (!t) return;
      const e = this._queue.pop(), r = e.id;
      this._resolveHash[eu] = {
        resolve: e.resolve,
        reject: e.reject
      }, t.postMessage({
        data: e.arguments,
        uuid: eu++,
        id: r
      });
    }
  }
  const ru = new ub(), lb = [
    ".jpeg",
    ".jpg",
    ".png",
    ".webp",
    ".avif"
  ], hb = [
    "image/jpeg",
    "image/png",
    "image/webp",
    "image/avif"
  ];
  async function db(i) {
    const t = await St.get().fetch(i);
    if (!t.ok) throw new Error(`[loadImageBitmap] Failed to fetch ${i}: ${t.status} ${t.statusText}`);
    const e = await t.blob();
    return await createImageBitmap(e);
  }
  const Lh = {
    name: "loadTextures",
    extension: {
      type: P.LoadParser,
      priority: ve.High,
      name: "loadTextures"
    },
    config: {
      preferWorkers: true,
      preferCreateImageBitmap: true,
      crossOrigin: "anonymous"
    },
    test(i) {
      return ri(i, hb) || Me(i, lb);
    },
    async load(i, t, e) {
      var _a2;
      let r = null;
      globalThis.createImageBitmap && this.config.preferCreateImageBitmap ? this.config.preferWorkers && await ru.isImageBitmapSupported() ? r = await ru.loadImageBitmap(i) : r = await db(i) : r = await new Promise((s) => {
        r = new Image(), r.crossOrigin = this.config.crossOrigin, r.src = i, r.complete ? s(r) : r.onload = () => {
          s(r);
        };
      });
      const n = new ti({
        resource: r,
        alphaMode: "premultiply-alpha-on-upload",
        resolution: ((_a2 = t.data) == null ? void 0 : _a2.resolution) || da(i),
        ...t.data
      });
      return Fr(n, e, i);
    },
    unload(i) {
      i.destroy(true);
    }
  }, Hh = [
    ".mp4",
    ".m4v",
    ".webm",
    ".ogg",
    ".ogv",
    ".h264",
    ".avi",
    ".mov"
  ], fb = Hh.map((i) => `video/${i.substring(1)}`);
  function pb(i, t, e) {
    e === void 0 && !t.startsWith("data:") ? i.crossOrigin = gb(t) : e !== false && (i.crossOrigin = typeof e == "string" ? e : "anonymous");
  }
  function _b(i) {
    return new Promise((t, e) => {
      i.addEventListener("canplaythrough", r), i.addEventListener("error", n), i.load();
      function r() {
        s(), t();
      }
      function n(o) {
        s(), e(o);
      }
      function s() {
        i.removeEventListener("canplaythrough", r), i.removeEventListener("error", n);
      }
    });
  }
  function gb(i, t = globalThis.location) {
    if (i.startsWith("data:")) return "";
    t = t || globalThis.location;
    const e = new URL(i, document.baseURI);
    return e.hostname !== t.hostname || e.port !== t.port || e.protocol !== t.protocol ? "anonymous" : "";
  }
  const mb = {
    name: "loadVideo",
    extension: {
      type: P.LoadParser,
      name: "loadVideo"
    },
    test(i) {
      const t = ri(i, fb), e = Me(i, Hh);
      return t || e;
    },
    async load(i, t, e) {
      var _a2, _b2;
      const r = {
        ...vn.defaultOptions,
        resolution: ((_a2 = t.data) == null ? void 0 : _a2.resolution) || da(i),
        alphaMode: ((_b2 = t.data) == null ? void 0 : _b2.alphaMode) || await Yl(),
        ...t.data
      }, n = document.createElement("video"), s = {
        preload: r.autoLoad !== false ? "auto" : void 0,
        "webkit-playsinline": r.playsinline !== false ? "" : void 0,
        playsinline: r.playsinline !== false ? "" : void 0,
        muted: r.muted === true ? "" : void 0,
        loop: r.loop === true ? "" : void 0,
        autoplay: r.autoPlay !== false ? "" : void 0
      };
      Object.keys(s).forEach((c) => {
        const u = s[c];
        u !== void 0 && n.setAttribute(c, u);
      }), r.muted === true && (n.muted = true), pb(n, i, r.crossorigin);
      const o = document.createElement("source");
      let a;
      if (i.startsWith("data:")) a = i.slice(5, i.indexOf(";"));
      else if (!i.startsWith("blob:")) {
        const c = i.split("?")[0].slice(i.lastIndexOf(".") + 1).toLowerCase();
        a = vn.MIME_TYPES[c] || `video/${c}`;
      }
      return o.src = i, a && (o.type = a), new Promise((c) => {
        const u = async () => {
          const l = new vn({
            ...r,
            resource: n
          });
          n.removeEventListener("canplay", u), t.data.preload && await _b(n), c(Fr(l, e, i));
        };
        n.addEventListener("canplay", u), n.appendChild(o);
      });
    },
    unload(i) {
      i.destroy(true);
    }
  }, zh = {
    extension: {
      type: P.ResolveParser,
      name: "resolveTexture"
    },
    test: Lh.test,
    parse: (i) => {
      var _a2;
      return {
        resolution: parseFloat(((_a2 = Dr.RETINA_PREFIX.exec(i)) == null ? void 0 : _a2[1]) ?? "1"),
        format: i.split(".").pop(),
        src: i
      };
    }
  }, bb = {
    extension: {
      type: P.ResolveParser,
      priority: -2,
      name: "resolveJson"
    },
    test: (i) => Dr.RETINA_PREFIX.test(i) && i.endsWith(".json"),
    parse: zh.parse
  };
  class wb {
    constructor() {
      this._detections = [], this._initialized = false, this.resolver = new Dr(), this.loader = new Hm(), this.cache = Tt, this._backgroundLoader = new Dm(this.loader), this._backgroundLoader.active = true, this.reset();
    }
    async init(t = {}) {
      var _a2, _b2;
      if (this._initialized) {
        ut("[Assets]AssetManager already initialized, did you load before calling this Assets.init()?");
        return;
      }
      if (this._initialized = true, t.defaultSearchParams && this.resolver.setDefaultSearchParams(t.defaultSearchParams), t.basePath && (this.resolver.basePath = t.basePath), t.bundleIdentifier && this.resolver.setBundleIdentifier(t.bundleIdentifier), t.manifest) {
        let s = t.manifest;
        typeof s == "string" && (s = await this.load(s)), this.resolver.addManifest(s);
      }
      const e = ((_a2 = t.texturePreference) == null ? void 0 : _a2.resolution) ?? 1, r = typeof e == "number" ? [
        e
      ] : e, n = await this._detectFormats({
        preferredFormats: (_b2 = t.texturePreference) == null ? void 0 : _b2.format,
        skipDetections: t.skipDetections,
        detections: this._detections
      });
      this.resolver.prefer({
        params: {
          format: n,
          resolution: r
        }
      }), t.preferences && this.setPreferences(t.preferences);
    }
    add(t) {
      this.resolver.add(t);
    }
    async load(t, e) {
      this._initialized || await this.init();
      const r = Mn(t), n = Re(t).map((a) => {
        if (typeof a != "string") {
          const c = this.resolver.getAlias(a);
          return c.some((u) => !this.resolver.hasKey(u)) && this.add(a), Array.isArray(c) ? c[0] : c;
        }
        return this.resolver.hasKey(a) || this.add({
          alias: a,
          src: a
        }), a;
      }), s = this.resolver.resolve(n), o = await this._mapLoadToResolve(s, e);
      return r ? o[n[0]] : o;
    }
    addBundle(t, e) {
      this.resolver.addBundle(t, e);
    }
    async loadBundle(t, e) {
      this._initialized || await this.init();
      let r = false;
      typeof t == "string" && (r = true, t = [
        t
      ]);
      const n = this.resolver.resolveBundle(t), s = {}, o = Object.keys(n);
      let a = 0, c = 0;
      const u = () => {
        e == null ? void 0 : e(++a / c);
      }, l = o.map((h) => {
        const f = n[h];
        return c += Object.keys(f).length, this._mapLoadToResolve(f, u).then((p) => {
          s[h] = p;
        });
      });
      return await Promise.all(l), r ? s[t[0]] : s;
    }
    async backgroundLoad(t) {
      this._initialized || await this.init(), typeof t == "string" && (t = [
        t
      ]);
      const e = this.resolver.resolve(t);
      this._backgroundLoader.add(Object.values(e));
    }
    async backgroundLoadBundle(t) {
      this._initialized || await this.init(), typeof t == "string" && (t = [
        t
      ]);
      const e = this.resolver.resolveBundle(t);
      Object.values(e).forEach((r) => {
        this._backgroundLoader.add(Object.values(r));
      });
    }
    reset() {
      this.resolver.reset(), this.loader.reset(), this.cache.reset(), this._initialized = false;
    }
    get(t) {
      if (typeof t == "string") return Tt.get(t);
      const e = {};
      for (let r = 0; r < t.length; r++) e[r] = Tt.get(t[r]);
      return e;
    }
    async _mapLoadToResolve(t, e) {
      const r = [
        ...new Set(Object.values(t))
      ];
      this._backgroundLoader.active = false;
      const n = await this.loader.load(r, e);
      this._backgroundLoader.active = true;
      const s = {};
      return r.forEach((o) => {
        const a = n[o.src], c = [
          o.src
        ];
        o.alias && c.push(...o.alias), c.forEach((u) => {
          s[u] = a;
        }), Tt.set(c, a);
      }), s;
    }
    async unload(t) {
      this._initialized || await this.init();
      const e = Re(t).map((n) => typeof n != "string" ? n.src : n), r = this.resolver.resolve(e);
      await this._unloadFromResolved(r);
    }
    async unloadBundle(t) {
      this._initialized || await this.init(), t = Re(t);
      const e = this.resolver.resolveBundle(t), r = Object.keys(e).map((n) => this._unloadFromResolved(e[n]));
      await Promise.all(r);
    }
    async _unloadFromResolved(t) {
      const e = Object.values(t);
      e.forEach((r) => {
        Tt.remove(r.src);
      }), await this.loader.unload(e);
    }
    async _detectFormats(t) {
      let e = [];
      t.preferredFormats && (e = Array.isArray(t.preferredFormats) ? t.preferredFormats : [
        t.preferredFormats
      ]);
      for (const r of t.detections) t.skipDetections || await r.test() ? e = await r.add(e) : t.skipDetections || (e = await r.remove(e));
      return e = e.filter((r, n) => e.indexOf(r) === n), e;
    }
    get detections() {
      return this._detections;
    }
    setPreferences(t) {
      this.loader.parsers.forEach((e) => {
        e.config && Object.keys(e.config).filter((r) => r in t).forEach((r) => {
          e.config[r] = t[r];
        });
      });
    }
  }
  const nn = new wb();
  Mt.handleByList(P.LoadParser, nn.loader.parsers).handleByList(P.ResolveParser, nn.resolver.parsers).handleByList(P.CacheParser, nn.cache.parsers).handleByList(P.DetectionParser, nn.detections);
  Mt.add(Im, Um, Fm, Lm, Gm, Om, Nm, Wm, qm, eb, nb, Lh, mb, Mm, Bm, zh, bb);
  const iu = {
    loader: P.LoadParser,
    resolver: P.ResolveParser,
    cache: P.CacheParser,
    detection: P.DetectionParser
  };
  Mt.handle(P.Asset, (i) => {
    const t = i.ref;
    Object.entries(iu).filter(([e]) => !!t[e]).forEach(([e, r]) => Mt.add(Object.assign(t[e], {
      extension: t[e].extension ?? r
    })));
  }, (i) => {
    const t = i.ref;
    Object.keys(iu).filter((e) => !!t[e]).forEach((e) => Mt.remove(t[e]));
  });
  const Z3 = {
    extension: {
      type: P.DetectionParser,
      priority: 3
    },
    test: async () => !!(await Kn() || Yn()),
    add: async (i) => [
      ...i,
      "basis"
    ],
    remove: async (i) => i.filter((t) => t !== "basis")
  };
  class Qn extends Ht {
    constructor(t) {
      super(t), this.uploadMethodId = "compressed", this.resource = t.resource, this.mipLevelCount = this.resource.length;
    }
  }
  let sn;
  function nu() {
    if (sn) return sn;
    const t = document.createElement("canvas").getContext("webgl");
    return t ? (sn = [
      ...t.getExtension("EXT_texture_compression_bptc") ? [
        "bc6h-rgb-ufloat",
        "bc6h-rgb-float",
        "bc7-rgba-unorm",
        "bc7-rgba-unorm-srgb"
      ] : [],
      ...t.getExtension("WEBGL_compressed_texture_s3tc") ? [
        "bc1-rgba-unorm",
        "bc2-rgba-unorm",
        "bc3-rgba-unorm"
      ] : [],
      ...t.getExtension("WEBGL_compressed_texture_s3tc_srgb") ? [
        "bc1-rgba-unorm-srgb",
        "bc2-rgba-unorm-srgb",
        "bc3-rgba-unorm-srgb"
      ] : [],
      ...t.getExtension("EXT_texture_compression_rgtc") ? [
        "bc4-r-unorm",
        "bc4-r-snorm",
        "bc5-rg-unorm",
        "bc5-rg-snorm"
      ] : [],
      ...t.getExtension("WEBGL_compressed_texture_etc") ? [
        "etc2-rgb8unorm",
        "etc2-rgb8unorm-srgb",
        "etc2-rgba8unorm",
        "etc2-rgba8unorm-srgb",
        "etc2-rgb8a1unorm",
        "etc2-rgb8a1unorm-srgb",
        "eac-r11unorm",
        "eac-rg11unorm"
      ] : [],
      ...t.getExtension("WEBGL_compressed_texture_astc") ? [
        "astc-4x4-unorm",
        "astc-4x4-unorm-srgb",
        "astc-5x4-unorm",
        "astc-5x4-unorm-srgb",
        "astc-5x5-unorm",
        "astc-5x5-unorm-srgb",
        "astc-6x5-unorm",
        "astc-6x5-unorm-srgb",
        "astc-6x6-unorm",
        "astc-6x6-unorm-srgb",
        "astc-8x5-unorm",
        "astc-8x5-unorm-srgb",
        "astc-8x6-unorm",
        "astc-8x6-unorm-srgb",
        "astc-8x8-unorm",
        "astc-8x8-unorm-srgb",
        "astc-10x5-unorm",
        "astc-10x5-unorm-srgb",
        "astc-10x6-unorm",
        "astc-10x6-unorm-srgb",
        "astc-10x8-unorm",
        "astc-10x8-unorm-srgb",
        "astc-10x10-unorm",
        "astc-10x10-unorm-srgb",
        "astc-12x10-unorm",
        "astc-12x10-unorm-srgb",
        "astc-12x12-unorm",
        "astc-12x12-unorm-srgb"
      ] : []
    ], sn) : [];
  }
  let on;
  async function su() {
    if (on) return on;
    const i = await navigator.gpu.requestAdapter();
    return on = [
      ...i.features.has("texture-compression-bc") ? [
        "bc1-rgba-unorm",
        "bc1-rgba-unorm-srgb",
        "bc2-rgba-unorm",
        "bc2-rgba-unorm-srgb",
        "bc3-rgba-unorm",
        "bc3-rgba-unorm-srgb",
        "bc4-r-unorm",
        "bc4-r-snorm",
        "bc5-rg-unorm",
        "bc5-rg-snorm",
        "bc6h-rgb-ufloat",
        "bc6h-rgb-float",
        "bc7-rgba-unorm",
        "bc7-rgba-unorm-srgb"
      ] : [],
      ...i.features.has("texture-compression-etc2") ? [
        "etc2-rgb8unorm",
        "etc2-rgb8unorm-srgb",
        "etc2-rgb8a1unorm",
        "etc2-rgb8a1unorm-srgb",
        "etc2-rgba8unorm",
        "etc2-rgba8unorm-srgb",
        "eac-r11unorm",
        "eac-r11snorm",
        "eac-rg11unorm",
        "eac-rg11snorm"
      ] : [],
      ...i.features.has("texture-compression-astc") ? [
        "astc-4x4-unorm",
        "astc-4x4-unorm-srgb",
        "astc-5x4-unorm",
        "astc-5x4-unorm-srgb",
        "astc-5x5-unorm",
        "astc-5x5-unorm-srgb",
        "astc-6x5-unorm",
        "astc-6x5-unorm-srgb",
        "astc-6x6-unorm",
        "astc-6x6-unorm-srgb",
        "astc-8x5-unorm",
        "astc-8x5-unorm-srgb",
        "astc-8x6-unorm",
        "astc-8x6-unorm-srgb",
        "astc-8x8-unorm",
        "astc-8x8-unorm-srgb",
        "astc-10x5-unorm",
        "astc-10x5-unorm-srgb",
        "astc-10x6-unorm",
        "astc-10x6-unorm-srgb",
        "astc-10x8-unorm",
        "astc-10x8-unorm-srgb",
        "astc-10x10-unorm",
        "astc-10x10-unorm-srgb",
        "astc-12x10-unorm",
        "astc-12x10-unorm-srgb",
        "astc-12x12-unorm",
        "astc-12x12-unorm-srgb"
      ] : []
    ], on;
  }
  let an;
  async function jh() {
    return an !== void 0 || (an = await (async () => {
      const i = await Kn(), t = Yn();
      if (i && t) {
        const e = await su(), r = nu();
        return e.filter((n) => r.includes(n));
      } else {
        if (i) return await su();
        if (t) return nu();
      }
      return [];
    })()), an;
  }
  const yb = [
    "r8unorm",
    "r8snorm",
    "r8uint",
    "r8sint",
    "r16uint",
    "r16sint",
    "r16float",
    "rg8unorm",
    "rg8snorm",
    "rg8uint",
    "rg8sint",
    "r32uint",
    "r32sint",
    "r32float",
    "rg16uint",
    "rg16sint",
    "rg16float",
    "rgba8unorm",
    "rgba8unorm-srgb",
    "rgba8snorm",
    "rgba8uint",
    "rgba8sint",
    "bgra8unorm",
    "bgra8unorm-srgb",
    "rgb9e5ufloat",
    "rgb10a2unorm",
    "rg11b10ufloat",
    "rg32uint",
    "rg32sint",
    "rg32float",
    "rgba16uint",
    "rgba16sint",
    "rgba16float",
    "rgba32uint",
    "rgba32sint",
    "rgba32float",
    "stencil8",
    "depth16unorm",
    "depth24plus",
    "depth24plus-stencil8",
    "depth32float",
    "depth32float-stencil8"
  ];
  let cn;
  async function ts() {
    if (cn !== void 0) return cn;
    const i = await jh();
    return cn = [
      ...yb,
      ...i
    ], cn;
  }
  const xb = `(function () {
    'use strict';

    function createLevelBuffers(basisTexture, basisTranscoderFormat) {
      const images = basisTexture.getNumImages();
      const levels = basisTexture.getNumLevels(0);
      const success = basisTexture.startTranscoding();
      if (!success) {
        throw new Error("startTranscoding failed");
      }
      const levelBuffers = [];
      for (let levelIndex = 0; levelIndex < levels; ++levelIndex) {
        for (let sliceIndex = 0; sliceIndex < images; ++sliceIndex) {
          const transcodeSize = basisTexture.getImageTranscodedSizeInBytes(sliceIndex, levelIndex, basisTranscoderFormat);
          const levelBuffer = new Uint8Array(transcodeSize);
          const success2 = basisTexture.transcodeImage(levelBuffer, sliceIndex, levelIndex, basisTranscoderFormat, 1, 0);
          if (!success2) {
            throw new Error("transcodeImage failed");
          }
          levelBuffers.push(levelBuffer);
        }
      }
      return levelBuffers;
    }

    const gpuFormatToBasisTranscoderFormatMap = {
      "bc3-rgba-unorm": 3,
      // cTFBC3_RGBA
      "bc7-rgba-unorm": 6,
      // cTFBC7_RGBA,
      "etc2-rgba8unorm": 1,
      // cTFETC2_RGBA,
      "astc-4x4-unorm": 10,
      // cTFASTC_4x4_RGBA,
      // Uncompressed
      rgba8unorm: 13,
      // cTFRGBA32,
      rgba4unorm: 16
      // cTFRGBA4444,
    };
    function gpuFormatToBasisTranscoderFormat(transcoderFormat) {
      const format = gpuFormatToBasisTranscoderFormatMap[transcoderFormat];
      if (format) {
        return format;
      }
      throw new Error(\`Unsupported transcoderFormat: \${transcoderFormat}\`);
    }

    const settings = {
      jsUrl: "basis/basis_transcoder.js",
      wasmUrl: "basis/basis_transcoder.wasm"
    };
    let basisTranscoderFormat;
    let basisTranscodedTextureFormat;
    let basisPromise;
    async function getBasis() {
      if (!basisPromise) {
        const absoluteJsUrl = new URL(settings.jsUrl, location.origin).href;
        const absoluteWasmUrl = new URL(settings.wasmUrl, location.origin).href;
        importScripts(absoluteJsUrl);
        basisPromise = new Promise((resolve) => {
          BASIS({
            locateFile: (_file) => absoluteWasmUrl
          }).then((module) => {
            module.initializeBasis();
            resolve(module.BasisFile);
          });
        });
      }
      return basisPromise;
    }
    async function fetchBasisTexture(url, BasisTexture) {
      const basisResponse = await fetch(url);
      if (basisResponse.ok) {
        const basisArrayBuffer = await basisResponse.arrayBuffer();
        return new BasisTexture(new Uint8Array(basisArrayBuffer));
      }
      throw new Error(\`Failed to load Basis texture: \${url}\`);
    }
    const preferredTranscodedFormat = [
      "bc7-rgba-unorm",
      "astc-4x4-unorm",
      "etc2-rgba8unorm",
      "bc3-rgba-unorm",
      "rgba8unorm"
    ];
    async function load(url) {
      const BasisTexture = await getBasis();
      const basisTexture = await fetchBasisTexture(url, BasisTexture);
      const levelBuffers = createLevelBuffers(basisTexture, basisTranscoderFormat);
      return {
        width: basisTexture.getImageWidth(0, 0),
        height: basisTexture.getImageHeight(0, 0),
        format: basisTranscodedTextureFormat,
        resource: levelBuffers,
        alphaMode: "no-premultiply-alpha"
      };
    }
    async function init(jsUrl, wasmUrl, supportedTextures) {
      if (jsUrl)
        settings.jsUrl = jsUrl;
      if (wasmUrl)
        settings.wasmUrl = wasmUrl;
      basisTranscodedTextureFormat = preferredTranscodedFormat.filter((format) => supportedTextures.includes(format))[0];
      basisTranscoderFormat = gpuFormatToBasisTranscoderFormat(basisTranscodedTextureFormat);
      await getBasis();
    }
    const messageHandlers = {
      init: async (data) => {
        const { jsUrl, wasmUrl, supportedTextures } = data;
        await init(jsUrl, wasmUrl, supportedTextures);
      },
      load: async (data) => {
        try {
          const textureOptions = await load(data.url);
          return {
            type: "load",
            url: data.url,
            success: true,
            textureOptions,
            transferables: textureOptions.resource?.map((arr) => arr.buffer)
          };
        } catch (e) {
          throw e;
        }
      }
    };
    self.onmessage = async (messageEvent) => {
      const message = messageEvent.data;
      const response = await messageHandlers[message.type](message);
      if (response) {
        self.postMessage(response, response.transferables);
      }
    };

})();
`;
  let Xr = null, Wh = class {
    constructor() {
      Xr || (Xr = URL.createObjectURL(new Blob([
        xb
      ], {
        type: "application/javascript"
      }))), this.worker = new Worker(Xr);
    }
  };
  Wh.revokeObjectURL = function() {
    Xr && (URL.revokeObjectURL(Xr), Xr = null);
  };
  const ou = {
    jsUrl: "https://files.pixijs.download/transcoders/basis/basis_transcoder.js",
    wasmUrl: "https://files.pixijs.download/transcoders/basis/basis_transcoder.wasm"
  };
  let ui;
  const Vh = {};
  function vb(i) {
    return ui || (ui = new Wh().worker, ui.onmessage = (t) => {
      const { success: e, url: r, textureOptions: n } = t.data;
      e || console.warn("Failed to load Basis texture", r), Vh[r](n);
    }, ui.postMessage({
      type: "init",
      jsUrl: ou.jsUrl,
      wasmUrl: ou.wasmUrl,
      supportedTextures: i
    })), ui;
  }
  function Sb(i, t) {
    const e = vb(t);
    return new Promise((r) => {
      Vh[i] = r, e.postMessage({
        type: "load",
        url: i
      });
    });
  }
  const Q3 = {
    extension: {
      type: P.LoadParser,
      priority: ve.High,
      name: "loadBasis"
    },
    name: "loadBasis",
    test(i) {
      return Me(i, [
        ".basis"
      ]);
    },
    async load(i, t, e) {
      const r = await ts(), n = await Sb(i, r), s = new Qn(n);
      return Fr(s, e, i);
    },
    unload(i) {
      Array.isArray(i) ? i.forEach((t) => t.destroy(true)) : i.destroy(true);
    }
  };
  const Eb = {
    MAGIC: 0,
    SIZE: 1,
    FLAGS: 2,
    HEIGHT: 3,
    WIDTH: 4,
    MIPMAP_COUNT: 7,
    PIXEL_FORMAT: 19,
    PF_FLAGS: 20,
    FOURCC: 21,
    RGB_BITCOUNT: 22,
    R_BIT_MASK: 23,
    G_BIT_MASK: 24,
    B_BIT_MASK: 25,
    A_BIT_MASK: 26
  }, Ab = {
    DXGI_FORMAT: 0,
    RESOURCE_DIMENSION: 1,
    MISC_FLAG: 2,
    ARRAY_SIZE: 3,
    MISC_FLAGS2: 4
  };
  var Xh = ((i) => (i[i.DXGI_FORMAT_UNKNOWN = 0] = "DXGI_FORMAT_UNKNOWN", i[i.DXGI_FORMAT_R32G32B32A32_TYPELESS = 1] = "DXGI_FORMAT_R32G32B32A32_TYPELESS", i[i.DXGI_FORMAT_R32G32B32A32_FLOAT = 2] = "DXGI_FORMAT_R32G32B32A32_FLOAT", i[i.DXGI_FORMAT_R32G32B32A32_UINT = 3] = "DXGI_FORMAT_R32G32B32A32_UINT", i[i.DXGI_FORMAT_R32G32B32A32_SINT = 4] = "DXGI_FORMAT_R32G32B32A32_SINT", i[i.DXGI_FORMAT_R32G32B32_TYPELESS = 5] = "DXGI_FORMAT_R32G32B32_TYPELESS", i[i.DXGI_FORMAT_R32G32B32_FLOAT = 6] = "DXGI_FORMAT_R32G32B32_FLOAT", i[i.DXGI_FORMAT_R32G32B32_UINT = 7] = "DXGI_FORMAT_R32G32B32_UINT", i[i.DXGI_FORMAT_R32G32B32_SINT = 8] = "DXGI_FORMAT_R32G32B32_SINT", i[i.DXGI_FORMAT_R16G16B16A16_TYPELESS = 9] = "DXGI_FORMAT_R16G16B16A16_TYPELESS", i[i.DXGI_FORMAT_R16G16B16A16_FLOAT = 10] = "DXGI_FORMAT_R16G16B16A16_FLOAT", i[i.DXGI_FORMAT_R16G16B16A16_UNORM = 11] = "DXGI_FORMAT_R16G16B16A16_UNORM", i[i.DXGI_FORMAT_R16G16B16A16_UINT = 12] = "DXGI_FORMAT_R16G16B16A16_UINT", i[i.DXGI_FORMAT_R16G16B16A16_SNORM = 13] = "DXGI_FORMAT_R16G16B16A16_SNORM", i[i.DXGI_FORMAT_R16G16B16A16_SINT = 14] = "DXGI_FORMAT_R16G16B16A16_SINT", i[i.DXGI_FORMAT_R32G32_TYPELESS = 15] = "DXGI_FORMAT_R32G32_TYPELESS", i[i.DXGI_FORMAT_R32G32_FLOAT = 16] = "DXGI_FORMAT_R32G32_FLOAT", i[i.DXGI_FORMAT_R32G32_UINT = 17] = "DXGI_FORMAT_R32G32_UINT", i[i.DXGI_FORMAT_R32G32_SINT = 18] = "DXGI_FORMAT_R32G32_SINT", i[i.DXGI_FORMAT_R32G8X24_TYPELESS = 19] = "DXGI_FORMAT_R32G8X24_TYPELESS", i[i.DXGI_FORMAT_D32_FLOAT_S8X24_UINT = 20] = "DXGI_FORMAT_D32_FLOAT_S8X24_UINT", i[i.DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS = 21] = "DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS", i[i.DXGI_FORMAT_X32_TYPELESS_G8X24_UINT = 22] = "DXGI_FORMAT_X32_TYPELESS_G8X24_UINT", i[i.DXGI_FORMAT_R10G10B10A2_TYPELESS = 23] = "DXGI_FORMAT_R10G10B10A2_TYPELESS", i[i.DXGI_FORMAT_R10G10B10A2_UNORM = 24] = "DXGI_FORMAT_R10G10B10A2_UNORM", i[i.DXGI_FORMAT_R10G10B10A2_UINT = 25] = "DXGI_FORMAT_R10G10B10A2_UINT", i[i.DXGI_FORMAT_R11G11B10_FLOAT = 26] = "DXGI_FORMAT_R11G11B10_FLOAT", i[i.DXGI_FORMAT_R8G8B8A8_TYPELESS = 27] = "DXGI_FORMAT_R8G8B8A8_TYPELESS", i[i.DXGI_FORMAT_R8G8B8A8_UNORM = 28] = "DXGI_FORMAT_R8G8B8A8_UNORM", i[i.DXGI_FORMAT_R8G8B8A8_UNORM_SRGB = 29] = "DXGI_FORMAT_R8G8B8A8_UNORM_SRGB", i[i.DXGI_FORMAT_R8G8B8A8_UINT = 30] = "DXGI_FORMAT_R8G8B8A8_UINT", i[i.DXGI_FORMAT_R8G8B8A8_SNORM = 31] = "DXGI_FORMAT_R8G8B8A8_SNORM", i[i.DXGI_FORMAT_R8G8B8A8_SINT = 32] = "DXGI_FORMAT_R8G8B8A8_SINT", i[i.DXGI_FORMAT_R16G16_TYPELESS = 33] = "DXGI_FORMAT_R16G16_TYPELESS", i[i.DXGI_FORMAT_R16G16_FLOAT = 34] = "DXGI_FORMAT_R16G16_FLOAT", i[i.DXGI_FORMAT_R16G16_UNORM = 35] = "DXGI_FORMAT_R16G16_UNORM", i[i.DXGI_FORMAT_R16G16_UINT = 36] = "DXGI_FORMAT_R16G16_UINT", i[i.DXGI_FORMAT_R16G16_SNORM = 37] = "DXGI_FORMAT_R16G16_SNORM", i[i.DXGI_FORMAT_R16G16_SINT = 38] = "DXGI_FORMAT_R16G16_SINT", i[i.DXGI_FORMAT_R32_TYPELESS = 39] = "DXGI_FORMAT_R32_TYPELESS", i[i.DXGI_FORMAT_D32_FLOAT = 40] = "DXGI_FORMAT_D32_FLOAT", i[i.DXGI_FORMAT_R32_FLOAT = 41] = "DXGI_FORMAT_R32_FLOAT", i[i.DXGI_FORMAT_R32_UINT = 42] = "DXGI_FORMAT_R32_UINT", i[i.DXGI_FORMAT_R32_SINT = 43] = "DXGI_FORMAT_R32_SINT", i[i.DXGI_FORMAT_R24G8_TYPELESS = 44] = "DXGI_FORMAT_R24G8_TYPELESS", i[i.DXGI_FORMAT_D24_UNORM_S8_UINT = 45] = "DXGI_FORMAT_D24_UNORM_S8_UINT", i[i.DXGI_FORMAT_R24_UNORM_X8_TYPELESS = 46] = "DXGI_FORMAT_R24_UNORM_X8_TYPELESS", i[i.DXGI_FORMAT_X24_TYPELESS_G8_UINT = 47] = "DXGI_FORMAT_X24_TYPELESS_G8_UINT", i[i.DXGI_FORMAT_R8G8_TYPELESS = 48] = "DXGI_FORMAT_R8G8_TYPELESS", i[i.DXGI_FORMAT_R8G8_UNORM = 49] = "DXGI_FORMAT_R8G8_UNORM", i[i.DXGI_FORMAT_R8G8_UINT = 50] = "DXGI_FORMAT_R8G8_UINT", i[i.DXGI_FORMAT_R8G8_SNORM = 51] = "DXGI_FORMAT_R8G8_SNORM", i[i.DXGI_FORMAT_R8G8_SINT = 52] = "DXGI_FORMAT_R8G8_SINT", i[i.DXGI_FORMAT_R16_TYPELESS = 53] = "DXGI_FORMAT_R16_TYPELESS", i[i.DXGI_FORMAT_R16_FLOAT = 54] = "DXGI_FORMAT_R16_FLOAT", i[i.DXGI_FORMAT_D16_UNORM = 55] = "DXGI_FORMAT_D16_UNORM", i[i.DXGI_FORMAT_R16_UNORM = 56] = "DXGI_FORMAT_R16_UNORM", i[i.DXGI_FORMAT_R16_UINT = 57] = "DXGI_FORMAT_R16_UINT", i[i.DXGI_FORMAT_R16_SNORM = 58] = "DXGI_FORMAT_R16_SNORM", i[i.DXGI_FORMAT_R16_SINT = 59] = "DXGI_FORMAT_R16_SINT", i[i.DXGI_FORMAT_R8_TYPELESS = 60] = "DXGI_FORMAT_R8_TYPELESS", i[i.DXGI_FORMAT_R8_UNORM = 61] = "DXGI_FORMAT_R8_UNORM", i[i.DXGI_FORMAT_R8_UINT = 62] = "DXGI_FORMAT_R8_UINT", i[i.DXGI_FORMAT_R8_SNORM = 63] = "DXGI_FORMAT_R8_SNORM", i[i.DXGI_FORMAT_R8_SINT = 64] = "DXGI_FORMAT_R8_SINT", i[i.DXGI_FORMAT_A8_UNORM = 65] = "DXGI_FORMAT_A8_UNORM", i[i.DXGI_FORMAT_R1_UNORM = 66] = "DXGI_FORMAT_R1_UNORM", i[i.DXGI_FORMAT_R9G9B9E5_SHAREDEXP = 67] = "DXGI_FORMAT_R9G9B9E5_SHAREDEXP", i[i.DXGI_FORMAT_R8G8_B8G8_UNORM = 68] = "DXGI_FORMAT_R8G8_B8G8_UNORM", i[i.DXGI_FORMAT_G8R8_G8B8_UNORM = 69] = "DXGI_FORMAT_G8R8_G8B8_UNORM", i[i.DXGI_FORMAT_BC1_TYPELESS = 70] = "DXGI_FORMAT_BC1_TYPELESS", i[i.DXGI_FORMAT_BC1_UNORM = 71] = "DXGI_FORMAT_BC1_UNORM", i[i.DXGI_FORMAT_BC1_UNORM_SRGB = 72] = "DXGI_FORMAT_BC1_UNORM_SRGB", i[i.DXGI_FORMAT_BC2_TYPELESS = 73] = "DXGI_FORMAT_BC2_TYPELESS", i[i.DXGI_FORMAT_BC2_UNORM = 74] = "DXGI_FORMAT_BC2_UNORM", i[i.DXGI_FORMAT_BC2_UNORM_SRGB = 75] = "DXGI_FORMAT_BC2_UNORM_SRGB", i[i.DXGI_FORMAT_BC3_TYPELESS = 76] = "DXGI_FORMAT_BC3_TYPELESS", i[i.DXGI_FORMAT_BC3_UNORM = 77] = "DXGI_FORMAT_BC3_UNORM", i[i.DXGI_FORMAT_BC3_UNORM_SRGB = 78] = "DXGI_FORMAT_BC3_UNORM_SRGB", i[i.DXGI_FORMAT_BC4_TYPELESS = 79] = "DXGI_FORMAT_BC4_TYPELESS", i[i.DXGI_FORMAT_BC4_UNORM = 80] = "DXGI_FORMAT_BC4_UNORM", i[i.DXGI_FORMAT_BC4_SNORM = 81] = "DXGI_FORMAT_BC4_SNORM", i[i.DXGI_FORMAT_BC5_TYPELESS = 82] = "DXGI_FORMAT_BC5_TYPELESS", i[i.DXGI_FORMAT_BC5_UNORM = 83] = "DXGI_FORMAT_BC5_UNORM", i[i.DXGI_FORMAT_BC5_SNORM = 84] = "DXGI_FORMAT_BC5_SNORM", i[i.DXGI_FORMAT_B5G6R5_UNORM = 85] = "DXGI_FORMAT_B5G6R5_UNORM", i[i.DXGI_FORMAT_B5G5R5A1_UNORM = 86] = "DXGI_FORMAT_B5G5R5A1_UNORM", i[i.DXGI_FORMAT_B8G8R8A8_UNORM = 87] = "DXGI_FORMAT_B8G8R8A8_UNORM", i[i.DXGI_FORMAT_B8G8R8X8_UNORM = 88] = "DXGI_FORMAT_B8G8R8X8_UNORM", i[i.DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM = 89] = "DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM", i[i.DXGI_FORMAT_B8G8R8A8_TYPELESS = 90] = "DXGI_FORMAT_B8G8R8A8_TYPELESS", i[i.DXGI_FORMAT_B8G8R8A8_UNORM_SRGB = 91] = "DXGI_FORMAT_B8G8R8A8_UNORM_SRGB", i[i.DXGI_FORMAT_B8G8R8X8_TYPELESS = 92] = "DXGI_FORMAT_B8G8R8X8_TYPELESS", i[i.DXGI_FORMAT_B8G8R8X8_UNORM_SRGB = 93] = "DXGI_FORMAT_B8G8R8X8_UNORM_SRGB", i[i.DXGI_FORMAT_BC6H_TYPELESS = 94] = "DXGI_FORMAT_BC6H_TYPELESS", i[i.DXGI_FORMAT_BC6H_UF16 = 95] = "DXGI_FORMAT_BC6H_UF16", i[i.DXGI_FORMAT_BC6H_SF16 = 96] = "DXGI_FORMAT_BC6H_SF16", i[i.DXGI_FORMAT_BC7_TYPELESS = 97] = "DXGI_FORMAT_BC7_TYPELESS", i[i.DXGI_FORMAT_BC7_UNORM = 98] = "DXGI_FORMAT_BC7_UNORM", i[i.DXGI_FORMAT_BC7_UNORM_SRGB = 99] = "DXGI_FORMAT_BC7_UNORM_SRGB", i[i.DXGI_FORMAT_AYUV = 100] = "DXGI_FORMAT_AYUV", i[i.DXGI_FORMAT_Y410 = 101] = "DXGI_FORMAT_Y410", i[i.DXGI_FORMAT_Y416 = 102] = "DXGI_FORMAT_Y416", i[i.DXGI_FORMAT_NV12 = 103] = "DXGI_FORMAT_NV12", i[i.DXGI_FORMAT_P010 = 104] = "DXGI_FORMAT_P010", i[i.DXGI_FORMAT_P016 = 105] = "DXGI_FORMAT_P016", i[i.DXGI_FORMAT_420_OPAQUE = 106] = "DXGI_FORMAT_420_OPAQUE", i[i.DXGI_FORMAT_YUY2 = 107] = "DXGI_FORMAT_YUY2", i[i.DXGI_FORMAT_Y210 = 108] = "DXGI_FORMAT_Y210", i[i.DXGI_FORMAT_Y216 = 109] = "DXGI_FORMAT_Y216", i[i.DXGI_FORMAT_NV11 = 110] = "DXGI_FORMAT_NV11", i[i.DXGI_FORMAT_AI44 = 111] = "DXGI_FORMAT_AI44", i[i.DXGI_FORMAT_IA44 = 112] = "DXGI_FORMAT_IA44", i[i.DXGI_FORMAT_P8 = 113] = "DXGI_FORMAT_P8", i[i.DXGI_FORMAT_A8P8 = 114] = "DXGI_FORMAT_A8P8", i[i.DXGI_FORMAT_B4G4R4A4_UNORM = 115] = "DXGI_FORMAT_B4G4R4A4_UNORM", i[i.DXGI_FORMAT_P208 = 116] = "DXGI_FORMAT_P208", i[i.DXGI_FORMAT_V208 = 117] = "DXGI_FORMAT_V208", i[i.DXGI_FORMAT_V408 = 118] = "DXGI_FORMAT_V408", i[i.DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE = 119] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE", i[i.DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE = 120] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE", i[i.DXGI_FORMAT_FORCE_UINT = 121] = "DXGI_FORMAT_FORCE_UINT", i))(Xh || {}), qh = ((i) => (i[i.DDS_DIMENSION_TEXTURE1D = 2] = "DDS_DIMENSION_TEXTURE1D", i[i.DDS_DIMENSION_TEXTURE2D = 3] = "DDS_DIMENSION_TEXTURE2D", i[i.DDS_DIMENSION_TEXTURE3D = 6] = "DDS_DIMENSION_TEXTURE3D", i))(qh || {});
  function qt(i) {
    return i.charCodeAt(0) + (i.charCodeAt(1) << 8) + (i.charCodeAt(2) << 16) + (i.charCodeAt(3) << 24);
  }
  var he = ((i) => (i[i.UNKNOWN = 0] = "UNKNOWN", i[i.R8G8B8 = 20] = "R8G8B8", i[i.A8R8G8B8 = 21] = "A8R8G8B8", i[i.X8R8G8B8 = 22] = "X8R8G8B8", i[i.R5G6B5 = 23] = "R5G6B5", i[i.X1R5G5B5 = 24] = "X1R5G5B5", i[i.A1R5G5B5 = 25] = "A1R5G5B5", i[i.A4R4G4B4 = 26] = "A4R4G4B4", i[i.R3G3B2 = 27] = "R3G3B2", i[i.A8 = 28] = "A8", i[i.A8R3G3B2 = 29] = "A8R3G3B2", i[i.X4R4G4B4 = 30] = "X4R4G4B4", i[i.A2B10G10R10 = 31] = "A2B10G10R10", i[i.A8B8G8R8 = 32] = "A8B8G8R8", i[i.X8B8G8R8 = 33] = "X8B8G8R8", i[i.G16R16 = 34] = "G16R16", i[i.A2R10G10B10 = 35] = "A2R10G10B10", i[i.A16B16G16R16 = 36] = "A16B16G16R16", i[i.A8P8 = 40] = "A8P8", i[i.P8 = 41] = "P8", i[i.L8 = 50] = "L8", i[i.A8L8 = 51] = "A8L8", i[i.A4L4 = 52] = "A4L4", i[i.V8U8 = 60] = "V8U8", i[i.L6V5U5 = 61] = "L6V5U5", i[i.X8L8V8U8 = 62] = "X8L8V8U8", i[i.Q8W8V8U8 = 63] = "Q8W8V8U8", i[i.V16U16 = 64] = "V16U16", i[i.A2W10V10U10 = 67] = "A2W10V10U10", i[i.Q16W16V16U16 = 110] = "Q16W16V16U16", i[i.R16F = 111] = "R16F", i[i.G16R16F = 112] = "G16R16F", i[i.A16B16G16R16F = 113] = "A16B16G16R16F", i[i.R32F = 114] = "R32F", i[i.G32R32F = 115] = "G32R32F", i[i.A32B32G32R32F = 116] = "A32B32G32R32F", i[i.UYVY = qt("UYVY")] = "UYVY", i[i.R8G8_B8G8 = qt("RGBG")] = "R8G8_B8G8", i[i.YUY2 = qt("YUY2")] = "YUY2", i[i.D3DFMT_G8R8_G8B8 = qt("GRGB")] = "D3DFMT_G8R8_G8B8", i[i.DXT1 = qt("DXT1")] = "DXT1", i[i.DXT2 = qt("DXT2")] = "DXT2", i[i.DXT3 = qt("DXT3")] = "DXT3", i[i.DXT4 = qt("DXT4")] = "DXT4", i[i.DXT5 = qt("DXT5")] = "DXT5", i[i.ATI1 = qt("ATI1")] = "ATI1", i[i.AT1N = qt("AT1N")] = "AT1N", i[i.ATI2 = qt("ATI2")] = "ATI2", i[i.AT2N = qt("AT2N")] = "AT2N", i[i.BC4U = qt("BC4U")] = "BC4U", i[i.BC4S = qt("BC4S")] = "BC4S", i[i.BC5U = qt("BC5U")] = "BC5U", i[i.BC5S = qt("BC5S")] = "BC5S", i[i.DX10 = qt("DX10")] = "DX10", i))(he || {});
  const au = {
    [he.DXT1]: "bc1-rgba-unorm",
    [he.DXT2]: "bc2-rgba-unorm",
    [he.DXT3]: "bc2-rgba-unorm",
    [he.DXT4]: "bc3-rgba-unorm",
    [he.DXT5]: "bc3-rgba-unorm",
    [he.ATI1]: "bc4-r-unorm",
    [he.BC4U]: "bc4-r-unorm",
    [he.BC4S]: "bc4-r-snorm",
    [he.ATI2]: "bc5-rg-unorm",
    [he.BC5U]: "bc5-rg-unorm",
    [he.BC5S]: "bc5-rg-snorm",
    36: "rgba16uint",
    110: "rgba16sint",
    111: "r16float",
    112: "rg16float",
    113: "rgba16float",
    114: "r32float",
    115: "rg32float",
    116: "rgba32float"
  }, de = {
    70: "bc1-rgba-unorm",
    71: "bc1-rgba-unorm",
    72: "bc1-rgba-unorm-srgb",
    73: "bc2-rgba-unorm",
    74: "bc2-rgba-unorm",
    75: "bc2-rgba-unorm-srgb",
    76: "bc3-rgba-unorm",
    77: "bc3-rgba-unorm",
    78: "bc3-rgba-unorm-srgb",
    79: "bc4-r-unorm",
    80: "bc4-r-unorm",
    81: "bc4-r-snorm",
    82: "bc5-rg-unorm",
    83: "bc5-rg-unorm",
    84: "bc5-rg-snorm",
    94: "bc6h-rgb-ufloat",
    95: "bc6h-rgb-ufloat",
    96: "bc6h-rgb-float",
    97: "bc7-rgba-unorm",
    98: "bc7-rgba-unorm",
    99: "bc7-rgba-unorm-srgb",
    28: "rgba8unorm",
    29: "rgba8unorm-srgb",
    87: "bgra8unorm",
    91: "bgra8unorm-srgb",
    41: "r32float",
    49: "rg8unorm",
    56: "r16uint",
    61: "r8unorm",
    24: "rgb10a2unorm",
    11: "rgba16uint",
    13: "rgba16sint",
    10: "rgba16float",
    54: "r16float",
    34: "rg16float",
    16: "rg32float",
    2: "rgba32float"
  }, at = {
    MAGIC_VALUE: 542327876,
    MAGIC_SIZE: 4,
    HEADER_SIZE: 124,
    HEADER_DX10_SIZE: 20,
    PIXEL_FORMAT_FLAGS: {
      ALPHAPIXELS: 1,
      ALPHA: 2,
      FOURCC: 4,
      RGB: 64,
      RGBA: 65,
      YUV: 512,
      LUMINANCE: 131072,
      LUMINANCEA: 131073
    },
    RESOURCE_MISC_TEXTURECUBE: 4,
    HEADER_FIELDS: Eb,
    HEADER_DX10_FIELDS: Ab,
    DXGI_FORMAT: Xh,
    D3D10_RESOURCE_DIMENSION: qh,
    D3DFMT: he
  }, Tb = {
    "bc1-rgba-unorm": 8,
    "bc1-rgba-unorm-srgb": 8,
    "bc2-rgba-unorm": 16,
    "bc2-rgba-unorm-srgb": 16,
    "bc3-rgba-unorm": 16,
    "bc3-rgba-unorm-srgb": 16,
    "bc4-r-unorm": 8,
    "bc4-r-snorm": 8,
    "bc5-rg-unorm": 16,
    "bc5-rg-snorm": 16,
    "bc6h-rgb-ufloat": 16,
    "bc6h-rgb-float": 16,
    "bc7-rgba-unorm": 16,
    "bc7-rgba-unorm-srgb": 16
  };
  function Cb(i, t) {
    const { format: e, fourCC: r, width: n, height: s, dataOffset: o, mipmapCount: a } = Pb(i);
    if (!t.includes(e)) throw new Error(`Unsupported texture format: ${r} ${e}, supported: ${t}`);
    if (a <= 1) return {
      format: e,
      width: n,
      height: s,
      resource: [
        new Uint8Array(i, o)
      ],
      alphaMode: "no-premultiply-alpha"
    };
    const c = Rb(e, n, s, o, a, i);
    return {
      format: e,
      width: n,
      height: s,
      resource: c,
      alphaMode: "no-premultiply-alpha"
    };
  }
  function Rb(i, t, e, r, n, s) {
    const o = [], a = Tb[i];
    let c = t, u = e, l = r;
    for (let h = 0; h < n; ++h) {
      const f = a ? Math.max(4, c) / 4 * Math.max(4, u) / 4 * a : c * u * 4, p = new Uint8Array(s, l, f);
      o.push(p), l += f, c = Math.max(c >> 1, 1), u = Math.max(u >> 1, 1);
    }
    return o;
  }
  function Pb(i) {
    const t = new Uint32Array(i, 0, at.HEADER_SIZE / Uint32Array.BYTES_PER_ELEMENT);
    if (t[at.HEADER_FIELDS.MAGIC] !== at.MAGIC_VALUE) throw new Error("Invalid magic number in DDS header");
    const e = t[at.HEADER_FIELDS.HEIGHT], r = t[at.HEADER_FIELDS.WIDTH], n = Math.max(1, t[at.HEADER_FIELDS.MIPMAP_COUNT]), s = t[at.HEADER_FIELDS.PF_FLAGS], o = t[at.HEADER_FIELDS.FOURCC], a = Bb(t, s, o, i), c = at.MAGIC_SIZE + at.HEADER_SIZE + (o === at.D3DFMT.DX10 ? at.HEADER_DX10_SIZE : 0);
    return {
      format: a,
      fourCC: o,
      width: r,
      height: e,
      dataOffset: c,
      mipmapCount: n
    };
  }
  function Bb(i, t, e, r) {
    if (t & at.PIXEL_FORMAT_FLAGS.FOURCC) {
      if (e === at.D3DFMT.DX10) {
        const n = new Uint32Array(r, at.MAGIC_SIZE + at.HEADER_SIZE, at.HEADER_DX10_SIZE / Uint32Array.BYTES_PER_ELEMENT);
        if (n[at.HEADER_DX10_FIELDS.MISC_FLAG] === at.RESOURCE_MISC_TEXTURECUBE) throw new Error("DDSParser does not support cubemap textures");
        if (n[at.HEADER_DX10_FIELDS.RESOURCE_DIMENSION] === at.D3D10_RESOURCE_DIMENSION.DDS_DIMENSION_TEXTURE3D) throw new Error("DDSParser does not supported 3D texture data");
        const a = n[at.HEADER_DX10_FIELDS.DXGI_FORMAT];
        if (a in de) return de[a];
        throw new Error(`DDSParser cannot parse texture data with DXGI format ${a}`);
      }
      if (e in au) return au[e];
      throw new Error(`DDSParser cannot parse texture data with fourCC format ${e}`);
    }
    if (t & at.PIXEL_FORMAT_FLAGS.RGB || t & at.PIXEL_FORMAT_FLAGS.RGBA) return Mb(i);
    throw t & at.PIXEL_FORMAT_FLAGS.YUV ? new Error("DDSParser does not supported YUV uncompressed texture data.") : t & at.PIXEL_FORMAT_FLAGS.LUMINANCE || t & at.PIXEL_FORMAT_FLAGS.LUMINANCEA ? new Error("DDSParser does not support single-channel (lumninance) texture data!") : t & at.PIXEL_FORMAT_FLAGS.ALPHA || t & at.PIXEL_FORMAT_FLAGS.ALPHAPIXELS ? new Error("DDSParser does not support single-channel (alpha) texture data!") : new Error("DDSParser failed to load a texture file due to an unknown reason!");
  }
  function Mb(i) {
    const t = i[at.HEADER_FIELDS.RGB_BITCOUNT], e = i[at.HEADER_FIELDS.R_BIT_MASK], r = i[at.HEADER_FIELDS.G_BIT_MASK], n = i[at.HEADER_FIELDS.B_BIT_MASK], s = i[at.HEADER_FIELDS.A_BIT_MASK];
    switch (t) {
      case 32:
        if (e === 255 && r === 65280 && n === 16711680 && s === 4278190080) return de[at.DXGI_FORMAT.DXGI_FORMAT_R8G8B8A8_UNORM];
        if (e === 16711680 && r === 65280 && n === 255 && s === 4278190080) return de[at.DXGI_FORMAT.DXGI_FORMAT_B8G8R8A8_UNORM];
        if (e === 1072693248 && r === 1047552 && n === 1023 && s === 3221225472) return de[at.DXGI_FORMAT.DXGI_FORMAT_R10G10B10A2_UNORM];
        if (e === 65535 && r === 4294901760 && n === 0 && s === 0) return de[at.DXGI_FORMAT.DXGI_FORMAT_R16G16_UNORM];
        if (e === 4294967295 && r === 0 && n === 0 && s === 0) return de[at.DXGI_FORMAT.DXGI_FORMAT_R32_FLOAT];
        break;
      case 24:
        break;
      case 16:
        if (e === 31744 && r === 992 && n === 31 && s === 32768) return de[at.DXGI_FORMAT.DXGI_FORMAT_B5G5R5A1_UNORM];
        if (e === 63488 && r === 2016 && n === 31 && s === 0) return de[at.DXGI_FORMAT.DXGI_FORMAT_B5G6R5_UNORM];
        if (e === 3840 && r === 240 && n === 15 && s === 61440) return de[at.DXGI_FORMAT.DXGI_FORMAT_B4G4R4A4_UNORM];
        if (e === 255 && r === 0 && n === 0 && s === 65280) return de[at.DXGI_FORMAT.DXGI_FORMAT_R8G8_UNORM];
        if (e === 65535 && r === 0 && n === 0 && s === 0) return de[at.DXGI_FORMAT.DXGI_FORMAT_R16_UNORM];
        break;
      case 8:
        if (e === 255 && r === 0 && n === 0 && s === 0) return de[at.DXGI_FORMAT.DXGI_FORMAT_R8_UNORM];
        break;
    }
    throw new Error(`DDSParser does not support uncompressed texture with configuration:
                bitCount = ${t}, rBitMask = ${e}, gBitMask = ${r}, aBitMask = ${s}`);
  }
  const tR = {
    extension: {
      type: P.LoadParser,
      priority: ve.High,
      name: "loadDDS"
    },
    name: "loadDDS",
    test(i) {
      return Me(i, [
        ".dds"
      ]);
    },
    async load(i, t, e) {
      const r = await ts(), s = await (await fetch(i)).arrayBuffer(), o = Cb(s, r), a = new Qn(o);
      return Fr(a, e, i);
    },
    unload(i) {
      Array.isArray(i) ? i.forEach((t) => t.destroy(true)) : i.destroy(true);
    }
  };
  const Db = {
    33776: "bc1-rgba-unorm",
    33777: "bc1-rgba-unorm",
    33778: "bc2-rgba-unorm",
    33779: "bc3-rgba-unorm",
    35916: "bc1-rgba-unorm-srgb",
    35917: "bc1-rgba-unorm-srgb",
    35918: "bc2-rgba-unorm-srgb",
    35919: "bc3-rgba-unorm-srgb",
    36283: "bc4-r-unorm",
    36284: "bc4-r-snorm",
    36285: "bc5-rg-unorm",
    36286: "bc5-rg-snorm",
    37488: "eac-r11unorm",
    37490: "eac-rg11snorm",
    37492: "etc2-rgb8unorm",
    37496: "etc2-rgba8unorm",
    37493: "etc2-rgb8unorm-srgb",
    37497: "etc2-rgba8unorm-srgb",
    37494: "etc2-rgb8a1unorm",
    37495: "etc2-rgb8a1unorm-srgb",
    37808: "astc-4x4-unorm",
    37840: "astc-4x4-unorm-srgb",
    37809: "astc-5x4-unorm",
    37841: "astc-5x4-unorm-srgb",
    37810: "astc-5x5-unorm",
    37842: "astc-5x5-unorm-srgb",
    37811: "astc-6x5-unorm",
    37843: "astc-6x5-unorm-srgb",
    37812: "astc-6x6-unorm",
    37844: "astc-6x6-unorm-srgb",
    37813: "astc-8x5-unorm",
    37845: "astc-8x5-unorm-srgb",
    37814: "astc-8x6-unorm",
    37846: "astc-8x6-unorm-srgb",
    37815: "astc-8x8-unorm",
    37847: "astc-8x8-unorm-srgb",
    37816: "astc-10x5-unorm",
    37848: "astc-10x5-unorm-srgb",
    37817: "astc-10x6-unorm",
    37849: "astc-10x6-unorm-srgb",
    37818: "astc-10x8-unorm",
    37850: "astc-10x8-unorm-srgb",
    37819: "astc-10x10-unorm",
    37851: "astc-10x10-unorm-srgb",
    37820: "astc-12x10-unorm",
    37852: "astc-12x10-unorm-srgb",
    37821: "astc-12x12-unorm",
    37853: "astc-12x12-unorm-srgb",
    36492: "bc7-rgba-unorm",
    36493: "bc7-rgba-unorm-srgb",
    36494: "bc6h-rgb-float",
    36495: "bc6h-rgb-ufloat",
    35907: "rgba8unorm-srgb",
    36759: "rgba8snorm",
    36220: "rgba8uint",
    36238: "rgba8sint",
    6408: "rgba8unorm"
  }, Ib = [
    171,
    75,
    84,
    88,
    32,
    49,
    49,
    187,
    13,
    10,
    26,
    10
  ], Fb = {
    FILE_IDENTIFIER: 0,
    ENDIANNESS: 12,
    GL_TYPE: 16,
    GL_TYPE_SIZE: 20,
    GL_FORMAT: 24,
    GL_INTERNAL_FORMAT: 28,
    GL_BASE_INTERNAL_FORMAT: 32,
    PIXEL_WIDTH: 36,
    PIXEL_HEIGHT: 40,
    PIXEL_DEPTH: 44,
    NUMBER_OF_ARRAY_ELEMENTS: 48,
    NUMBER_OF_FACES: 52,
    NUMBER_OF_MIPMAP_LEVELS: 56,
    BYTES_OF_KEY_VALUE_DATA: 60
  }, Ub = 64, kb = 67305985, Gb = {
    5121: 1,
    5123: 2,
    5124: 4,
    5125: 4,
    5126: 4,
    36193: 8
  }, Ob = {
    6408: 4,
    6407: 3,
    33319: 2,
    6403: 1,
    6409: 1,
    6410: 2,
    6406: 1
  }, Nb = {
    32819: 2,
    32820: 2,
    33635: 2
  }, Lb = {
    33776: 0.5,
    33777: 0.5,
    33778: 1,
    33779: 1,
    35916: 0.5,
    35917: 0.5,
    35918: 1,
    35919: 1,
    36283: 0.5,
    36284: 0.5,
    36285: 1,
    36286: 1,
    37488: 0.5,
    37489: 0.5,
    37490: 1,
    37491: 1,
    37492: 0.5,
    37496: 1,
    37493: 0.5,
    37497: 1,
    37494: 0.5,
    37495: 0.5,
    37808: 1,
    37840: 1,
    37809: 0.8,
    37841: 0.8,
    37810: 0.64,
    37842: 0.64,
    37811: 0.53375,
    37843: 0.53375,
    37812: 0.445,
    37844: 0.445,
    37813: 0.4,
    37845: 0.4,
    37814: 0.33375,
    37846: 0.33375,
    37815: 0.25,
    37847: 0.25,
    37816: 0.32,
    37848: 0.32,
    37817: 0.26625,
    37849: 0.26625,
    37818: 0.2,
    37850: 0.2,
    37819: 0.16,
    37851: 0.16,
    37820: 0.13375,
    37852: 0.13375,
    37821: 0.11125,
    37853: 0.11125,
    36492: 1,
    36493: 1,
    36494: 1,
    36495: 1
  }, Lt = {
    FILE_HEADER_SIZE: Ub,
    FILE_IDENTIFIER: Ib,
    FORMATS_TO_COMPONENTS: Ob,
    INTERNAL_FORMAT_TO_BYTES_PER_PIXEL: Lb,
    INTERNAL_FORMAT_TO_TEXTURE_FORMATS: Db,
    FIELDS: Fb,
    TYPES_TO_BYTES_PER_COMPONENT: Gb,
    TYPES_TO_BYTES_PER_PIXEL: Nb,
    ENDIANNESS: kb
  };
  function Hb(i, t) {
    const e = new DataView(i);
    if (!Vb(e)) throw new Error("Invalid KTX identifier in header");
    const { littleEndian: r, glType: n, glFormat: s, glInternalFormat: o, pixelWidth: a, pixelHeight: c, numberOfMipmapLevels: u, offset: l } = Wb(e), h = Lt.INTERNAL_FORMAT_TO_TEXTURE_FORMATS[o];
    if (!h) throw new Error(`Unknown texture format ${o}`);
    if (!t.includes(h)) throw new Error(`Unsupported texture format: ${h}, supportedFormats: ${t}`);
    const f = jb(n, s, o), p = zb(e, n, f, a, c, l, u, r);
    return {
      format: h,
      width: a,
      height: c,
      resource: p,
      alphaMode: "no-premultiply-alpha"
    };
  }
  function zb(i, t, e, r, n, s, o, a) {
    const c = r + 3 & -4, u = n + 3 & -4;
    let l = r * n;
    t === 0 && (l = c * u);
    let h = l * e, f = r, p = n, m = c, y = u, b = s;
    const v = new Array(o);
    for (let A = 0; A < o; A++) {
      const T = i.getUint32(b, a);
      let G = b + 4;
      v[A] = new Uint8Array(i.buffer, G, h), G += h, b += T + 4, b = b % 4 !== 0 ? b + 4 - b % 4 : b, f = f >> 1 || 1, p = p >> 1 || 1, m = f + 4 - 1 & -4, y = p + 4 - 1 & -4, h = m * y * e;
    }
    return v;
  }
  function jb(i, t, e) {
    let r = Lt.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[e];
    if (i !== 0 && (Lt.TYPES_TO_BYTES_PER_COMPONENT[i] ? r = Lt.TYPES_TO_BYTES_PER_COMPONENT[i] * Lt.FORMATS_TO_COMPONENTS[t] : r = Lt.TYPES_TO_BYTES_PER_PIXEL[i]), r === void 0) throw new Error("Unable to resolve the pixel format stored in the *.ktx file!");
    return r;
  }
  function Wb(i) {
    const t = i.getUint32(Lt.FIELDS.ENDIANNESS, true) === Lt.ENDIANNESS, e = i.getUint32(Lt.FIELDS.GL_TYPE, t), r = i.getUint32(Lt.FIELDS.GL_FORMAT, t), n = i.getUint32(Lt.FIELDS.GL_INTERNAL_FORMAT, t), s = i.getUint32(Lt.FIELDS.PIXEL_WIDTH, t), o = i.getUint32(Lt.FIELDS.PIXEL_HEIGHT, t) || 1, a = i.getUint32(Lt.FIELDS.PIXEL_DEPTH, t) || 1, c = i.getUint32(Lt.FIELDS.NUMBER_OF_ARRAY_ELEMENTS, t) || 1, u = i.getUint32(Lt.FIELDS.NUMBER_OF_FACES, t), l = i.getUint32(Lt.FIELDS.NUMBER_OF_MIPMAP_LEVELS, t), h = i.getUint32(Lt.FIELDS.BYTES_OF_KEY_VALUE_DATA, t);
    if (o === 0 || a !== 1) throw new Error("Only 2D textures are supported");
    if (u !== 1) throw new Error("CubeTextures are not supported by KTXLoader yet!");
    if (c !== 1) throw new Error("WebGL does not support array textures");
    return {
      littleEndian: t,
      glType: e,
      glFormat: r,
      glInternalFormat: n,
      pixelWidth: s,
      pixelHeight: o,
      numberOfMipmapLevels: l,
      offset: Lt.FILE_HEADER_SIZE + h
    };
  }
  function Vb(i) {
    for (let t = 0; t < Lt.FILE_IDENTIFIER.length; t++) if (i.getUint8(t) !== Lt.FILE_IDENTIFIER[t]) return false;
    return true;
  }
  const eR = {
    extension: {
      type: P.LoadParser,
      priority: ve.High,
      name: "loadKTX"
    },
    name: "loadKTX",
    test(i) {
      return Me(i, ".ktx");
    },
    async load(i, t, e) {
      const r = await ts(), s = await (await fetch(i)).arrayBuffer(), o = Hb(s, r), a = new Qn(o);
      return Fr(a, e, i);
    },
    unload(i) {
      Array.isArray(i) ? i.forEach((t) => t.destroy(true)) : i.destroy(true);
    }
  }, Xb = `(function () {
    'use strict';

    const converters = {
      rgb8unorm: {
        convertedFormat: "rgba8unorm",
        convertFunction: convertRGBtoRGBA
      },
      "rgb8unorm-srgb": {
        convertedFormat: "rgba8unorm-srgb",
        convertFunction: convertRGBtoRGBA
      }
    };
    function convertFormatIfRequired(textureOptions) {
      const format = textureOptions.format;
      if (converters[format]) {
        const convertFunction = converters[format].convertFunction;
        const levelBuffers = textureOptions.resource;
        for (let i = 0; i < levelBuffers.length; i++) {
          levelBuffers[i] = convertFunction(levelBuffers[i]);
        }
        textureOptions.format = converters[format].convertedFormat;
      }
    }
    function convertRGBtoRGBA(levelBuffer) {
      const pixelCount = levelBuffer.byteLength / 3;
      const levelBufferWithAlpha = new Uint32Array(pixelCount);
      for (let i = 0; i < pixelCount; ++i) {
        levelBufferWithAlpha[i] = levelBuffer[i * 3] + (levelBuffer[i * 3 + 1] << 8) + (levelBuffer[i * 3 + 2] << 16) + 4278190080;
      }
      return new Uint8Array(levelBufferWithAlpha.buffer);
    }

    function createLevelBuffersFromKTX(ktxTexture) {
      const levelBuffers = [];
      for (let i = 0; i < ktxTexture.numLevels; i++) {
        const imageData = ktxTexture.getImageData(i, 0, 0);
        const levelBuffer = new Uint8Array(imageData.byteLength);
        levelBuffer.set(imageData);
        levelBuffers.push(levelBuffer);
      }
      return levelBuffers;
    }

    const glFormatToGPUFormatMap = {
      6408: "rgba8unorm",
      32856: "bgra8unorm",
      //
      32857: "rgb10a2unorm",
      33189: "depth16unorm",
      33190: "depth24plus",
      33321: "r8unorm",
      33323: "rg8unorm",
      33325: "r16float",
      33326: "r32float",
      33327: "rg16float",
      33328: "rg32float",
      33329: "r8sint",
      33330: "r8uint",
      33331: "r16sint",
      33332: "r16uint",
      33333: "r32sint",
      33334: "r32uint",
      33335: "rg8sint",
      33336: "rg8uint",
      33337: "rg16sint",
      33338: "rg16uint",
      33339: "rg32sint",
      33340: "rg32uint",
      33778: "bc2-rgba-unorm",
      33779: "bc3-rgba-unorm",
      34836: "rgba32float",
      34842: "rgba16float",
      35056: "depth24plus-stencil8",
      35898: "rg11b10ufloat",
      35901: "rgb9e5ufloat",
      35907: "rgba8unorm-srgb",
      // bgra8unorm-srgb
      36012: "depth32float",
      36013: "depth32float-stencil8",
      36168: "stencil8",
      36208: "rgba32uint",
      36214: "rgba16uint",
      36220: "rgba8uint",
      36226: "rgba32sint",
      36232: "rgba16sint",
      36238: "rgba8sint",
      36492: "bc7-rgba-unorm",
      36756: "r8snorm",
      36757: "rg8snorm",
      36759: "rgba8snorm",
      37496: "etc2-rgba8unorm",
      37808: "astc-4x4-unorm"
    };
    function glFormatToGPUFormat(glInternalFormat) {
      const format = glFormatToGPUFormatMap[glInternalFormat];
      if (format) {
        return format;
      }
      throw new Error(\`Unsupported glInternalFormat: \${glInternalFormat}\`);
    }

    const vkFormatToGPUFormatMap = {
      23: "rgb8unorm",
      // VK_FORMAT_R8G8B8_UNORM
      37: "rgba8unorm",
      // VK_FORMAT_R8G8B8A8_UNORM
      43: "rgba8unorm-srgb"
      // VK_FORMAT_R8G8B8A8_SRGB
      // TODO add more!
    };
    function vkFormatToGPUFormat(vkFormat) {
      const format = vkFormatToGPUFormatMap[vkFormat];
      if (format) {
        return format;
      }
      throw new Error(\`Unsupported VkFormat: \${vkFormat}\`);
    }

    function getTextureFormatFromKTXTexture(ktxTexture) {
      if (ktxTexture.classId === 2) {
        return vkFormatToGPUFormat(ktxTexture.vkFormat);
      }
      return glFormatToGPUFormat(ktxTexture.glInternalformat);
    }

    const gpuFormatToBasisTranscoderFormatMap = {
      "bc3-rgba-unorm": "BC3_RGBA",
      "bc7-rgba-unorm": "BC7_M5_RGBA",
      "etc2-rgba8unorm": "ETC2_RGBA",
      "astc-4x4-unorm": "ASTC_4x4_RGBA",
      // Uncompressed
      rgba8unorm: "RGBA32",
      rg11b10ufloat: "R11F_G11F_B10F"
    };
    function gpuFormatToKTXBasisTranscoderFormat(transcoderFormat) {
      const format = gpuFormatToBasisTranscoderFormatMap[transcoderFormat];
      if (format) {
        return format;
      }
      throw new Error(\`Unsupported transcoderFormat: \${transcoderFormat}\`);
    }

    const settings = {
      jsUrl: "",
      wasmUrl: ""
    };
    let basisTranscoderFormat;
    let basisTranscodedTextureFormat;
    let ktxPromise;
    async function getKTX() {
      if (!ktxPromise) {
        const absoluteJsUrl = new URL(settings.jsUrl, location.origin).href;
        const absoluteWasmUrl = new URL(settings.wasmUrl, location.origin).href;
        importScripts(absoluteJsUrl);
        ktxPromise = new Promise((resolve) => {
          LIBKTX({
            locateFile: (_file) => absoluteWasmUrl
          }).then((libktx) => {
            resolve(libktx);
          });
        });
      }
      return ktxPromise;
    }
    async function fetchKTXTexture(url, ktx) {
      const ktx2Response = await fetch(url);
      if (ktx2Response.ok) {
        const ktx2ArrayBuffer = await ktx2Response.arrayBuffer();
        return new ktx.ktxTexture(new Uint8Array(ktx2ArrayBuffer));
      }
      throw new Error(\`Failed to load KTX(2) texture: \${url}\`);
    }
    const preferredTranscodedFormat = [
      "bc7-rgba-unorm",
      "astc-4x4-unorm",
      "etc2-rgba8unorm",
      "bc3-rgba-unorm",
      "rgba8unorm"
    ];
    async function load(url) {
      const ktx = await getKTX();
      const ktxTexture = await fetchKTXTexture(url, ktx);
      let format;
      if (ktxTexture.needsTranscoding) {
        format = basisTranscodedTextureFormat;
        const transcodeFormat = ktx.TranscodeTarget[basisTranscoderFormat];
        const result = ktxTexture.transcodeBasis(transcodeFormat, 0);
        if (result !== ktx.ErrorCode.SUCCESS) {
          throw new Error("Unable to transcode basis texture.");
        }
      } else {
        format = getTextureFormatFromKTXTexture(ktxTexture);
      }
      const levelBuffers = createLevelBuffersFromKTX(ktxTexture);
      const textureOptions = {
        width: ktxTexture.baseWidth,
        height: ktxTexture.baseHeight,
        format,
        mipLevelCount: ktxTexture.numLevels,
        resource: levelBuffers,
        alphaMode: "no-premultiply-alpha"
      };
      convertFormatIfRequired(textureOptions);
      return textureOptions;
    }
    async function init(jsUrl, wasmUrl, supportedTextures) {
      if (jsUrl)
        settings.jsUrl = jsUrl;
      if (wasmUrl)
        settings.wasmUrl = wasmUrl;
      basisTranscodedTextureFormat = preferredTranscodedFormat.filter((format) => supportedTextures.includes(format))[0];
      basisTranscoderFormat = gpuFormatToKTXBasisTranscoderFormat(basisTranscodedTextureFormat);
      await getKTX();
    }
    const messageHandlers = {
      init: async (data) => {
        const { jsUrl, wasmUrl, supportedTextures } = data;
        await init(jsUrl, wasmUrl, supportedTextures);
      },
      load: async (data) => {
        try {
          const textureOptions = await load(data.url);
          return {
            type: "load",
            url: data.url,
            success: true,
            textureOptions,
            transferables: textureOptions.resource?.map((arr) => arr.buffer)
          };
        } catch (e) {
          throw e;
        }
      }
    };
    self.onmessage = async (messageEvent) => {
      const message = messageEvent.data;
      const response = await messageHandlers[message.type]?.(message);
      if (response) {
        self.postMessage(response, response.transferables);
      }
    };

})();
`;
  let qr = null;
  class $h {
    constructor() {
      qr || (qr = URL.createObjectURL(new Blob([
        Xb
      ], {
        type: "application/javascript"
      }))), this.worker = new Worker(qr);
    }
  }
  $h.revokeObjectURL = function() {
    qr && (URL.revokeObjectURL(qr), qr = null);
  };
  const cu = {
    jsUrl: "https://files.pixijs.download/transcoders/ktx/libktx.js",
    wasmUrl: "https://files.pixijs.download/transcoders/ktx/libktx.wasm"
  };
  let li;
  const Yh = {};
  function qb(i) {
    return li || (li = new $h().worker, li.onmessage = (t) => {
      const { success: e, url: r, textureOptions: n } = t.data;
      e || console.warn("Failed to load KTX texture", r), Yh[r](n);
    }, li.postMessage({
      type: "init",
      jsUrl: cu.jsUrl,
      wasmUrl: cu.wasmUrl,
      supportedTextures: i
    })), li;
  }
  function $b(i, t) {
    const e = qb(t);
    return new Promise((r) => {
      Yh[i] = r, e.postMessage({
        type: "load",
        url: i
      });
    });
  }
  const rR = {
    extension: {
      type: P.LoadParser,
      priority: ve.High,
      name: "loadKTX2"
    },
    name: "loadKTX2",
    test(i) {
      return Me(i, ".ktx2");
    },
    async load(i, t, e) {
      const r = await ts(), n = await $b(i, r), s = new Qn(n);
      return Fr(s, e, i);
    },
    async unload(i) {
      Array.isArray(i) ? i.forEach((t) => t.destroy(true)) : i.destroy(true);
    }
  };
  const Uo = [
    "basis",
    "bc7",
    "bc6h",
    "astc",
    "etc2",
    "bc5",
    "bc4",
    "bc3",
    "bc2",
    "bc1",
    "eac"
  ], iR = {
    extension: P.ResolveParser,
    test: (i) => Me(i, [
      ".ktx",
      ".ktx2",
      ".dds"
    ]),
    parse: (i) => {
      var _a2;
      let t;
      const e = i.split(".");
      if (e.length > 2) {
        const r = e[e.length - 2];
        Uo.includes(r) && (t = r);
      } else t = e[e.length - 1];
      return {
        resolution: parseFloat(((_a2 = Dr.RETINA_PREFIX.exec(i)) == null ? void 0 : _a2[1]) ?? "1"),
        format: t,
        src: i
      };
    }
  };
  let un;
  const nR = {
    extension: {
      type: P.DetectionParser,
      priority: 2
    },
    test: async () => !!(await Kn() || Yn()),
    add: async (i) => {
      const t = await jh();
      return un = Yb(t), [
        ...un,
        ...i
      ];
    },
    remove: async (i) => un ? i.filter((t) => !(t in un)) : i
  };
  function Yb(i) {
    const t = [
      "basis"
    ], e = {};
    return i.forEach((r) => {
      const n = r.split("-")[0];
      n && !e[n] && (e[n] = true, t.push(n));
    }), t.sort((r, n) => {
      const s = Uo.indexOf(r), o = Uo.indexOf(n);
      return s === -1 ? 1 : o === -1 ? -1 : s - o;
    }), t;
  }
  const Kb = new re(), ko = class {
    cull(t, e, r = true) {
      this._cullRecursive(t, e, r);
    }
    _cullRecursive(t, e, r = true) {
      if (t.cullable && t.measurable && t.includeInBuild) {
        const n = t.cullArea ?? Vn(t, r, Kb);
        t.culled = n.x >= e.x + e.width || n.y >= e.y + e.height || n.x + n.width <= e.x || n.y + n.height <= e.y;
      } else t.culled = false;
      if (!(!t.cullableChildren || t.culled || !t.renderable || !t.measurable || !t.includeInBuild)) for (let n = 0; n < t.children.length; n++) this._cullRecursive(t.children[n], e, r);
    }
  };
  ko.shared = new ko();
  let Zb = ko;
  class Jb {
    static init() {
      this._renderRef = this.render.bind(this), this.render = () => {
        Zb.shared.cull(this.stage, this.renderer.screen), this.renderer.render({
          container: this.stage
        });
      };
    }
    static destroy() {
      this.render = this._renderRef;
    }
  }
  Jb.extension = {
    priority: 10,
    type: P.Application,
    name: "culler"
  };
  var hi = {}, Xe = {}, xr = {}, uu;
  function es() {
    if (uu) return xr;
    uu = 1;
    function i(s, o, a) {
      if (a === void 0 && (a = Array.prototype), s && typeof a.find == "function") return a.find.call(s, o);
      for (var c = 0; c < s.length; c++) if (Object.prototype.hasOwnProperty.call(s, c)) {
        var u = s[c];
        if (o.call(void 0, u, c, s)) return u;
      }
    }
    function t(s, o) {
      return o === void 0 && (o = Object), o && typeof o.freeze == "function" ? o.freeze(s) : s;
    }
    function e(s, o) {
      if (s === null || typeof s != "object") throw new TypeError("target is not an object");
      for (var a in o) Object.prototype.hasOwnProperty.call(o, a) && (s[a] = o[a]);
      return s;
    }
    var r = t({
      HTML: "text/html",
      isHTML: function(s) {
        return s === r.HTML;
      },
      XML_APPLICATION: "application/xml",
      XML_TEXT: "text/xml",
      XML_XHTML_APPLICATION: "application/xhtml+xml",
      XML_SVG_IMAGE: "image/svg+xml"
    }), n = t({
      HTML: "http://www.w3.org/1999/xhtml",
      isHTML: function(s) {
        return s === n.HTML;
      },
      SVG: "http://www.w3.org/2000/svg",
      XML: "http://www.w3.org/XML/1998/namespace",
      XMLNS: "http://www.w3.org/2000/xmlns/"
    });
    return xr.assign = e, xr.find = i, xr.freeze = t, xr.MIME_TYPE = r, xr.NAMESPACE = n, xr;
  }
  var lu;
  function Kh() {
    if (lu) return Xe;
    lu = 1;
    var i = es(), t = i.find, e = i.NAMESPACE;
    function r(g) {
      return g !== "";
    }
    function n(g) {
      return g ? g.split(/[\t\n\f\r ]+/).filter(r) : [];
    }
    function s(g, w) {
      return g.hasOwnProperty(w) || (g[w] = true), g;
    }
    function o(g) {
      if (!g) return [];
      var w = n(g);
      return Object.keys(w.reduce(s, {}));
    }
    function a(g) {
      return function(w) {
        return g && g.indexOf(w) !== -1;
      };
    }
    function c(g, w) {
      for (var E in g) Object.prototype.hasOwnProperty.call(g, E) && (w[E] = g[E]);
    }
    function u(g, w) {
      var E = g.prototype;
      if (!(E instanceof w)) {
        let k = function() {
        };
        k.prototype = w.prototype, k = new k(), c(E, k), g.prototype = E = k;
      }
      E.constructor != g && (typeof g != "function" && console.error("unknown Class:" + g), E.constructor = g);
    }
    var l = {}, h = l.ELEMENT_NODE = 1, f = l.ATTRIBUTE_NODE = 2, p = l.TEXT_NODE = 3, m = l.CDATA_SECTION_NODE = 4, y = l.ENTITY_REFERENCE_NODE = 5, b = l.ENTITY_NODE = 6, v = l.PROCESSING_INSTRUCTION_NODE = 7, A = l.COMMENT_NODE = 8, T = l.DOCUMENT_NODE = 9, G = l.DOCUMENT_TYPE_NODE = 10, H = l.DOCUMENT_FRAGMENT_NODE = 11, Y = l.NOTATION_NODE = 12, L = {}, W = {}, C = L.INDEX_SIZE_ERR = (W[1] = "Index size error", 1), I = L.DOMSTRING_SIZE_ERR = (W[2] = "DOMString size error", 2), z = L.HIERARCHY_REQUEST_ERR = (W[3] = "Hierarchy request error", 3), Z = L.WRONG_DOCUMENT_ERR = (W[4] = "Wrong document", 4), j = L.INVALID_CHARACTER_ERR = (W[5] = "Invalid character", 5), X = L.NO_DATA_ALLOWED_ERR = (W[6] = "No data allowed", 6), Q = L.NO_MODIFICATION_ALLOWED_ERR = (W[7] = "No modification allowed", 7), x = L.NOT_FOUND_ERR = (W[8] = "Not found", 8), R = L.NOT_SUPPORTED_ERR = (W[9] = "Not supported", 9), S = L.INUSE_ATTRIBUTE_ERR = (W[10] = "Attribute in use", 10), B = L.INVALID_STATE_ERR = (W[11] = "Invalid state", 11), D = L.SYNTAX_ERR = (W[12] = "Syntax error", 12), N = L.INVALID_MODIFICATION_ERR = (W[13] = "Invalid modification", 13), O = L.NAMESPACE_ERR = (W[14] = "Invalid namespace", 14), q = L.INVALID_ACCESS_ERR = (W[15] = "Invalid access", 15);
    function V(g, w) {
      if (w instanceof Error) var E = w;
      else E = this, Error.call(this, W[g]), this.message = W[g], Error.captureStackTrace && Error.captureStackTrace(this, V);
      return E.code = g, w && (this.message = this.message + ": " + w), E;
    }
    V.prototype = Error.prototype, c(L, V);
    function $() {
    }
    $.prototype = {
      length: 0,
      item: function(g) {
        return g >= 0 && g < this.length ? this[g] : null;
      },
      toString: function(g, w) {
        for (var E = [], k = 0; k < this.length; k++) kr(this[k], E, g, w);
        return E.join("");
      },
      filter: function(g) {
        return Array.prototype.filter.call(this, g);
      },
      indexOf: function(g) {
        return Array.prototype.indexOf.call(this, g);
      }
    };
    function ft(g, w) {
      this._node = g, this._refresh = w, pt(this);
    }
    function pt(g) {
      var w = g._node._inc || g._node.ownerDocument._inc;
      if (g._inc !== w) {
        var E = g._refresh(g._node);
        if (Ka(g, "length", E.length), !g.$$length || E.length < g.$$length) for (var k = E.length; k in g; k++) Object.prototype.hasOwnProperty.call(g, k) && delete g[k];
        c(E, g), g._inc = w;
      }
    }
    ft.prototype.item = function(g) {
      return pt(this), this[g] || null;
    }, u(ft, $);
    function it() {
    }
    function gt(g, w) {
      for (var E = g.length; E--; ) if (g[E] === w) return E;
    }
    function _t(g, w, E, k) {
      if (k ? w[gt(w, k)] = E : w[w.length++] = E, g) {
        E.ownerElement = g;
        var K = g.ownerDocument;
        K && (k && we(K, g, k), be(K, g, E));
      }
    }
    function ne(g, w, E) {
      var k = gt(w, E);
      if (k >= 0) {
        for (var K = w.length - 1; k < K; ) w[k] = w[++k];
        if (w.length = K, g) {
          var ot = g.ownerDocument;
          ot && (we(ot, g, E), E.ownerElement = null);
        }
      } else throw new V(x, new Error(g.tagName + "@" + E));
    }
    it.prototype = {
      length: 0,
      item: $.prototype.item,
      getNamedItem: function(g) {
        for (var w = this.length; w--; ) {
          var E = this[w];
          if (E.nodeName == g) return E;
        }
      },
      setNamedItem: function(g) {
        var w = g.ownerElement;
        if (w && w != this._ownerElement) throw new V(S);
        var E = this.getNamedItem(g.nodeName);
        return _t(this._ownerElement, this, g, E), E;
      },
      setNamedItemNS: function(g) {
        var w = g.ownerElement, E;
        if (w && w != this._ownerElement) throw new V(S);
        return E = this.getNamedItemNS(g.namespaceURI, g.localName), _t(this._ownerElement, this, g, E), E;
      },
      removeNamedItem: function(g) {
        var w = this.getNamedItem(g);
        return ne(this._ownerElement, this, w), w;
      },
      removeNamedItemNS: function(g, w) {
        var E = this.getNamedItemNS(g, w);
        return ne(this._ownerElement, this, E), E;
      },
      getNamedItemNS: function(g, w) {
        for (var E = this.length; E--; ) {
          var k = this[E];
          if (k.localName == w && k.namespaceURI == g) return k;
        }
        return null;
      }
    };
    function te() {
    }
    te.prototype = {
      hasFeature: function(g, w) {
        return true;
      },
      createDocument: function(g, w, E) {
        var k = new tt();
        if (k.implementation = this, k.childNodes = new $(), k.doctype = E || null, E && k.appendChild(E), w) {
          var K = k.createElementNS(g, w);
          k.appendChild(K);
        }
        return k;
      },
      createDocumentType: function(g, w, E) {
        var k = new zi();
        return k.name = g, k.nodeName = g, k.publicId = w || "", k.systemId = E || "", k;
      }
    };
    function ht() {
    }
    ht.prototype = {
      firstChild: null,
      lastChild: null,
      previousSibling: null,
      nextSibling: null,
      attributes: null,
      parentNode: null,
      childNodes: null,
      ownerDocument: null,
      nodeValue: null,
      namespaceURI: null,
      prefix: null,
      localName: null,
      insertBefore: function(g, w) {
        return Li(this, g, w);
      },
      replaceChild: function(g, w) {
        Li(this, g, w, ja), w && this.removeChild(w);
      },
      removeChild: function(g) {
        return ir(this, g);
      },
      appendChild: function(g) {
        return this.insertBefore(g, null);
      },
      hasChildNodes: function() {
        return this.firstChild != null;
      },
      cloneNode: function(g) {
        return vs(this.ownerDocument || this, this, g);
      },
      normalize: function() {
        for (var g = this.firstChild; g; ) {
          var w = g.nextSibling;
          w && w.nodeType == p && g.nodeType == p ? (this.removeChild(w), g.appendData(w.data)) : (g.normalize(), g = w);
        }
      },
      isSupported: function(g, w) {
        return this.ownerDocument.implementation.hasFeature(g, w);
      },
      hasAttributes: function() {
        return this.attributes.length > 0;
      },
      lookupPrefix: function(g) {
        for (var w = this; w; ) {
          var E = w._nsMap;
          if (E) {
            for (var k in E) if (Object.prototype.hasOwnProperty.call(E, k) && E[k] === g) return k;
          }
          w = w.nodeType == f ? w.ownerDocument : w.parentNode;
        }
        return null;
      },
      lookupNamespaceURI: function(g) {
        for (var w = this; w; ) {
          var E = w._nsMap;
          if (E && Object.prototype.hasOwnProperty.call(E, g)) return E[g];
          w = w.nodeType == f ? w.ownerDocument : w.parentNode;
        }
        return null;
      },
      isDefaultNamespace: function(g) {
        var w = this.lookupPrefix(g);
        return w == null;
      }
    };
    function Ut(g) {
      return g == "<" && "&lt;" || g == ">" && "&gt;" || g == "&" && "&amp;" || g == '"' && "&quot;" || "&#" + g.charCodeAt() + ";";
    }
    c(l, ht), c(l, ht.prototype);
    function st(g, w) {
      if (w(g)) return true;
      if (g = g.firstChild) do
        if (st(g, w)) return true;
      while (g = g.nextSibling);
    }
    function tt() {
      this.ownerDocument = this;
    }
    function be(g, w, E) {
      g && g._inc++;
      var k = E.namespaceURI;
      k === e.XMLNS && (w._nsMap[E.prefix ? E.localName : ""] = E.value);
    }
    function we(g, w, E, k) {
      g && g._inc++;
      var K = E.namespaceURI;
      K === e.XMLNS && delete w._nsMap[E.prefix ? E.localName : ""];
    }
    function He(g, w, E) {
      if (g && g._inc) {
        g._inc++;
        var k = w.childNodes;
        if (E) k[k.length++] = E;
        else {
          for (var K = w.firstChild, ot = 0; K; ) k[ot++] = K, K = K.nextSibling;
          k.length = ot, delete k[k.length];
        }
      }
    }
    function ir(g, w) {
      var E = w.previousSibling, k = w.nextSibling;
      return E ? E.nextSibling = k : g.firstChild = k, k ? k.previousSibling = E : g.lastChild = E, w.parentNode = null, w.previousSibling = null, w.nextSibling = null, He(g.ownerDocument, g), w;
    }
    function Pt(g) {
      return g && (g.nodeType === ht.DOCUMENT_NODE || g.nodeType === ht.DOCUMENT_FRAGMENT_NODE || g.nodeType === ht.ELEMENT_NODE);
    }
    function ee(g) {
      return g && (De(g) || _s(g) || Ee(g) || g.nodeType === ht.DOCUMENT_FRAGMENT_NODE || g.nodeType === ht.COMMENT_NODE || g.nodeType === ht.PROCESSING_INSTRUCTION_NODE);
    }
    function Ee(g) {
      return g && g.nodeType === ht.DOCUMENT_TYPE_NODE;
    }
    function De(g) {
      return g && g.nodeType === ht.ELEMENT_NODE;
    }
    function _s(g) {
      return g && g.nodeType === ht.TEXT_NODE;
    }
    function Ha(g, w) {
      var E = g.childNodes || [];
      if (t(E, De) || Ee(w)) return false;
      var k = t(E, Ee);
      return !(w && k && E.indexOf(k) > E.indexOf(w));
    }
    function za(g, w) {
      var E = g.childNodes || [];
      function k(ot) {
        return De(ot) && ot !== w;
      }
      if (t(E, k)) return false;
      var K = t(E, Ee);
      return !(w && K && E.indexOf(K) > E.indexOf(w));
    }
    function _p(g, w, E) {
      if (!Pt(g)) throw new V(z, "Unexpected parent node type " + g.nodeType);
      if (E && E.parentNode !== g) throw new V(x, "child not in parent");
      if (!ee(w) || Ee(w) && g.nodeType !== ht.DOCUMENT_NODE) throw new V(z, "Unexpected node type " + w.nodeType + " for parent node type " + g.nodeType);
    }
    function gp(g, w, E) {
      var k = g.childNodes || [], K = w.childNodes || [];
      if (w.nodeType === ht.DOCUMENT_FRAGMENT_NODE) {
        var ot = K.filter(De);
        if (ot.length > 1 || t(K, _s)) throw new V(z, "More than one element or text in fragment");
        if (ot.length === 1 && !Ha(g, E)) throw new V(z, "Element in fragment can not be inserted before doctype");
      }
      if (De(w) && !Ha(g, E)) throw new V(z, "Only one element can be added and only after doctype");
      if (Ee(w)) {
        if (t(k, Ee)) throw new V(z, "Only one doctype is allowed");
        var Bt = t(k, De);
        if (E && k.indexOf(Bt) < k.indexOf(E)) throw new V(z, "Doctype can only be inserted before an element");
        if (!E && Bt) throw new V(z, "Doctype can not be appended since element is present");
      }
    }
    function ja(g, w, E) {
      var k = g.childNodes || [], K = w.childNodes || [];
      if (w.nodeType === ht.DOCUMENT_FRAGMENT_NODE) {
        var ot = K.filter(De);
        if (ot.length > 1 || t(K, _s)) throw new V(z, "More than one element or text in fragment");
        if (ot.length === 1 && !za(g, E)) throw new V(z, "Element in fragment can not be inserted before doctype");
      }
      if (De(w) && !za(g, E)) throw new V(z, "Only one element can be added and only after doctype");
      if (Ee(w)) {
        if (t(k, function(ze) {
          return Ee(ze) && ze !== E;
        })) throw new V(z, "Only one doctype is allowed");
        var Bt = t(k, De);
        if (E && k.indexOf(Bt) < k.indexOf(E)) throw new V(z, "Doctype can only be inserted before an element");
      }
    }
    function Li(g, w, E, k) {
      _p(g, w, E), g.nodeType === ht.DOCUMENT_NODE && (k || gp)(g, w, E);
      var K = w.parentNode;
      if (K && K.removeChild(w), w.nodeType === H) {
        var ot = w.firstChild;
        if (ot == null) return w;
        var Bt = w.lastChild;
      } else ot = Bt = w;
      var se = E ? E.previousSibling : g.lastChild;
      ot.previousSibling = se, Bt.nextSibling = E, se ? se.nextSibling = ot : g.firstChild = ot, E == null ? g.lastChild = Bt : E.previousSibling = Bt;
      do
        ot.parentNode = g;
      while (ot !== Bt && (ot = ot.nextSibling));
      return He(g.ownerDocument || g, g), w.nodeType == H && (w.firstChild = w.lastChild = null), w;
    }
    function mp(g, w) {
      return w.parentNode && w.parentNode.removeChild(w), w.parentNode = g, w.previousSibling = g.lastChild, w.nextSibling = null, w.previousSibling ? w.previousSibling.nextSibling = w : g.firstChild = w, g.lastChild = w, He(g.ownerDocument, g, w), w;
    }
    tt.prototype = {
      nodeName: "#document",
      nodeType: T,
      doctype: null,
      documentElement: null,
      _inc: 1,
      insertBefore: function(g, w) {
        if (g.nodeType == H) {
          for (var E = g.firstChild; E; ) {
            var k = E.nextSibling;
            this.insertBefore(E, w), E = k;
          }
          return g;
        }
        return Li(this, g, w), g.ownerDocument = this, this.documentElement === null && g.nodeType === h && (this.documentElement = g), g;
      },
      removeChild: function(g) {
        return this.documentElement == g && (this.documentElement = null), ir(this, g);
      },
      replaceChild: function(g, w) {
        Li(this, g, w, ja), g.ownerDocument = this, w && this.removeChild(w), De(g) && (this.documentElement = g);
      },
      importNode: function(g, w) {
        return Ya(this, g, w);
      },
      getElementById: function(g) {
        var w = null;
        return st(this.documentElement, function(E) {
          if (E.nodeType == h && E.getAttribute("id") == g) return w = E, true;
        }), w;
      },
      getElementsByClassName: function(g) {
        var w = o(g);
        return new ft(this, function(E) {
          var k = [];
          return w.length > 0 && st(E.documentElement, function(K) {
            if (K !== E && K.nodeType === h) {
              var ot = K.getAttribute("class");
              if (ot) {
                var Bt = g === ot;
                if (!Bt) {
                  var se = o(ot);
                  Bt = w.every(a(se));
                }
                Bt && k.push(K);
              }
            }
          }), k;
        });
      },
      createElement: function(g) {
        var w = new pr();
        w.ownerDocument = this, w.nodeName = g, w.tagName = g, w.localName = g, w.childNodes = new $();
        var E = w.attributes = new it();
        return E._ownerElement = w, w;
      },
      createDocumentFragment: function() {
        var g = new ji();
        return g.ownerDocument = this, g.childNodes = new $(), g;
      },
      createTextNode: function(g) {
        var w = new gs();
        return w.ownerDocument = this, w.appendData(g), w;
      },
      createComment: function(g) {
        var w = new ms();
        return w.ownerDocument = this, w.appendData(g), w;
      },
      createCDATASection: function(g) {
        var w = new bs();
        return w.ownerDocument = this, w.appendData(g), w;
      },
      createProcessingInstruction: function(g, w) {
        var E = new ys();
        return E.ownerDocument = this, E.tagName = E.nodeName = E.target = g, E.nodeValue = E.data = w, E;
      },
      createAttribute: function(g) {
        var w = new Hi();
        return w.ownerDocument = this, w.name = g, w.nodeName = g, w.localName = g, w.specified = true, w;
      },
      createEntityReference: function(g) {
        var w = new ws();
        return w.ownerDocument = this, w.nodeName = g, w;
      },
      createElementNS: function(g, w) {
        var E = new pr(), k = w.split(":"), K = E.attributes = new it();
        return E.childNodes = new $(), E.ownerDocument = this, E.nodeName = w, E.tagName = w, E.namespaceURI = g, k.length == 2 ? (E.prefix = k[0], E.localName = k[1]) : E.localName = w, K._ownerElement = E, E;
      },
      createAttributeNS: function(g, w) {
        var E = new Hi(), k = w.split(":");
        return E.ownerDocument = this, E.nodeName = w, E.name = w, E.namespaceURI = g, E.specified = true, k.length == 2 ? (E.prefix = k[0], E.localName = k[1]) : E.localName = w, E;
      }
    }, u(tt, ht);
    function pr() {
      this._nsMap = {};
    }
    pr.prototype = {
      nodeType: h,
      hasAttribute: function(g) {
        return this.getAttributeNode(g) != null;
      },
      getAttribute: function(g) {
        var w = this.getAttributeNode(g);
        return w && w.value || "";
      },
      getAttributeNode: function(g) {
        return this.attributes.getNamedItem(g);
      },
      setAttribute: function(g, w) {
        var E = this.ownerDocument.createAttribute(g);
        E.value = E.nodeValue = "" + w, this.setAttributeNode(E);
      },
      removeAttribute: function(g) {
        var w = this.getAttributeNode(g);
        w && this.removeAttributeNode(w);
      },
      appendChild: function(g) {
        return g.nodeType === H ? this.insertBefore(g, null) : mp(this, g);
      },
      setAttributeNode: function(g) {
        return this.attributes.setNamedItem(g);
      },
      setAttributeNodeNS: function(g) {
        return this.attributes.setNamedItemNS(g);
      },
      removeAttributeNode: function(g) {
        return this.attributes.removeNamedItem(g.nodeName);
      },
      removeAttributeNS: function(g, w) {
        var E = this.getAttributeNodeNS(g, w);
        E && this.removeAttributeNode(E);
      },
      hasAttributeNS: function(g, w) {
        return this.getAttributeNodeNS(g, w) != null;
      },
      getAttributeNS: function(g, w) {
        var E = this.getAttributeNodeNS(g, w);
        return E && E.value || "";
      },
      setAttributeNS: function(g, w, E) {
        var k = this.ownerDocument.createAttributeNS(g, w);
        k.value = k.nodeValue = "" + E, this.setAttributeNode(k);
      },
      getAttributeNodeNS: function(g, w) {
        return this.attributes.getNamedItemNS(g, w);
      },
      getElementsByTagName: function(g) {
        return new ft(this, function(w) {
          var E = [];
          return st(w, function(k) {
            k !== w && k.nodeType == h && (g === "*" || k.tagName == g) && E.push(k);
          }), E;
        });
      },
      getElementsByTagNameNS: function(g, w) {
        return new ft(this, function(E) {
          var k = [];
          return st(E, function(K) {
            K !== E && K.nodeType === h && (g === "*" || K.namespaceURI === g) && (w === "*" || K.localName == w) && k.push(K);
          }), k;
        });
      }
    }, tt.prototype.getElementsByTagName = pr.prototype.getElementsByTagName, tt.prototype.getElementsByTagNameNS = pr.prototype.getElementsByTagNameNS, u(pr, ht);
    function Hi() {
    }
    Hi.prototype.nodeType = f, u(Hi, ht);
    function ii() {
    }
    ii.prototype = {
      data: "",
      substringData: function(g, w) {
        return this.data.substring(g, g + w);
      },
      appendData: function(g) {
        g = this.data + g, this.nodeValue = this.data = g, this.length = g.length;
      },
      insertData: function(g, w) {
        this.replaceData(g, 0, w);
      },
      appendChild: function(g) {
        throw new Error(W[z]);
      },
      deleteData: function(g, w) {
        this.replaceData(g, w, "");
      },
      replaceData: function(g, w, E) {
        var k = this.data.substring(0, g), K = this.data.substring(g + w);
        E = k + E + K, this.nodeValue = this.data = E, this.length = E.length;
      }
    }, u(ii, ht);
    function gs() {
    }
    gs.prototype = {
      nodeName: "#text",
      nodeType: p,
      splitText: function(g) {
        var w = this.data, E = w.substring(g);
        w = w.substring(0, g), this.data = this.nodeValue = w, this.length = w.length;
        var k = this.ownerDocument.createTextNode(E);
        return this.parentNode && this.parentNode.insertBefore(k, this.nextSibling), k;
      }
    }, u(gs, ii);
    function ms() {
    }
    ms.prototype = {
      nodeName: "#comment",
      nodeType: A
    }, u(ms, ii);
    function bs() {
    }
    bs.prototype = {
      nodeName: "#cdata-section",
      nodeType: m
    }, u(bs, ii);
    function zi() {
    }
    zi.prototype.nodeType = G, u(zi, ht);
    function Wa() {
    }
    Wa.prototype.nodeType = Y, u(Wa, ht);
    function Va() {
    }
    Va.prototype.nodeType = b, u(Va, ht);
    function ws() {
    }
    ws.prototype.nodeType = y, u(ws, ht);
    function ji() {
    }
    ji.prototype.nodeName = "#document-fragment", ji.prototype.nodeType = H, u(ji, ht);
    function ys() {
    }
    ys.prototype.nodeType = v, u(ys, ht);
    function Xa() {
    }
    Xa.prototype.serializeToString = function(g, w, E) {
      return qa.call(g, w, E);
    }, ht.prototype.toString = qa;
    function qa(g, w) {
      var E = [], k = this.nodeType == 9 && this.documentElement || this, K = k.prefix, ot = k.namespaceURI;
      if (ot && K == null) {
        var K = k.lookupPrefix(ot);
        if (K == null) var Bt = [
          {
            namespace: ot,
            prefix: null
          }
        ];
      }
      return kr(this, E, g, w, Bt), E.join("");
    }
    function $a(g, w, E) {
      var k = g.prefix || "", K = g.namespaceURI;
      if (!K || k === "xml" && K === e.XML || K === e.XMLNS) return false;
      for (var ot = E.length; ot--; ) {
        var Bt = E[ot];
        if (Bt.prefix === k) return Bt.namespace !== K;
      }
      return true;
    }
    function xs(g, w, E) {
      g.push(" ", w, '="', E.replace(/[<>&"\t\n\r]/g, Ut), '"');
    }
    function kr(g, w, E, k, K) {
      if (K || (K = []), k) if (g = k(g), g) {
        if (typeof g == "string") {
          w.push(g);
          return;
        }
      } else return;
      switch (g.nodeType) {
        case h:
          var ot = g.attributes, Bt = ot.length, Zt = g.firstChild, se = g.tagName;
          E = e.isHTML(g.namespaceURI) || E;
          var ze = se;
          if (!E && !g.prefix && g.namespaceURI) {
            for (var nr, je = 0; je < ot.length; je++) if (ot.item(je).name === "xmlns") {
              nr = ot.item(je).value;
              break;
            }
            if (!nr) for (var _r = K.length - 1; _r >= 0; _r--) {
              var gr = K[_r];
              if (gr.prefix === "" && gr.namespace === g.namespaceURI) {
                nr = gr.namespace;
                break;
              }
            }
            if (nr !== g.namespaceURI) for (var _r = K.length - 1; _r >= 0; _r--) {
              var gr = K[_r];
              if (gr.namespace === g.namespaceURI) {
                gr.prefix && (ze = gr.prefix + ":" + se);
                break;
              }
            }
          }
          w.push("<", ze);
          for (var mr = 0; mr < Bt; mr++) {
            var Ie = ot.item(mr);
            Ie.prefix == "xmlns" ? K.push({
              prefix: Ie.localName,
              namespace: Ie.value
            }) : Ie.nodeName == "xmlns" && K.push({
              prefix: "",
              namespace: Ie.value
            });
          }
          for (var mr = 0; mr < Bt; mr++) {
            var Ie = ot.item(mr);
            if ($a(Ie, E, K)) {
              var br = Ie.prefix || "", ni = Ie.namespaceURI;
              xs(w, br ? "xmlns:" + br : "xmlns", ni), K.push({
                prefix: br,
                namespace: ni
              });
            }
            kr(Ie, w, E, k, K);
          }
          if (se === ze && $a(g, E, K)) {
            var br = g.prefix || "", ni = g.namespaceURI;
            xs(w, br ? "xmlns:" + br : "xmlns", ni), K.push({
              prefix: br,
              namespace: ni
            });
          }
          if (Zt || E && !/^(?:meta|link|img|br|hr|input)$/i.test(se)) {
            if (w.push(">"), E && /^script$/i.test(se)) for (; Zt; ) Zt.data ? w.push(Zt.data) : kr(Zt, w, E, k, K.slice()), Zt = Zt.nextSibling;
            else for (; Zt; ) kr(Zt, w, E, k, K.slice()), Zt = Zt.nextSibling;
            w.push("</", ze, ">");
          } else w.push("/>");
          return;
        case T:
        case H:
          for (var Zt = g.firstChild; Zt; ) kr(Zt, w, E, k, K.slice()), Zt = Zt.nextSibling;
          return;
        case f:
          return xs(w, g.name, g.value);
        case p:
          return w.push(g.data.replace(/[<&>]/g, Ut));
        case m:
          return w.push("<![CDATA[", g.data, "]]>");
        case A:
          return w.push("<!--", g.data, "-->");
        case G:
          var Za = g.publicId, Gr = g.systemId;
          if (w.push("<!DOCTYPE ", g.name), Za) w.push(" PUBLIC ", Za), Gr && Gr != "." && w.push(" ", Gr), w.push(">");
          else if (Gr && Gr != ".") w.push(" SYSTEM ", Gr, ">");
          else {
            var Ja = g.internalSubset;
            Ja && w.push(" [", Ja, "]"), w.push(">");
          }
          return;
        case v:
          return w.push("<?", g.target, " ", g.data, "?>");
        case y:
          return w.push("&", g.nodeName, ";");
        default:
          w.push("??", g.nodeName);
      }
    }
    function Ya(g, w, E) {
      var k;
      switch (w.nodeType) {
        case h:
          k = w.cloneNode(false), k.ownerDocument = g;
        case H:
          break;
        case f:
          E = true;
          break;
      }
      if (k || (k = w.cloneNode(false)), k.ownerDocument = g, k.parentNode = null, E) for (var K = w.firstChild; K; ) k.appendChild(Ya(g, K, E)), K = K.nextSibling;
      return k;
    }
    function vs(g, w, E) {
      var k = new w.constructor();
      for (var K in w) if (Object.prototype.hasOwnProperty.call(w, K)) {
        var ot = w[K];
        typeof ot != "object" && ot != k[K] && (k[K] = ot);
      }
      switch (w.childNodes && (k.childNodes = new $()), k.ownerDocument = g, k.nodeType) {
        case h:
          var Bt = w.attributes, se = k.attributes = new it(), ze = Bt.length;
          se._ownerElement = k;
          for (var nr = 0; nr < ze; nr++) k.setAttributeNode(vs(g, Bt.item(nr), true));
          break;
        case f:
          E = true;
      }
      if (E) for (var je = w.firstChild; je; ) k.appendChild(vs(g, je, E)), je = je.nextSibling;
      return k;
    }
    function Ka(g, w, E) {
      g[w] = E;
    }
    try {
      if (Object.defineProperty) {
        let g = function(w) {
          switch (w.nodeType) {
            case h:
            case H:
              var E = [];
              for (w = w.firstChild; w; ) w.nodeType !== 7 && w.nodeType !== 8 && E.push(g(w)), w = w.nextSibling;
              return E.join("");
            default:
              return w.nodeValue;
          }
        };
        Object.defineProperty(ft.prototype, "length", {
          get: function() {
            return pt(this), this.$$length;
          }
        }), Object.defineProperty(ht.prototype, "textContent", {
          get: function() {
            return g(this);
          },
          set: function(w) {
            switch (this.nodeType) {
              case h:
              case H:
                for (; this.firstChild; ) this.removeChild(this.firstChild);
                (w || String(w)) && this.appendChild(this.ownerDocument.createTextNode(w));
                break;
              default:
                this.data = w, this.value = w, this.nodeValue = w;
            }
          }
        }), Ka = function(w, E, k) {
          w["$$" + E] = k;
        };
      }
    } catch {
    }
    return Xe.DocumentType = zi, Xe.DOMException = V, Xe.DOMImplementation = te, Xe.Element = pr, Xe.Node = ht, Xe.NodeList = $, Xe.XMLSerializer = Xa, Xe;
  }
  var di = {}, eo = {}, hu;
  function Qb() {
    return hu || (hu = 1, function(i) {
      "use strict";
      var t = es().freeze;
      i.XML_ENTITIES = t({
        amp: "&",
        apos: "'",
        gt: ">",
        lt: "<",
        quot: '"'
      }), i.HTML_ENTITIES = t({
        Aacute: "\xC1",
        aacute: "\xE1",
        Abreve: "\u0102",
        abreve: "\u0103",
        ac: "\u223E",
        acd: "\u223F",
        acE: "\u223E\u0333",
        Acirc: "\xC2",
        acirc: "\xE2",
        acute: "\xB4",
        Acy: "\u0410",
        acy: "\u0430",
        AElig: "\xC6",
        aelig: "\xE6",
        af: "\u2061",
        Afr: "\u{1D504}",
        afr: "\u{1D51E}",
        Agrave: "\xC0",
        agrave: "\xE0",
        alefsym: "\u2135",
        aleph: "\u2135",
        Alpha: "\u0391",
        alpha: "\u03B1",
        Amacr: "\u0100",
        amacr: "\u0101",
        amalg: "\u2A3F",
        AMP: "&",
        amp: "&",
        And: "\u2A53",
        and: "\u2227",
        andand: "\u2A55",
        andd: "\u2A5C",
        andslope: "\u2A58",
        andv: "\u2A5A",
        ang: "\u2220",
        ange: "\u29A4",
        angle: "\u2220",
        angmsd: "\u2221",
        angmsdaa: "\u29A8",
        angmsdab: "\u29A9",
        angmsdac: "\u29AA",
        angmsdad: "\u29AB",
        angmsdae: "\u29AC",
        angmsdaf: "\u29AD",
        angmsdag: "\u29AE",
        angmsdah: "\u29AF",
        angrt: "\u221F",
        angrtvb: "\u22BE",
        angrtvbd: "\u299D",
        angsph: "\u2222",
        angst: "\xC5",
        angzarr: "\u237C",
        Aogon: "\u0104",
        aogon: "\u0105",
        Aopf: "\u{1D538}",
        aopf: "\u{1D552}",
        ap: "\u2248",
        apacir: "\u2A6F",
        apE: "\u2A70",
        ape: "\u224A",
        apid: "\u224B",
        apos: "'",
        ApplyFunction: "\u2061",
        approx: "\u2248",
        approxeq: "\u224A",
        Aring: "\xC5",
        aring: "\xE5",
        Ascr: "\u{1D49C}",
        ascr: "\u{1D4B6}",
        Assign: "\u2254",
        ast: "*",
        asymp: "\u2248",
        asympeq: "\u224D",
        Atilde: "\xC3",
        atilde: "\xE3",
        Auml: "\xC4",
        auml: "\xE4",
        awconint: "\u2233",
        awint: "\u2A11",
        backcong: "\u224C",
        backepsilon: "\u03F6",
        backprime: "\u2035",
        backsim: "\u223D",
        backsimeq: "\u22CD",
        Backslash: "\u2216",
        Barv: "\u2AE7",
        barvee: "\u22BD",
        Barwed: "\u2306",
        barwed: "\u2305",
        barwedge: "\u2305",
        bbrk: "\u23B5",
        bbrktbrk: "\u23B6",
        bcong: "\u224C",
        Bcy: "\u0411",
        bcy: "\u0431",
        bdquo: "\u201E",
        becaus: "\u2235",
        Because: "\u2235",
        because: "\u2235",
        bemptyv: "\u29B0",
        bepsi: "\u03F6",
        bernou: "\u212C",
        Bernoullis: "\u212C",
        Beta: "\u0392",
        beta: "\u03B2",
        beth: "\u2136",
        between: "\u226C",
        Bfr: "\u{1D505}",
        bfr: "\u{1D51F}",
        bigcap: "\u22C2",
        bigcirc: "\u25EF",
        bigcup: "\u22C3",
        bigodot: "\u2A00",
        bigoplus: "\u2A01",
        bigotimes: "\u2A02",
        bigsqcup: "\u2A06",
        bigstar: "\u2605",
        bigtriangledown: "\u25BD",
        bigtriangleup: "\u25B3",
        biguplus: "\u2A04",
        bigvee: "\u22C1",
        bigwedge: "\u22C0",
        bkarow: "\u290D",
        blacklozenge: "\u29EB",
        blacksquare: "\u25AA",
        blacktriangle: "\u25B4",
        blacktriangledown: "\u25BE",
        blacktriangleleft: "\u25C2",
        blacktriangleright: "\u25B8",
        blank: "\u2423",
        blk12: "\u2592",
        blk14: "\u2591",
        blk34: "\u2593",
        block: "\u2588",
        bne: "=\u20E5",
        bnequiv: "\u2261\u20E5",
        bNot: "\u2AED",
        bnot: "\u2310",
        Bopf: "\u{1D539}",
        bopf: "\u{1D553}",
        bot: "\u22A5",
        bottom: "\u22A5",
        bowtie: "\u22C8",
        boxbox: "\u29C9",
        boxDL: "\u2557",
        boxDl: "\u2556",
        boxdL: "\u2555",
        boxdl: "\u2510",
        boxDR: "\u2554",
        boxDr: "\u2553",
        boxdR: "\u2552",
        boxdr: "\u250C",
        boxH: "\u2550",
        boxh: "\u2500",
        boxHD: "\u2566",
        boxHd: "\u2564",
        boxhD: "\u2565",
        boxhd: "\u252C",
        boxHU: "\u2569",
        boxHu: "\u2567",
        boxhU: "\u2568",
        boxhu: "\u2534",
        boxminus: "\u229F",
        boxplus: "\u229E",
        boxtimes: "\u22A0",
        boxUL: "\u255D",
        boxUl: "\u255C",
        boxuL: "\u255B",
        boxul: "\u2518",
        boxUR: "\u255A",
        boxUr: "\u2559",
        boxuR: "\u2558",
        boxur: "\u2514",
        boxV: "\u2551",
        boxv: "\u2502",
        boxVH: "\u256C",
        boxVh: "\u256B",
        boxvH: "\u256A",
        boxvh: "\u253C",
        boxVL: "\u2563",
        boxVl: "\u2562",
        boxvL: "\u2561",
        boxvl: "\u2524",
        boxVR: "\u2560",
        boxVr: "\u255F",
        boxvR: "\u255E",
        boxvr: "\u251C",
        bprime: "\u2035",
        Breve: "\u02D8",
        breve: "\u02D8",
        brvbar: "\xA6",
        Bscr: "\u212C",
        bscr: "\u{1D4B7}",
        bsemi: "\u204F",
        bsim: "\u223D",
        bsime: "\u22CD",
        bsol: "\\",
        bsolb: "\u29C5",
        bsolhsub: "\u27C8",
        bull: "\u2022",
        bullet: "\u2022",
        bump: "\u224E",
        bumpE: "\u2AAE",
        bumpe: "\u224F",
        Bumpeq: "\u224E",
        bumpeq: "\u224F",
        Cacute: "\u0106",
        cacute: "\u0107",
        Cap: "\u22D2",
        cap: "\u2229",
        capand: "\u2A44",
        capbrcup: "\u2A49",
        capcap: "\u2A4B",
        capcup: "\u2A47",
        capdot: "\u2A40",
        CapitalDifferentialD: "\u2145",
        caps: "\u2229\uFE00",
        caret: "\u2041",
        caron: "\u02C7",
        Cayleys: "\u212D",
        ccaps: "\u2A4D",
        Ccaron: "\u010C",
        ccaron: "\u010D",
        Ccedil: "\xC7",
        ccedil: "\xE7",
        Ccirc: "\u0108",
        ccirc: "\u0109",
        Cconint: "\u2230",
        ccups: "\u2A4C",
        ccupssm: "\u2A50",
        Cdot: "\u010A",
        cdot: "\u010B",
        cedil: "\xB8",
        Cedilla: "\xB8",
        cemptyv: "\u29B2",
        cent: "\xA2",
        CenterDot: "\xB7",
        centerdot: "\xB7",
        Cfr: "\u212D",
        cfr: "\u{1D520}",
        CHcy: "\u0427",
        chcy: "\u0447",
        check: "\u2713",
        checkmark: "\u2713",
        Chi: "\u03A7",
        chi: "\u03C7",
        cir: "\u25CB",
        circ: "\u02C6",
        circeq: "\u2257",
        circlearrowleft: "\u21BA",
        circlearrowright: "\u21BB",
        circledast: "\u229B",
        circledcirc: "\u229A",
        circleddash: "\u229D",
        CircleDot: "\u2299",
        circledR: "\xAE",
        circledS: "\u24C8",
        CircleMinus: "\u2296",
        CirclePlus: "\u2295",
        CircleTimes: "\u2297",
        cirE: "\u29C3",
        cire: "\u2257",
        cirfnint: "\u2A10",
        cirmid: "\u2AEF",
        cirscir: "\u29C2",
        ClockwiseContourIntegral: "\u2232",
        CloseCurlyDoubleQuote: "\u201D",
        CloseCurlyQuote: "\u2019",
        clubs: "\u2663",
        clubsuit: "\u2663",
        Colon: "\u2237",
        colon: ":",
        Colone: "\u2A74",
        colone: "\u2254",
        coloneq: "\u2254",
        comma: ",",
        commat: "@",
        comp: "\u2201",
        compfn: "\u2218",
        complement: "\u2201",
        complexes: "\u2102",
        cong: "\u2245",
        congdot: "\u2A6D",
        Congruent: "\u2261",
        Conint: "\u222F",
        conint: "\u222E",
        ContourIntegral: "\u222E",
        Copf: "\u2102",
        copf: "\u{1D554}",
        coprod: "\u2210",
        Coproduct: "\u2210",
        COPY: "\xA9",
        copy: "\xA9",
        copysr: "\u2117",
        CounterClockwiseContourIntegral: "\u2233",
        crarr: "\u21B5",
        Cross: "\u2A2F",
        cross: "\u2717",
        Cscr: "\u{1D49E}",
        cscr: "\u{1D4B8}",
        csub: "\u2ACF",
        csube: "\u2AD1",
        csup: "\u2AD0",
        csupe: "\u2AD2",
        ctdot: "\u22EF",
        cudarrl: "\u2938",
        cudarrr: "\u2935",
        cuepr: "\u22DE",
        cuesc: "\u22DF",
        cularr: "\u21B6",
        cularrp: "\u293D",
        Cup: "\u22D3",
        cup: "\u222A",
        cupbrcap: "\u2A48",
        CupCap: "\u224D",
        cupcap: "\u2A46",
        cupcup: "\u2A4A",
        cupdot: "\u228D",
        cupor: "\u2A45",
        cups: "\u222A\uFE00",
        curarr: "\u21B7",
        curarrm: "\u293C",
        curlyeqprec: "\u22DE",
        curlyeqsucc: "\u22DF",
        curlyvee: "\u22CE",
        curlywedge: "\u22CF",
        curren: "\xA4",
        curvearrowleft: "\u21B6",
        curvearrowright: "\u21B7",
        cuvee: "\u22CE",
        cuwed: "\u22CF",
        cwconint: "\u2232",
        cwint: "\u2231",
        cylcty: "\u232D",
        Dagger: "\u2021",
        dagger: "\u2020",
        daleth: "\u2138",
        Darr: "\u21A1",
        dArr: "\u21D3",
        darr: "\u2193",
        dash: "\u2010",
        Dashv: "\u2AE4",
        dashv: "\u22A3",
        dbkarow: "\u290F",
        dblac: "\u02DD",
        Dcaron: "\u010E",
        dcaron: "\u010F",
        Dcy: "\u0414",
        dcy: "\u0434",
        DD: "\u2145",
        dd: "\u2146",
        ddagger: "\u2021",
        ddarr: "\u21CA",
        DDotrahd: "\u2911",
        ddotseq: "\u2A77",
        deg: "\xB0",
        Del: "\u2207",
        Delta: "\u0394",
        delta: "\u03B4",
        demptyv: "\u29B1",
        dfisht: "\u297F",
        Dfr: "\u{1D507}",
        dfr: "\u{1D521}",
        dHar: "\u2965",
        dharl: "\u21C3",
        dharr: "\u21C2",
        DiacriticalAcute: "\xB4",
        DiacriticalDot: "\u02D9",
        DiacriticalDoubleAcute: "\u02DD",
        DiacriticalGrave: "`",
        DiacriticalTilde: "\u02DC",
        diam: "\u22C4",
        Diamond: "\u22C4",
        diamond: "\u22C4",
        diamondsuit: "\u2666",
        diams: "\u2666",
        die: "\xA8",
        DifferentialD: "\u2146",
        digamma: "\u03DD",
        disin: "\u22F2",
        div: "\xF7",
        divide: "\xF7",
        divideontimes: "\u22C7",
        divonx: "\u22C7",
        DJcy: "\u0402",
        djcy: "\u0452",
        dlcorn: "\u231E",
        dlcrop: "\u230D",
        dollar: "$",
        Dopf: "\u{1D53B}",
        dopf: "\u{1D555}",
        Dot: "\xA8",
        dot: "\u02D9",
        DotDot: "\u20DC",
        doteq: "\u2250",
        doteqdot: "\u2251",
        DotEqual: "\u2250",
        dotminus: "\u2238",
        dotplus: "\u2214",
        dotsquare: "\u22A1",
        doublebarwedge: "\u2306",
        DoubleContourIntegral: "\u222F",
        DoubleDot: "\xA8",
        DoubleDownArrow: "\u21D3",
        DoubleLeftArrow: "\u21D0",
        DoubleLeftRightArrow: "\u21D4",
        DoubleLeftTee: "\u2AE4",
        DoubleLongLeftArrow: "\u27F8",
        DoubleLongLeftRightArrow: "\u27FA",
        DoubleLongRightArrow: "\u27F9",
        DoubleRightArrow: "\u21D2",
        DoubleRightTee: "\u22A8",
        DoubleUpArrow: "\u21D1",
        DoubleUpDownArrow: "\u21D5",
        DoubleVerticalBar: "\u2225",
        DownArrow: "\u2193",
        Downarrow: "\u21D3",
        downarrow: "\u2193",
        DownArrowBar: "\u2913",
        DownArrowUpArrow: "\u21F5",
        DownBreve: "\u0311",
        downdownarrows: "\u21CA",
        downharpoonleft: "\u21C3",
        downharpoonright: "\u21C2",
        DownLeftRightVector: "\u2950",
        DownLeftTeeVector: "\u295E",
        DownLeftVector: "\u21BD",
        DownLeftVectorBar: "\u2956",
        DownRightTeeVector: "\u295F",
        DownRightVector: "\u21C1",
        DownRightVectorBar: "\u2957",
        DownTee: "\u22A4",
        DownTeeArrow: "\u21A7",
        drbkarow: "\u2910",
        drcorn: "\u231F",
        drcrop: "\u230C",
        Dscr: "\u{1D49F}",
        dscr: "\u{1D4B9}",
        DScy: "\u0405",
        dscy: "\u0455",
        dsol: "\u29F6",
        Dstrok: "\u0110",
        dstrok: "\u0111",
        dtdot: "\u22F1",
        dtri: "\u25BF",
        dtrif: "\u25BE",
        duarr: "\u21F5",
        duhar: "\u296F",
        dwangle: "\u29A6",
        DZcy: "\u040F",
        dzcy: "\u045F",
        dzigrarr: "\u27FF",
        Eacute: "\xC9",
        eacute: "\xE9",
        easter: "\u2A6E",
        Ecaron: "\u011A",
        ecaron: "\u011B",
        ecir: "\u2256",
        Ecirc: "\xCA",
        ecirc: "\xEA",
        ecolon: "\u2255",
        Ecy: "\u042D",
        ecy: "\u044D",
        eDDot: "\u2A77",
        Edot: "\u0116",
        eDot: "\u2251",
        edot: "\u0117",
        ee: "\u2147",
        efDot: "\u2252",
        Efr: "\u{1D508}",
        efr: "\u{1D522}",
        eg: "\u2A9A",
        Egrave: "\xC8",
        egrave: "\xE8",
        egs: "\u2A96",
        egsdot: "\u2A98",
        el: "\u2A99",
        Element: "\u2208",
        elinters: "\u23E7",
        ell: "\u2113",
        els: "\u2A95",
        elsdot: "\u2A97",
        Emacr: "\u0112",
        emacr: "\u0113",
        empty: "\u2205",
        emptyset: "\u2205",
        EmptySmallSquare: "\u25FB",
        emptyv: "\u2205",
        EmptyVerySmallSquare: "\u25AB",
        emsp: "\u2003",
        emsp13: "\u2004",
        emsp14: "\u2005",
        ENG: "\u014A",
        eng: "\u014B",
        ensp: "\u2002",
        Eogon: "\u0118",
        eogon: "\u0119",
        Eopf: "\u{1D53C}",
        eopf: "\u{1D556}",
        epar: "\u22D5",
        eparsl: "\u29E3",
        eplus: "\u2A71",
        epsi: "\u03B5",
        Epsilon: "\u0395",
        epsilon: "\u03B5",
        epsiv: "\u03F5",
        eqcirc: "\u2256",
        eqcolon: "\u2255",
        eqsim: "\u2242",
        eqslantgtr: "\u2A96",
        eqslantless: "\u2A95",
        Equal: "\u2A75",
        equals: "=",
        EqualTilde: "\u2242",
        equest: "\u225F",
        Equilibrium: "\u21CC",
        equiv: "\u2261",
        equivDD: "\u2A78",
        eqvparsl: "\u29E5",
        erarr: "\u2971",
        erDot: "\u2253",
        Escr: "\u2130",
        escr: "\u212F",
        esdot: "\u2250",
        Esim: "\u2A73",
        esim: "\u2242",
        Eta: "\u0397",
        eta: "\u03B7",
        ETH: "\xD0",
        eth: "\xF0",
        Euml: "\xCB",
        euml: "\xEB",
        euro: "\u20AC",
        excl: "!",
        exist: "\u2203",
        Exists: "\u2203",
        expectation: "\u2130",
        ExponentialE: "\u2147",
        exponentiale: "\u2147",
        fallingdotseq: "\u2252",
        Fcy: "\u0424",
        fcy: "\u0444",
        female: "\u2640",
        ffilig: "\uFB03",
        fflig: "\uFB00",
        ffllig: "\uFB04",
        Ffr: "\u{1D509}",
        ffr: "\u{1D523}",
        filig: "\uFB01",
        FilledSmallSquare: "\u25FC",
        FilledVerySmallSquare: "\u25AA",
        fjlig: "fj",
        flat: "\u266D",
        fllig: "\uFB02",
        fltns: "\u25B1",
        fnof: "\u0192",
        Fopf: "\u{1D53D}",
        fopf: "\u{1D557}",
        ForAll: "\u2200",
        forall: "\u2200",
        fork: "\u22D4",
        forkv: "\u2AD9",
        Fouriertrf: "\u2131",
        fpartint: "\u2A0D",
        frac12: "\xBD",
        frac13: "\u2153",
        frac14: "\xBC",
        frac15: "\u2155",
        frac16: "\u2159",
        frac18: "\u215B",
        frac23: "\u2154",
        frac25: "\u2156",
        frac34: "\xBE",
        frac35: "\u2157",
        frac38: "\u215C",
        frac45: "\u2158",
        frac56: "\u215A",
        frac58: "\u215D",
        frac78: "\u215E",
        frasl: "\u2044",
        frown: "\u2322",
        Fscr: "\u2131",
        fscr: "\u{1D4BB}",
        gacute: "\u01F5",
        Gamma: "\u0393",
        gamma: "\u03B3",
        Gammad: "\u03DC",
        gammad: "\u03DD",
        gap: "\u2A86",
        Gbreve: "\u011E",
        gbreve: "\u011F",
        Gcedil: "\u0122",
        Gcirc: "\u011C",
        gcirc: "\u011D",
        Gcy: "\u0413",
        gcy: "\u0433",
        Gdot: "\u0120",
        gdot: "\u0121",
        gE: "\u2267",
        ge: "\u2265",
        gEl: "\u2A8C",
        gel: "\u22DB",
        geq: "\u2265",
        geqq: "\u2267",
        geqslant: "\u2A7E",
        ges: "\u2A7E",
        gescc: "\u2AA9",
        gesdot: "\u2A80",
        gesdoto: "\u2A82",
        gesdotol: "\u2A84",
        gesl: "\u22DB\uFE00",
        gesles: "\u2A94",
        Gfr: "\u{1D50A}",
        gfr: "\u{1D524}",
        Gg: "\u22D9",
        gg: "\u226B",
        ggg: "\u22D9",
        gimel: "\u2137",
        GJcy: "\u0403",
        gjcy: "\u0453",
        gl: "\u2277",
        gla: "\u2AA5",
        glE: "\u2A92",
        glj: "\u2AA4",
        gnap: "\u2A8A",
        gnapprox: "\u2A8A",
        gnE: "\u2269",
        gne: "\u2A88",
        gneq: "\u2A88",
        gneqq: "\u2269",
        gnsim: "\u22E7",
        Gopf: "\u{1D53E}",
        gopf: "\u{1D558}",
        grave: "`",
        GreaterEqual: "\u2265",
        GreaterEqualLess: "\u22DB",
        GreaterFullEqual: "\u2267",
        GreaterGreater: "\u2AA2",
        GreaterLess: "\u2277",
        GreaterSlantEqual: "\u2A7E",
        GreaterTilde: "\u2273",
        Gscr: "\u{1D4A2}",
        gscr: "\u210A",
        gsim: "\u2273",
        gsime: "\u2A8E",
        gsiml: "\u2A90",
        Gt: "\u226B",
        GT: ">",
        gt: ">",
        gtcc: "\u2AA7",
        gtcir: "\u2A7A",
        gtdot: "\u22D7",
        gtlPar: "\u2995",
        gtquest: "\u2A7C",
        gtrapprox: "\u2A86",
        gtrarr: "\u2978",
        gtrdot: "\u22D7",
        gtreqless: "\u22DB",
        gtreqqless: "\u2A8C",
        gtrless: "\u2277",
        gtrsim: "\u2273",
        gvertneqq: "\u2269\uFE00",
        gvnE: "\u2269\uFE00",
        Hacek: "\u02C7",
        hairsp: "\u200A",
        half: "\xBD",
        hamilt: "\u210B",
        HARDcy: "\u042A",
        hardcy: "\u044A",
        hArr: "\u21D4",
        harr: "\u2194",
        harrcir: "\u2948",
        harrw: "\u21AD",
        Hat: "^",
        hbar: "\u210F",
        Hcirc: "\u0124",
        hcirc: "\u0125",
        hearts: "\u2665",
        heartsuit: "\u2665",
        hellip: "\u2026",
        hercon: "\u22B9",
        Hfr: "\u210C",
        hfr: "\u{1D525}",
        HilbertSpace: "\u210B",
        hksearow: "\u2925",
        hkswarow: "\u2926",
        hoarr: "\u21FF",
        homtht: "\u223B",
        hookleftarrow: "\u21A9",
        hookrightarrow: "\u21AA",
        Hopf: "\u210D",
        hopf: "\u{1D559}",
        horbar: "\u2015",
        HorizontalLine: "\u2500",
        Hscr: "\u210B",
        hscr: "\u{1D4BD}",
        hslash: "\u210F",
        Hstrok: "\u0126",
        hstrok: "\u0127",
        HumpDownHump: "\u224E",
        HumpEqual: "\u224F",
        hybull: "\u2043",
        hyphen: "\u2010",
        Iacute: "\xCD",
        iacute: "\xED",
        ic: "\u2063",
        Icirc: "\xCE",
        icirc: "\xEE",
        Icy: "\u0418",
        icy: "\u0438",
        Idot: "\u0130",
        IEcy: "\u0415",
        iecy: "\u0435",
        iexcl: "\xA1",
        iff: "\u21D4",
        Ifr: "\u2111",
        ifr: "\u{1D526}",
        Igrave: "\xCC",
        igrave: "\xEC",
        ii: "\u2148",
        iiiint: "\u2A0C",
        iiint: "\u222D",
        iinfin: "\u29DC",
        iiota: "\u2129",
        IJlig: "\u0132",
        ijlig: "\u0133",
        Im: "\u2111",
        Imacr: "\u012A",
        imacr: "\u012B",
        image: "\u2111",
        ImaginaryI: "\u2148",
        imagline: "\u2110",
        imagpart: "\u2111",
        imath: "\u0131",
        imof: "\u22B7",
        imped: "\u01B5",
        Implies: "\u21D2",
        in: "\u2208",
        incare: "\u2105",
        infin: "\u221E",
        infintie: "\u29DD",
        inodot: "\u0131",
        Int: "\u222C",
        int: "\u222B",
        intcal: "\u22BA",
        integers: "\u2124",
        Integral: "\u222B",
        intercal: "\u22BA",
        Intersection: "\u22C2",
        intlarhk: "\u2A17",
        intprod: "\u2A3C",
        InvisibleComma: "\u2063",
        InvisibleTimes: "\u2062",
        IOcy: "\u0401",
        iocy: "\u0451",
        Iogon: "\u012E",
        iogon: "\u012F",
        Iopf: "\u{1D540}",
        iopf: "\u{1D55A}",
        Iota: "\u0399",
        iota: "\u03B9",
        iprod: "\u2A3C",
        iquest: "\xBF",
        Iscr: "\u2110",
        iscr: "\u{1D4BE}",
        isin: "\u2208",
        isindot: "\u22F5",
        isinE: "\u22F9",
        isins: "\u22F4",
        isinsv: "\u22F3",
        isinv: "\u2208",
        it: "\u2062",
        Itilde: "\u0128",
        itilde: "\u0129",
        Iukcy: "\u0406",
        iukcy: "\u0456",
        Iuml: "\xCF",
        iuml: "\xEF",
        Jcirc: "\u0134",
        jcirc: "\u0135",
        Jcy: "\u0419",
        jcy: "\u0439",
        Jfr: "\u{1D50D}",
        jfr: "\u{1D527}",
        jmath: "\u0237",
        Jopf: "\u{1D541}",
        jopf: "\u{1D55B}",
        Jscr: "\u{1D4A5}",
        jscr: "\u{1D4BF}",
        Jsercy: "\u0408",
        jsercy: "\u0458",
        Jukcy: "\u0404",
        jukcy: "\u0454",
        Kappa: "\u039A",
        kappa: "\u03BA",
        kappav: "\u03F0",
        Kcedil: "\u0136",
        kcedil: "\u0137",
        Kcy: "\u041A",
        kcy: "\u043A",
        Kfr: "\u{1D50E}",
        kfr: "\u{1D528}",
        kgreen: "\u0138",
        KHcy: "\u0425",
        khcy: "\u0445",
        KJcy: "\u040C",
        kjcy: "\u045C",
        Kopf: "\u{1D542}",
        kopf: "\u{1D55C}",
        Kscr: "\u{1D4A6}",
        kscr: "\u{1D4C0}",
        lAarr: "\u21DA",
        Lacute: "\u0139",
        lacute: "\u013A",
        laemptyv: "\u29B4",
        lagran: "\u2112",
        Lambda: "\u039B",
        lambda: "\u03BB",
        Lang: "\u27EA",
        lang: "\u27E8",
        langd: "\u2991",
        langle: "\u27E8",
        lap: "\u2A85",
        Laplacetrf: "\u2112",
        laquo: "\xAB",
        Larr: "\u219E",
        lArr: "\u21D0",
        larr: "\u2190",
        larrb: "\u21E4",
        larrbfs: "\u291F",
        larrfs: "\u291D",
        larrhk: "\u21A9",
        larrlp: "\u21AB",
        larrpl: "\u2939",
        larrsim: "\u2973",
        larrtl: "\u21A2",
        lat: "\u2AAB",
        lAtail: "\u291B",
        latail: "\u2919",
        late: "\u2AAD",
        lates: "\u2AAD\uFE00",
        lBarr: "\u290E",
        lbarr: "\u290C",
        lbbrk: "\u2772",
        lbrace: "{",
        lbrack: "[",
        lbrke: "\u298B",
        lbrksld: "\u298F",
        lbrkslu: "\u298D",
        Lcaron: "\u013D",
        lcaron: "\u013E",
        Lcedil: "\u013B",
        lcedil: "\u013C",
        lceil: "\u2308",
        lcub: "{",
        Lcy: "\u041B",
        lcy: "\u043B",
        ldca: "\u2936",
        ldquo: "\u201C",
        ldquor: "\u201E",
        ldrdhar: "\u2967",
        ldrushar: "\u294B",
        ldsh: "\u21B2",
        lE: "\u2266",
        le: "\u2264",
        LeftAngleBracket: "\u27E8",
        LeftArrow: "\u2190",
        Leftarrow: "\u21D0",
        leftarrow: "\u2190",
        LeftArrowBar: "\u21E4",
        LeftArrowRightArrow: "\u21C6",
        leftarrowtail: "\u21A2",
        LeftCeiling: "\u2308",
        LeftDoubleBracket: "\u27E6",
        LeftDownTeeVector: "\u2961",
        LeftDownVector: "\u21C3",
        LeftDownVectorBar: "\u2959",
        LeftFloor: "\u230A",
        leftharpoondown: "\u21BD",
        leftharpoonup: "\u21BC",
        leftleftarrows: "\u21C7",
        LeftRightArrow: "\u2194",
        Leftrightarrow: "\u21D4",
        leftrightarrow: "\u2194",
        leftrightarrows: "\u21C6",
        leftrightharpoons: "\u21CB",
        leftrightsquigarrow: "\u21AD",
        LeftRightVector: "\u294E",
        LeftTee: "\u22A3",
        LeftTeeArrow: "\u21A4",
        LeftTeeVector: "\u295A",
        leftthreetimes: "\u22CB",
        LeftTriangle: "\u22B2",
        LeftTriangleBar: "\u29CF",
        LeftTriangleEqual: "\u22B4",
        LeftUpDownVector: "\u2951",
        LeftUpTeeVector: "\u2960",
        LeftUpVector: "\u21BF",
        LeftUpVectorBar: "\u2958",
        LeftVector: "\u21BC",
        LeftVectorBar: "\u2952",
        lEg: "\u2A8B",
        leg: "\u22DA",
        leq: "\u2264",
        leqq: "\u2266",
        leqslant: "\u2A7D",
        les: "\u2A7D",
        lescc: "\u2AA8",
        lesdot: "\u2A7F",
        lesdoto: "\u2A81",
        lesdotor: "\u2A83",
        lesg: "\u22DA\uFE00",
        lesges: "\u2A93",
        lessapprox: "\u2A85",
        lessdot: "\u22D6",
        lesseqgtr: "\u22DA",
        lesseqqgtr: "\u2A8B",
        LessEqualGreater: "\u22DA",
        LessFullEqual: "\u2266",
        LessGreater: "\u2276",
        lessgtr: "\u2276",
        LessLess: "\u2AA1",
        lesssim: "\u2272",
        LessSlantEqual: "\u2A7D",
        LessTilde: "\u2272",
        lfisht: "\u297C",
        lfloor: "\u230A",
        Lfr: "\u{1D50F}",
        lfr: "\u{1D529}",
        lg: "\u2276",
        lgE: "\u2A91",
        lHar: "\u2962",
        lhard: "\u21BD",
        lharu: "\u21BC",
        lharul: "\u296A",
        lhblk: "\u2584",
        LJcy: "\u0409",
        ljcy: "\u0459",
        Ll: "\u22D8",
        ll: "\u226A",
        llarr: "\u21C7",
        llcorner: "\u231E",
        Lleftarrow: "\u21DA",
        llhard: "\u296B",
        lltri: "\u25FA",
        Lmidot: "\u013F",
        lmidot: "\u0140",
        lmoust: "\u23B0",
        lmoustache: "\u23B0",
        lnap: "\u2A89",
        lnapprox: "\u2A89",
        lnE: "\u2268",
        lne: "\u2A87",
        lneq: "\u2A87",
        lneqq: "\u2268",
        lnsim: "\u22E6",
        loang: "\u27EC",
        loarr: "\u21FD",
        lobrk: "\u27E6",
        LongLeftArrow: "\u27F5",
        Longleftarrow: "\u27F8",
        longleftarrow: "\u27F5",
        LongLeftRightArrow: "\u27F7",
        Longleftrightarrow: "\u27FA",
        longleftrightarrow: "\u27F7",
        longmapsto: "\u27FC",
        LongRightArrow: "\u27F6",
        Longrightarrow: "\u27F9",
        longrightarrow: "\u27F6",
        looparrowleft: "\u21AB",
        looparrowright: "\u21AC",
        lopar: "\u2985",
        Lopf: "\u{1D543}",
        lopf: "\u{1D55D}",
        loplus: "\u2A2D",
        lotimes: "\u2A34",
        lowast: "\u2217",
        lowbar: "_",
        LowerLeftArrow: "\u2199",
        LowerRightArrow: "\u2198",
        loz: "\u25CA",
        lozenge: "\u25CA",
        lozf: "\u29EB",
        lpar: "(",
        lparlt: "\u2993",
        lrarr: "\u21C6",
        lrcorner: "\u231F",
        lrhar: "\u21CB",
        lrhard: "\u296D",
        lrm: "\u200E",
        lrtri: "\u22BF",
        lsaquo: "\u2039",
        Lscr: "\u2112",
        lscr: "\u{1D4C1}",
        Lsh: "\u21B0",
        lsh: "\u21B0",
        lsim: "\u2272",
        lsime: "\u2A8D",
        lsimg: "\u2A8F",
        lsqb: "[",
        lsquo: "\u2018",
        lsquor: "\u201A",
        Lstrok: "\u0141",
        lstrok: "\u0142",
        Lt: "\u226A",
        LT: "<",
        lt: "<",
        ltcc: "\u2AA6",
        ltcir: "\u2A79",
        ltdot: "\u22D6",
        lthree: "\u22CB",
        ltimes: "\u22C9",
        ltlarr: "\u2976",
        ltquest: "\u2A7B",
        ltri: "\u25C3",
        ltrie: "\u22B4",
        ltrif: "\u25C2",
        ltrPar: "\u2996",
        lurdshar: "\u294A",
        luruhar: "\u2966",
        lvertneqq: "\u2268\uFE00",
        lvnE: "\u2268\uFE00",
        macr: "\xAF",
        male: "\u2642",
        malt: "\u2720",
        maltese: "\u2720",
        Map: "\u2905",
        map: "\u21A6",
        mapsto: "\u21A6",
        mapstodown: "\u21A7",
        mapstoleft: "\u21A4",
        mapstoup: "\u21A5",
        marker: "\u25AE",
        mcomma: "\u2A29",
        Mcy: "\u041C",
        mcy: "\u043C",
        mdash: "\u2014",
        mDDot: "\u223A",
        measuredangle: "\u2221",
        MediumSpace: "\u205F",
        Mellintrf: "\u2133",
        Mfr: "\u{1D510}",
        mfr: "\u{1D52A}",
        mho: "\u2127",
        micro: "\xB5",
        mid: "\u2223",
        midast: "*",
        midcir: "\u2AF0",
        middot: "\xB7",
        minus: "\u2212",
        minusb: "\u229F",
        minusd: "\u2238",
        minusdu: "\u2A2A",
        MinusPlus: "\u2213",
        mlcp: "\u2ADB",
        mldr: "\u2026",
        mnplus: "\u2213",
        models: "\u22A7",
        Mopf: "\u{1D544}",
        mopf: "\u{1D55E}",
        mp: "\u2213",
        Mscr: "\u2133",
        mscr: "\u{1D4C2}",
        mstpos: "\u223E",
        Mu: "\u039C",
        mu: "\u03BC",
        multimap: "\u22B8",
        mumap: "\u22B8",
        nabla: "\u2207",
        Nacute: "\u0143",
        nacute: "\u0144",
        nang: "\u2220\u20D2",
        nap: "\u2249",
        napE: "\u2A70\u0338",
        napid: "\u224B\u0338",
        napos: "\u0149",
        napprox: "\u2249",
        natur: "\u266E",
        natural: "\u266E",
        naturals: "\u2115",
        nbsp: "\xA0",
        nbump: "\u224E\u0338",
        nbumpe: "\u224F\u0338",
        ncap: "\u2A43",
        Ncaron: "\u0147",
        ncaron: "\u0148",
        Ncedil: "\u0145",
        ncedil: "\u0146",
        ncong: "\u2247",
        ncongdot: "\u2A6D\u0338",
        ncup: "\u2A42",
        Ncy: "\u041D",
        ncy: "\u043D",
        ndash: "\u2013",
        ne: "\u2260",
        nearhk: "\u2924",
        neArr: "\u21D7",
        nearr: "\u2197",
        nearrow: "\u2197",
        nedot: "\u2250\u0338",
        NegativeMediumSpace: "\u200B",
        NegativeThickSpace: "\u200B",
        NegativeThinSpace: "\u200B",
        NegativeVeryThinSpace: "\u200B",
        nequiv: "\u2262",
        nesear: "\u2928",
        nesim: "\u2242\u0338",
        NestedGreaterGreater: "\u226B",
        NestedLessLess: "\u226A",
        NewLine: `
`,
        nexist: "\u2204",
        nexists: "\u2204",
        Nfr: "\u{1D511}",
        nfr: "\u{1D52B}",
        ngE: "\u2267\u0338",
        nge: "\u2271",
        ngeq: "\u2271",
        ngeqq: "\u2267\u0338",
        ngeqslant: "\u2A7E\u0338",
        nges: "\u2A7E\u0338",
        nGg: "\u22D9\u0338",
        ngsim: "\u2275",
        nGt: "\u226B\u20D2",
        ngt: "\u226F",
        ngtr: "\u226F",
        nGtv: "\u226B\u0338",
        nhArr: "\u21CE",
        nharr: "\u21AE",
        nhpar: "\u2AF2",
        ni: "\u220B",
        nis: "\u22FC",
        nisd: "\u22FA",
        niv: "\u220B",
        NJcy: "\u040A",
        njcy: "\u045A",
        nlArr: "\u21CD",
        nlarr: "\u219A",
        nldr: "\u2025",
        nlE: "\u2266\u0338",
        nle: "\u2270",
        nLeftarrow: "\u21CD",
        nleftarrow: "\u219A",
        nLeftrightarrow: "\u21CE",
        nleftrightarrow: "\u21AE",
        nleq: "\u2270",
        nleqq: "\u2266\u0338",
        nleqslant: "\u2A7D\u0338",
        nles: "\u2A7D\u0338",
        nless: "\u226E",
        nLl: "\u22D8\u0338",
        nlsim: "\u2274",
        nLt: "\u226A\u20D2",
        nlt: "\u226E",
        nltri: "\u22EA",
        nltrie: "\u22EC",
        nLtv: "\u226A\u0338",
        nmid: "\u2224",
        NoBreak: "\u2060",
        NonBreakingSpace: "\xA0",
        Nopf: "\u2115",
        nopf: "\u{1D55F}",
        Not: "\u2AEC",
        not: "\xAC",
        NotCongruent: "\u2262",
        NotCupCap: "\u226D",
        NotDoubleVerticalBar: "\u2226",
        NotElement: "\u2209",
        NotEqual: "\u2260",
        NotEqualTilde: "\u2242\u0338",
        NotExists: "\u2204",
        NotGreater: "\u226F",
        NotGreaterEqual: "\u2271",
        NotGreaterFullEqual: "\u2267\u0338",
        NotGreaterGreater: "\u226B\u0338",
        NotGreaterLess: "\u2279",
        NotGreaterSlantEqual: "\u2A7E\u0338",
        NotGreaterTilde: "\u2275",
        NotHumpDownHump: "\u224E\u0338",
        NotHumpEqual: "\u224F\u0338",
        notin: "\u2209",
        notindot: "\u22F5\u0338",
        notinE: "\u22F9\u0338",
        notinva: "\u2209",
        notinvb: "\u22F7",
        notinvc: "\u22F6",
        NotLeftTriangle: "\u22EA",
        NotLeftTriangleBar: "\u29CF\u0338",
        NotLeftTriangleEqual: "\u22EC",
        NotLess: "\u226E",
        NotLessEqual: "\u2270",
        NotLessGreater: "\u2278",
        NotLessLess: "\u226A\u0338",
        NotLessSlantEqual: "\u2A7D\u0338",
        NotLessTilde: "\u2274",
        NotNestedGreaterGreater: "\u2AA2\u0338",
        NotNestedLessLess: "\u2AA1\u0338",
        notni: "\u220C",
        notniva: "\u220C",
        notnivb: "\u22FE",
        notnivc: "\u22FD",
        NotPrecedes: "\u2280",
        NotPrecedesEqual: "\u2AAF\u0338",
        NotPrecedesSlantEqual: "\u22E0",
        NotReverseElement: "\u220C",
        NotRightTriangle: "\u22EB",
        NotRightTriangleBar: "\u29D0\u0338",
        NotRightTriangleEqual: "\u22ED",
        NotSquareSubset: "\u228F\u0338",
        NotSquareSubsetEqual: "\u22E2",
        NotSquareSuperset: "\u2290\u0338",
        NotSquareSupersetEqual: "\u22E3",
        NotSubset: "\u2282\u20D2",
        NotSubsetEqual: "\u2288",
        NotSucceeds: "\u2281",
        NotSucceedsEqual: "\u2AB0\u0338",
        NotSucceedsSlantEqual: "\u22E1",
        NotSucceedsTilde: "\u227F\u0338",
        NotSuperset: "\u2283\u20D2",
        NotSupersetEqual: "\u2289",
        NotTilde: "\u2241",
        NotTildeEqual: "\u2244",
        NotTildeFullEqual: "\u2247",
        NotTildeTilde: "\u2249",
        NotVerticalBar: "\u2224",
        npar: "\u2226",
        nparallel: "\u2226",
        nparsl: "\u2AFD\u20E5",
        npart: "\u2202\u0338",
        npolint: "\u2A14",
        npr: "\u2280",
        nprcue: "\u22E0",
        npre: "\u2AAF\u0338",
        nprec: "\u2280",
        npreceq: "\u2AAF\u0338",
        nrArr: "\u21CF",
        nrarr: "\u219B",
        nrarrc: "\u2933\u0338",
        nrarrw: "\u219D\u0338",
        nRightarrow: "\u21CF",
        nrightarrow: "\u219B",
        nrtri: "\u22EB",
        nrtrie: "\u22ED",
        nsc: "\u2281",
        nsccue: "\u22E1",
        nsce: "\u2AB0\u0338",
        Nscr: "\u{1D4A9}",
        nscr: "\u{1D4C3}",
        nshortmid: "\u2224",
        nshortparallel: "\u2226",
        nsim: "\u2241",
        nsime: "\u2244",
        nsimeq: "\u2244",
        nsmid: "\u2224",
        nspar: "\u2226",
        nsqsube: "\u22E2",
        nsqsupe: "\u22E3",
        nsub: "\u2284",
        nsubE: "\u2AC5\u0338",
        nsube: "\u2288",
        nsubset: "\u2282\u20D2",
        nsubseteq: "\u2288",
        nsubseteqq: "\u2AC5\u0338",
        nsucc: "\u2281",
        nsucceq: "\u2AB0\u0338",
        nsup: "\u2285",
        nsupE: "\u2AC6\u0338",
        nsupe: "\u2289",
        nsupset: "\u2283\u20D2",
        nsupseteq: "\u2289",
        nsupseteqq: "\u2AC6\u0338",
        ntgl: "\u2279",
        Ntilde: "\xD1",
        ntilde: "\xF1",
        ntlg: "\u2278",
        ntriangleleft: "\u22EA",
        ntrianglelefteq: "\u22EC",
        ntriangleright: "\u22EB",
        ntrianglerighteq: "\u22ED",
        Nu: "\u039D",
        nu: "\u03BD",
        num: "#",
        numero: "\u2116",
        numsp: "\u2007",
        nvap: "\u224D\u20D2",
        nVDash: "\u22AF",
        nVdash: "\u22AE",
        nvDash: "\u22AD",
        nvdash: "\u22AC",
        nvge: "\u2265\u20D2",
        nvgt: ">\u20D2",
        nvHarr: "\u2904",
        nvinfin: "\u29DE",
        nvlArr: "\u2902",
        nvle: "\u2264\u20D2",
        nvlt: "<\u20D2",
        nvltrie: "\u22B4\u20D2",
        nvrArr: "\u2903",
        nvrtrie: "\u22B5\u20D2",
        nvsim: "\u223C\u20D2",
        nwarhk: "\u2923",
        nwArr: "\u21D6",
        nwarr: "\u2196",
        nwarrow: "\u2196",
        nwnear: "\u2927",
        Oacute: "\xD3",
        oacute: "\xF3",
        oast: "\u229B",
        ocir: "\u229A",
        Ocirc: "\xD4",
        ocirc: "\xF4",
        Ocy: "\u041E",
        ocy: "\u043E",
        odash: "\u229D",
        Odblac: "\u0150",
        odblac: "\u0151",
        odiv: "\u2A38",
        odot: "\u2299",
        odsold: "\u29BC",
        OElig: "\u0152",
        oelig: "\u0153",
        ofcir: "\u29BF",
        Ofr: "\u{1D512}",
        ofr: "\u{1D52C}",
        ogon: "\u02DB",
        Ograve: "\xD2",
        ograve: "\xF2",
        ogt: "\u29C1",
        ohbar: "\u29B5",
        ohm: "\u03A9",
        oint: "\u222E",
        olarr: "\u21BA",
        olcir: "\u29BE",
        olcross: "\u29BB",
        oline: "\u203E",
        olt: "\u29C0",
        Omacr: "\u014C",
        omacr: "\u014D",
        Omega: "\u03A9",
        omega: "\u03C9",
        Omicron: "\u039F",
        omicron: "\u03BF",
        omid: "\u29B6",
        ominus: "\u2296",
        Oopf: "\u{1D546}",
        oopf: "\u{1D560}",
        opar: "\u29B7",
        OpenCurlyDoubleQuote: "\u201C",
        OpenCurlyQuote: "\u2018",
        operp: "\u29B9",
        oplus: "\u2295",
        Or: "\u2A54",
        or: "\u2228",
        orarr: "\u21BB",
        ord: "\u2A5D",
        order: "\u2134",
        orderof: "\u2134",
        ordf: "\xAA",
        ordm: "\xBA",
        origof: "\u22B6",
        oror: "\u2A56",
        orslope: "\u2A57",
        orv: "\u2A5B",
        oS: "\u24C8",
        Oscr: "\u{1D4AA}",
        oscr: "\u2134",
        Oslash: "\xD8",
        oslash: "\xF8",
        osol: "\u2298",
        Otilde: "\xD5",
        otilde: "\xF5",
        Otimes: "\u2A37",
        otimes: "\u2297",
        otimesas: "\u2A36",
        Ouml: "\xD6",
        ouml: "\xF6",
        ovbar: "\u233D",
        OverBar: "\u203E",
        OverBrace: "\u23DE",
        OverBracket: "\u23B4",
        OverParenthesis: "\u23DC",
        par: "\u2225",
        para: "\xB6",
        parallel: "\u2225",
        parsim: "\u2AF3",
        parsl: "\u2AFD",
        part: "\u2202",
        PartialD: "\u2202",
        Pcy: "\u041F",
        pcy: "\u043F",
        percnt: "%",
        period: ".",
        permil: "\u2030",
        perp: "\u22A5",
        pertenk: "\u2031",
        Pfr: "\u{1D513}",
        pfr: "\u{1D52D}",
        Phi: "\u03A6",
        phi: "\u03C6",
        phiv: "\u03D5",
        phmmat: "\u2133",
        phone: "\u260E",
        Pi: "\u03A0",
        pi: "\u03C0",
        pitchfork: "\u22D4",
        piv: "\u03D6",
        planck: "\u210F",
        planckh: "\u210E",
        plankv: "\u210F",
        plus: "+",
        plusacir: "\u2A23",
        plusb: "\u229E",
        pluscir: "\u2A22",
        plusdo: "\u2214",
        plusdu: "\u2A25",
        pluse: "\u2A72",
        PlusMinus: "\xB1",
        plusmn: "\xB1",
        plussim: "\u2A26",
        plustwo: "\u2A27",
        pm: "\xB1",
        Poincareplane: "\u210C",
        pointint: "\u2A15",
        Popf: "\u2119",
        popf: "\u{1D561}",
        pound: "\xA3",
        Pr: "\u2ABB",
        pr: "\u227A",
        prap: "\u2AB7",
        prcue: "\u227C",
        prE: "\u2AB3",
        pre: "\u2AAF",
        prec: "\u227A",
        precapprox: "\u2AB7",
        preccurlyeq: "\u227C",
        Precedes: "\u227A",
        PrecedesEqual: "\u2AAF",
        PrecedesSlantEqual: "\u227C",
        PrecedesTilde: "\u227E",
        preceq: "\u2AAF",
        precnapprox: "\u2AB9",
        precneqq: "\u2AB5",
        precnsim: "\u22E8",
        precsim: "\u227E",
        Prime: "\u2033",
        prime: "\u2032",
        primes: "\u2119",
        prnap: "\u2AB9",
        prnE: "\u2AB5",
        prnsim: "\u22E8",
        prod: "\u220F",
        Product: "\u220F",
        profalar: "\u232E",
        profline: "\u2312",
        profsurf: "\u2313",
        prop: "\u221D",
        Proportion: "\u2237",
        Proportional: "\u221D",
        propto: "\u221D",
        prsim: "\u227E",
        prurel: "\u22B0",
        Pscr: "\u{1D4AB}",
        pscr: "\u{1D4C5}",
        Psi: "\u03A8",
        psi: "\u03C8",
        puncsp: "\u2008",
        Qfr: "\u{1D514}",
        qfr: "\u{1D52E}",
        qint: "\u2A0C",
        Qopf: "\u211A",
        qopf: "\u{1D562}",
        qprime: "\u2057",
        Qscr: "\u{1D4AC}",
        qscr: "\u{1D4C6}",
        quaternions: "\u210D",
        quatint: "\u2A16",
        quest: "?",
        questeq: "\u225F",
        QUOT: '"',
        quot: '"',
        rAarr: "\u21DB",
        race: "\u223D\u0331",
        Racute: "\u0154",
        racute: "\u0155",
        radic: "\u221A",
        raemptyv: "\u29B3",
        Rang: "\u27EB",
        rang: "\u27E9",
        rangd: "\u2992",
        range: "\u29A5",
        rangle: "\u27E9",
        raquo: "\xBB",
        Rarr: "\u21A0",
        rArr: "\u21D2",
        rarr: "\u2192",
        rarrap: "\u2975",
        rarrb: "\u21E5",
        rarrbfs: "\u2920",
        rarrc: "\u2933",
        rarrfs: "\u291E",
        rarrhk: "\u21AA",
        rarrlp: "\u21AC",
        rarrpl: "\u2945",
        rarrsim: "\u2974",
        Rarrtl: "\u2916",
        rarrtl: "\u21A3",
        rarrw: "\u219D",
        rAtail: "\u291C",
        ratail: "\u291A",
        ratio: "\u2236",
        rationals: "\u211A",
        RBarr: "\u2910",
        rBarr: "\u290F",
        rbarr: "\u290D",
        rbbrk: "\u2773",
        rbrace: "}",
        rbrack: "]",
        rbrke: "\u298C",
        rbrksld: "\u298E",
        rbrkslu: "\u2990",
        Rcaron: "\u0158",
        rcaron: "\u0159",
        Rcedil: "\u0156",
        rcedil: "\u0157",
        rceil: "\u2309",
        rcub: "}",
        Rcy: "\u0420",
        rcy: "\u0440",
        rdca: "\u2937",
        rdldhar: "\u2969",
        rdquo: "\u201D",
        rdquor: "\u201D",
        rdsh: "\u21B3",
        Re: "\u211C",
        real: "\u211C",
        realine: "\u211B",
        realpart: "\u211C",
        reals: "\u211D",
        rect: "\u25AD",
        REG: "\xAE",
        reg: "\xAE",
        ReverseElement: "\u220B",
        ReverseEquilibrium: "\u21CB",
        ReverseUpEquilibrium: "\u296F",
        rfisht: "\u297D",
        rfloor: "\u230B",
        Rfr: "\u211C",
        rfr: "\u{1D52F}",
        rHar: "\u2964",
        rhard: "\u21C1",
        rharu: "\u21C0",
        rharul: "\u296C",
        Rho: "\u03A1",
        rho: "\u03C1",
        rhov: "\u03F1",
        RightAngleBracket: "\u27E9",
        RightArrow: "\u2192",
        Rightarrow: "\u21D2",
        rightarrow: "\u2192",
        RightArrowBar: "\u21E5",
        RightArrowLeftArrow: "\u21C4",
        rightarrowtail: "\u21A3",
        RightCeiling: "\u2309",
        RightDoubleBracket: "\u27E7",
        RightDownTeeVector: "\u295D",
        RightDownVector: "\u21C2",
        RightDownVectorBar: "\u2955",
        RightFloor: "\u230B",
        rightharpoondown: "\u21C1",
        rightharpoonup: "\u21C0",
        rightleftarrows: "\u21C4",
        rightleftharpoons: "\u21CC",
        rightrightarrows: "\u21C9",
        rightsquigarrow: "\u219D",
        RightTee: "\u22A2",
        RightTeeArrow: "\u21A6",
        RightTeeVector: "\u295B",
        rightthreetimes: "\u22CC",
        RightTriangle: "\u22B3",
        RightTriangleBar: "\u29D0",
        RightTriangleEqual: "\u22B5",
        RightUpDownVector: "\u294F",
        RightUpTeeVector: "\u295C",
        RightUpVector: "\u21BE",
        RightUpVectorBar: "\u2954",
        RightVector: "\u21C0",
        RightVectorBar: "\u2953",
        ring: "\u02DA",
        risingdotseq: "\u2253",
        rlarr: "\u21C4",
        rlhar: "\u21CC",
        rlm: "\u200F",
        rmoust: "\u23B1",
        rmoustache: "\u23B1",
        rnmid: "\u2AEE",
        roang: "\u27ED",
        roarr: "\u21FE",
        robrk: "\u27E7",
        ropar: "\u2986",
        Ropf: "\u211D",
        ropf: "\u{1D563}",
        roplus: "\u2A2E",
        rotimes: "\u2A35",
        RoundImplies: "\u2970",
        rpar: ")",
        rpargt: "\u2994",
        rppolint: "\u2A12",
        rrarr: "\u21C9",
        Rrightarrow: "\u21DB",
        rsaquo: "\u203A",
        Rscr: "\u211B",
        rscr: "\u{1D4C7}",
        Rsh: "\u21B1",
        rsh: "\u21B1",
        rsqb: "]",
        rsquo: "\u2019",
        rsquor: "\u2019",
        rthree: "\u22CC",
        rtimes: "\u22CA",
        rtri: "\u25B9",
        rtrie: "\u22B5",
        rtrif: "\u25B8",
        rtriltri: "\u29CE",
        RuleDelayed: "\u29F4",
        ruluhar: "\u2968",
        rx: "\u211E",
        Sacute: "\u015A",
        sacute: "\u015B",
        sbquo: "\u201A",
        Sc: "\u2ABC",
        sc: "\u227B",
        scap: "\u2AB8",
        Scaron: "\u0160",
        scaron: "\u0161",
        sccue: "\u227D",
        scE: "\u2AB4",
        sce: "\u2AB0",
        Scedil: "\u015E",
        scedil: "\u015F",
        Scirc: "\u015C",
        scirc: "\u015D",
        scnap: "\u2ABA",
        scnE: "\u2AB6",
        scnsim: "\u22E9",
        scpolint: "\u2A13",
        scsim: "\u227F",
        Scy: "\u0421",
        scy: "\u0441",
        sdot: "\u22C5",
        sdotb: "\u22A1",
        sdote: "\u2A66",
        searhk: "\u2925",
        seArr: "\u21D8",
        searr: "\u2198",
        searrow: "\u2198",
        sect: "\xA7",
        semi: ";",
        seswar: "\u2929",
        setminus: "\u2216",
        setmn: "\u2216",
        sext: "\u2736",
        Sfr: "\u{1D516}",
        sfr: "\u{1D530}",
        sfrown: "\u2322",
        sharp: "\u266F",
        SHCHcy: "\u0429",
        shchcy: "\u0449",
        SHcy: "\u0428",
        shcy: "\u0448",
        ShortDownArrow: "\u2193",
        ShortLeftArrow: "\u2190",
        shortmid: "\u2223",
        shortparallel: "\u2225",
        ShortRightArrow: "\u2192",
        ShortUpArrow: "\u2191",
        shy: "\xAD",
        Sigma: "\u03A3",
        sigma: "\u03C3",
        sigmaf: "\u03C2",
        sigmav: "\u03C2",
        sim: "\u223C",
        simdot: "\u2A6A",
        sime: "\u2243",
        simeq: "\u2243",
        simg: "\u2A9E",
        simgE: "\u2AA0",
        siml: "\u2A9D",
        simlE: "\u2A9F",
        simne: "\u2246",
        simplus: "\u2A24",
        simrarr: "\u2972",
        slarr: "\u2190",
        SmallCircle: "\u2218",
        smallsetminus: "\u2216",
        smashp: "\u2A33",
        smeparsl: "\u29E4",
        smid: "\u2223",
        smile: "\u2323",
        smt: "\u2AAA",
        smte: "\u2AAC",
        smtes: "\u2AAC\uFE00",
        SOFTcy: "\u042C",
        softcy: "\u044C",
        sol: "/",
        solb: "\u29C4",
        solbar: "\u233F",
        Sopf: "\u{1D54A}",
        sopf: "\u{1D564}",
        spades: "\u2660",
        spadesuit: "\u2660",
        spar: "\u2225",
        sqcap: "\u2293",
        sqcaps: "\u2293\uFE00",
        sqcup: "\u2294",
        sqcups: "\u2294\uFE00",
        Sqrt: "\u221A",
        sqsub: "\u228F",
        sqsube: "\u2291",
        sqsubset: "\u228F",
        sqsubseteq: "\u2291",
        sqsup: "\u2290",
        sqsupe: "\u2292",
        sqsupset: "\u2290",
        sqsupseteq: "\u2292",
        squ: "\u25A1",
        Square: "\u25A1",
        square: "\u25A1",
        SquareIntersection: "\u2293",
        SquareSubset: "\u228F",
        SquareSubsetEqual: "\u2291",
        SquareSuperset: "\u2290",
        SquareSupersetEqual: "\u2292",
        SquareUnion: "\u2294",
        squarf: "\u25AA",
        squf: "\u25AA",
        srarr: "\u2192",
        Sscr: "\u{1D4AE}",
        sscr: "\u{1D4C8}",
        ssetmn: "\u2216",
        ssmile: "\u2323",
        sstarf: "\u22C6",
        Star: "\u22C6",
        star: "\u2606",
        starf: "\u2605",
        straightepsilon: "\u03F5",
        straightphi: "\u03D5",
        strns: "\xAF",
        Sub: "\u22D0",
        sub: "\u2282",
        subdot: "\u2ABD",
        subE: "\u2AC5",
        sube: "\u2286",
        subedot: "\u2AC3",
        submult: "\u2AC1",
        subnE: "\u2ACB",
        subne: "\u228A",
        subplus: "\u2ABF",
        subrarr: "\u2979",
        Subset: "\u22D0",
        subset: "\u2282",
        subseteq: "\u2286",
        subseteqq: "\u2AC5",
        SubsetEqual: "\u2286",
        subsetneq: "\u228A",
        subsetneqq: "\u2ACB",
        subsim: "\u2AC7",
        subsub: "\u2AD5",
        subsup: "\u2AD3",
        succ: "\u227B",
        succapprox: "\u2AB8",
        succcurlyeq: "\u227D",
        Succeeds: "\u227B",
        SucceedsEqual: "\u2AB0",
        SucceedsSlantEqual: "\u227D",
        SucceedsTilde: "\u227F",
        succeq: "\u2AB0",
        succnapprox: "\u2ABA",
        succneqq: "\u2AB6",
        succnsim: "\u22E9",
        succsim: "\u227F",
        SuchThat: "\u220B",
        Sum: "\u2211",
        sum: "\u2211",
        sung: "\u266A",
        Sup: "\u22D1",
        sup: "\u2283",
        sup1: "\xB9",
        sup2: "\xB2",
        sup3: "\xB3",
        supdot: "\u2ABE",
        supdsub: "\u2AD8",
        supE: "\u2AC6",
        supe: "\u2287",
        supedot: "\u2AC4",
        Superset: "\u2283",
        SupersetEqual: "\u2287",
        suphsol: "\u27C9",
        suphsub: "\u2AD7",
        suplarr: "\u297B",
        supmult: "\u2AC2",
        supnE: "\u2ACC",
        supne: "\u228B",
        supplus: "\u2AC0",
        Supset: "\u22D1",
        supset: "\u2283",
        supseteq: "\u2287",
        supseteqq: "\u2AC6",
        supsetneq: "\u228B",
        supsetneqq: "\u2ACC",
        supsim: "\u2AC8",
        supsub: "\u2AD4",
        supsup: "\u2AD6",
        swarhk: "\u2926",
        swArr: "\u21D9",
        swarr: "\u2199",
        swarrow: "\u2199",
        swnwar: "\u292A",
        szlig: "\xDF",
        Tab: "	",
        target: "\u2316",
        Tau: "\u03A4",
        tau: "\u03C4",
        tbrk: "\u23B4",
        Tcaron: "\u0164",
        tcaron: "\u0165",
        Tcedil: "\u0162",
        tcedil: "\u0163",
        Tcy: "\u0422",
        tcy: "\u0442",
        tdot: "\u20DB",
        telrec: "\u2315",
        Tfr: "\u{1D517}",
        tfr: "\u{1D531}",
        there4: "\u2234",
        Therefore: "\u2234",
        therefore: "\u2234",
        Theta: "\u0398",
        theta: "\u03B8",
        thetasym: "\u03D1",
        thetav: "\u03D1",
        thickapprox: "\u2248",
        thicksim: "\u223C",
        ThickSpace: "\u205F\u200A",
        thinsp: "\u2009",
        ThinSpace: "\u2009",
        thkap: "\u2248",
        thksim: "\u223C",
        THORN: "\xDE",
        thorn: "\xFE",
        Tilde: "\u223C",
        tilde: "\u02DC",
        TildeEqual: "\u2243",
        TildeFullEqual: "\u2245",
        TildeTilde: "\u2248",
        times: "\xD7",
        timesb: "\u22A0",
        timesbar: "\u2A31",
        timesd: "\u2A30",
        tint: "\u222D",
        toea: "\u2928",
        top: "\u22A4",
        topbot: "\u2336",
        topcir: "\u2AF1",
        Topf: "\u{1D54B}",
        topf: "\u{1D565}",
        topfork: "\u2ADA",
        tosa: "\u2929",
        tprime: "\u2034",
        TRADE: "\u2122",
        trade: "\u2122",
        triangle: "\u25B5",
        triangledown: "\u25BF",
        triangleleft: "\u25C3",
        trianglelefteq: "\u22B4",
        triangleq: "\u225C",
        triangleright: "\u25B9",
        trianglerighteq: "\u22B5",
        tridot: "\u25EC",
        trie: "\u225C",
        triminus: "\u2A3A",
        TripleDot: "\u20DB",
        triplus: "\u2A39",
        trisb: "\u29CD",
        tritime: "\u2A3B",
        trpezium: "\u23E2",
        Tscr: "\u{1D4AF}",
        tscr: "\u{1D4C9}",
        TScy: "\u0426",
        tscy: "\u0446",
        TSHcy: "\u040B",
        tshcy: "\u045B",
        Tstrok: "\u0166",
        tstrok: "\u0167",
        twixt: "\u226C",
        twoheadleftarrow: "\u219E",
        twoheadrightarrow: "\u21A0",
        Uacute: "\xDA",
        uacute: "\xFA",
        Uarr: "\u219F",
        uArr: "\u21D1",
        uarr: "\u2191",
        Uarrocir: "\u2949",
        Ubrcy: "\u040E",
        ubrcy: "\u045E",
        Ubreve: "\u016C",
        ubreve: "\u016D",
        Ucirc: "\xDB",
        ucirc: "\xFB",
        Ucy: "\u0423",
        ucy: "\u0443",
        udarr: "\u21C5",
        Udblac: "\u0170",
        udblac: "\u0171",
        udhar: "\u296E",
        ufisht: "\u297E",
        Ufr: "\u{1D518}",
        ufr: "\u{1D532}",
        Ugrave: "\xD9",
        ugrave: "\xF9",
        uHar: "\u2963",
        uharl: "\u21BF",
        uharr: "\u21BE",
        uhblk: "\u2580",
        ulcorn: "\u231C",
        ulcorner: "\u231C",
        ulcrop: "\u230F",
        ultri: "\u25F8",
        Umacr: "\u016A",
        umacr: "\u016B",
        uml: "\xA8",
        UnderBar: "_",
        UnderBrace: "\u23DF",
        UnderBracket: "\u23B5",
        UnderParenthesis: "\u23DD",
        Union: "\u22C3",
        UnionPlus: "\u228E",
        Uogon: "\u0172",
        uogon: "\u0173",
        Uopf: "\u{1D54C}",
        uopf: "\u{1D566}",
        UpArrow: "\u2191",
        Uparrow: "\u21D1",
        uparrow: "\u2191",
        UpArrowBar: "\u2912",
        UpArrowDownArrow: "\u21C5",
        UpDownArrow: "\u2195",
        Updownarrow: "\u21D5",
        updownarrow: "\u2195",
        UpEquilibrium: "\u296E",
        upharpoonleft: "\u21BF",
        upharpoonright: "\u21BE",
        uplus: "\u228E",
        UpperLeftArrow: "\u2196",
        UpperRightArrow: "\u2197",
        Upsi: "\u03D2",
        upsi: "\u03C5",
        upsih: "\u03D2",
        Upsilon: "\u03A5",
        upsilon: "\u03C5",
        UpTee: "\u22A5",
        UpTeeArrow: "\u21A5",
        upuparrows: "\u21C8",
        urcorn: "\u231D",
        urcorner: "\u231D",
        urcrop: "\u230E",
        Uring: "\u016E",
        uring: "\u016F",
        urtri: "\u25F9",
        Uscr: "\u{1D4B0}",
        uscr: "\u{1D4CA}",
        utdot: "\u22F0",
        Utilde: "\u0168",
        utilde: "\u0169",
        utri: "\u25B5",
        utrif: "\u25B4",
        uuarr: "\u21C8",
        Uuml: "\xDC",
        uuml: "\xFC",
        uwangle: "\u29A7",
        vangrt: "\u299C",
        varepsilon: "\u03F5",
        varkappa: "\u03F0",
        varnothing: "\u2205",
        varphi: "\u03D5",
        varpi: "\u03D6",
        varpropto: "\u221D",
        vArr: "\u21D5",
        varr: "\u2195",
        varrho: "\u03F1",
        varsigma: "\u03C2",
        varsubsetneq: "\u228A\uFE00",
        varsubsetneqq: "\u2ACB\uFE00",
        varsupsetneq: "\u228B\uFE00",
        varsupsetneqq: "\u2ACC\uFE00",
        vartheta: "\u03D1",
        vartriangleleft: "\u22B2",
        vartriangleright: "\u22B3",
        Vbar: "\u2AEB",
        vBar: "\u2AE8",
        vBarv: "\u2AE9",
        Vcy: "\u0412",
        vcy: "\u0432",
        VDash: "\u22AB",
        Vdash: "\u22A9",
        vDash: "\u22A8",
        vdash: "\u22A2",
        Vdashl: "\u2AE6",
        Vee: "\u22C1",
        vee: "\u2228",
        veebar: "\u22BB",
        veeeq: "\u225A",
        vellip: "\u22EE",
        Verbar: "\u2016",
        verbar: "|",
        Vert: "\u2016",
        vert: "|",
        VerticalBar: "\u2223",
        VerticalLine: "|",
        VerticalSeparator: "\u2758",
        VerticalTilde: "\u2240",
        VeryThinSpace: "\u200A",
        Vfr: "\u{1D519}",
        vfr: "\u{1D533}",
        vltri: "\u22B2",
        vnsub: "\u2282\u20D2",
        vnsup: "\u2283\u20D2",
        Vopf: "\u{1D54D}",
        vopf: "\u{1D567}",
        vprop: "\u221D",
        vrtri: "\u22B3",
        Vscr: "\u{1D4B1}",
        vscr: "\u{1D4CB}",
        vsubnE: "\u2ACB\uFE00",
        vsubne: "\u228A\uFE00",
        vsupnE: "\u2ACC\uFE00",
        vsupne: "\u228B\uFE00",
        Vvdash: "\u22AA",
        vzigzag: "\u299A",
        Wcirc: "\u0174",
        wcirc: "\u0175",
        wedbar: "\u2A5F",
        Wedge: "\u22C0",
        wedge: "\u2227",
        wedgeq: "\u2259",
        weierp: "\u2118",
        Wfr: "\u{1D51A}",
        wfr: "\u{1D534}",
        Wopf: "\u{1D54E}",
        wopf: "\u{1D568}",
        wp: "\u2118",
        wr: "\u2240",
        wreath: "\u2240",
        Wscr: "\u{1D4B2}",
        wscr: "\u{1D4CC}",
        xcap: "\u22C2",
        xcirc: "\u25EF",
        xcup: "\u22C3",
        xdtri: "\u25BD",
        Xfr: "\u{1D51B}",
        xfr: "\u{1D535}",
        xhArr: "\u27FA",
        xharr: "\u27F7",
        Xi: "\u039E",
        xi: "\u03BE",
        xlArr: "\u27F8",
        xlarr: "\u27F5",
        xmap: "\u27FC",
        xnis: "\u22FB",
        xodot: "\u2A00",
        Xopf: "\u{1D54F}",
        xopf: "\u{1D569}",
        xoplus: "\u2A01",
        xotime: "\u2A02",
        xrArr: "\u27F9",
        xrarr: "\u27F6",
        Xscr: "\u{1D4B3}",
        xscr: "\u{1D4CD}",
        xsqcup: "\u2A06",
        xuplus: "\u2A04",
        xutri: "\u25B3",
        xvee: "\u22C1",
        xwedge: "\u22C0",
        Yacute: "\xDD",
        yacute: "\xFD",
        YAcy: "\u042F",
        yacy: "\u044F",
        Ycirc: "\u0176",
        ycirc: "\u0177",
        Ycy: "\u042B",
        ycy: "\u044B",
        yen: "\xA5",
        Yfr: "\u{1D51C}",
        yfr: "\u{1D536}",
        YIcy: "\u0407",
        yicy: "\u0457",
        Yopf: "\u{1D550}",
        yopf: "\u{1D56A}",
        Yscr: "\u{1D4B4}",
        yscr: "\u{1D4CE}",
        YUcy: "\u042E",
        yucy: "\u044E",
        Yuml: "\u0178",
        yuml: "\xFF",
        Zacute: "\u0179",
        zacute: "\u017A",
        Zcaron: "\u017D",
        zcaron: "\u017E",
        Zcy: "\u0417",
        zcy: "\u0437",
        Zdot: "\u017B",
        zdot: "\u017C",
        zeetrf: "\u2128",
        ZeroWidthSpace: "\u200B",
        Zeta: "\u0396",
        zeta: "\u03B6",
        Zfr: "\u2128",
        zfr: "\u{1D537}",
        ZHcy: "\u0416",
        zhcy: "\u0436",
        zigrarr: "\u21DD",
        Zopf: "\u2124",
        zopf: "\u{1D56B}",
        Zscr: "\u{1D4B5}",
        zscr: "\u{1D4CF}",
        zwj: "\u200D",
        zwnj: "\u200C"
      }), i.entityMap = i.HTML_ENTITIES;
    }(eo)), eo;
  }
  var ln = {}, du;
  function tw() {
    if (du) return ln;
    du = 1;
    var i = es().NAMESPACE, t = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, e = new RegExp("[\\-\\.0-9" + t.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]"), r = new RegExp("^" + t.source + e.source + "*(?::" + t.source + e.source + "*)?$"), n = 0, s = 1, o = 2, a = 3, c = 4, u = 5, l = 6, h = 7;
    function f(C, I) {
      this.message = C, this.locator = I, Error.captureStackTrace && Error.captureStackTrace(this, f);
    }
    f.prototype = new Error(), f.prototype.name = f.name;
    function p() {
    }
    p.prototype = {
      parse: function(C, I, z) {
        var Z = this.domBuilder;
        Z.startDocument(), G(I, I = {}), m(C, I, z, Z, this.errorHandler), Z.endDocument();
      }
    };
    function m(C, I, z, Z, j) {
      function X(Pt) {
        if (Pt > 65535) {
          Pt -= 65536;
          var ee = 55296 + (Pt >> 10), Ee = 56320 + (Pt & 1023);
          return String.fromCharCode(ee, Ee);
        } else return String.fromCharCode(Pt);
      }
      function Q(Pt) {
        var ee = Pt.slice(1, -1);
        return Object.hasOwnProperty.call(z, ee) ? z[ee] : ee.charAt(0) === "#" ? X(parseInt(ee.substr(1).replace("x", "0x"))) : (j.error("entity not found:" + Pt), Pt);
      }
      function x(Pt) {
        if (Pt > V) {
          var ee = C.substring(V, Pt).replace(/&#?\w+;/g, Q);
          N && R(V), Z.characters(ee, 0, Pt - V), V = Pt;
        }
      }
      function R(Pt, ee) {
        for (; Pt >= B && (ee = D.exec(C)); ) S = ee.index, B = S + ee[0].length, N.lineNumber++;
        N.columnNumber = Pt - S + 1;
      }
      for (var S = 0, B = 0, D = /.*(?:\r\n?|\n)|.*$/g, N = Z.locator, O = [
        {
          currentNSMap: I
        }
      ], q = {}, V = 0; ; ) {
        try {
          var $ = C.indexOf("<", V);
          if ($ < 0) {
            if (!C.substr(V).match(/^\s*$/)) {
              var ft = Z.doc, pt = ft.createTextNode(C.substr(V));
              ft.appendChild(pt), Z.currentElement = pt;
            }
            return;
          }
          switch ($ > V && x($), C.charAt($ + 1)) {
            case "/":
              var tt = C.indexOf(">", $ + 3), it = C.substring($ + 2, tt).replace(/[ \t\n\r]+$/g, ""), gt = O.pop();
              tt < 0 ? (it = C.substring($ + 2).replace(/[\s<].*/, ""), j.error("end tag name: " + it + " is not complete:" + gt.tagName), tt = $ + 1 + it.length) : it.match(/\s</) && (it = it.replace(/[\s<].*/, ""), j.error("end tag name: " + it + " maybe not complete"), tt = $ + 1 + it.length);
              var _t = gt.localNSMap, ne = gt.tagName == it, te = ne || gt.tagName && gt.tagName.toLowerCase() == it.toLowerCase();
              if (te) {
                if (Z.endElement(gt.uri, gt.localName, it), _t) for (var ht in _t) Object.prototype.hasOwnProperty.call(_t, ht) && Z.endPrefixMapping(ht);
                ne || j.fatalError("end tag name: " + it + " is not match the current start tagName:" + gt.tagName);
              } else O.push(gt);
              tt++;
              break;
            case "?":
              N && R($), tt = Y(C, $, Z);
              break;
            case "!":
              N && R($), tt = H(C, $, Z, j);
              break;
            default:
              N && R($);
              var Ut = new L(), st = O[O.length - 1].currentNSMap, tt = b(C, $, Ut, st, Q, j), be = Ut.length;
              if (!Ut.closed && T(C, tt, Ut.tagName, q) && (Ut.closed = true, z.nbsp || j.warning("unclosed xml attribute")), N && be) {
                for (var we = y(N, {}), He = 0; He < be; He++) {
                  var ir = Ut[He];
                  R(ir.offset), ir.locator = y(N, {});
                }
                Z.locator = we, v(Ut, Z, st) && O.push(Ut), Z.locator = N;
              } else v(Ut, Z, st) && O.push(Ut);
              i.isHTML(Ut.uri) && !Ut.closed ? tt = A(C, tt, Ut.tagName, Q, Z) : tt++;
          }
        } catch (Pt) {
          if (Pt instanceof f) throw Pt;
          j.error("element parse error: " + Pt), tt = -1;
        }
        tt > V ? V = tt : x(Math.max($, V) + 1);
      }
    }
    function y(C, I) {
      return I.lineNumber = C.lineNumber, I.columnNumber = C.columnNumber, I;
    }
    function b(C, I, z, Z, j, X) {
      function Q(O, q, V) {
        z.attributeNames.hasOwnProperty(O) && X.fatalError("Attribute " + O + " redefined"), z.addValue(O, q.replace(/[\t\n\r]/g, " ").replace(/&#?\w+;/g, j), V);
      }
      for (var x, R, S = ++I, B = n; ; ) {
        var D = C.charAt(S);
        switch (D) {
          case "=":
            if (B === s) x = C.slice(I, S), B = a;
            else if (B === o) B = a;
            else throw new Error("attribute equal must after attrName");
            break;
          case "'":
          case '"':
            if (B === a || B === s) if (B === s && (X.warning('attribute value must after "="'), x = C.slice(I, S)), I = S + 1, S = C.indexOf(D, I), S > 0) R = C.slice(I, S), Q(x, R, I - 1), B = u;
            else throw new Error("attribute value no end '" + D + "' match");
            else if (B == c) R = C.slice(I, S), Q(x, R, I), X.warning('attribute "' + x + '" missed start quot(' + D + ")!!"), I = S + 1, B = u;
            else throw new Error('attribute value must after "="');
            break;
          case "/":
            switch (B) {
              case n:
                z.setTagName(C.slice(I, S));
              case u:
              case l:
              case h:
                B = h, z.closed = true;
              case c:
              case s:
                break;
              case o:
                z.closed = true;
                break;
              default:
                throw new Error("attribute invalid close char('/')");
            }
            break;
          case "":
            return X.error("unexpected end of input"), B == n && z.setTagName(C.slice(I, S)), S;
          case ">":
            switch (B) {
              case n:
                z.setTagName(C.slice(I, S));
              case u:
              case l:
              case h:
                break;
              case c:
              case s:
                R = C.slice(I, S), R.slice(-1) === "/" && (z.closed = true, R = R.slice(0, -1));
              case o:
                B === o && (R = x), B == c ? (X.warning('attribute "' + R + '" missed quot(")!'), Q(x, R, I)) : ((!i.isHTML(Z[""]) || !R.match(/^(?:disabled|checked|selected)$/i)) && X.warning('attribute "' + R + '" missed value!! "' + R + '" instead!!'), Q(R, R, I));
                break;
              case a:
                throw new Error("attribute value missed!!");
            }
            return S;
          case "\x80":
            D = " ";
          default:
            if (D <= " ") switch (B) {
              case n:
                z.setTagName(C.slice(I, S)), B = l;
                break;
              case s:
                x = C.slice(I, S), B = o;
                break;
              case c:
                var R = C.slice(I, S);
                X.warning('attribute "' + R + '" missed quot(")!!'), Q(x, R, I);
              case u:
                B = l;
                break;
            }
            else switch (B) {
              case o:
                var N = z.tagName;
                (!i.isHTML(Z[""]) || !x.match(/^(?:disabled|checked|selected)$/i)) && X.warning('attribute "' + x + '" missed value!! "' + x + '" instead2!!'), Q(x, x, I), I = S, B = s;
                break;
              case u:
                X.warning('attribute space is required"' + x + '"!!');
              case l:
                B = s, I = S;
                break;
              case a:
                B = c, I = S;
                break;
              case h:
                throw new Error("elements closed character '/' and '>' must be connected to");
            }
        }
        S++;
      }
    }
    function v(C, I, z) {
      for (var Z = C.tagName, j = null, D = C.length; D--; ) {
        var X = C[D], Q = X.qName, x = X.value, N = Q.indexOf(":");
        if (N > 0) var R = X.prefix = Q.slice(0, N), S = Q.slice(N + 1), B = R === "xmlns" && S;
        else S = Q, R = null, B = Q === "xmlns" && "";
        X.localName = S, B !== false && (j == null && (j = {}, G(z, z = {})), z[B] = j[B] = x, X.uri = i.XMLNS, I.startPrefixMapping(B, x));
      }
      for (var D = C.length; D--; ) {
        X = C[D];
        var R = X.prefix;
        R && (R === "xml" && (X.uri = i.XML), R !== "xmlns" && (X.uri = z[R || ""]));
      }
      var N = Z.indexOf(":");
      N > 0 ? (R = C.prefix = Z.slice(0, N), S = C.localName = Z.slice(N + 1)) : (R = null, S = C.localName = Z);
      var O = C.uri = z[R || ""];
      if (I.startElement(O, S, Z, C), C.closed) {
        if (I.endElement(O, S, Z), j) for (R in j) Object.prototype.hasOwnProperty.call(j, R) && I.endPrefixMapping(R);
      } else return C.currentNSMap = z, C.localNSMap = j, true;
    }
    function A(C, I, z, Z, j) {
      if (/^(?:script|textarea)$/i.test(z)) {
        var X = C.indexOf("</" + z + ">", I), Q = C.substring(I + 1, X);
        if (/[&<]/.test(Q)) return /^script$/i.test(z) ? (j.characters(Q, 0, Q.length), X) : (Q = Q.replace(/&#?\w+;/g, Z), j.characters(Q, 0, Q.length), X);
      }
      return I + 1;
    }
    function T(C, I, z, Z) {
      var j = Z[z];
      return j == null && (j = C.lastIndexOf("</" + z + ">"), j < I && (j = C.lastIndexOf("</" + z)), Z[z] = j), j < I;
    }
    function G(C, I) {
      for (var z in C) Object.prototype.hasOwnProperty.call(C, z) && (I[z] = C[z]);
    }
    function H(C, I, z, Z) {
      var j = C.charAt(I + 2);
      switch (j) {
        case "-":
          if (C.charAt(I + 3) === "-") {
            var X = C.indexOf("-->", I + 4);
            return X > I ? (z.comment(C, I + 4, X - I - 4), X + 3) : (Z.error("Unclosed comment"), -1);
          } else return -1;
        default:
          if (C.substr(I + 3, 6) == "CDATA[") {
            var X = C.indexOf("]]>", I + 9);
            return z.startCDATA(), z.characters(C, I + 9, X - I - 9), z.endCDATA(), X + 3;
          }
          var Q = W(C, I), x = Q.length;
          if (x > 1 && /!doctype/i.test(Q[0][0])) {
            var R = Q[1][0], S = false, B = false;
            x > 3 && (/^public$/i.test(Q[2][0]) ? (S = Q[3][0], B = x > 4 && Q[4][0]) : /^system$/i.test(Q[2][0]) && (B = Q[3][0]));
            var D = Q[x - 1];
            return z.startDTD(R, S, B), z.endDTD(), D.index + D[0].length;
          }
      }
      return -1;
    }
    function Y(C, I, z) {
      var Z = C.indexOf("?>", I);
      if (Z) {
        var j = C.substring(I, Z).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
        if (j) {
          var X = j[0].length;
          return z.processingInstruction(j[1], j[2]), Z + 2;
        } else return -1;
      }
      return -1;
    }
    function L() {
      this.attributeNames = {};
    }
    L.prototype = {
      setTagName: function(C) {
        if (!r.test(C)) throw new Error("invalid tagName:" + C);
        this.tagName = C;
      },
      addValue: function(C, I, z) {
        if (!r.test(C)) throw new Error("invalid attribute:" + C);
        this.attributeNames[C] = this.length, this[this.length++] = {
          qName: C,
          value: I,
          offset: z
        };
      },
      length: 0,
      getLocalName: function(C) {
        return this[C].localName;
      },
      getLocator: function(C) {
        return this[C].locator;
      },
      getQName: function(C) {
        return this[C].qName;
      },
      getURI: function(C) {
        return this[C].uri;
      },
      getValue: function(C) {
        return this[C].value;
      }
    };
    function W(C, I) {
      var z, Z = [], j = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
      for (j.lastIndex = I, j.exec(C); z = j.exec(C); ) if (Z.push(z), z[1]) return Z;
    }
    return ln.XMLReader = p, ln.ParseError = f, ln;
  }
  var fu;
  function ew() {
    if (fu) return di;
    fu = 1;
    var i = es(), t = Kh(), e = Qb(), r = tw(), n = t.DOMImplementation, s = i.NAMESPACE, o = r.ParseError, a = r.XMLReader;
    function c(b) {
      return b.replace(/\r[\n\u0085]/g, `
`).replace(/[\r\u0085\u2028]/g, `
`);
    }
    function u(b) {
      this.options = b || {
        locator: {}
      };
    }
    u.prototype.parseFromString = function(b, v) {
      var A = this.options, T = new a(), G = A.domBuilder || new h(), H = A.errorHandler, Y = A.locator, L = A.xmlns || {}, W = /\/x?html?$/.test(v), C = W ? e.HTML_ENTITIES : e.XML_ENTITIES;
      Y && G.setDocumentLocator(Y), T.errorHandler = l(H, G, Y), T.domBuilder = A.domBuilder || G, W && (L[""] = s.HTML), L.xml = L.xml || s.XML;
      var I = A.normalizeLineEndings || c;
      return b && typeof b == "string" ? T.parse(I(b), L, C) : T.errorHandler.error("invalid doc source"), G.doc;
    };
    function l(b, v, A) {
      if (!b) {
        if (v instanceof h) return v;
        b = v;
      }
      var T = {}, G = b instanceof Function;
      A = A || {};
      function H(Y) {
        var L = b[Y];
        !L && G && (L = b.length == 2 ? function(W) {
          b(Y, W);
        } : b), T[Y] = L && function(W) {
          L("[xmldom " + Y + "]	" + W + p(A));
        } || function() {
        };
      }
      return H("warning"), H("error"), H("fatalError"), T;
    }
    function h() {
      this.cdata = false;
    }
    function f(b, v) {
      v.lineNumber = b.lineNumber, v.columnNumber = b.columnNumber;
    }
    h.prototype = {
      startDocument: function() {
        this.doc = new n().createDocument(null, null, null), this.locator && (this.doc.documentURI = this.locator.systemId);
      },
      startElement: function(b, v, A, T) {
        var G = this.doc, H = G.createElementNS(b, A || v), Y = T.length;
        y(this, H), this.currentElement = H, this.locator && f(this.locator, H);
        for (var L = 0; L < Y; L++) {
          var b = T.getURI(L), W = T.getValue(L), A = T.getQName(L), C = G.createAttributeNS(b, A);
          this.locator && f(T.getLocator(L), C), C.value = C.nodeValue = W, H.setAttributeNode(C);
        }
      },
      endElement: function(b, v, A) {
        var T = this.currentElement, G = T.tagName;
        this.currentElement = T.parentNode;
      },
      startPrefixMapping: function(b, v) {
      },
      endPrefixMapping: function(b) {
      },
      processingInstruction: function(b, v) {
        var A = this.doc.createProcessingInstruction(b, v);
        this.locator && f(this.locator, A), y(this, A);
      },
      ignorableWhitespace: function(b, v, A) {
      },
      characters: function(b, v, A) {
        if (b = m.apply(this, arguments), b) {
          if (this.cdata) var T = this.doc.createCDATASection(b);
          else var T = this.doc.createTextNode(b);
          this.currentElement ? this.currentElement.appendChild(T) : /^\s*$/.test(b) && this.doc.appendChild(T), this.locator && f(this.locator, T);
        }
      },
      skippedEntity: function(b) {
      },
      endDocument: function() {
        this.doc.normalize();
      },
      setDocumentLocator: function(b) {
        (this.locator = b) && (b.lineNumber = 0);
      },
      comment: function(b, v, A) {
        b = m.apply(this, arguments);
        var T = this.doc.createComment(b);
        this.locator && f(this.locator, T), y(this, T);
      },
      startCDATA: function() {
        this.cdata = true;
      },
      endCDATA: function() {
        this.cdata = false;
      },
      startDTD: function(b, v, A) {
        var T = this.doc.implementation;
        if (T && T.createDocumentType) {
          var G = T.createDocumentType(b, v, A);
          this.locator && f(this.locator, G), y(this, G), this.doc.doctype = G;
        }
      },
      warning: function(b) {
        console.warn("[xmldom warning]	" + b, p(this.locator));
      },
      error: function(b) {
        console.error("[xmldom error]	" + b, p(this.locator));
      },
      fatalError: function(b) {
        throw new o(b, this.locator);
      }
    };
    function p(b) {
      if (b) return `
@` + (b.systemId || "") + "#[line:" + b.lineNumber + ",col:" + b.columnNumber + "]";
    }
    function m(b, v, A) {
      return typeof b == "string" ? b.substr(v, A) : b.length >= v + A || v ? new java.lang.String(b, v, A) + "" : b;
    }
    "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function(b) {
      h.prototype[b] = function() {
        return null;
      };
    });
    function y(b, v) {
      b.currentElement ? b.currentElement.appendChild(v) : b.doc.appendChild(v);
    }
    return di.__DOMHandler = h, di.normalizeLineEndings = c, di.DOMParser = u, di;
  }
  var pu;
  function rw() {
    if (pu) return hi;
    pu = 1;
    var i = Kh();
    return hi.DOMImplementation = i.DOMImplementation, hi.XMLSerializer = i.XMLSerializer, hi.DOMParser = ew().DOMParser, hi;
  }
  var oR = rw();
  class iw {
    constructor() {
      this.interactionFrequency = 10, this._deltaTime = 0, this._didMove = false, this._tickerAdded = false, this._pauseUpdate = true;
    }
    init(t) {
      this.removeTickerListener(), this.events = t, this.interactionFrequency = 10, this._deltaTime = 0, this._didMove = false, this._tickerAdded = false, this._pauseUpdate = true;
    }
    get pauseUpdate() {
      return this._pauseUpdate;
    }
    set pauseUpdate(t) {
      this._pauseUpdate = t;
    }
    addTickerListener() {
      this._tickerAdded || !this.domElement || (ae.system.add(this._tickerUpdate, this, hr.INTERACTION), this._tickerAdded = true);
    }
    removeTickerListener() {
      this._tickerAdded && (ae.system.remove(this._tickerUpdate, this), this._tickerAdded = false);
    }
    pointerMoved() {
      this._didMove = true;
    }
    _update() {
      if (!this.domElement || this._pauseUpdate) return;
      if (this._didMove) {
        this._didMove = false;
        return;
      }
      const t = this.events._rootPointerEvent;
      this.events.supportsTouchEvents && t.pointerType === "touch" || globalThis.document.dispatchEvent(new PointerEvent("pointermove", {
        clientX: t.clientX,
        clientY: t.clientY,
        pointerType: t.pointerType,
        pointerId: t.pointerId
      }));
    }
    _tickerUpdate(t) {
      this._deltaTime += t.deltaTime, !(this._deltaTime < this.interactionFrequency) && (this._deltaTime = 0, this._update());
    }
  }
  const or = new iw();
  class Gn extends Di {
    constructor() {
      super(...arguments), this.client = new Ct(), this.movement = new Ct(), this.offset = new Ct(), this.global = new Ct(), this.screen = new Ct();
    }
    get clientX() {
      return this.client.x;
    }
    get clientY() {
      return this.client.y;
    }
    get x() {
      return this.clientX;
    }
    get y() {
      return this.clientY;
    }
    get movementX() {
      return this.movement.x;
    }
    get movementY() {
      return this.movement.y;
    }
    get offsetX() {
      return this.offset.x;
    }
    get offsetY() {
      return this.offset.y;
    }
    get globalX() {
      return this.global.x;
    }
    get globalY() {
      return this.global.y;
    }
    get screenX() {
      return this.screen.x;
    }
    get screenY() {
      return this.screen.y;
    }
    getLocalPosition(t, e, r) {
      return t.worldTransform.applyInverse(r || this.global, e);
    }
    getModifierState(t) {
      return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(t);
    }
    initMouseEvent(t, e, r, n, s, o, a, c, u, l, h, f, p, m, y) {
      throw new Error("Method not implemented.");
    }
  }
  class Te extends Gn {
    constructor() {
      super(...arguments), this.width = 0, this.height = 0, this.isPrimary = false;
    }
    getCoalescedEvents() {
      return this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove" ? [
        this
      ] : [];
    }
    getPredictedEvents() {
      throw new Error("getPredictedEvents is not supported!");
    }
  }
  class Jr extends Gn {
    constructor() {
      super(...arguments), this.DOM_DELTA_PIXEL = 0, this.DOM_DELTA_LINE = 1, this.DOM_DELTA_PAGE = 2;
    }
  }
  Jr.DOM_DELTA_PIXEL = 0;
  Jr.DOM_DELTA_LINE = 1;
  Jr.DOM_DELTA_PAGE = 2;
  const nw = 2048, sw = new Ct(), fi = new Ct();
  class ow {
    constructor(t) {
      this.dispatch = new me(), this.moveOnAll = false, this.enableGlobalMoveEvents = true, this.mappingState = {
        trackingData: {}
      }, this.eventPool = /* @__PURE__ */ new Map(), this._allInteractiveElements = [], this._hitElements = [], this._isPointerMoveEvent = false, this.rootTarget = t, this.hitPruneFn = this.hitPruneFn.bind(this), this.hitTestFn = this.hitTestFn.bind(this), this.mapPointerDown = this.mapPointerDown.bind(this), this.mapPointerMove = this.mapPointerMove.bind(this), this.mapPointerOut = this.mapPointerOut.bind(this), this.mapPointerOver = this.mapPointerOver.bind(this), this.mapPointerUp = this.mapPointerUp.bind(this), this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this), this.mapWheel = this.mapWheel.bind(this), this.mappingTable = {}, this.addEventMapping("pointerdown", this.mapPointerDown), this.addEventMapping("pointermove", this.mapPointerMove), this.addEventMapping("pointerout", this.mapPointerOut), this.addEventMapping("pointerleave", this.mapPointerOut), this.addEventMapping("pointerover", this.mapPointerOver), this.addEventMapping("pointerup", this.mapPointerUp), this.addEventMapping("pointerupoutside", this.mapPointerUpOutside), this.addEventMapping("wheel", this.mapWheel);
    }
    addEventMapping(t, e) {
      this.mappingTable[t] || (this.mappingTable[t] = []), this.mappingTable[t].push({
        fn: e,
        priority: 0
      }), this.mappingTable[t].sort((r, n) => r.priority - n.priority);
    }
    dispatchEvent(t, e) {
      t.propagationStopped = false, t.propagationImmediatelyStopped = false, this.propagate(t, e), this.dispatch.emit(e || t.type, t);
    }
    mapEvent(t) {
      if (!this.rootTarget) return;
      const e = this.mappingTable[t.type];
      if (e) for (let r = 0, n = e.length; r < n; r++) e[r].fn(t);
      else ut(`[EventBoundary]: Event mapping not defined for ${t.type}`);
    }
    hitTest(t, e) {
      or.pauseUpdate = true;
      const n = this._isPointerMoveEvent && this.enableGlobalMoveEvents ? "hitTestMoveRecursive" : "hitTestRecursive", s = this[n](this.rootTarget, this.rootTarget.eventMode, sw.set(t, e), this.hitTestFn, this.hitPruneFn);
      return s && s[0];
    }
    propagate(t, e) {
      if (!t.target) return;
      const r = t.composedPath();
      t.eventPhase = t.CAPTURING_PHASE;
      for (let n = 0, s = r.length - 1; n < s; n++) if (t.currentTarget = r[n], this.notifyTarget(t, e), t.propagationStopped || t.propagationImmediatelyStopped) return;
      if (t.eventPhase = t.AT_TARGET, t.currentTarget = t.target, this.notifyTarget(t, e), !(t.propagationStopped || t.propagationImmediatelyStopped)) {
        t.eventPhase = t.BUBBLING_PHASE;
        for (let n = r.length - 2; n >= 0; n--) if (t.currentTarget = r[n], this.notifyTarget(t, e), t.propagationStopped || t.propagationImmediatelyStopped) return;
      }
    }
    all(t, e, r = this._allInteractiveElements) {
      if (r.length === 0) return;
      t.eventPhase = t.BUBBLING_PHASE;
      const n = Array.isArray(e) ? e : [
        e
      ];
      for (let s = r.length - 1; s >= 0; s--) n.forEach((o) => {
        t.currentTarget = r[s], this.notifyTarget(t, o);
      });
    }
    propagationPath(t) {
      const e = [
        t
      ];
      for (let r = 0; r < nw && t !== this.rootTarget && t.parent; r++) {
        if (!t.parent) throw new Error("Cannot find propagation path to disconnected target");
        e.push(t.parent), t = t.parent;
      }
      return e.reverse(), e;
    }
    hitTestMoveRecursive(t, e, r, n, s, o = false) {
      let a = false;
      if (this._interactivePrune(t)) return null;
      if ((t.eventMode === "dynamic" || e === "dynamic") && (or.pauseUpdate = false), t.interactiveChildren && t.children) {
        const l = t.children;
        for (let h = l.length - 1; h >= 0; h--) {
          const f = l[h], p = this.hitTestMoveRecursive(f, this._isInteractive(e) ? e : f.eventMode, r, n, s, o || s(t, r));
          if (p) {
            if (p.length > 0 && !p[p.length - 1].parent) continue;
            const m = t.isInteractive();
            (p.length > 0 || m) && (m && this._allInteractiveElements.push(t), p.push(t)), this._hitElements.length === 0 && (this._hitElements = p), a = true;
          }
        }
      }
      const c = this._isInteractive(e), u = t.isInteractive();
      return u && u && this._allInteractiveElements.push(t), o || this._hitElements.length > 0 ? null : a ? this._hitElements : c && !s(t, r) && n(t, r) ? u ? [
        t
      ] : [] : null;
    }
    hitTestRecursive(t, e, r, n, s) {
      if (this._interactivePrune(t) || s(t, r)) return null;
      if ((t.eventMode === "dynamic" || e === "dynamic") && (or.pauseUpdate = false), t.interactiveChildren && t.children) {
        const c = t.children, u = r;
        for (let l = c.length - 1; l >= 0; l--) {
          const h = c[l], f = this.hitTestRecursive(h, this._isInteractive(e) ? e : h.eventMode, u, n, s);
          if (f) {
            if (f.length > 0 && !f[f.length - 1].parent) continue;
            const p = t.isInteractive();
            return (f.length > 0 || p) && f.push(t), f;
          }
        }
      }
      const o = this._isInteractive(e), a = t.isInteractive();
      return o && n(t, r) ? a ? [
        t
      ] : [] : null;
    }
    _isInteractive(t) {
      return t === "static" || t === "dynamic";
    }
    _interactivePrune(t) {
      return !t || !t.visible || !t.renderable || !t.includeInBuild || !t.measurable || t.eventMode === "none" || t.eventMode === "passive" && !t.interactiveChildren;
    }
    hitPruneFn(t, e) {
      if (t.hitArea && (t.worldTransform.applyInverse(e, fi), !t.hitArea.contains(fi.x, fi.y))) return true;
      if (t.effects && t.effects.length) for (let r = 0; r < t.effects.length; r++) {
        const n = t.effects[r];
        if (n.containsPoint && !n.containsPoint(e, this.hitTestFn)) return true;
      }
      return false;
    }
    hitTestFn(t, e) {
      return t.hitArea ? true : (t == null ? void 0 : t.containsPoint) ? (t.worldTransform.applyInverse(e, fi), t.containsPoint(fi)) : false;
    }
    notifyTarget(t, e) {
      var _a2, _b2;
      if (!t.currentTarget.isInteractive()) return;
      e = e ?? t.type;
      const r = `on${e}`;
      (_b2 = (_a2 = t.currentTarget)[r]) == null ? void 0 : _b2.call(_a2, t);
      const n = t.eventPhase === t.CAPTURING_PHASE || t.eventPhase === t.AT_TARGET ? `${e}capture` : e;
      this._notifyListeners(t, n), t.eventPhase === t.AT_TARGET && this._notifyListeners(t, e);
    }
    mapPointerDown(t) {
      if (!(t instanceof Te)) {
        ut("EventBoundary cannot map a non-pointer event as a pointer event");
        return;
      }
      const e = this.createPointerEvent(t);
      if (this.dispatchEvent(e, "pointerdown"), e.pointerType === "touch") this.dispatchEvent(e, "touchstart");
      else if (e.pointerType === "mouse" || e.pointerType === "pen") {
        const n = e.button === 2;
        this.dispatchEvent(e, n ? "rightdown" : "mousedown");
      }
      const r = this.trackingData(t.pointerId);
      r.pressTargetsByButton[t.button] = e.composedPath(), this.freeEvent(e);
    }
    mapPointerMove(t) {
      var _a2, _b2;
      if (!(t instanceof Te)) {
        ut("EventBoundary cannot map a non-pointer event as a pointer event");
        return;
      }
      this._allInteractiveElements.length = 0, this._hitElements.length = 0, this._isPointerMoveEvent = true;
      const e = this.createPointerEvent(t);
      this._isPointerMoveEvent = false;
      const r = e.pointerType === "mouse" || e.pointerType === "pen", n = this.trackingData(t.pointerId), s = this.findMountedTarget(n.overTargets);
      if (((_a2 = n.overTargets) == null ? void 0 : _a2.length) > 0 && s !== e.target) {
        const c = t.type === "mousemove" ? "mouseout" : "pointerout", u = this.createPointerEvent(t, c, s);
        if (this.dispatchEvent(u, "pointerout"), r && this.dispatchEvent(u, "mouseout"), !e.composedPath().includes(s)) {
          const l = this.createPointerEvent(t, "pointerleave", s);
          for (l.eventPhase = l.AT_TARGET; l.target && !e.composedPath().includes(l.target); ) l.currentTarget = l.target, this.notifyTarget(l), r && this.notifyTarget(l, "mouseleave"), l.target = l.target.parent;
          this.freeEvent(l);
        }
        this.freeEvent(u);
      }
      if (s !== e.target) {
        const c = t.type === "mousemove" ? "mouseover" : "pointerover", u = this.clonePointerEvent(e, c);
        this.dispatchEvent(u, "pointerover"), r && this.dispatchEvent(u, "mouseover");
        let l = s == null ? void 0 : s.parent;
        for (; l && l !== this.rootTarget.parent && l !== e.target; ) l = l.parent;
        if (!l || l === this.rootTarget.parent) {
          const f = this.clonePointerEvent(e, "pointerenter");
          for (f.eventPhase = f.AT_TARGET; f.target && f.target !== s && f.target !== this.rootTarget.parent; ) f.currentTarget = f.target, this.notifyTarget(f), r && this.notifyTarget(f, "mouseenter"), f.target = f.target.parent;
          this.freeEvent(f);
        }
        this.freeEvent(u);
      }
      const o = [], a = this.enableGlobalMoveEvents ?? true;
      this.moveOnAll ? o.push("pointermove") : this.dispatchEvent(e, "pointermove"), a && o.push("globalpointermove"), e.pointerType === "touch" && (this.moveOnAll ? o.splice(1, 0, "touchmove") : this.dispatchEvent(e, "touchmove"), a && o.push("globaltouchmove")), r && (this.moveOnAll ? o.splice(1, 0, "mousemove") : this.dispatchEvent(e, "mousemove"), a && o.push("globalmousemove"), this.cursor = (_b2 = e.target) == null ? void 0 : _b2.cursor), o.length > 0 && this.all(e, o), this._allInteractiveElements.length = 0, this._hitElements.length = 0, n.overTargets = e.composedPath(), this.freeEvent(e);
    }
    mapPointerOver(t) {
      var _a2;
      if (!(t instanceof Te)) {
        ut("EventBoundary cannot map a non-pointer event as a pointer event");
        return;
      }
      const e = this.trackingData(t.pointerId), r = this.createPointerEvent(t), n = r.pointerType === "mouse" || r.pointerType === "pen";
      this.dispatchEvent(r, "pointerover"), n && this.dispatchEvent(r, "mouseover"), r.pointerType === "mouse" && (this.cursor = (_a2 = r.target) == null ? void 0 : _a2.cursor);
      const s = this.clonePointerEvent(r, "pointerenter");
      for (s.eventPhase = s.AT_TARGET; s.target && s.target !== this.rootTarget.parent; ) s.currentTarget = s.target, this.notifyTarget(s), n && this.notifyTarget(s, "mouseenter"), s.target = s.target.parent;
      e.overTargets = r.composedPath(), this.freeEvent(r), this.freeEvent(s);
    }
    mapPointerOut(t) {
      if (!(t instanceof Te)) {
        ut("EventBoundary cannot map a non-pointer event as a pointer event");
        return;
      }
      const e = this.trackingData(t.pointerId);
      if (e.overTargets) {
        const r = t.pointerType === "mouse" || t.pointerType === "pen", n = this.findMountedTarget(e.overTargets), s = this.createPointerEvent(t, "pointerout", n);
        this.dispatchEvent(s), r && this.dispatchEvent(s, "mouseout");
        const o = this.createPointerEvent(t, "pointerleave", n);
        for (o.eventPhase = o.AT_TARGET; o.target && o.target !== this.rootTarget.parent; ) o.currentTarget = o.target, this.notifyTarget(o), r && this.notifyTarget(o, "mouseleave"), o.target = o.target.parent;
        e.overTargets = null, this.freeEvent(s), this.freeEvent(o);
      }
      this.cursor = null;
    }
    mapPointerUp(t) {
      if (!(t instanceof Te)) {
        ut("EventBoundary cannot map a non-pointer event as a pointer event");
        return;
      }
      const e = performance.now(), r = this.createPointerEvent(t);
      if (this.dispatchEvent(r, "pointerup"), r.pointerType === "touch") this.dispatchEvent(r, "touchend");
      else if (r.pointerType === "mouse" || r.pointerType === "pen") {
        const a = r.button === 2;
        this.dispatchEvent(r, a ? "rightup" : "mouseup");
      }
      const n = this.trackingData(t.pointerId), s = this.findMountedTarget(n.pressTargetsByButton[t.button]);
      let o = s;
      if (s && !r.composedPath().includes(s)) {
        let a = s;
        for (; a && !r.composedPath().includes(a); ) {
          if (r.currentTarget = a, this.notifyTarget(r, "pointerupoutside"), r.pointerType === "touch") this.notifyTarget(r, "touchendoutside");
          else if (r.pointerType === "mouse" || r.pointerType === "pen") {
            const c = r.button === 2;
            this.notifyTarget(r, c ? "rightupoutside" : "mouseupoutside");
          }
          a = a.parent;
        }
        delete n.pressTargetsByButton[t.button], o = a;
      }
      if (o) {
        const a = this.clonePointerEvent(r, "click");
        a.target = o, a.path = null, n.clicksByButton[t.button] || (n.clicksByButton[t.button] = {
          clickCount: 0,
          target: a.target,
          timeStamp: e
        });
        const c = n.clicksByButton[t.button];
        if (c.target === a.target && e - c.timeStamp < 200 ? ++c.clickCount : c.clickCount = 1, c.target = a.target, c.timeStamp = e, a.detail = c.clickCount, a.pointerType === "mouse") {
          const u = a.button === 2;
          this.dispatchEvent(a, u ? "rightclick" : "click");
        } else a.pointerType === "touch" && this.dispatchEvent(a, "tap");
        this.dispatchEvent(a, "pointertap"), this.freeEvent(a);
      }
      this.freeEvent(r);
    }
    mapPointerUpOutside(t) {
      if (!(t instanceof Te)) {
        ut("EventBoundary cannot map a non-pointer event as a pointer event");
        return;
      }
      const e = this.trackingData(t.pointerId), r = this.findMountedTarget(e.pressTargetsByButton[t.button]), n = this.createPointerEvent(t);
      if (r) {
        let s = r;
        for (; s; ) n.currentTarget = s, this.notifyTarget(n, "pointerupoutside"), n.pointerType === "touch" ? this.notifyTarget(n, "touchendoutside") : (n.pointerType === "mouse" || n.pointerType === "pen") && this.notifyTarget(n, n.button === 2 ? "rightupoutside" : "mouseupoutside"), s = s.parent;
        delete e.pressTargetsByButton[t.button];
      }
      this.freeEvent(n);
    }
    mapWheel(t) {
      if (!(t instanceof Jr)) {
        ut("EventBoundary cannot map a non-wheel event as a wheel event");
        return;
      }
      const e = this.createWheelEvent(t);
      this.dispatchEvent(e), this.freeEvent(e);
    }
    findMountedTarget(t) {
      if (!t) return null;
      let e = t[0];
      for (let r = 1; r < t.length && t[r].parent === e; r++) e = t[r];
      return e;
    }
    createPointerEvent(t, e, r) {
      const n = this.allocateEvent(Te);
      return this.copyPointerData(t, n), this.copyMouseData(t, n), this.copyData(t, n), n.nativeEvent = t.nativeEvent, n.originalEvent = t, n.target = r ?? this.hitTest(n.global.x, n.global.y) ?? this._hitElements[0], typeof e == "string" && (n.type = e), n;
    }
    createWheelEvent(t) {
      const e = this.allocateEvent(Jr);
      return this.copyWheelData(t, e), this.copyMouseData(t, e), this.copyData(t, e), e.nativeEvent = t.nativeEvent, e.originalEvent = t, e.target = this.hitTest(e.global.x, e.global.y), e;
    }
    clonePointerEvent(t, e) {
      const r = this.allocateEvent(Te);
      return r.nativeEvent = t.nativeEvent, r.originalEvent = t.originalEvent, this.copyPointerData(t, r), this.copyMouseData(t, r), this.copyData(t, r), r.target = t.target, r.path = t.composedPath().slice(), r.type = e ?? r.type, r;
    }
    copyWheelData(t, e) {
      e.deltaMode = t.deltaMode, e.deltaX = t.deltaX, e.deltaY = t.deltaY, e.deltaZ = t.deltaZ;
    }
    copyPointerData(t, e) {
      t instanceof Te && e instanceof Te && (e.pointerId = t.pointerId, e.width = t.width, e.height = t.height, e.isPrimary = t.isPrimary, e.pointerType = t.pointerType, e.pressure = t.pressure, e.tangentialPressure = t.tangentialPressure, e.tiltX = t.tiltX, e.tiltY = t.tiltY, e.twist = t.twist);
    }
    copyMouseData(t, e) {
      t instanceof Gn && e instanceof Gn && (e.altKey = t.altKey, e.button = t.button, e.buttons = t.buttons, e.client.copyFrom(t.client), e.ctrlKey = t.ctrlKey, e.metaKey = t.metaKey, e.movement.copyFrom(t.movement), e.screen.copyFrom(t.screen), e.shiftKey = t.shiftKey, e.global.copyFrom(t.global));
    }
    copyData(t, e) {
      e.isTrusted = t.isTrusted, e.srcElement = t.srcElement, e.timeStamp = performance.now(), e.type = t.type, e.detail = t.detail, e.view = t.view, e.which = t.which, e.layer.copyFrom(t.layer), e.page.copyFrom(t.page);
    }
    trackingData(t) {
      return this.mappingState.trackingData[t] || (this.mappingState.trackingData[t] = {
        pressTargetsByButton: {},
        clicksByButton: {},
        overTarget: null
      }), this.mappingState.trackingData[t];
    }
    allocateEvent(t) {
      this.eventPool.has(t) || this.eventPool.set(t, []);
      const e = this.eventPool.get(t).pop() || new t(this);
      return e.eventPhase = e.NONE, e.currentTarget = null, e.path = null, e.target = null, e;
    }
    freeEvent(t) {
      if (t.manager !== this) throw new Error("It is illegal to free an event not managed by this EventBoundary!");
      const e = t.constructor;
      this.eventPool.has(e) || this.eventPool.set(e, []), this.eventPool.get(e).push(t);
    }
    _notifyListeners(t, e) {
      const r = t.currentTarget._events[e];
      if (r) if ("fn" in r) r.once && t.currentTarget.removeListener(e, r.fn, void 0, true), r.fn.call(r.context, t);
      else for (let n = 0, s = r.length; n < s && !t.propagationImmediatelyStopped; n++) r[n].once && t.currentTarget.removeListener(e, r[n].fn, void 0, true), r[n].fn.call(r[n].context, t);
    }
  }
  const aw = 1, cw = {
    touchstart: "pointerdown",
    touchend: "pointerup",
    touchendoutside: "pointerupoutside",
    touchmove: "pointermove",
    touchcancel: "pointercancel"
  }, fa = class Go {
    constructor(t) {
      this.supportsTouchEvents = "ontouchstart" in globalThis, this.supportsPointerEvents = !!globalThis.PointerEvent, this.domElement = null, this.resolution = 1, this.renderer = t, this.rootBoundary = new ow(null), or.init(this), this.autoPreventDefault = true, this._eventsAdded = false, this._rootPointerEvent = new Te(null), this._rootWheelEvent = new Jr(null), this.cursorStyles = {
        default: "inherit",
        pointer: "pointer"
      }, this.features = new Proxy({
        ...Go.defaultEventFeatures
      }, {
        set: (e, r, n) => (r === "globalMove" && (this.rootBoundary.enableGlobalMoveEvents = n), e[r] = n, true)
      }), this._onPointerDown = this._onPointerDown.bind(this), this._onPointerMove = this._onPointerMove.bind(this), this._onPointerUp = this._onPointerUp.bind(this), this._onPointerOverOut = this._onPointerOverOut.bind(this), this.onWheel = this.onWheel.bind(this);
    }
    static get defaultEventMode() {
      return this._defaultEventMode;
    }
    init(t) {
      const { canvas: e, resolution: r } = this.renderer;
      this.setTargetElement(e), this.resolution = r, Go._defaultEventMode = t.eventMode ?? "passive", Object.assign(this.features, t.eventFeatures ?? {}), this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove;
    }
    resolutionChange(t) {
      this.resolution = t;
    }
    destroy() {
      this.setTargetElement(null), this.renderer = null, this._currentCursor = null;
    }
    setCursor(t) {
      t = t || "default";
      let e = true;
      if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas && (e = false), this._currentCursor === t) return;
      this._currentCursor = t;
      const r = this.cursorStyles[t];
      if (r) switch (typeof r) {
        case "string":
          e && (this.domElement.style.cursor = r);
          break;
        case "function":
          r(t);
          break;
        case "object":
          e && Object.assign(this.domElement.style, r);
          break;
      }
      else e && typeof t == "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, t) && (this.domElement.style.cursor = t);
    }
    get pointer() {
      return this._rootPointerEvent;
    }
    _onPointerDown(t) {
      if (!this.features.click) return;
      this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
      const e = this._normalizeToPointerData(t);
      this.autoPreventDefault && e[0].isNormalized && (t.cancelable || !("cancelable" in t)) && t.preventDefault();
      for (let r = 0, n = e.length; r < n; r++) {
        const s = e[r], o = this._bootstrapEvent(this._rootPointerEvent, s);
        this.rootBoundary.mapEvent(o);
      }
      this.setCursor(this.rootBoundary.cursor);
    }
    _onPointerMove(t) {
      if (!this.features.move) return;
      this.rootBoundary.rootTarget = this.renderer.lastObjectRendered, or.pointerMoved();
      const e = this._normalizeToPointerData(t);
      for (let r = 0, n = e.length; r < n; r++) {
        const s = this._bootstrapEvent(this._rootPointerEvent, e[r]);
        this.rootBoundary.mapEvent(s);
      }
      this.setCursor(this.rootBoundary.cursor);
    }
    _onPointerUp(t) {
      if (!this.features.click) return;
      this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
      let e = t.target;
      t.composedPath && t.composedPath().length > 0 && (e = t.composedPath()[0]);
      const r = e !== this.domElement ? "outside" : "", n = this._normalizeToPointerData(t);
      for (let s = 0, o = n.length; s < o; s++) {
        const a = this._bootstrapEvent(this._rootPointerEvent, n[s]);
        a.type += r, this.rootBoundary.mapEvent(a);
      }
      this.setCursor(this.rootBoundary.cursor);
    }
    _onPointerOverOut(t) {
      if (!this.features.click) return;
      this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
      const e = this._normalizeToPointerData(t);
      for (let r = 0, n = e.length; r < n; r++) {
        const s = this._bootstrapEvent(this._rootPointerEvent, e[r]);
        this.rootBoundary.mapEvent(s);
      }
      this.setCursor(this.rootBoundary.cursor);
    }
    onWheel(t) {
      if (!this.features.wheel) return;
      const e = this.normalizeWheelEvent(t);
      this.rootBoundary.rootTarget = this.renderer.lastObjectRendered, this.rootBoundary.mapEvent(e);
    }
    setTargetElement(t) {
      this._removeEvents(), this.domElement = t, or.domElement = t, this._addEvents();
    }
    _addEvents() {
      if (this._eventsAdded || !this.domElement) return;
      or.addTickerListener();
      const t = this.domElement.style;
      t && (globalThis.navigator.msPointerEnabled ? (t.msContentZooming = "none", t.msTouchAction = "none") : this.supportsPointerEvents && (t.touchAction = "none")), this.supportsPointerEvents ? (globalThis.document.addEventListener("pointermove", this._onPointerMove, true), this.domElement.addEventListener("pointerdown", this._onPointerDown, true), this.domElement.addEventListener("pointerleave", this._onPointerOverOut, true), this.domElement.addEventListener("pointerover", this._onPointerOverOut, true), globalThis.addEventListener("pointerup", this._onPointerUp, true)) : (globalThis.document.addEventListener("mousemove", this._onPointerMove, true), this.domElement.addEventListener("mousedown", this._onPointerDown, true), this.domElement.addEventListener("mouseout", this._onPointerOverOut, true), this.domElement.addEventListener("mouseover", this._onPointerOverOut, true), globalThis.addEventListener("mouseup", this._onPointerUp, true), this.supportsTouchEvents && (this.domElement.addEventListener("touchstart", this._onPointerDown, true), this.domElement.addEventListener("touchend", this._onPointerUp, true), this.domElement.addEventListener("touchmove", this._onPointerMove, true))), this.domElement.addEventListener("wheel", this.onWheel, {
        passive: true,
        capture: true
      }), this._eventsAdded = true;
    }
    _removeEvents() {
      if (!this._eventsAdded || !this.domElement) return;
      or.removeTickerListener();
      const t = this.domElement.style;
      t && (globalThis.navigator.msPointerEnabled ? (t.msContentZooming = "", t.msTouchAction = "") : this.supportsPointerEvents && (t.touchAction = "")), this.supportsPointerEvents ? (globalThis.document.removeEventListener("pointermove", this._onPointerMove, true), this.domElement.removeEventListener("pointerdown", this._onPointerDown, true), this.domElement.removeEventListener("pointerleave", this._onPointerOverOut, true), this.domElement.removeEventListener("pointerover", this._onPointerOverOut, true), globalThis.removeEventListener("pointerup", this._onPointerUp, true)) : (globalThis.document.removeEventListener("mousemove", this._onPointerMove, true), this.domElement.removeEventListener("mousedown", this._onPointerDown, true), this.domElement.removeEventListener("mouseout", this._onPointerOverOut, true), this.domElement.removeEventListener("mouseover", this._onPointerOverOut, true), globalThis.removeEventListener("mouseup", this._onPointerUp, true), this.supportsTouchEvents && (this.domElement.removeEventListener("touchstart", this._onPointerDown, true), this.domElement.removeEventListener("touchend", this._onPointerUp, true), this.domElement.removeEventListener("touchmove", this._onPointerMove, true))), this.domElement.removeEventListener("wheel", this.onWheel, true), this.domElement = null, this._eventsAdded = false;
    }
    mapPositionToPoint(t, e, r) {
      const n = this.domElement.isConnected ? this.domElement.getBoundingClientRect() : {
        x: 0,
        y: 0,
        width: this.domElement.width,
        height: this.domElement.height,
        left: 0,
        top: 0
      }, s = 1 / this.resolution;
      t.x = (e - n.left) * (this.domElement.width / n.width) * s, t.y = (r - n.top) * (this.domElement.height / n.height) * s;
    }
    _normalizeToPointerData(t) {
      const e = [];
      if (this.supportsTouchEvents && t instanceof TouchEvent) for (let r = 0, n = t.changedTouches.length; r < n; r++) {
        const s = t.changedTouches[r];
        typeof s.button > "u" && (s.button = 0), typeof s.buttons > "u" && (s.buttons = 1), typeof s.isPrimary > "u" && (s.isPrimary = t.touches.length === 1 && t.type === "touchstart"), typeof s.width > "u" && (s.width = s.radiusX || 1), typeof s.height > "u" && (s.height = s.radiusY || 1), typeof s.tiltX > "u" && (s.tiltX = 0), typeof s.tiltY > "u" && (s.tiltY = 0), typeof s.pointerType > "u" && (s.pointerType = "touch"), typeof s.pointerId > "u" && (s.pointerId = s.identifier || 0), typeof s.pressure > "u" && (s.pressure = s.force || 0.5), typeof s.twist > "u" && (s.twist = 0), typeof s.tangentialPressure > "u" && (s.tangentialPressure = 0), typeof s.layerX > "u" && (s.layerX = s.offsetX = s.clientX), typeof s.layerY > "u" && (s.layerY = s.offsetY = s.clientY), s.isNormalized = true, s.type = t.type, e.push(s);
      }
      else if (!globalThis.MouseEvent || t instanceof MouseEvent && (!this.supportsPointerEvents || !(t instanceof globalThis.PointerEvent))) {
        const r = t;
        typeof r.isPrimary > "u" && (r.isPrimary = true), typeof r.width > "u" && (r.width = 1), typeof r.height > "u" && (r.height = 1), typeof r.tiltX > "u" && (r.tiltX = 0), typeof r.tiltY > "u" && (r.tiltY = 0), typeof r.pointerType > "u" && (r.pointerType = "mouse"), typeof r.pointerId > "u" && (r.pointerId = aw), typeof r.pressure > "u" && (r.pressure = 0.5), typeof r.twist > "u" && (r.twist = 0), typeof r.tangentialPressure > "u" && (r.tangentialPressure = 0), r.isNormalized = true, e.push(r);
      } else e.push(t);
      return e;
    }
    normalizeWheelEvent(t) {
      const e = this._rootWheelEvent;
      return this._transferMouseData(e, t), e.deltaX = t.deltaX, e.deltaY = t.deltaY, e.deltaZ = t.deltaZ, e.deltaMode = t.deltaMode, this.mapPositionToPoint(e.screen, t.clientX, t.clientY), e.global.copyFrom(e.screen), e.offset.copyFrom(e.screen), e.nativeEvent = t, e.type = t.type, e;
    }
    _bootstrapEvent(t, e) {
      return t.originalEvent = null, t.nativeEvent = e, t.pointerId = e.pointerId, t.width = e.width, t.height = e.height, t.isPrimary = e.isPrimary, t.pointerType = e.pointerType, t.pressure = e.pressure, t.tangentialPressure = e.tangentialPressure, t.tiltX = e.tiltX, t.tiltY = e.tiltY, t.twist = e.twist, this._transferMouseData(t, e), this.mapPositionToPoint(t.screen, e.clientX, e.clientY), t.global.copyFrom(t.screen), t.offset.copyFrom(t.screen), t.isTrusted = e.isTrusted, t.type === "pointerleave" && (t.type = "pointerout"), t.type.startsWith("mouse") && (t.type = t.type.replace("mouse", "pointer")), t.type.startsWith("touch") && (t.type = cw[t.type] || t.type), t;
    }
    _transferMouseData(t, e) {
      t.isTrusted = e.isTrusted, t.srcElement = e.srcElement, t.timeStamp = performance.now(), t.type = e.type, t.altKey = e.altKey, t.button = e.button, t.buttons = e.buttons, t.client.x = e.clientX, t.client.y = e.clientY, t.ctrlKey = e.ctrlKey, t.metaKey = e.metaKey, t.movement.x = e.movementX, t.movement.y = e.movementY, t.page.x = e.pageX, t.page.y = e.pageY, t.relatedTarget = null, t.shiftKey = e.shiftKey;
    }
  };
  fa.extension = {
    name: "events",
    type: [
      P.WebGLSystem,
      P.CanvasSystem,
      P.WebGPUSystem
    ],
    priority: -1
  };
  fa.defaultEventFeatures = {
    move: true,
    globalMove: true,
    click: true,
    wheel: true
  };
  uw = fa;
  aR = {
    onclick: null,
    onmousedown: null,
    onmouseenter: null,
    onmouseleave: null,
    onmousemove: null,
    onglobalmousemove: null,
    onmouseout: null,
    onmouseover: null,
    onmouseup: null,
    onmouseupoutside: null,
    onpointercancel: null,
    onpointerdown: null,
    onpointerenter: null,
    onpointerleave: null,
    onpointermove: null,
    onglobalpointermove: null,
    onpointerout: null,
    onpointerover: null,
    onpointertap: null,
    onpointerup: null,
    onpointerupoutside: null,
    onrightclick: null,
    onrightdown: null,
    onrightup: null,
    onrightupoutside: null,
    ontap: null,
    ontouchcancel: null,
    ontouchend: null,
    ontouchendoutside: null,
    ontouchmove: null,
    onglobaltouchmove: null,
    ontouchstart: null,
    onwheel: null,
    get interactive() {
      return this.eventMode === "dynamic" || this.eventMode === "static";
    },
    set interactive(i) {
      this.eventMode = i ? "static" : "passive";
    },
    _internalEventMode: void 0,
    get eventMode() {
      return this._internalEventMode ?? uw.defaultEventMode;
    },
    set eventMode(i) {
      this._internalEventMode = i;
    },
    isInteractive() {
      return this.eventMode === "static" || this.eventMode === "dynamic";
    },
    interactiveChildren: true,
    hitArea: null,
    addEventListener(i, t, e) {
      const r = typeof e == "boolean" && e || typeof e == "object" && e.capture, n = typeof e == "object" ? e.signal : void 0, s = typeof e == "object" ? e.once === true : false, o = typeof t == "function" ? void 0 : t;
      i = r ? `${i}capture` : i;
      const a = typeof t == "function" ? t : t.handleEvent, c = this;
      n && n.addEventListener("abort", () => {
        c.off(i, a, o);
      }), s ? c.once(i, a, o) : c.on(i, a, o);
    },
    removeEventListener(i, t, e) {
      const r = typeof e == "boolean" && e || typeof e == "object" && e.capture, n = typeof t == "function" ? void 0 : t;
      i = r ? `${i}capture` : i, t = typeof t == "function" ? t : t.handleEvent, this.off(i, t, n);
    },
    dispatchEvent(i) {
      if (!(i instanceof Di)) throw new Error("Container cannot propagate events outside of the Federated Events API");
      return i.defaultPrevented = false, i.path = null, i.target = this, i.manager.dispatchEvent(i), !i.defaultPrevented;
    }
  };
  var Zh = `in vec2 aPosition;
out vec2 vTextureCoord;

uniform vec4 uInputSize;
uniform vec4 uOutputFrame;
uniform vec4 uOutputTexture;

vec4 filterVertexPosition( void )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
    
    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aPosition * (uOutputFrame.zw * uInputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`, lw = `
in vec2 vTextureCoord;

out vec4 finalColor;

uniform float uAlpha;
uniform sampler2D uTexture;

void main()
{
    finalColor =  texture(uTexture, vTextureCoord) * uAlpha;
}
`, _u = `struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

struct AlphaUniforms {
  uAlpha:f32,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler : sampler;

@group(1) @binding(0) var<uniform> alphaUniforms : AlphaUniforms;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>
  };

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  
}

fn getSize() -> vec2<f32>
{
  return gfu.uGlobalFrame.zw;
}
  
@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>, 
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition)
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {
 
    var sample = textureSample(uTexture, uSampler, uv);
    
    return sample * alphaUniforms.uAlpha;
}`;
  const hw = class Jh extends ei {
    constructor(t) {
      t = {
        ...Jh.defaultOptions,
        ...t
      };
      const e = Ne.from({
        vertex: {
          source: _u,
          entryPoint: "mainVertex"
        },
        fragment: {
          source: _u,
          entryPoint: "mainFragment"
        }
      }), r = rr.from({
        vertex: Zh,
        fragment: lw,
        name: "alpha-filter"
      }), { alpha: n, ...s } = t, o = new Qt({
        uAlpha: {
          value: n,
          type: "f32"
        }
      });
      super({
        ...s,
        gpuProgram: e,
        glProgram: r,
        resources: {
          alphaUniforms: o
        }
      });
    }
    get alpha() {
      return this.resources.alphaUniforms.uniforms.uAlpha;
    }
    set alpha(t) {
      this.resources.alphaUniforms.uniforms.uAlpha = t;
    }
  };
  hw.defaultOptions = {
    alpha: 1
  };
  let dw = 0;
  class fw {
    constructor(t) {
      this._poolKeyHash = /* @__PURE__ */ Object.create(null), this._texturePool = {}, this.textureOptions = t || {}, this.enableFullScreen = false;
    }
    createTexture(t, e, r) {
      const n = new Ht({
        ...this.textureOptions,
        width: t,
        height: e,
        resolution: 1,
        antialias: r,
        autoGarbageCollect: true
      });
      return new J({
        source: n,
        label: `texturePool_${dw++}`
      });
    }
    getOptimalTexture(t, e, r = 1, n) {
      let s = Math.ceil(t * r - 1e-6), o = Math.ceil(e * r - 1e-6);
      s = $r(s), o = $r(o);
      const a = (s << 17) + (o << 1) + (n ? 1 : 0);
      this._texturePool[a] || (this._texturePool[a] = []);
      let c = this._texturePool[a].pop();
      return c || (c = this.createTexture(s, o, n)), c.source._resolution = r, c.source.width = s / r, c.source.height = o / r, c.source.pixelWidth = s, c.source.pixelHeight = o, c.frame.x = 0, c.frame.y = 0, c.frame.width = t, c.frame.height = e, c.updateUvs(), this._poolKeyHash[c.uid] = a, c;
    }
    getSameSizeTexture(t, e = false) {
      const r = t.source;
      return this.getOptimalTexture(t.width, t.height, r._resolution, e);
    }
    returnTexture(t) {
      const e = this._poolKeyHash[t.uid];
      this._texturePool[e].push(t);
    }
    clear(t) {
      if (t = t !== false, t) for (const e in this._texturePool) {
        const r = this._texturePool[e];
        if (r) for (let n = 0; n < r.length; n++) r[n].destroy(true);
      }
      this._texturePool = {};
    }
  }
  const Jt = new fw(), Qh = {
    5: [
      0.153388,
      0.221461,
      0.250301
    ],
    7: [
      0.071303,
      0.131514,
      0.189879,
      0.214607
    ],
    9: [
      0.028532,
      0.067234,
      0.124009,
      0.179044,
      0.20236
    ],
    11: [
      93e-4,
      0.028002,
      0.065984,
      0.121703,
      0.175713,
      0.198596
    ],
    13: [
      2406e-6,
      9255e-6,
      0.027867,
      0.065666,
      0.121117,
      0.174868,
      0.197641
    ],
    15: [
      489e-6,
      2403e-6,
      9246e-6,
      0.02784,
      0.065602,
      0.120999,
      0.174697,
      0.197448
    ]
  }, pw = [
    "in vec2 vBlurTexCoords[%size%];",
    "uniform sampler2D uTexture;",
    "out vec4 finalColor;",
    "void main(void)",
    "{",
    "    finalColor = vec4(0.0);",
    "    %blur%",
    "}"
  ].join(`
`);
  function _w(i) {
    const t = Qh[i], e = t.length;
    let r = pw, n = "";
    const s = "finalColor += texture(uTexture, vBlurTexCoords[%index%]) * %value%;";
    let o;
    for (let a = 0; a < i; a++) {
      let c = s.replace("%index%", a.toString());
      o = a, a >= e && (o = i - a - 1), c = c.replace("%value%", t[o].toString()), n += c, n += `
`;
    }
    return r = r.replace("%blur%", n), r = r.replace("%size%", i.toString()), r;
  }
  const gw = `
    in vec2 aPosition;

    uniform float uStrength;

    out vec2 vBlurTexCoords[%size%];

    uniform vec4 uInputSize;
    uniform vec4 uOutputFrame;
    uniform vec4 uOutputTexture;

    vec4 filterVertexPosition( void )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
    
    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

    vec2 filterTextureCoord( void )
    {
        return aPosition * (uOutputFrame.zw * uInputSize.zw);
    }

    void main(void)
    {
        gl_Position = filterVertexPosition();

        float pixelStrength = uInputSize.%dimension% * uStrength;

        vec2 textureCoord = filterTextureCoord();
        %blur%
    }`;
  function mw(i, t) {
    const e = Math.ceil(i / 2);
    let r = gw, n = "", s;
    t ? s = "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * pixelStrength, 0.0);" : s = "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * pixelStrength);";
    for (let o = 0; o < i; o++) {
      let a = s.replace("%index%", o.toString());
      a = a.replace("%sampleIndex%", `${o - (e - 1)}.0`), n += a, n += `
`;
    }
    return r = r.replace("%blur%", n), r = r.replace("%size%", i.toString()), r = r.replace("%dimension%", t ? "z" : "w"), r;
  }
  function bw(i, t) {
    const e = mw(t, i), r = _w(t);
    return rr.from({
      vertex: e,
      fragment: r,
      name: `blur-${i ? "horizontal" : "vertical"}-pass-filter`
    });
  }
  var ww = `

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

struct BlurUniforms {
  uStrength:f32,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler : sampler;

@group(1) @binding(0) var<uniform> blurUniforms : BlurUniforms;


struct VSOutput {
    @builtin(position) position: vec4<f32>,
    %blur-struct%
  };

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  
}

fn getSize() -> vec2<f32>
{
  return gfu.uGlobalFrame.zw;
}


@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>, 
) -> VSOutput {

  let filteredCord = filterTextureCoord(aPosition);

  let strength = gfu.uInputSize.w * blurUniforms.uStrength;

  return VSOutput(
   filterVertexPosition(aPosition),
    %blur-vertex-out%
  );
}

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  %blur-fragment-in%
) -> @location(0) vec4<f32> {

    var   finalColor = vec4(0.0);

    %blur-sampling%

    return finalColor;
}`;
  function yw(i, t) {
    const e = Qh[t], r = e.length, n = [], s = [], o = [];
    for (let h = 0; h < t; h++) {
      n[h] = `@location(${h}) offset${h}: vec2<f32>,`, i ? s[h] = `filteredCord + vec2(${h - r + 1} * strength, 0.0),` : s[h] = `filteredCord + vec2(0.0, ${h - r + 1} * strength),`;
      const f = h < r ? h : t - h - 1, p = e[f].toString();
      o[h] = `finalColor += textureSample(uTexture, uSampler, offset${h}) * ${p};`;
    }
    const a = n.join(`
`), c = s.join(`
`), u = o.join(`
`), l = ww.replace("%blur-struct%", a).replace("%blur-vertex-out%", c).replace("%blur-fragment-in%", a).replace("%blur-sampling%", u);
    return Ne.from({
      vertex: {
        source: l,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: l,
        entryPoint: "mainFragment"
      }
    });
  }
  const td = class ed extends ei {
    constructor(t) {
      t = {
        ...ed.defaultOptions,
        ...t
      };
      const e = bw(t.horizontal, t.kernelSize), r = yw(t.horizontal, t.kernelSize);
      super({
        glProgram: e,
        gpuProgram: r,
        resources: {
          blurUniforms: {
            uStrength: {
              value: 0,
              type: "f32"
            }
          }
        },
        ...t
      }), this.horizontal = t.horizontal, this._quality = 0, this.quality = t.quality, this.blur = t.strength, this._uniforms = this.resources.blurUniforms.uniforms;
    }
    apply(t, e, r, n) {
      if (this._uniforms.uStrength = this.strength / this.passes, this.passes === 1) t.applyFilter(this, e, r, n);
      else {
        const s = Jt.getSameSizeTexture(e);
        let o = e, a = s;
        this._state.blend = false;
        for (let c = 0; c < this.passes - 1; c++) {
          t.applyFilter(this, o, a, t.renderer.type === ge.WEBGPU);
          const u = a;
          a = o, o = u;
        }
        this._state.blend = true, t.applyFilter(this, o, r, n), Jt.returnTexture(s);
      }
    }
    get blur() {
      return this.strength;
    }
    set blur(t) {
      this.padding = 1 + Math.abs(t) * 2, this.strength = t;
    }
    get quality() {
      return this._quality;
    }
    set quality(t) {
      this._quality = t, this.passes = t;
    }
  };
  td.defaultOptions = {
    strength: 8,
    quality: 4,
    kernelSize: 5
  };
  let ro = td;
  class xw extends ei {
    constructor(...t) {
      let e = t[0] ?? {};
      typeof e == "number" && (lt(dt, "BlurFilter constructor params are now options object. See params: { strength, quality, resolution, kernelSize }"), e = {
        strength: e
      }, t[1] !== void 0 && (e.quality = t[1]), t[2] !== void 0 && (e.resolution = t[2] || "inherit"), t[3] !== void 0 && (e.kernelSize = t[3])), e = {
        ...ro.defaultOptions,
        ...e
      };
      const { strength: r, quality: n, ...s } = e;
      super({
        ...s,
        compatibleRenderers: ge.BOTH,
        resources: {}
      }), this._repeatEdgePixels = false, this.blurXFilter = new ro({
        horizontal: false,
        ...e
      }), this.blurYFilter = new ro({
        horizontal: true,
        ...e
      }), this.quality = n, this.blur = r, this.repeatEdgePixels = false;
    }
    apply(t, e, r, n) {
      const s = Math.abs(this.blurXFilter.strength), o = Math.abs(this.blurYFilter.strength);
      if (s && o) {
        const a = Jt.getSameSizeTexture(e);
        this.blurXFilter.blendMode = "normal", this.blurXFilter.apply(t, e, a, true), this.blurYFilter.blendMode = this.blendMode, this.blurYFilter.apply(t, a, r, n), Jt.returnTexture(a);
      } else o ? (this.blurYFilter.blendMode = this.blendMode, this.blurYFilter.apply(t, e, r, n)) : (this.blurXFilter.blendMode = this.blendMode, this.blurXFilter.apply(t, e, r, n));
    }
    updatePadding() {
      this._repeatEdgePixels ? this.padding = 0 : this.padding = Math.max(Math.abs(this.blurXFilter.blur), Math.abs(this.blurYFilter.blur)) * 2;
    }
    get blur() {
      return this.blurXFilter.blur;
    }
    set blur(t) {
      this.blurXFilter.blur = this.blurYFilter.blur = t, this.updatePadding();
    }
    get quality() {
      return this.blurXFilter.quality;
    }
    set quality(t) {
      this.blurXFilter.quality = this.blurYFilter.quality = t;
    }
    get blurX() {
      return this.blurXFilter.blur;
    }
    set blurX(t) {
      this.blurXFilter.blur = t, this.updatePadding();
    }
    get blurY() {
      return this.blurYFilter.blur;
    }
    set blurY(t) {
      this.blurYFilter.blur = t, this.updatePadding();
    }
    get repeatEdgePixels() {
      return this._repeatEdgePixels;
    }
    set repeatEdgePixels(t) {
      this._repeatEdgePixels = t, this.updatePadding();
    }
  }
  xw.defaultOptions = {
    strength: 8,
    quality: 4,
    kernelSize: 5
  };
  var vw = `
in vec2 vTextureCoord;
in vec4 vColor;

out vec4 finalColor;

uniform float uNoise;
uniform float uSeed;
uniform sampler2D uTexture;

float rand(vec2 co)
{
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

void main()
{
    vec4 color = texture(uTexture, vTextureCoord);
    float randomValue = rand(gl_FragCoord.xy * uSeed);
    float diff = (randomValue - 0.5) *  uNoise;

    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (color.a > 0.0) {
        color.rgb /= color.a;
    }

    color.r += diff;
    color.g += diff;
    color.b += diff;

    // Premultiply alpha again.
    color.rgb *= color.a;

    finalColor = color;
}
`, gu = `

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

struct NoiseUniforms {
  uNoise:f32,
  uSeed:f32,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler : sampler;

@group(1) @binding(0) var<uniform> noiseUniforms : NoiseUniforms;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>
  };

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  
}

fn getSize() -> vec2<f32>
{
  return gfu.uGlobalFrame.zw;
}
  
@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>, 
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition)
  );
}

fn rand(co:vec2<f32>) -> f32
{
  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}



@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {

    var pixelPosition =  globalTextureCoord(position.xy);// / (getSize());//-  gfu.uOutputFrame.xy);
  
    
    var sample = textureSample(uTexture, uSampler, uv);
    var randomValue =  rand(pixelPosition.xy * noiseUniforms.uSeed);
    var diff = (randomValue - 0.5) * noiseUniforms.uNoise;
  
    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (sample.a > 0.0) {
      sample.r /= sample.a;
      sample.g /= sample.a;
      sample.b /= sample.a;
    }

    sample.r += diff;
    sample.g += diff;
    sample.b += diff;

    // Premultiply alpha again.
    sample.r *= sample.a;
    sample.g *= sample.a;
    sample.b *= sample.a;
    
    return sample;
}`;
  const Sw = class rd extends ei {
    constructor(t = {}) {
      t = {
        ...rd.defaultOptions,
        ...t
      };
      const e = Ne.from({
        vertex: {
          source: gu,
          entryPoint: "mainVertex"
        },
        fragment: {
          source: gu,
          entryPoint: "mainFragment"
        }
      }), r = rr.from({
        vertex: Zh,
        fragment: vw,
        name: "noise-filter"
      }), { noise: n, seed: s, ...o } = t;
      super({
        ...o,
        gpuProgram: e,
        glProgram: r,
        resources: {
          noiseUniforms: new Qt({
            uNoise: {
              value: 1,
              type: "f32"
            },
            uSeed: {
              value: 1,
              type: "f32"
            }
          })
        }
      }), this.noise = n, this.seed = s ?? Math.random();
    }
    get noise() {
      return this.resources.noiseUniforms.uniforms.uNoise;
    }
    set noise(t) {
      this.resources.noiseUniforms.uniforms.uNoise = t;
    }
    get seed() {
      return this.resources.noiseUniforms.uniforms.uSeed;
    }
    set seed(t) {
      this.resources.noiseUniforms.uniforms.uSeed = t;
    }
  };
  Sw.defaultOptions = {
    noise: 0.5
  };
  Ew = class {
    constructor(t) {
      this._renderer = t;
    }
    push(t, e, r) {
      this._renderer.renderPipes.batch.break(r), r.add({
        renderPipeId: "filter",
        canBundle: false,
        action: "pushFilter",
        container: e,
        filterEffect: t
      });
    }
    pop(t, e, r) {
      this._renderer.renderPipes.batch.break(r), r.add({
        renderPipeId: "filter",
        action: "popFilter",
        canBundle: false
      });
    }
    execute(t) {
      t.action === "pushFilter" ? this._renderer.filter.push(t) : t.action === "popFilter" && this._renderer.filter.pop();
    }
    destroy() {
      this._renderer = null;
    }
  };
  Ew.extension = {
    type: [
      P.WebGLPipes,
      P.WebGPUPipes,
      P.CanvasPipes
    ],
    name: "filter"
  };
  const Aw = new nt();
  function Tw(i, t) {
    return t.clear(), id(i, t), t.isValid || t.set(0, 0, 0, 0), i.renderGroup ? t.applyMatrix(i.renderGroup.localTransform) : t.applyMatrix(i.parentRenderGroup.worldTransform), t;
  }
  function id(i, t) {
    if (i.localDisplayStatus !== 7 || !i.measurable) return;
    const e = !!i.effects.length;
    let r = t;
    if ((i.renderGroup || e) && (r = Ke.get().clear()), i.boundsArea) t.addRect(i.boundsArea, i.worldTransform);
    else {
      if (i.renderPipeId) {
        const s = i.bounds;
        r.addFrame(s.minX, s.minY, s.maxX, s.maxY, i.groupTransform);
      }
      const n = i.children;
      for (let s = 0; s < n.length; s++) id(n[s], r);
    }
    if (e) {
      let n = false;
      for (let s = 0; s < i.effects.length; s++) i.effects[s].addBounds && (n || (n = true, r.applyMatrix(i.parentRenderGroup.worldTransform)), i.effects[s].addBounds(r, true));
      n && (r.applyMatrix(i.parentRenderGroup.worldTransform.copyTo(Aw).invert()), t.addBounds(r, i.relativeGroupTransform)), t.addBounds(r), Ke.return(r);
    } else i.renderGroup && (t.addBounds(r, i.relativeGroupTransform), Ke.return(r));
  }
  function Cw(i, t) {
    t.clear();
    const e = t.matrix;
    for (let r = 0; r < i.length; r++) {
      const n = i[r];
      n.globalDisplayStatus < 7 || (t.matrix = n.worldTransform, n.addBounds(t));
    }
    return t.matrix = e, t;
  }
  const Rw = new Ii({
    attributes: {
      aPosition: {
        buffer: new Float32Array([
          0,
          0,
          1,
          0,
          1,
          1,
          0,
          1
        ]),
        location: 0,
        format: "float32x2",
        stride: 2 * 4,
        offset: 0
      }
    },
    indexBuffer: new Uint32Array([
      0,
      1,
      2,
      0,
      2,
      3
    ])
  });
  Pw = class {
    constructor(t) {
      this._filterStackIndex = 0, this._filterStack = [], this._filterGlobalUniforms = new Qt({
        uInputSize: {
          value: new Float32Array(4),
          type: "vec4<f32>"
        },
        uInputPixel: {
          value: new Float32Array(4),
          type: "vec4<f32>"
        },
        uInputClamp: {
          value: new Float32Array(4),
          type: "vec4<f32>"
        },
        uOutputFrame: {
          value: new Float32Array(4),
          type: "vec4<f32>"
        },
        uGlobalFrame: {
          value: new Float32Array(4),
          type: "vec4<f32>"
        },
        uOutputTexture: {
          value: new Float32Array(4),
          type: "vec4<f32>"
        }
      }), this._globalFilterBindGroup = new Ze({}), this.renderer = t;
    }
    get activeBackTexture() {
      var _a2;
      return (_a2 = this._activeFilterData) == null ? void 0 : _a2.backTexture;
    }
    push(t) {
      var _a2;
      const e = this.renderer, r = t.filterEffect.filters;
      this._filterStack[this._filterStackIndex] || (this._filterStack[this._filterStackIndex] = this._getFilterData());
      const n = this._filterStack[this._filterStackIndex];
      if (this._filterStackIndex++, r.length === 0) {
        n.skip = true;
        return;
      }
      const s = n.bounds;
      t.renderables ? Cw(t.renderables, s) : t.filterEffect.filterArea ? (s.clear(), s.addRect(t.filterEffect.filterArea), s.applyMatrix(t.container.worldTransform)) : Tw(t.container, s);
      const o = e.renderTarget.renderTarget.colorTexture.source;
      let a = 1 / 0, c = 0, u = true, l = false, h = false;
      for (let p = 0; p < r.length; p++) {
        const m = r[p];
        if (a = Math.min(a, m.resolution === "inherit" ? o._resolution : m.resolution), c += m.padding, m.antialias === "off" ? u = false : m.antialias === "inherit" && u && (u = o.antialias), !!!(m.compatibleRenderers & e.type)) {
          h = false;
          break;
        }
        if (m.blendRequired && !(((_a2 = e.backBuffer) == null ? void 0 : _a2.useBackBuffer) ?? true)) {
          ut("Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options."), h = false;
          break;
        }
        h = m.enabled || h, l = l || m.blendRequired;
      }
      if (!h) {
        n.skip = true;
        return;
      }
      const f = e.renderTarget.rootViewPort;
      if (s.scale(a).fitBounds(0, f.width, 0, f.height).scale(1 / a).pad(c).ceil(), !s.isPositive) {
        n.skip = true;
        return;
      }
      n.skip = false, n.bounds = s, n.blendRequired = l, n.container = t.container, n.filterEffect = t.filterEffect, n.previousRenderSurface = e.renderTarget.renderSurface, n.inputTexture = Jt.getOptimalTexture(s.width, s.height, a, u), e.renderTarget.bind(n.inputTexture, true), e.globalUniforms.push({
        offset: s
      });
    }
    pop() {
      const t = this.renderer;
      this._filterStackIndex--;
      const e = this._filterStack[this._filterStackIndex];
      if (e.skip) return;
      this._activeFilterData = e;
      const r = e.inputTexture, n = e.bounds;
      let s = J.EMPTY;
      if (t.renderTarget.finishRenderPass(), e.blendRequired) {
        const a = this._filterStackIndex > 0 ? this._filterStack[this._filterStackIndex - 1].bounds : null, c = t.renderTarget.getRenderTarget(e.previousRenderSurface);
        s = this.getBackTexture(c, n, a);
      }
      e.backTexture = s;
      const o = e.filterEffect.filters;
      if (this._globalFilterBindGroup.setResource(r.source.style, 2), this._globalFilterBindGroup.setResource(s.source, 3), t.globalUniforms.pop(), o.length === 1) o[0].apply(this, r, e.previousRenderSurface, false), Jt.returnTexture(r);
      else {
        let a = e.inputTexture, c = Jt.getOptimalTexture(n.width, n.height, a.source._resolution, false), u = 0;
        for (u = 0; u < o.length - 1; ++u) {
          o[u].apply(this, a, c, true);
          const h = a;
          a = c, c = h;
        }
        o[u].apply(this, a, e.previousRenderSurface, false), Jt.returnTexture(a), Jt.returnTexture(c);
      }
      e.blendRequired && Jt.returnTexture(s);
    }
    getBackTexture(t, e, r) {
      const n = t.colorTexture.source._resolution, s = Jt.getOptimalTexture(e.width, e.height, n, false);
      let o = e.minX, a = e.minY;
      r && (o -= r.minX, a -= r.minY), o = Math.floor(o * n), a = Math.floor(a * n);
      const c = Math.ceil(e.width * n), u = Math.ceil(e.height * n);
      return this.renderer.renderTarget.copyToTexture(t, s, {
        x: o,
        y: a
      }, {
        width: c,
        height: u
      }, {
        x: 0,
        y: 0
      }), s;
    }
    applyFilter(t, e, r, n) {
      const s = this.renderer, o = this._filterStack[this._filterStackIndex], a = o.bounds, c = Ct.shared, l = o.previousRenderSurface === r;
      let h = this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution, f = this._filterStackIndex - 1;
      for (; f > 0 && this._filterStack[f].skip; ) --f;
      f > 0 && (h = this._filterStack[f].inputTexture.source._resolution);
      const p = this._filterGlobalUniforms, m = p.uniforms, y = m.uOutputFrame, b = m.uInputSize, v = m.uInputPixel, A = m.uInputClamp, T = m.uGlobalFrame, G = m.uOutputTexture;
      if (l) {
        let L = this._filterStackIndex;
        for (; L > 0; ) {
          L--;
          const W = this._filterStack[this._filterStackIndex - 1];
          if (!W.skip) {
            c.x = W.bounds.minX, c.y = W.bounds.minY;
            break;
          }
        }
        y[0] = a.minX - c.x, y[1] = a.minY - c.y;
      } else y[0] = 0, y[1] = 0;
      y[2] = e.frame.width, y[3] = e.frame.height, b[0] = e.source.width, b[1] = e.source.height, b[2] = 1 / b[0], b[3] = 1 / b[1], v[0] = e.source.pixelWidth, v[1] = e.source.pixelHeight, v[2] = 1 / v[0], v[3] = 1 / v[1], A[0] = 0.5 * v[2], A[1] = 0.5 * v[3], A[2] = e.frame.width * b[2] - 0.5 * v[2], A[3] = e.frame.height * b[3] - 0.5 * v[3];
      const H = this.renderer.renderTarget.rootRenderTarget.colorTexture;
      T[0] = c.x * h, T[1] = c.y * h, T[2] = H.source.width * h, T[3] = H.source.height * h;
      const Y = this.renderer.renderTarget.getRenderTarget(r);
      if (s.renderTarget.bind(r, !!n), r instanceof J ? (G[0] = r.frame.width, G[1] = r.frame.height) : (G[0] = Y.width, G[1] = Y.height), G[2] = Y.isRoot ? -1 : 1, p.update(), s.renderPipes.uniformBatch) {
        const L = s.renderPipes.uniformBatch.getUboResource(p);
        this._globalFilterBindGroup.setResource(L, 0);
      } else this._globalFilterBindGroup.setResource(p, 0);
      this._globalFilterBindGroup.setResource(e.source, 1), this._globalFilterBindGroup.setResource(e.source.style, 2), t.groups[0] = this._globalFilterBindGroup, s.encoder.draw({
        geometry: Rw,
        shader: t,
        state: t._state,
        topology: "triangle-list"
      }), s.type === ge.WEBGL && s.renderTarget.finishRenderPass();
    }
    _getFilterData() {
      return {
        skip: false,
        inputTexture: null,
        bounds: new re(),
        container: null,
        filterEffect: null,
        blendRequired: false,
        previousRenderSurface: null
      };
    }
    calculateSpriteMatrix(t, e) {
      const r = this._activeFilterData, n = t.set(r.inputTexture._source.width, 0, 0, r.inputTexture._source.height, r.bounds.minX, r.bounds.minY), s = e.worldTransform.copyTo(nt.shared);
      return s.invert(), n.prepend(s), n.scale(1 / e.texture.frame.width, 1 / e.texture.frame.height), n.translate(e.anchor.x, e.anchor.y), n;
    }
  };
  Pw.extension = {
    type: [
      P.WebGLSystem,
      P.WebGPUSystem
    ],
    name: "filter"
  };
  var Bw = `in vec2 vMaskCoord;
in vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform sampler2D uMaskTexture;

uniform float uAlpha;
uniform vec4 uMaskClamp;

out vec4 finalColor;

void main(void)
{
    float clip = step(3.5,
        step(uMaskClamp.x, vMaskCoord.x) +
        step(uMaskClamp.y, vMaskCoord.y) +
        step(vMaskCoord.x, uMaskClamp.z) +
        step(vMaskCoord.y, uMaskClamp.w));

    // TODO look into why this is needed
    float npmAlpha = uAlpha; 
    vec4 original = texture(uTexture, vTextureCoord);
    vec4 masky = texture(uMaskTexture, vMaskCoord);
    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);

    original *= (alphaMul * masky.r * uAlpha * clip);

    finalColor = original;
}
`, Mw = `in vec2 aPosition;

out vec2 vTextureCoord;
out vec2 vMaskCoord;


uniform vec4 uInputSize;
uniform vec4 uOutputFrame;
uniform vec4 uOutputTexture;
uniform mat3 uFilterMatrix;

vec4 filterVertexPosition(  vec2 aPosition )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
       
    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

vec2 filterTextureCoord(  vec2 aPosition )
{
    return aPosition * (uOutputFrame.zw * uInputSize.zw);
}

vec2 getFilterCoord( vec2 aPosition )
{
    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;
}   

void main(void)
{
    gl_Position = filterVertexPosition(aPosition);
    vTextureCoord = filterTextureCoord(aPosition);
    vMaskCoord = getFilterCoord(aPosition);
}
`, mu = `struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,  
};

struct MaskUniforms {
  uFilterMatrix:mat3x3<f32>,
  uMaskClamp:vec4<f32>,
  uAlpha:f32,
};


@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler : sampler;

@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;
@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>,
    @location(1) filterUv : vec2<f32>,
  };

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  
}

fn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>
{
  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;
}

fn getSize() -> vec2<f32>
{

  
  return gfu.uGlobalFrame.zw;
}
  
@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>, 
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition),
   getFilterCoord(aPosition)
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @location(1) filterUv: vec2<f32>,
  @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {

    var maskClamp = filterUniforms.uMaskClamp;

     var clip = step(3.5,
        step(maskClamp.x, filterUv.x) +
        step(maskClamp.y, filterUv.y) +
        step(filterUv.x, maskClamp.z) +
        step(filterUv.y, maskClamp.w));

    var mask = textureSample(uMaskTexture, uSampler, filterUv);
    var source = textureSample(uTexture, uSampler, uv);
    
    var npmAlpha = 0.0;

    var alphaMul = 1.0 - npmAlpha * (1.0 - mask.a);

    var a = (alphaMul * mask.r) * clip;

    return vec4(source.rgb, source.a) * a;
}`;
  class Dw extends ei {
    constructor(t) {
      const { sprite: e, ...r } = t, n = new Il(e.texture), s = new Qt({
        uFilterMatrix: {
          value: new nt(),
          type: "mat3x3<f32>"
        },
        uMaskClamp: {
          value: n.uClampFrame,
          type: "vec4<f32>"
        },
        uAlpha: {
          value: 1,
          type: "f32"
        }
      }), o = Ne.from({
        vertex: {
          source: mu,
          entryPoint: "mainVertex"
        },
        fragment: {
          source: mu,
          entryPoint: "mainFragment"
        }
      }), a = rr.from({
        vertex: Mw,
        fragment: Bw,
        name: "mask-filter"
      });
      super({
        ...r,
        gpuProgram: o,
        glProgram: a,
        resources: {
          filterUniforms: s,
          uMaskTexture: e.texture.source
        }
      }), this.sprite = e, this._textureMatrix = n;
    }
    apply(t, e, r, n) {
      this._textureMatrix.texture = this.sprite.texture, t.calculateSpriteMatrix(this.resources.filterUniforms.uniforms.uFilterMatrix, this.sprite).prepend(this._textureMatrix.mapCoord), this.resources.uMaskTexture = this.sprite.texture.source, t.applyFilter(this, e, r, n);
    }
  }
  function bu(i, t, e, r, n, s, o, a) {
    const c = o - e, u = a - r, l = n - e, h = s - r, f = i - e, p = t - r, m = c * c + u * u, y = c * l + u * h, b = c * f + u * p, v = l * l + h * h, A = l * f + h * p, T = 1 / (m * v - y * y), G = (v * b - y * A) * T, H = (m * A - y * b) * T;
    return G >= 0 && H >= 0 && G + H < 1;
  }
  const nd = class sd {
    constructor(t) {
      this._tick = () => {
        this.timeout = setTimeout(this._processQueue, 0);
      }, this._processQueue = () => {
        const { queue: e } = this;
        let r = 0;
        for (; e.length && r < sd.uploadsPerFrame; ) {
          const n = e.shift();
          this.uploadQueueItem(n), r++;
        }
        e.length ? ae.system.addOnce(this._tick, this, hr.UTILITY) : this._resolve();
      }, this.renderer = t, this.queue = [], this.resolves = [];
    }
    getQueue() {
      return [
        ...this.queue
      ];
    }
    add(t) {
      const e = Array.isArray(t) ? t : [
        t
      ];
      for (const r of e) r instanceof Dt ? this._addContainer(r) : this.resolveQueueItem(r, this.queue);
      return this;
    }
    _addContainer(t) {
      this.resolveQueueItem(t, this.queue);
      for (const e of t.children) this._addContainer(e);
    }
    upload(t) {
      return t && this.add(t), new Promise((e) => {
        this.queue.length ? (this.resolves.push(e), this.dedupeQueue(), ae.system.addOnce(this._tick, this, hr.UTILITY)) : e();
      });
    }
    dedupeQueue() {
      const t = /* @__PURE__ */ Object.create(null);
      let e = 0;
      for (let r = 0; r < this.queue.length; r++) {
        const n = this.queue[r];
        t[n.uid] || (t[n.uid] = true, this.queue[e++] = n);
      }
      this.queue.length = e;
    }
    _resolve() {
      const { resolves: t } = this, e = t.slice(0);
      t.length = 0;
      for (const r of e) r();
    }
  };
  nd.uploadsPerFrame = 4;
  let Iw = nd;
  class $e extends Dt {
    constructor(t) {
      t instanceof oe && (t = {
        context: t
      });
      const { context: e, roundPixels: r, ...n } = t || {};
      super({
        label: "Graphics",
        ...n
      }), this.canBundle = true, this.renderPipeId = "graphics", this._roundPixels = 0, e ? this._context = e : this._context = this._ownedContext = new oe(), this._context.on("update", this.onViewUpdate, this), this.allowChildren = false, this.roundPixels = r ?? false;
    }
    set context(t) {
      t !== this._context && (this._context.off("update", this.onViewUpdate, this), this._context = t, this._context.on("update", this.onViewUpdate, this), this.onViewUpdate());
    }
    get context() {
      return this._context;
    }
    get bounds() {
      return this._context.bounds;
    }
    addBounds(t) {
      t.addBounds(this._context.bounds);
    }
    containsPoint(t) {
      return this._context.containsPoint(t);
    }
    get roundPixels() {
      return !!this._roundPixels;
    }
    set roundPixels(t) {
      this._roundPixels = t ? 1 : 0;
    }
    onViewUpdate() {
      if (this._didChangeId += 4096, this._didGraphicsUpdate = true, this.didViewUpdate) return;
      this.didViewUpdate = true;
      const t = this.renderGroup || this.parentRenderGroup;
      t && t.onChildViewUpdate(this);
    }
    destroy(t) {
      this._ownedContext && !t ? this._ownedContext.destroy(t) : (t === true || (t == null ? void 0 : t.context) === true) && this._context.destroy(t), this._ownedContext = null, this._context = null, super.destroy(t);
    }
    _callContextMethod(t, e) {
      return this.context[t](...e), this;
    }
    setFillStyle(...t) {
      return this._callContextMethod("setFillStyle", t);
    }
    setStrokeStyle(...t) {
      return this._callContextMethod("setStrokeStyle", t);
    }
    fill(...t) {
      return this._callContextMethod("fill", t);
    }
    stroke(...t) {
      return this._callContextMethod("stroke", t);
    }
    texture(...t) {
      return this._callContextMethod("texture", t);
    }
    beginPath() {
      return this._callContextMethod("beginPath", []);
    }
    cut() {
      return this._callContextMethod("cut", []);
    }
    arc(...t) {
      return this._callContextMethod("arc", t);
    }
    arcTo(...t) {
      return this._callContextMethod("arcTo", t);
    }
    arcToSvg(...t) {
      return this._callContextMethod("arcToSvg", t);
    }
    bezierCurveTo(...t) {
      return this._callContextMethod("bezierCurveTo", t);
    }
    closePath() {
      return this._callContextMethod("closePath", []);
    }
    ellipse(...t) {
      return this._callContextMethod("ellipse", t);
    }
    circle(...t) {
      return this._callContextMethod("circle", t);
    }
    path(...t) {
      return this._callContextMethod("path", t);
    }
    lineTo(...t) {
      return this._callContextMethod("lineTo", t);
    }
    moveTo(...t) {
      return this._callContextMethod("moveTo", t);
    }
    quadraticCurveTo(...t) {
      return this._callContextMethod("quadraticCurveTo", t);
    }
    rect(...t) {
      return this._callContextMethod("rect", t);
    }
    roundRect(...t) {
      return this._callContextMethod("roundRect", t);
    }
    poly(...t) {
      return this._callContextMethod("poly", t);
    }
    regularPoly(...t) {
      return this._callContextMethod("regularPoly", t);
    }
    roundPoly(...t) {
      return this._callContextMethod("roundPoly", t);
    }
    roundShape(...t) {
      return this._callContextMethod("roundShape", t);
    }
    filletRect(...t) {
      return this._callContextMethod("filletRect", t);
    }
    chamferRect(...t) {
      return this._callContextMethod("chamferRect", t);
    }
    star(...t) {
      return this._callContextMethod("star", t);
    }
    svg(...t) {
      return this._callContextMethod("svg", t);
    }
    restore(...t) {
      return this._callContextMethod("restore", t);
    }
    save() {
      return this._callContextMethod("save", []);
    }
    getTransform() {
      return this.context.getTransform();
    }
    resetTransform() {
      return this._callContextMethod("resetTransform", []);
    }
    rotateTransform(...t) {
      return this._callContextMethod("rotate", t);
    }
    scaleTransform(...t) {
      return this._callContextMethod("scale", t);
    }
    setTransform(...t) {
      return this._callContextMethod("setTransform", t);
    }
    transform(...t) {
      return this._callContextMethod("transform", t);
    }
    translateTransform(...t) {
      return this._callContextMethod("translate", t);
    }
    clear() {
      return this._callContextMethod("clear", []);
    }
    get fillStyle() {
      return this._context.fillStyle;
    }
    set fillStyle(t) {
      this._context.fillStyle = t;
    }
    get strokeStyle() {
      return this._context.strokeStyle;
    }
    set strokeStyle(t) {
      this._context.strokeStyle = t;
    }
    clone(t = false) {
      return t ? new $e(this._context.clone()) : (this._ownedContext = null, new $e(this._context));
    }
    lineStyle(t, e, r) {
      lt(dt, "Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.");
      const n = {};
      return t && (n.width = t), e && (n.color = e), r && (n.alpha = r), this.context.strokeStyle = n, this;
    }
    beginFill(t, e) {
      lt(dt, "Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");
      const r = {};
      return t && (r.color = t), e && (r.alpha = e), this.context.fillStyle = r, this;
    }
    endFill() {
      lt(dt, "Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style."), this.context.fill();
      const t = this.context.strokeStyle;
      return (t.width !== oe.defaultStrokeStyle.width || t.color !== oe.defaultStrokeStyle.color || t.alpha !== oe.defaultStrokeStyle.alpha) && this.context.stroke(), this;
    }
    drawCircle(...t) {
      return lt(dt, "Graphics#drawCircle has been renamed to Graphics#circle"), this._callContextMethod("circle", t);
    }
    drawEllipse(...t) {
      return lt(dt, "Graphics#drawEllipse has been renamed to Graphics#ellipse"), this._callContextMethod("ellipse", t);
    }
    drawPolygon(...t) {
      return lt(dt, "Graphics#drawPolygon has been renamed to Graphics#poly"), this._callContextMethod("poly", t);
    }
    drawRect(...t) {
      return lt(dt, "Graphics#drawRect has been renamed to Graphics#rect"), this._callContextMethod("rect", t);
    }
    drawRoundedRect(...t) {
      return lt(dt, "Graphics#drawRoundedRect has been renamed to Graphics#roundRect"), this._callContextMethod("roundRect", t);
    }
    drawStar(...t) {
      return lt(dt, "Graphics#drawStar has been renamed to Graphics#star"), this._callContextMethod("star", t);
    }
  }
  const od = class ad extends Ii {
    constructor(...t) {
      let e = t[0] ?? {};
      e instanceof Float32Array && (lt(dt, "use new MeshGeometry({ positions, uvs, indices }) instead"), e = {
        positions: e,
        uvs: t[1],
        indices: t[2]
      }), e = {
        ...ad.defaultOptions,
        ...e
      };
      const r = e.positions || new Float32Array([
        0,
        0,
        1,
        0,
        1,
        1,
        0,
        1
      ]), n = e.uvs || new Float32Array([
        0,
        0,
        1,
        0,
        1,
        1,
        0,
        1
      ]), s = e.indices || new Uint32Array([
        0,
        1,
        2,
        0,
        2,
        3
      ]), o = e.shrinkBuffersToFit, a = new Pe({
        data: r,
        label: "attribute-mesh-positions",
        shrinkToFit: o,
        usage: yt.VERTEX | yt.COPY_DST
      }), c = new Pe({
        data: n,
        label: "attribute-mesh-uvs",
        shrinkToFit: o,
        usage: yt.VERTEX | yt.COPY_DST
      }), u = new Pe({
        data: s,
        label: "index-mesh-buffer",
        shrinkToFit: o,
        usage: yt.INDEX | yt.COPY_DST
      });
      super({
        attributes: {
          aPosition: {
            buffer: a,
            format: "float32x2",
            stride: 2 * 4,
            offset: 0
          },
          aUV: {
            buffer: c,
            format: "float32x2",
            stride: 2 * 4,
            offset: 0
          }
        },
        indexBuffer: u,
        topology: e.topology
      }), this.batchMode = "auto";
    }
    get positions() {
      return this.attributes.aPosition.buffer.data;
    }
    set positions(t) {
      this.attributes.aPosition.buffer.data = t;
    }
    get uvs() {
      return this.attributes.aUV.buffer.data;
    }
    set uvs(t) {
      this.attributes.aUV.buffer.data = t;
    }
    get indices() {
      return this.indexBuffer.data;
    }
    set indices(t) {
      this.indexBuffer.data = t;
    }
  };
  od.defaultOptions = {
    topology: "triangle-list",
    shrinkBuffersToFit: false
  };
  let Fi = od;
  class cd extends Dt {
    constructor(...t) {
      let e = t[0];
      e instanceof Ii && (lt(dt, "Mesh: use new Mesh({ geometry, shader }) instead"), e = {
        geometry: e,
        shader: t[1]
      }, t[3] && (lt(dt, "Mesh: drawMode argument has been removed, use geometry.topology instead"), e.geometry.topology = t[3]));
      const { geometry: r, shader: n, texture: s, roundPixels: o, state: a, ...c } = e;
      super({
        label: "Mesh",
        ...c
      }), this.renderPipeId = "mesh", this.canBundle = true, this._shader = null, this._roundPixels = 0, this.allowChildren = false, this.shader = n ?? null, this.texture = s ?? (n == null ? void 0 : n.texture) ?? J.WHITE, this.state = a ?? Le.for2d(), this._geometry = r, this._geometry.on("update", this.onViewUpdate, this), this.roundPixels = o ?? false;
    }
    get roundPixels() {
      return !!this._roundPixels;
    }
    set roundPixels(t) {
      this._roundPixels = t ? 1 : 0;
    }
    get material() {
      return lt(dt, "mesh.material property has been removed, use mesh.shader instead"), this._shader;
    }
    set shader(t) {
      this._shader !== t && (this._shader = t, this.onViewUpdate());
    }
    get shader() {
      return this._shader;
    }
    set geometry(t) {
      var _a2;
      this._geometry !== t && ((_a2 = this._geometry) == null ? void 0 : _a2.off("update", this.onViewUpdate, this), t.on("update", this.onViewUpdate, this), this._geometry = t, this.onViewUpdate());
    }
    get geometry() {
      return this._geometry;
    }
    set texture(t) {
      t || (t = J.EMPTY);
      const e = this._texture;
      e !== t && (e && e.dynamic && e.off("update", this.onViewUpdate, this), t.dynamic && t.on("update", this.onViewUpdate, this), this.shader && (this.shader.texture = t), this._texture = t, this.onViewUpdate());
    }
    get texture() {
      return this._texture;
    }
    get batched() {
      return this._shader ? false : this._geometry instanceof Fi ? this._geometry.batchMode === "auto" ? this._geometry.positions.length / 2 <= 100 : this._geometry.batchMode === "batch" : false;
    }
    get bounds() {
      return this._geometry.bounds;
    }
    addBounds(t) {
      t.addBounds(this.geometry.bounds);
    }
    containsPoint(t) {
      const { x: e, y: r } = t;
      if (!this.bounds.containsPoint(e, r)) return false;
      const n = this.geometry.getBuffer("aPosition").data, s = this.geometry.topology === "triangle-strip" ? 3 : 1;
      if (this.geometry.getIndex()) {
        const o = this.geometry.getIndex().data, a = o.length;
        for (let c = 0; c + 2 < a; c += s) {
          const u = o[c] * 2, l = o[c + 1] * 2, h = o[c + 2] * 2;
          if (bu(e, r, n[u], n[u + 1], n[l], n[l + 1], n[h], n[h + 1])) return true;
        }
      } else {
        const o = n.length / 2;
        for (let a = 0; a + 2 < o; a += s) {
          const c = a * 2, u = (a + 1) * 2, l = (a + 2) * 2;
          if (bu(e, r, n[c], n[c + 1], n[u], n[u + 1], n[l], n[l + 1])) return true;
        }
      }
      return false;
    }
    onViewUpdate() {
      if (this._didChangeId += 4096, this.didViewUpdate) return;
      this.didViewUpdate = true;
      const t = this.renderGroup || this.parentRenderGroup;
      t && t.onChildViewUpdate(this);
    }
    destroy(t) {
      var _a2;
      if (super.destroy(t), typeof t == "boolean" ? t : t == null ? void 0 : t.texture) {
        const r = typeof t == "boolean" ? t : t == null ? void 0 : t.textureSource;
        this._texture.destroy(r);
      }
      (_a2 = this._geometry) == null ? void 0 : _a2.off("update", this.onViewUpdate, this), this._texture = null, this._geometry = null, this._shader = null;
    }
  }
  class On extends lr {
    constructor(t, e = true) {
      super(t[0] instanceof J ? t[0] : t[0].texture), this._textures = null, this._durations = null, this._autoUpdate = e, this._isConnectedToTicker = false, this.animationSpeed = 1, this.loop = true, this.updateAnchor = false, this.onComplete = null, this.onFrameChange = null, this.onLoop = null, this._currentTime = 0, this._playing = false, this._previousFrame = null, this.textures = t;
    }
    stop() {
      this._playing && (this._playing = false, this._autoUpdate && this._isConnectedToTicker && (ae.shared.remove(this.update, this), this._isConnectedToTicker = false));
    }
    play() {
      this._playing || (this._playing = true, this._autoUpdate && !this._isConnectedToTicker && (ae.shared.add(this.update, this, hr.HIGH), this._isConnectedToTicker = true));
    }
    gotoAndStop(t) {
      this.stop(), this.currentFrame = t;
    }
    gotoAndPlay(t) {
      this.currentFrame = t, this.play();
    }
    update(t) {
      if (!this._playing) return;
      const e = t.deltaTime, r = this.animationSpeed * e, n = this.currentFrame;
      if (this._durations !== null) {
        let s = this._currentTime % 1 * this._durations[this.currentFrame];
        for (s += r / 60 * 1e3; s < 0; ) this._currentTime--, s += this._durations[this.currentFrame];
        const o = Math.sign(this.animationSpeed * e);
        for (this._currentTime = Math.floor(this._currentTime); s >= this._durations[this.currentFrame]; ) s -= this._durations[this.currentFrame] * o, this._currentTime += o;
        this._currentTime += s / this._durations[this.currentFrame];
      } else this._currentTime += r;
      this._currentTime < 0 && !this.loop ? (this.gotoAndStop(0), this.onComplete && this.onComplete()) : this._currentTime >= this._textures.length && !this.loop ? (this.gotoAndStop(this._textures.length - 1), this.onComplete && this.onComplete()) : n !== this.currentFrame && (this.loop && this.onLoop && (this.animationSpeed > 0 && this.currentFrame < n || this.animationSpeed < 0 && this.currentFrame > n) && this.onLoop(), this._updateTexture());
    }
    _updateTexture() {
      const t = this.currentFrame;
      this._previousFrame !== t && (this._previousFrame = t, this.texture = this._textures[t], this.updateAnchor && this.anchor.copyFrom(this.texture.defaultAnchor), this.onFrameChange && this.onFrameChange(this.currentFrame));
    }
    destroy() {
      this.stop(), super.destroy(), this.onComplete = null, this.onFrameChange = null, this.onLoop = null;
    }
    static fromFrames(t) {
      const e = [];
      for (let r = 0; r < t.length; ++r) e.push(J.from(t[r]));
      return new On(e);
    }
    static fromImages(t) {
      const e = [];
      for (let r = 0; r < t.length; ++r) e.push(J.from(t[r]));
      return new On(e);
    }
    get totalFrames() {
      return this._textures.length;
    }
    get textures() {
      return this._textures;
    }
    set textures(t) {
      if (t[0] instanceof J) this._textures = t, this._durations = null;
      else {
        this._textures = [], this._durations = [];
        for (let e = 0; e < t.length; e++) this._textures.push(t[e].texture), this._durations.push(t[e].time);
      }
      this._previousFrame = null, this.gotoAndStop(0), this._updateTexture();
    }
    get currentFrame() {
      let t = Math.floor(this._currentTime) % this._textures.length;
      return t < 0 && (t += this._textures.length), t;
    }
    set currentFrame(t) {
      if (t < 0 || t > this.totalFrames - 1) throw new Error(`[AnimatedSprite]: Invalid frame index value ${t}, expected to be between 0 and totalFrames ${this.totalFrames}.`);
      const e = this.currentFrame;
      this._currentTime = t, e !== this.currentFrame && this._updateTexture();
    }
    get playing() {
      return this._playing;
    }
    get autoUpdate() {
      return this._autoUpdate;
    }
    set autoUpdate(t) {
      t !== this._autoUpdate && (this._autoUpdate = t, !this._autoUpdate && this._isConnectedToTicker ? (ae.shared.remove(this.update, this), this._isConnectedToTicker = false) : this._autoUpdate && !this._isConnectedToTicker && this._playing && (ae.shared.add(this.update, this), this._isConnectedToTicker = true));
    }
  }
  class Fw {
    constructor({ matrix: t, observer: e } = {}) {
      this.dirty = true, this._matrix = t ?? new nt(), this.observer = e, this.position = new Xt(this, 0, 0), this.scale = new Xt(this, 1, 1), this.pivot = new Xt(this, 0, 0), this.skew = new Xt(this, 0, 0), this._rotation = 0, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1;
    }
    get matrix() {
      const t = this._matrix;
      return this.dirty && (t.a = this._cx * this.scale.x, t.b = this._sx * this.scale.x, t.c = this._cy * this.scale.y, t.d = this._sy * this.scale.y, t.tx = this.position.x - (this.pivot.x * t.a + this.pivot.y * t.c), t.ty = this.position.y - (this.pivot.x * t.b + this.pivot.y * t.d), this.dirty = false), t;
    }
    _onUpdate(t) {
      var _a2;
      this.dirty = true, t === this.skew && this.updateSkew(), (_a2 = this.observer) == null ? void 0 : _a2._onUpdate(this);
    }
    updateSkew() {
      this._cx = Math.cos(this._rotation + this.skew.y), this._sx = Math.sin(this._rotation + this.skew.y), this._cy = -Math.sin(this._rotation - this.skew.x), this._sy = Math.cos(this._rotation - this.skew.x), this.dirty = true;
    }
    toString() {
      return `[pixi.js/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`;
    }
    setFromMatrix(t) {
      t.decompose(this), this.dirty = true;
    }
    get rotation() {
      return this._rotation;
    }
    set rotation(t) {
      this._rotation !== t && (this._rotation = t, this._onUpdate(this.skew));
    }
  }
  const ud = class Sn extends Dt {
    constructor(...t) {
      let e = t[0] || {};
      e instanceof J && (e = {
        texture: e
      }), t.length > 1 && (lt(dt, "use new TilingSprite({ texture, width:100, height:100 }) instead"), e.width = t[1], e.height = t[2]), e = {
        ...Sn.defaultOptions,
        ...e
      };
      const { texture: r, anchor: n, tilePosition: s, tileScale: o, tileRotation: a, width: c, height: u, applyAnchorToTexture: l, roundPixels: h, ...f } = e ?? {};
      super({
        label: "TilingSprite",
        ...f
      }), this.renderPipeId = "tilingSprite", this.canBundle = true, this.batched = true, this._roundPixels = 0, this._bounds = {
        minX: 0,
        maxX: 1,
        minY: 0,
        maxY: 0
      }, this._boundsDirty = true, this.allowChildren = false, this._anchor = new Xt({
        _onUpdate: () => {
          this.onViewUpdate();
        }
      }), this._applyAnchorToTexture = l, this.texture = r, this._width = c ?? r.width, this._height = u ?? r.height, this._tileTransform = new Fw({
        observer: {
          _onUpdate: () => this.onViewUpdate()
        }
      }), n && (this.anchor = n), this.tilePosition = s, this.tileScale = o, this.tileRotation = a, this.roundPixels = h ?? false;
    }
    static from(t, e = {}) {
      return typeof t == "string" ? new Sn({
        texture: Tt.get(t),
        ...e
      }) : new Sn({
        texture: t,
        ...e
      });
    }
    get clampMargin() {
      return this._texture.textureMatrix.clampMargin;
    }
    set clampMargin(t) {
      this._texture.textureMatrix.clampMargin = t;
    }
    get anchor() {
      return this._anchor;
    }
    set anchor(t) {
      typeof t == "number" ? this._anchor.set(t) : this._anchor.copyFrom(t);
    }
    get tilePosition() {
      return this._tileTransform.position;
    }
    set tilePosition(t) {
      this._tileTransform.position.copyFrom(t);
    }
    get tileScale() {
      return this._tileTransform.scale;
    }
    set tileScale(t) {
      typeof t == "number" ? this._tileTransform.scale.set(t) : this._tileTransform.scale.copyFrom(t);
    }
    set tileRotation(t) {
      this._tileTransform.rotation = t;
    }
    get tileRotation() {
      return this._tileTransform.rotation;
    }
    get tileTransform() {
      return this._tileTransform;
    }
    get roundPixels() {
      return !!this._roundPixels;
    }
    set roundPixels(t) {
      this._roundPixels = t ? 1 : 0;
    }
    get bounds() {
      return this._boundsDirty && (this._updateBounds(), this._boundsDirty = false), this._bounds;
    }
    set texture(t) {
      t || (t = J.EMPTY);
      const e = this._texture;
      e !== t && (e && e.dynamic && e.off("update", this.onViewUpdate, this), t.dynamic && t.on("update", this.onViewUpdate, this), this._texture = t, this.onViewUpdate());
    }
    get texture() {
      return this._texture;
    }
    set width(t) {
      this._width = t, this.onViewUpdate();
    }
    get width() {
      return this._width;
    }
    set height(t) {
      this._height = t, this.onViewUpdate();
    }
    get height() {
      return this._height;
    }
    _updateBounds() {
      const t = this._bounds, e = this._anchor, r = this._width, n = this._height;
      t.maxX = -e._x * r, t.minX = t.maxX + r, t.maxY = -e._y * n, t.minY = t.maxY + n;
    }
    addBounds(t) {
      const e = this.bounds;
      t.addFrame(e.minX, e.minY, e.maxX, e.maxY);
    }
    containsPoint(t) {
      const e = this._width, r = this._height, n = -e * this._anchor._x;
      let s = 0;
      return t.x >= n && t.x <= n + e && (s = -r * this._anchor._y, t.y >= s && t.y <= s + r);
    }
    onViewUpdate() {
      if (this._boundsDirty = true, this._didTilingSpriteUpdate = true, this._didChangeId += 4096, this.didViewUpdate) return;
      this.didViewUpdate = true;
      const t = this.renderGroup || this.parentRenderGroup;
      t && t.onChildViewUpdate(this);
    }
    destroy(t = false) {
      if (super.destroy(t), this._anchor = null, this._tileTransform = null, this._bounds = null, typeof t == "boolean" ? t : t == null ? void 0 : t.texture) {
        const r = typeof t == "boolean" ? t : t == null ? void 0 : t.textureSource;
        this._texture.destroy(r);
      }
      this._texture = null;
    }
  };
  ud.defaultOptions = {
    texture: J.EMPTY,
    anchor: {
      x: 0,
      y: 0
    },
    tilePosition: {
      x: 0,
      y: 0
    },
    tileScale: {
      x: 1,
      y: 1
    },
    tileRotation: 0,
    applyAnchorToTexture: false
  };
  let Uw = ud;
  class pa extends Dt {
    constructor(t, e) {
      const { text: r, resolution: n, style: s, anchor: o, width: a, height: c, roundPixels: u, ...l } = t;
      super({
        ...l
      }), this.batched = true, this._resolution = null, this._autoResolution = true, this._didTextUpdate = true, this._roundPixels = 0, this._bounds = new re(), this._boundsDirty = true, this._styleClass = e, this.text = r ?? "", this.style = s, this.resolution = n ?? null, this.allowChildren = false, this._anchor = new Xt({
        _onUpdate: () => {
          this.onViewUpdate();
        }
      }), o && (this.anchor = o), this.roundPixels = u ?? false, a !== void 0 && (this.width = a), c !== void 0 && (this.height = c);
    }
    get anchor() {
      return this._anchor;
    }
    set anchor(t) {
      typeof t == "number" ? this._anchor.set(t) : this._anchor.copyFrom(t);
    }
    get roundPixels() {
      return !!this._roundPixels;
    }
    set roundPixels(t) {
      this._roundPixels = t ? 1 : 0;
    }
    set text(t) {
      t = t.toString(), this._text !== t && (this._text = t, this.onViewUpdate());
    }
    get text() {
      return this._text;
    }
    set resolution(t) {
      this._autoResolution = t === null, this._resolution = t, this.onViewUpdate();
    }
    get resolution() {
      return this._resolution;
    }
    get style() {
      return this._style;
    }
    set style(t) {
      var _a2;
      t = t || {}, (_a2 = this._style) == null ? void 0 : _a2.off("update", this.onViewUpdate, this), t instanceof this._styleClass ? this._style = t : this._style = new this._styleClass(t), this._style.on("update", this.onViewUpdate, this), this.onViewUpdate();
    }
    get bounds() {
      return this._boundsDirty && (this._updateBounds(), this._boundsDirty = false), this._bounds;
    }
    get width() {
      return Math.abs(this.scale.x) * this.bounds.width;
    }
    set width(t) {
      this._setWidth(t, this.bounds.width);
    }
    get height() {
      return Math.abs(this.scale.y) * this.bounds.height;
    }
    set height(t) {
      this._setHeight(t, this.bounds.height);
    }
    getSize(t) {
      return t || (t = {}), t.width = Math.abs(this.scale.x) * this.bounds.width, t.height = Math.abs(this.scale.y) * this.bounds.height, t;
    }
    setSize(t, e) {
      let r, n;
      typeof t != "object" ? (r = t, n = e ?? t) : (r = t.width, n = t.height ?? t.width), r !== void 0 && this._setWidth(r, this.bounds.width), n !== void 0 && this._setHeight(n, this.bounds.height);
    }
    addBounds(t) {
      const e = this.bounds;
      t.addFrame(e.minX, e.minY, e.maxX, e.maxY);
    }
    containsPoint(t) {
      const e = this.bounds.width, r = this.bounds.height, n = -e * this.anchor.x;
      let s = 0;
      return t.x >= n && t.x <= n + e && (s = -r * this.anchor.y, t.y >= s && t.y <= s + r);
    }
    onViewUpdate() {
      if (this._didChangeId += 4096, this._boundsDirty = true, this.didViewUpdate) return;
      this.didViewUpdate = true, this._didTextUpdate = true;
      const t = this.renderGroup || this.parentRenderGroup;
      t && t.onChildViewUpdate(this);
    }
    _getKey() {
      return `${this.text}:${this._style.styleKey}:${this._resolution}`;
    }
    destroy(t = false) {
      super.destroy(t), this.owner = null, this._bounds = null, this._anchor = null, (typeof t == "boolean" ? t : t == null ? void 0 : t.style) && this._style.destroy(t), this._style = null, this._text = null;
    }
  }
  function _a(i, t) {
    let e = i[0] ?? {};
    return (typeof e == "string" || i[1]) && (lt(dt, `use new ${t}({ text: "hi!", style }) instead`), e = {
      text: e,
      style: i[1]
    }), e;
  }
  class ld extends pa {
    constructor(...t) {
      const e = _a(t, "Text");
      super(e, Oe), this.renderPipeId = "text";
    }
    _updateBounds() {
      const t = this._bounds, e = this._anchor, r = Ge.measureText(this._text, this._style), { width: n, height: s } = r;
      t.minX = -e._x * n, t.maxX = t.minX + n, t.minY = -e._y * s, t.maxY = t.minY + s;
    }
  }
  class kw extends Iw {
    resolveQueueItem(t, e) {
      return t instanceof Dt ? this.resolveContainerQueueItem(t, e) : t instanceof Ht || t instanceof J ? e.push(t.source) : t instanceof oe && e.push(t), null;
    }
    resolveContainerQueueItem(t, e) {
      t instanceof lr || t instanceof Uw || t instanceof cd ? e.push(t.texture.source) : t instanceof ld ? e.push(t) : t instanceof $e ? e.push(t.context) : t instanceof On && t.textures.forEach((r) => {
        r.source ? e.push(r.source) : e.push(r.texture.source);
      });
    }
    resolveGraphicsContextQueueItem(t) {
      this.renderer.graphicsContext.getContextRenderData(t);
      const { instructions: e } = t;
      for (const r of e) if (r.action === "texture") {
        const { image: n } = r.data;
        return n.source;
      } else if (r.action === "fill") {
        const { texture: n } = r.data.style;
        return n.source;
      }
      return null;
    }
  }
  class Gw extends pa {
    constructor(...t) {
      var e;
      const r = _a(t, "BitmapText");
      r.style ?? (r.style = r.style || {}), (e = r.style).fill ?? (e.fill = 16777215), super(r, Oe), this.renderPipeId = "bitmapText";
    }
    _updateBounds() {
      const t = this._bounds, e = this._anchor, r = kn.measureText(this.text, this._style), n = r.scale, s = r.offsetY * n;
      let o = r.width * n, a = r.height * n;
      const c = this._style._stroke;
      c && (o += c.width, a += c.width), t.minX = -e._x * o, t.maxX = t.minX + o, t.minY = -e._y * (a + s), t.maxY = t.minY + a;
    }
  }
  function Ow(i) {
    const t = i._stroke, e = i._fill, n = [
      `div { ${[
        `color: ${At.shared.setValue(e.color).toHex()}`,
        `font-size: ${i.fontSize}px`,
        `font-family: ${i.fontFamily}`,
        `font-weight: ${i.fontWeight}`,
        `font-style: ${i.fontStyle}`,
        `font-variant: ${i.fontVariant}`,
        `letter-spacing: ${i.letterSpacing}px`,
        `text-align: ${i.align}`,
        `padding: ${i.padding}px`,
        `white-space: ${i.whiteSpace === "pre" && i.wordWrap ? "pre-wrap" : i.whiteSpace}`,
        ...i.lineHeight ? [
          `line-height: ${i.lineHeight}px`
        ] : [],
        ...i.wordWrap ? [
          `word-wrap: ${i.breakWords ? "break-all" : "break-word"}`,
          `max-width: ${i.wordWrapWidth}px`
        ] : [],
        ...t ? [
          dd(t)
        ] : [],
        ...i.dropShadow ? [
          hd(i.dropShadow)
        ] : [],
        ...i.cssOverrides
      ].join(";")} }`
    ];
    return Nw(i.tagStyles, n), n.join(" ");
  }
  function hd(i) {
    const t = At.shared.setValue(i.color).setAlpha(i.alpha).toHexa(), e = Math.round(Math.cos(i.angle) * i.distance), r = Math.round(Math.sin(i.angle) * i.distance), n = `${e}px ${r}px`;
    return i.blur > 0 ? `text-shadow: ${n} ${i.blur}px ${t}` : `text-shadow: ${n} ${t}`;
  }
  function dd(i) {
    return [
      `-webkit-text-stroke-width: ${i.width}px`,
      `-webkit-text-stroke-color: ${At.shared.setValue(i.color).toHex()}`,
      `text-stroke-width: ${i.width}px`,
      `text-stroke-color: ${At.shared.setValue(i.color).toHex()}`,
      "paint-order: stroke"
    ].join(";");
  }
  const wu = {
    fontSize: "font-size: {{VALUE}}px",
    fontFamily: "font-family: {{VALUE}}",
    fontWeight: "font-weight: {{VALUE}}",
    fontStyle: "font-style: {{VALUE}}",
    fontVariant: "font-variant: {{VALUE}}",
    letterSpacing: "letter-spacing: {{VALUE}}px",
    align: "text-align: {{VALUE}}",
    padding: "padding: {{VALUE}}px",
    whiteSpace: "white-space: {{VALUE}}",
    lineHeight: "line-height: {{VALUE}}px",
    wordWrapWidth: "max-width: {{VALUE}}px"
  }, yu = {
    fill: (i) => `color: ${At.shared.setValue(i).toHex()}`,
    breakWords: (i) => `word-wrap: ${i ? "break-all" : "break-word"}`,
    stroke: dd,
    dropShadow: hd
  };
  function Nw(i, t) {
    for (const e in i) {
      const r = i[e], n = [];
      for (const s in r) yu[s] ? n.push(yu[s](r[s])) : wu[s] && n.push(wu[s].replace("{{VALUE}}", r[s]));
      t.push(`${e} { ${n.join(";")} }`);
    }
  }
  class rs extends Oe {
    constructor(t = {}) {
      super(t), this._cssOverrides = [], this.cssOverrides ?? (this.cssOverrides = t.cssOverrides), this.tagStyles = t.tagStyles ?? {};
    }
    set cssOverrides(t) {
      this._cssOverrides = t instanceof Array ? t : [
        t
      ], this.update();
    }
    get cssOverrides() {
      return this._cssOverrides;
    }
    _generateKey() {
      return this._styleKey = Mh(this) + this._cssOverrides.join("-"), this._styleKey;
    }
    update() {
      this._cssStyle = null, super.update();
    }
    clone() {
      return new rs({
        align: this.align,
        breakWords: this.breakWords,
        dropShadow: this.dropShadow ? {
          ...this.dropShadow
        } : null,
        fill: this._fill,
        fontFamily: this.fontFamily,
        fontSize: this.fontSize,
        fontStyle: this.fontStyle,
        fontVariant: this.fontVariant,
        fontWeight: this.fontWeight,
        letterSpacing: this.letterSpacing,
        lineHeight: this.lineHeight,
        padding: this.padding,
        stroke: this._stroke,
        whiteSpace: this.whiteSpace,
        wordWrap: this.wordWrap,
        wordWrapWidth: this.wordWrapWidth,
        cssOverrides: this.cssOverrides
      });
    }
    get cssStyle() {
      return this._cssStyle || (this._cssStyle = Ow(this)), this._cssStyle;
    }
    addOverride(...t) {
      const e = t.filter((r) => !this.cssOverrides.includes(r));
      e.length > 0 && (this.cssOverrides.push(...e), this.update());
    }
    removeOverride(...t) {
      const e = t.filter((r) => this.cssOverrides.includes(r));
      e.length > 0 && (this.cssOverrides = this.cssOverrides.filter((r) => !e.includes(r)), this.update());
    }
    set fill(t) {
      typeof t != "string" && typeof t != "number" && ut("[HTMLTextStyle] only color fill is not supported by HTMLText"), super.fill = t;
    }
    set stroke(t) {
      t && typeof t != "string" && typeof t != "number" && ut("[HTMLTextStyle] only color stroke is not supported by HTMLText"), super.stroke = t;
    }
  }
  const xu = "http://www.w3.org/2000/svg", vu = "http://www.w3.org/1999/xhtml";
  class fd {
    constructor() {
      this.svgRoot = document.createElementNS(xu, "svg"), this.foreignObject = document.createElementNS(xu, "foreignObject"), this.domElement = document.createElementNS(vu, "div"), this.styleElement = document.createElementNS(vu, "style"), this.image = new Image();
      const { foreignObject: t, svgRoot: e, styleElement: r, domElement: n } = this;
      t.setAttribute("width", "10000"), t.setAttribute("height", "10000"), t.style.overflow = "hidden", e.appendChild(t), t.appendChild(r), t.appendChild(n);
    }
  }
  let Su;
  function pd(i, t, e, r) {
    r = r || Su || (Su = new fd());
    const { domElement: n, styleElement: s, svgRoot: o } = r;
    n.innerHTML = `<style>${t.cssStyle};</style><div style='padding:0'>${i}</div>`, n.setAttribute("style", "transform-origin: top left; display: inline-block"), e && (s.textContent = e), document.body.appendChild(o);
    const a = n.getBoundingClientRect();
    o.remove();
    const c = Ge.measureFont(t.fontStyle).descent, u = t.padding * 2;
    return {
      width: a.width - u,
      height: a.height + c - u
    };
  }
  class Lw extends pa {
    constructor(...t) {
      const e = _a(t, "HtmlText");
      super(e, rs), this.renderPipeId = "htmlText";
    }
    _updateBounds() {
      const t = this._bounds, e = this._anchor, r = pd(this.text, this._style), { width: n, height: s } = r;
      t.minX = -e._x * n, t.maxX = t.minX + n, t.minY = -e._y * s, t.maxY = t.minY + s;
    }
  }
  class Hw extends kw {
    uploadQueueItem(t) {
      t instanceof Ht ? this.uploadTextureSource(t) : t instanceof ld ? this.uploadText(t) : t instanceof Lw ? this.uploadHTMLText(t) : t instanceof Gw ? this.uploadBitmapText(t) : t instanceof oe && this.uploadGraphicsContext(t);
    }
    uploadTextureSource(t) {
      this.renderer.texture.initSource(t);
    }
    uploadText(t) {
      this.renderer.renderPipes.text.initGpuText(t);
    }
    uploadBitmapText(t) {
      this.renderer.renderPipes.bitmapText.initGpuText(t);
    }
    uploadHTMLText(t) {
      this.renderer.renderPipes.htmlText.initGpuText(t);
    }
    uploadGraphicsContext(t) {
      this.renderer.graphicsContext.getContextRenderData(t);
      const { instructions: e } = t;
      for (const r of e) if (r.action === "texture") {
        const { image: n } = r.data;
        this.uploadTextureSource(n.source);
      } else if (r.action === "fill") {
        const { texture: n } = r.data.style;
        this.uploadTextureSource(n.source);
      }
      return null;
    }
  }
  class zw extends Hw {
    destroy() {
      clearTimeout(this.timeout), this.renderer = null, this.queue = null, this.resolves = null;
    }
  }
  zw.extension = {
    type: [
      P.WebGLSystem,
      P.WebGPUSystem
    ],
    name: "prepare"
  };
  function Eu(i, t, e) {
    if (i) for (const r in i) {
      const n = r.toLocaleLowerCase(), s = t[n];
      if (s) {
        let o = i[r];
        r === "header" && (o = o.replace(/@in\s+[^;]+;\s*/g, "").replace(/@out\s+[^;]+;\s*/g, "")), e && s.push(`//----${e}----//`), s.push(o);
      } else ut(`${r} placement hook does not exist in shader`);
    }
  }
  const jw = /\{\{(.*?)\}\}/g;
  function Au(i) {
    var _a2;
    const t = {};
    return (((_a2 = i.match(jw)) == null ? void 0 : _a2.map((r) => r.replace(/[{()}]/g, ""))) ?? []).forEach((r) => {
      t[r] = [];
    }), t;
  }
  function Tu(i, t) {
    let e;
    const r = /@in\s+([^;]+);/g;
    for (; (e = r.exec(i)) !== null; ) t.push(e[1]);
  }
  function Cu(i, t, e = false) {
    const r = [];
    Tu(t, r), i.forEach((a) => {
      a.header && Tu(a.header, r);
    });
    const n = r;
    e && n.sort();
    const s = n.map((a, c) => `       @location(${c}) ${a},`).join(`
`);
    let o = t.replace(/@in\s+[^;]+;\s*/g, "");
    return o = o.replace("{{in}}", `
${s}
`), o;
  }
  function Ru(i, t) {
    let e;
    const r = /@out\s+([^;]+);/g;
    for (; (e = r.exec(i)) !== null; ) t.push(e[1]);
  }
  function Ww(i) {
    const e = /\b(\w+)\s*:/g.exec(i);
    return e ? e[1] : "";
  }
  function Vw(i) {
    const t = /@.*?\s+/g;
    return i.replace(t, "");
  }
  function Xw(i, t) {
    const e = [];
    Ru(t, e), i.forEach((c) => {
      c.header && Ru(c.header, e);
    });
    let r = 0;
    const n = e.sort().map((c) => c.indexOf("builtin") > -1 ? c : `@location(${r++}) ${c}`).join(`,
`), s = e.sort().map((c) => `       var ${Vw(c)};`).join(`
`), o = `return VSOutput(
                ${e.sort().map((c) => ` ${Ww(c)}`).join(`,
`)});`;
    let a = t.replace(/@out\s+[^;]+;\s*/g, "");
    return a = a.replace("{{struct}}", `
${n}
`), a = a.replace("{{start}}", `
${s}
`), a = a.replace("{{return}}", `
${o}
`), a;
  }
  function Pu(i, t) {
    let e = i;
    for (const r in t) {
      const n = t[r];
      n.join(`
`).length ? e = e.replace(`{{${r}}}`, `//-----${r} START-----//
${n.join(`
`)}
//----${r} FINISH----//`) : e = e.replace(`{{${r}}}`, "");
    }
    return e;
  }
  const cr = /* @__PURE__ */ Object.create(null), io = /* @__PURE__ */ new Map();
  let qw = 0;
  function $w({ template: i, bits: t }) {
    const e = _d(i, t);
    if (cr[e]) return cr[e];
    const { vertex: r, fragment: n } = Kw(i, t);
    return cr[e] = gd(r, n, t), cr[e];
  }
  function Yw({ template: i, bits: t }) {
    const e = _d(i, t);
    return cr[e] || (cr[e] = gd(i.vertex, i.fragment, t)), cr[e];
  }
  function Kw(i, t) {
    const e = t.map((o) => o.vertex).filter((o) => !!o), r = t.map((o) => o.fragment).filter((o) => !!o);
    let n = Cu(e, i.vertex, true);
    n = Xw(e, n);
    const s = Cu(r, i.fragment, true);
    return {
      vertex: n,
      fragment: s
    };
  }
  function _d(i, t) {
    return t.map((e) => (io.has(e) || io.set(e, qw++), io.get(e))).sort((e, r) => e - r).join("-") + i.vertex + i.fragment;
  }
  function gd(i, t, e) {
    const r = Au(i), n = Au(t);
    return e.forEach((s) => {
      Eu(s.vertex, r, s.name), Eu(s.fragment, n, s.name);
    }), {
      vertex: Pu(i, r),
      fragment: Pu(t, n)
    };
  }
  const Zw = `
    @in aPosition: vec2<f32>;
    @in aUV: vec2<f32>;

    @out @builtin(position) vPosition: vec4<f32>;
    @out vUV : vec2<f32>;
    @out vColor : vec4<f32>;

    {{header}}

    struct VSOutput {
        {{struct}}
    };

    @vertex
    fn main( {{in}} ) -> VSOutput {

        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;
        var modelMatrix = mat3x3<f32>(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        var position = aPosition;
        var uv = aUV;

        {{start}}
        
        vColor = vec4<f32>(1., 1., 1., 1.);

        {{main}}

        vUV = uv;

        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;

        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);
       
        vColor *= globalUniforms.uWorldColorAlpha;

        {{end}}

        {{return}}
    };
`, Jw = `
    @in vUV : vec2<f32>;
    @in vColor : vec4<f32>;
   
    {{header}}

    @fragment
    fn main(
        {{in}}
      ) -> @location(0) vec4<f32> {
        
        {{start}}

        var outColor:vec4<f32>;
      
        {{main}}
        
        return outColor * vColor;
      };
`, Qw = `
    in vec2 aPosition;
    in vec2 aUV;

    out vec4 vColor;
    out vec2 vUV;

    {{header}}

    void main(void){

        mat3 worldTransformMatrix = uWorldTransformMatrix;
        mat3 modelMatrix = mat3(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        vec2 position = aPosition;
        vec2 uv = aUV;
        
        {{start}}
        
        vColor = vec4(1.);
        
        {{main}}
        
        vUV = uv;
        
        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;

        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);

        vColor *= uWorldColorAlpha;

        {{end}}
    }
`, ty = `
   
    in vec4 vColor;
    in vec2 vUV;

    out vec4 finalColor;

    {{header}}

    void main(void) {
        
        {{start}}

        vec4 outColor;
      
        {{main}}
        
        finalColor = outColor * vColor;
    }
`, ey = {
    name: "global-uniforms-bit",
    vertex: {
      header: `
        struct GlobalUniforms {
            uProjectionMatrix:mat3x3<f32>,
            uWorldTransformMatrix:mat3x3<f32>,
            uWorldColorAlpha: vec4<f32>,
            uResolution: vec2<f32>,
        }

        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;
        `
    }
  };
  const ry = {
    name: "global-uniforms-bit",
    vertex: {
      header: `
          uniform mat3 uProjectionMatrix;
          uniform mat3 uWorldTransformMatrix;
          uniform vec4 uWorldColorAlpha;
          uniform vec2 uResolution;
        `
    }
  };
  function Ui({ bits: i, name: t }) {
    const e = $w({
      template: {
        fragment: Jw,
        vertex: Zw
      },
      bits: [
        ey,
        ...i
      ]
    });
    return Ne.from({
      name: t,
      vertex: {
        source: e.vertex,
        entryPoint: "main"
      },
      fragment: {
        source: e.fragment,
        entryPoint: "main"
      }
    });
  }
  function ki({ bits: i, name: t }) {
    return new rr({
      name: t,
      ...Yw({
        template: {
          vertex: Qw,
          fragment: ty
        },
        bits: [
          ry,
          ...i
        ]
      })
    });
  }
  const ga = {
    name: "color-bit",
    vertex: {
      header: `
            @in aColor: vec4<f32>;
        `,
      main: `
            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);
        `
    }
  }, ma = {
    name: "color-bit",
    vertex: {
      header: `
            in vec4 aColor;
        `,
      main: `
            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);
        `
    }
  }, no = {};
  function iy(i) {
    const t = [];
    if (i === 1) t.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;"), t.push("@group(1) @binding(1) var textureSampler1: sampler;");
    else {
      let e = 0;
      for (let r = 0; r < i; r++) t.push(`@group(1) @binding(${e++}) var textureSource${r + 1}: texture_2d<f32>;`), t.push(`@group(1) @binding(${e++}) var textureSampler${r + 1}: sampler;`);
    }
    return t.join(`
`);
  }
  function ny(i) {
    const t = [];
    if (i === 1) t.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);");
    else {
      t.push("switch vTextureId {");
      for (let e = 0; e < i; e++) e === i - 1 ? t.push("  default:{") : t.push(`  case ${e}:{`), t.push(`      outColor = textureSampleGrad(textureSource${e + 1}, textureSampler${e + 1}, vUV, uvDx, uvDy);`), t.push("      break;}");
      t.push("}");
    }
    return t.join(`
`);
  }
  function ba(i) {
    return no[i] || (no[i] = {
      name: "texture-batch-bit",
      vertex: {
        header: `
                @in aTextureIdAndRound: vec2<u32>;
                @out @interpolate(flat) vTextureId : u32;
            `,
        main: `
                vTextureId = aTextureIdAndRound.y;
            `,
        end: `
                if(aTextureIdAndRound.x == 1)
                {
                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
                }
            `
      },
      fragment: {
        header: `
                @in @interpolate(flat) vTextureId: u32;

                ${iy(i)}
            `,
        main: `
                var uvDx = dpdx(vUV);
                var uvDy = dpdy(vUV);

                ${ny(i)}
            `
      }
    }), no[i];
  }
  const so = {};
  function sy(i) {
    const t = [];
    for (let e = 0; e < i; e++) e > 0 && t.push("else"), e < i - 1 && t.push(`if(vTextureId < ${e}.5)`), t.push("{"), t.push(`	outColor = texture(uTextures[${e}], vUV);`), t.push("}");
    return t.join(`
`);
  }
  function wa(i) {
    return so[i] || (so[i] = {
      name: "texture-batch-bit",
      vertex: {
        header: `
                in vec2 aTextureIdAndRound;
                out float vTextureId;

            `,
        main: `
                vTextureId = aTextureIdAndRound.y;
            `,
        end: `
                if(aTextureIdAndRound.x == 1.)
                {
                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
                }
            `
      },
      fragment: {
        header: `
                in float vTextureId;

                uniform sampler2D uTextures[${i}];

            `,
        main: `

                ${sy(i)}
            `
      }
    }), so[i];
  }
  const Gi = {
    name: "round-pixels-bit",
    vertex: {
      header: `
            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> 
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
    }
  }, Oi = {
    name: "round-pixels-bit",
    vertex: {
      header: `   
            vec2 roundPixels(vec2 position, vec2 targetSize)
            {       
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
    }
  }, Bu = {};
  function ya(i) {
    let t = Bu[i];
    if (t) return t;
    const e = new Int32Array(i);
    for (let r = 0; r < i; r++) e[r] = r;
    return t = Bu[i] = new Qt({
      uTextures: {
        value: e,
        type: "i32",
        size: i
      }
    }, {
      isStatic: true
    }), t;
  }
  class md {
    constructor() {
      this._didUpload = false, this._tempState = Le.for2d();
    }
    init(t) {
      const e = Ir(), r = ki({
        name: "batch",
        bits: [
          ma,
          wa(e),
          Oi
        ]
      });
      this._shader = new Se({
        glProgram: r,
        resources: {
          batchSamplers: ya(e)
        }
      }), t.renderer.runners.contextChange.add(this);
    }
    contextChange() {
      this._didUpload = false;
    }
    start(t, e) {
      const r = t.renderer;
      r.shader.bind(this._shader, this._didUpload), r.shader.updateUniformGroup(r.globalUniforms.uniformGroup), r.geometry.bind(e, this._shader.glProgram);
    }
    execute(t, e) {
      const r = t.renderer;
      this._didUpload = true, this._tempState.blendMode = e.blendMode, r.state.set(this._tempState);
      const n = e.textures.textures;
      for (let s = 0; s < e.textures.count; s++) r.texture.bind(n[s], s);
      r.geometry.draw("triangle-list", e.size, e.start);
    }
    destroy() {
      this._shader.destroy(true), this._shader = null;
    }
  }
  md.extension = {
    type: [
      P.WebGLPipesAdaptor
    ],
    name: "batch"
  };
  const hn = Le.for2d();
  class bd {
    init() {
      const t = Ui({
        name: "batch",
        bits: [
          ga,
          ba(Ir()),
          Gi
        ]
      });
      this._shader = new Se({
        gpuProgram: t,
        groups: {}
      });
    }
    start(t, e) {
      const r = t.renderer, n = r.encoder, s = this._shader.gpuProgram;
      this._geometry = e, n.setGeometry(e), hn.blendMode = "normal", r.pipeline.getPipeline(e, s, hn);
      const o = r.globalUniforms.bindGroup;
      n.resetBindGroup(1), n.setBindGroup(0, o, s);
    }
    execute(t, e) {
      const r = this._shader.gpuProgram, n = t.renderer, s = n.encoder;
      if (!e.bindGroup) {
        const c = e.textures;
        e.bindGroup = oa(c.textures, c.count);
      }
      hn.blendMode = e.blendMode;
      const o = n.bindGroup.getBindGroup(e.bindGroup, r, 1), a = n.pipeline.getPipeline(this._geometry, r, hn);
      e.bindGroup._touch(n.textureGC.count), s.setPipeline(a), s.renderPassEncoder.setBindGroup(1, o), s.renderPassEncoder.drawIndexed(e.size, 1, e.start);
    }
    destroy() {
      this._shader.destroy(true), this._shader = null;
    }
  }
  bd.extension = {
    type: [
      P.WebGPUPipesAdaptor
    ],
    name: "batch"
  };
  class wd {
    constructor(t, e) {
      this.state = Le.for2d(), this._batches = /* @__PURE__ */ Object.create(null), this._geometries = /* @__PURE__ */ Object.create(null), this.renderer = t, this._adaptor = e, this._adaptor.init(this);
    }
    buildStart(t) {
      if (!this._batches[t.uid]) {
        const e = new vh();
        this._batches[t.uid] = e, this._geometries[e.uid] = new Eh();
      }
      this._activeBatch = this._batches[t.uid], this._activeGeometry = this._geometries[this._activeBatch.uid], this._activeBatch.begin();
    }
    addToBatch(t) {
      this._activeBatch.add(t);
    }
    break(t) {
      this._activeBatch.break(t);
    }
    buildEnd(t) {
      const e = this._activeBatch, r = this._activeGeometry;
      e.finish(t), r.indexBuffer.setDataWithSize(e.indexBuffer, e.indexSize, true), r.buffers[0].setDataWithSize(e.attributeBuffer.float32View, e.attributeSize, false);
    }
    upload(t) {
      const e = this._batches[t.uid], r = this._geometries[e.uid];
      e.dirty && (e.dirty = false, r.buffers[0].update(e.attributeSize * 4));
    }
    execute(t) {
      if (t.action === "startBatch") {
        const e = t.batcher, r = this._geometries[e.uid];
        this._adaptor.start(this, r);
      }
      this._adaptor.execute(this, t);
    }
    destroy() {
      this.state = null, this.renderer = null, this._adaptor.destroy(), this._adaptor = null;
      for (const t in this._batches) this._batches[t].destroy();
      this._batches = null;
      for (const t in this._geometries) this._geometries[t].destroy();
      this._geometries = null;
    }
  }
  wd.extension = {
    type: [
      P.WebGLPipes,
      P.WebGPUPipes,
      P.CanvasPipes
    ],
    name: "batch"
  };
  const Si = {
    name: "local-uniform-bit",
    vertex: {
      header: `

            struct LocalUniforms {
                uTransformMatrix:mat3x3<f32>,
                uColor:vec4<f32>,
                uRound:f32,
            }

            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `,
      main: `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `,
      end: `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `
    }
  }, oy = {
    ...Si,
    vertex: {
      ...Si.vertex,
      header: Si.vertex.header.replace("group(1)", "group(2)")
    }
  }, xa = {
    name: "local-uniform-bit",
    vertex: {
      header: `

            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `,
      main: `
            vColor *= uColor;
            modelMatrix = uTransformMatrix;
        `,
      end: `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `
    }
  }, ay = {
    name: "texture-bit",
    vertex: {
      header: `

        struct TextureUniforms {
            uTextureMatrix:mat3x3<f32>,
        }

        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;
        `,
      main: `
            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;
        `
    },
    fragment: {
      header: `
            @group(2) @binding(0) var uTexture: texture_2d<f32>;
            @group(2) @binding(1) var uSampler: sampler;

         
        `,
      main: `
            outColor = textureSample(uTexture, uSampler, vUV);
        `
    }
  }, cy = {
    name: "texture-bit",
    vertex: {
      header: `
            uniform mat3 uTextureMatrix;
        `,
      main: `
            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;
        `
    },
    fragment: {
      header: `
        uniform sampler2D uTexture;

         
        `,
      main: `
            outColor = texture(uTexture, vUV);
        `
    }
  };
  function uy(i, t) {
    const e = i.root, r = i.instructionSet;
    r.reset(), t.batch.buildStart(r), t.blendMode.buildStart(), t.colorMask.buildStart(), e.sortableChildren && e.sortChildren(), yd(e, r, t, true), t.batch.buildEnd(r), t.blendMode.buildEnd(r);
  }
  function is(i, t, e) {
    i.globalDisplayStatus < 7 || !i.includeInBuild || (i.sortableChildren && i.sortChildren(), i.isSimple ? ly(i, t, e) : yd(i, t, e, false));
  }
  function ly(i, t, e) {
    if (i.renderPipeId && (e.blendMode.setBlendMode(i, i.groupBlendMode, t), i.didViewUpdate = false, e[i.renderPipeId].addRenderable(i, t)), !i.renderGroup) {
      const r = i.children, n = r.length;
      for (let s = 0; s < n; s++) is(r[s], t, e);
    }
  }
  function yd(i, t, e, r) {
    if (!r && i.renderGroup) e.renderGroup.addRenderGroup(i.renderGroup, t);
    else {
      for (let o = 0; o < i.effects.length; o++) {
        const a = i.effects[o];
        e[a.pipe].push(a, i, t);
      }
      const n = i.renderPipeId;
      n && (e.blendMode.setBlendMode(i, i.groupBlendMode, t), i.didViewUpdate = false, e[n].addRenderable(i, t));
      const s = i.children;
      if (s.length) for (let o = 0; o < s.length; o++) is(s[o], t, e);
      for (let o = i.effects.length - 1; o >= 0; o--) {
        const a = i.effects[o];
        e[a.pipe].pop(a, i, t);
      }
    }
  }
  const hy = new re();
  class dy extends Rn {
    constructor() {
      super(), this.filters = [
        new Dw({
          sprite: new lr(J.EMPTY),
          resolution: "inherit",
          antialias: "inherit"
        })
      ];
    }
    get sprite() {
      return this.filters[0].sprite;
    }
    set sprite(t) {
      this.filters[0].sprite = t;
    }
  }
  class xd {
    constructor(t) {
      this._activeMaskStage = [], this._renderer = t;
    }
    push(t, e, r) {
      const n = this._renderer;
      if (n.renderPipes.batch.break(r), r.add({
        renderPipeId: "alphaMask",
        action: "pushMaskBegin",
        mask: t,
        canBundle: false,
        maskedContainer: e
      }), t.renderMaskToTexture) {
        const s = t.mask;
        s.includeInBuild = true, is(s, r, n.renderPipes), s.includeInBuild = false;
      }
      n.renderPipes.batch.break(r), r.add({
        renderPipeId: "alphaMask",
        action: "pushMaskEnd",
        mask: t,
        maskedContainer: e,
        canBundle: false
      });
    }
    pop(t, e, r) {
      this._renderer.renderPipes.batch.break(r), r.add({
        renderPipeId: "alphaMask",
        action: "popMaskEnd",
        mask: t,
        canBundle: false
      });
    }
    execute(t) {
      const e = this._renderer, r = t.mask.renderMaskToTexture;
      if (t.action === "pushMaskBegin") {
        const n = vt.get(dy);
        if (r) {
          t.mask.mask.measurable = true;
          const s = Vn(t.mask.mask, true, hy);
          t.mask.mask.measurable = false, s.ceil();
          const o = e.renderTarget.renderTarget.colorTexture.source, a = Jt.getOptimalTexture(s.width, s.height, o._resolution, o.antialias);
          e.renderTarget.push(a, true), e.globalUniforms.push({
            offset: s,
            worldColor: 4294967295
          });
          const c = n.sprite;
          c.texture = a, c.worldTransform.tx = s.minX, c.worldTransform.ty = s.minY, this._activeMaskStage.push({
            filterEffect: n,
            maskedContainer: t.maskedContainer,
            filterTexture: a
          });
        } else n.sprite = t.mask.mask, this._activeMaskStage.push({
          filterEffect: n,
          maskedContainer: t.maskedContainer
        });
      } else if (t.action === "pushMaskEnd") {
        const n = this._activeMaskStage[this._activeMaskStage.length - 1];
        r && (e.type === ge.WEBGL && e.renderTarget.finishRenderPass(), e.renderTarget.pop(), e.globalUniforms.pop()), e.filter.push({
          renderPipeId: "filter",
          action: "pushFilter",
          container: n.maskedContainer,
          filterEffect: n.filterEffect,
          canBundle: false
        });
      } else if (t.action === "popMaskEnd") {
        e.filter.pop();
        const n = this._activeMaskStage.pop();
        r && Jt.returnTexture(n.filterTexture), vt.return(n.filterEffect);
      }
    }
    destroy() {
      this._renderer = null, this._activeMaskStage = null;
    }
  }
  xd.extension = {
    type: [
      P.WebGLPipes,
      P.WebGPUPipes,
      P.CanvasPipes
    ],
    name: "alphaMask"
  };
  class vd {
    constructor(t) {
      this._colorStack = [], this._colorStackIndex = 0, this._currentColor = 0, this._renderer = t;
    }
    buildStart() {
      this._colorStack[0] = 15, this._colorStackIndex = 1, this._currentColor = 15;
    }
    push(t, e, r) {
      this._renderer.renderPipes.batch.break(r);
      const s = this._colorStack;
      s[this._colorStackIndex] = s[this._colorStackIndex - 1] & t.mask;
      const o = this._colorStack[this._colorStackIndex];
      o !== this._currentColor && (this._currentColor = o, r.add({
        renderPipeId: "colorMask",
        colorMask: o,
        canBundle: false
      })), this._colorStackIndex++;
    }
    pop(t, e, r) {
      this._renderer.renderPipes.batch.break(r);
      const s = this._colorStack;
      this._colorStackIndex--;
      const o = s[this._colorStackIndex - 1];
      o !== this._currentColor && (this._currentColor = o, r.add({
        renderPipeId: "colorMask",
        colorMask: o,
        canBundle: false
      }));
    }
    execute(t) {
      this._renderer.colorMask.setMask(t.colorMask);
    }
    destroy() {
      this._colorStack = null;
    }
  }
  vd.extension = {
    type: [
      P.WebGLPipes,
      P.WebGPUPipes,
      P.CanvasPipes
    ],
    name: "colorMask"
  };
  class Sd {
    constructor(t) {
      this._maskStackHash = {}, this._maskHash = /* @__PURE__ */ new WeakMap(), this._renderer = t;
    }
    push(t, e, r) {
      var n;
      const s = t, o = this._renderer;
      o.renderPipes.batch.break(r), o.renderPipes.blendMode.setBlendMode(s.mask, "none", r), r.add({
        renderPipeId: "stencilMask",
        action: "pushMaskBegin",
        mask: t,
        canBundle: false
      });
      const a = s.mask;
      a.includeInBuild = true, this._maskHash.has(s) || this._maskHash.set(s, {
        instructionsStart: 0,
        instructionsLength: 0
      });
      const c = this._maskHash.get(s);
      c.instructionsStart = r.instructionSize, is(a, r, o.renderPipes), a.includeInBuild = false, o.renderPipes.batch.break(r), r.add({
        renderPipeId: "stencilMask",
        action: "pushMaskEnd",
        mask: t,
        canBundle: false
      });
      const u = r.instructionSize - c.instructionsStart - 1;
      c.instructionsLength = u;
      const l = o.renderTarget.renderTarget.uid;
      (n = this._maskStackHash)[l] ?? (n[l] = 0);
    }
    pop(t, e, r) {
      const n = t, s = this._renderer;
      s.renderPipes.batch.break(r), s.renderPipes.blendMode.setBlendMode(n.mask, "none", r), r.add({
        renderPipeId: "stencilMask",
        action: "popMaskBegin",
        canBundle: false
      });
      const o = this._maskHash.get(t);
      for (let a = 0; a < o.instructionsLength; a++) r.instructions[r.instructionSize++] = r.instructions[o.instructionsStart++];
      r.add({
        renderPipeId: "stencilMask",
        action: "popMaskEnd",
        canBundle: false
      });
    }
    execute(t) {
      var e;
      const r = this._renderer, n = r.renderTarget.renderTarget.uid;
      let s = (e = this._maskStackHash)[n] ?? (e[n] = 0);
      t.action === "pushMaskBegin" ? (r.renderTarget.ensureDepthStencil(), r.stencil.setStencilMode(Kt.RENDERING_MASK_ADD, s), s++, r.colorMask.setMask(0)) : t.action === "pushMaskEnd" ? (r.stencil.setStencilMode(Kt.MASK_ACTIVE, s), r.colorMask.setMask(15)) : t.action === "popMaskBegin" ? (r.colorMask.setMask(0), s !== 0 ? r.stencil.setStencilMode(Kt.RENDERING_MASK_REMOVE, s) : (r.renderTarget.clear(null, pe.STENCIL), r.stencil.setStencilMode(Kt.DISABLED, s)), s--) : t.action === "popMaskEnd" && (r.stencil.setStencilMode(Kt.MASK_ACTIVE, s), r.colorMask.setMask(15)), this._maskStackHash[n] = s;
    }
    destroy() {
      this._renderer = null, this._maskStackHash = null, this._maskHash = null;
    }
  }
  Sd.extension = {
    type: [
      P.WebGLPipes,
      P.WebGPUPipes,
      P.CanvasPipes
    ],
    name: "stencilMask"
  };
  var En = ((i) => (i[i.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", i[i.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", i[i.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER", i))(En || {});
  class fy {
    constructor(t, e) {
      this.buffer = t || null, this.updateID = -1, this.byteLength = -1, this.type = e;
    }
  }
  class Ed {
    constructor(t) {
      this._gpuBuffers = /* @__PURE__ */ Object.create(null), this._boundBufferBases = /* @__PURE__ */ Object.create(null), this._renderer = t;
    }
    destroy() {
      this._renderer = null, this._gl = null, this._gpuBuffers = null, this._boundBufferBases = null;
    }
    contextChange() {
      this._gpuBuffers = /* @__PURE__ */ Object.create(null), this._gl = this._renderer.gl;
    }
    getGlBuffer(t) {
      return this._gpuBuffers[t.uid] || this.createGLBuffer(t);
    }
    bind(t) {
      const { _gl: e } = this, r = this.getGlBuffer(t);
      e.bindBuffer(r.type, r.buffer);
    }
    bindBufferBase(t, e) {
      const { _gl: r } = this;
      if (this._boundBufferBases[e] !== t) {
        const n = this.getGlBuffer(t);
        this._boundBufferBases[e] = t, r.bindBufferBase(r.UNIFORM_BUFFER, e, n.buffer);
      }
    }
    bindBufferRange(t, e, r) {
      const { _gl: n } = this;
      r = r || 0;
      const s = this.getGlBuffer(t);
      n.bindBufferRange(n.UNIFORM_BUFFER, e || 0, s.buffer, r * 256, 256);
    }
    updateBuffer(t) {
      const { _gl: e } = this, r = this.getGlBuffer(t);
      if (t._updateID === r.updateID) return r;
      r.updateID = t._updateID, e.bindBuffer(r.type, r.buffer);
      const n = t.data;
      if (r.byteLength >= t.data.byteLength) e.bufferSubData(r.type, 0, n, 0, t._updateSize / n.BYTES_PER_ELEMENT);
      else {
        const s = t.descriptor.usage & yt.STATIC ? e.STATIC_DRAW : e.DYNAMIC_DRAW;
        r.byteLength = n.byteLength, e.bufferData(r.type, n, s);
      }
      return r;
    }
    destroyAll() {
      const t = this._gl;
      for (const e in this._gpuBuffers) t.deleteBuffer(this._gpuBuffers[e].buffer);
      this._gpuBuffers = /* @__PURE__ */ Object.create(null);
    }
    onBufferDestroy(t, e) {
      const r = this._gpuBuffers[t.uid], n = this._gl;
      e || n.deleteBuffer(r.buffer), this._gpuBuffers[t.uid] = null;
    }
    createGLBuffer(t) {
      const { _gl: e } = this;
      let r = En.ARRAY_BUFFER;
      t.descriptor.usage & yt.INDEX ? r = En.ELEMENT_ARRAY_BUFFER : t.descriptor.usage & yt.UNIFORM && (r = En.UNIFORM_BUFFER);
      const n = new fy(e.createBuffer(), r);
      return this._gpuBuffers[t.uid] = n, t.on("destroy", this.onBufferDestroy, this), n;
    }
  }
  Ed.extension = {
    type: [
      P.WebGLSystem
    ],
    name: "buffer"
  };
  const va = class Ad {
    constructor(t) {
      this.supports = {
        uint32Indices: true,
        uniformBufferObject: true,
        vertexArrayObject: true,
        srgbTextures: true,
        nonPowOf2wrapping: true,
        msaa: true,
        nonPowOf2mipmaps: true
      }, this._renderer = t, this.extensions = /* @__PURE__ */ Object.create(null), this.handleContextLost = this.handleContextLost.bind(this), this.handleContextRestored = this.handleContextRestored.bind(this);
    }
    get isLost() {
      return !this.gl || this.gl.isContextLost();
    }
    contextChange(t) {
      this.gl = t, this._renderer.gl = t;
    }
    init(t) {
      if (t = {
        ...Ad.defaultOptions,
        ...t
      }, t.context) this.initFromContext(t.context);
      else {
        const e = this._renderer.background.alpha < 1, r = t.premultipliedAlpha ?? true, n = t.antialias && !this._renderer.backBuffer.useBackBuffer;
        this.createContext(t.preferWebGLVersion, {
          alpha: e,
          premultipliedAlpha: r,
          antialias: n,
          stencil: true,
          preserveDrawingBuffer: t.preserveDrawingBuffer,
          powerPreference: t.powerPreference ?? "default"
        });
      }
    }
    initFromContext(t) {
      this.gl = t, this.webGLVersion = t instanceof St.get().getWebGLRenderingContext() ? 1 : 2, this.getExtensions(), this.validateContext(t), this._renderer.runners.contextChange.emit(t);
      const e = this._renderer.view.canvas;
      e.addEventListener("webglcontextlost", this.handleContextLost, false), e.addEventListener("webglcontextrestored", this.handleContextRestored, false);
    }
    createContext(t, e) {
      let r;
      const n = this._renderer.view.canvas;
      if (t === 2 && (r = n.getContext("webgl2", e)), !r && (r = n.getContext("webgl", e), !r)) throw new Error("This browser does not support WebGL. Try using the canvas renderer");
      this.gl = r, this.initFromContext(this.gl);
    }
    getExtensions() {
      const { gl: t } = this, e = {
        anisotropicFiltering: t.getExtension("EXT_texture_filter_anisotropic"),
        floatTextureLinear: t.getExtension("OES_texture_float_linear"),
        s3tc: t.getExtension("WEBGL_compressed_texture_s3tc"),
        s3tc_sRGB: t.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
        etc: t.getExtension("WEBGL_compressed_texture_etc"),
        etc1: t.getExtension("WEBGL_compressed_texture_etc1"),
        pvrtc: t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
        atc: t.getExtension("WEBGL_compressed_texture_atc"),
        astc: t.getExtension("WEBGL_compressed_texture_astc"),
        bptc: t.getExtension("EXT_texture_compression_bptc"),
        rgtc: t.getExtension("EXT_texture_compression_rgtc"),
        loseContext: t.getExtension("WEBGL_lose_context")
      };
      if (this.webGLVersion === 1) this.extensions = {
        ...e,
        drawBuffers: t.getExtension("WEBGL_draw_buffers"),
        depthTexture: t.getExtension("WEBGL_depth_texture"),
        vertexArrayObject: t.getExtension("OES_vertex_array_object") || t.getExtension("MOZ_OES_vertex_array_object") || t.getExtension("WEBKIT_OES_vertex_array_object"),
        uint32ElementIndex: t.getExtension("OES_element_index_uint"),
        floatTexture: t.getExtension("OES_texture_float"),
        floatTextureLinear: t.getExtension("OES_texture_float_linear"),
        textureHalfFloat: t.getExtension("OES_texture_half_float"),
        textureHalfFloatLinear: t.getExtension("OES_texture_half_float_linear"),
        vertexAttribDivisorANGLE: t.getExtension("ANGLE_instanced_arrays"),
        srgb: t.getExtension("EXT_sRGB")
      };
      else {
        this.extensions = {
          ...e,
          colorBufferFloat: t.getExtension("EXT_color_buffer_float")
        };
        const r = t.getExtension("WEBGL_provoking_vertex");
        r && r.provokingVertexWEBGL(r.FIRST_VERTEX_CONVENTION_WEBGL);
      }
    }
    handleContextLost(t) {
      t.preventDefault(), this._contextLossForced && (this._contextLossForced = false, setTimeout(() => {
        var _a2;
        this.gl.isContextLost() && ((_a2 = this.extensions.loseContext) == null ? void 0 : _a2.restoreContext());
      }, 0));
    }
    handleContextRestored() {
      this._renderer.runners.contextChange.emit(this.gl);
    }
    destroy() {
      var _a2;
      const t = this._renderer.view.canvas;
      this._renderer = null, t.removeEventListener("webglcontextlost", this.handleContextLost), t.removeEventListener("webglcontextrestored", this.handleContextRestored), this.gl.useProgram(null), (_a2 = this.extensions.loseContext) == null ? void 0 : _a2.loseContext();
    }
    forceContextLoss() {
      var _a2;
      (_a2 = this.extensions.loseContext) == null ? void 0 : _a2.loseContext(), this._contextLossForced = true;
    }
    validateContext(t) {
      const e = t.getContextAttributes();
      e && !e.stencil && ut("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
      const r = this.supports, n = this.webGLVersion === 2, s = this.extensions;
      r.uint32Indices = n || !!s.uint32ElementIndex, r.uniformBufferObject = n, r.vertexArrayObject = n || !!s.vertexArrayObject, r.srgbTextures = n || !!s.srgb, r.nonPowOf2wrapping = n, r.nonPowOf2mipmaps = n, r.msaa = n, r.uint32Indices || ut("Provided WebGL context does not support 32 index buffer, large scenes may not render correctly");
    }
  };
  va.extension = {
    type: [
      P.WebGLSystem
    ],
    name: "context"
  };
  va.defaultOptions = {
    context: null,
    premultipliedAlpha: true,
    preserveDrawingBuffer: false,
    powerPreference: void 0,
    preferWebGLVersion: 2
  };
  let py = va;
  function Td(i, t) {
    for (const e in i.attributes) {
      const r = i.attributes[e], n = t[e];
      n ? (r.location ?? (r.location = n.location), r.format ?? (r.format = n.format), r.offset ?? (r.offset = n.offset), r.instance ?? (r.instance = n.instance)) : ut(`Attribute ${e} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`);
    }
    _y(i);
  }
  function _y(i) {
    const { buffers: t, attributes: e } = i, r = {}, n = {};
    for (const s in t) {
      const o = t[s];
      r[o.uid] = 0, n[o.uid] = 0;
    }
    for (const s in e) {
      const o = e[s];
      r[o.buffer.uid] += Ti(o.format).stride;
    }
    for (const s in e) {
      const o = e[s];
      o.stride ?? (o.stride = r[o.buffer.uid]), o.start ?? (o.start = n[o.buffer.uid]), n[o.buffer.uid] += Ti(o.format).stride;
    }
  }
  var Oo = ((i) => (i[i.RGBA = 6408] = "RGBA", i[i.RGB = 6407] = "RGB", i[i.RG = 33319] = "RG", i[i.RED = 6403] = "RED", i[i.RGBA_INTEGER = 36249] = "RGBA_INTEGER", i[i.RGB_INTEGER = 36248] = "RGB_INTEGER", i[i.RG_INTEGER = 33320] = "RG_INTEGER", i[i.RED_INTEGER = 36244] = "RED_INTEGER", i[i.ALPHA = 6406] = "ALPHA", i[i.LUMINANCE = 6409] = "LUMINANCE", i[i.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", i[i.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", i[i.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL", i))(Oo || {}), Cd = ((i) => (i[i.TEXTURE_2D = 3553] = "TEXTURE_2D", i[i.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", i[i.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", i[i.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", i[i.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", i[i.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", i[i.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", i[i.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", i[i.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z", i))(Cd || {});
  var wt = ((i) => (i[i.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", i[i.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", i[i.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", i[i.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", i[i.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", i[i.UNSIGNED_INT = 5125] = "UNSIGNED_INT", i[i.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", i[i.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", i[i.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", i[i.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", i[i.BYTE = 5120] = "BYTE", i[i.SHORT = 5122] = "SHORT", i[i.INT = 5124] = "INT", i[i.FLOAT = 5126] = "FLOAT", i[i.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", i[i.HALF_FLOAT = 36193] = "HALF_FLOAT", i))(wt || {});
  const Mu = {
    uint8x2: wt.UNSIGNED_BYTE,
    uint8x4: wt.UNSIGNED_BYTE,
    sint8x2: wt.BYTE,
    sint8x4: wt.BYTE,
    unorm8x2: wt.UNSIGNED_BYTE,
    unorm8x4: wt.UNSIGNED_BYTE,
    snorm8x2: wt.BYTE,
    snorm8x4: wt.BYTE,
    uint16x2: wt.UNSIGNED_SHORT,
    uint16x4: wt.UNSIGNED_SHORT,
    sint16x2: wt.SHORT,
    sint16x4: wt.SHORT,
    unorm16x2: wt.UNSIGNED_SHORT,
    unorm16x4: wt.UNSIGNED_SHORT,
    snorm16x2: wt.SHORT,
    snorm16x4: wt.SHORT,
    float16x2: wt.HALF_FLOAT,
    float16x4: wt.HALF_FLOAT,
    float32: wt.FLOAT,
    float32x2: wt.FLOAT,
    float32x3: wt.FLOAT,
    float32x4: wt.FLOAT,
    uint32: wt.UNSIGNED_INT,
    uint32x2: wt.UNSIGNED_INT,
    uint32x3: wt.UNSIGNED_INT,
    uint32x4: wt.UNSIGNED_INT,
    sint32: wt.INT,
    sint32x2: wt.INT,
    sint32x3: wt.INT,
    sint32x4: wt.INT
  };
  function gy(i) {
    return Mu[i] ?? Mu.float32;
  }
  const my = {
    "point-list": 0,
    "line-list": 1,
    "line-strip": 3,
    "triangle-list": 4,
    "triangle-strip": 5
  };
  class Rd {
    constructor(t) {
      this._geometryVaoHash = /* @__PURE__ */ Object.create(null), this._renderer = t, this._activeGeometry = null, this._activeVao = null, this.hasVao = true, this.hasInstance = true;
    }
    contextChange() {
      const t = this.gl = this._renderer.gl;
      if (!this._renderer.context.supports.vertexArrayObject) throw new Error("[PixiJS] Vertex Array Objects are not supported on this device");
      const e = this._renderer.context.extensions.vertexArrayObject;
      e && (t.createVertexArray = () => e.createVertexArrayOES(), t.bindVertexArray = (n) => e.bindVertexArrayOES(n), t.deleteVertexArray = (n) => e.deleteVertexArrayOES(n));
      const r = this._renderer.context.extensions.vertexAttribDivisorANGLE;
      r && (t.drawArraysInstanced = (n, s, o, a) => {
        r.drawArraysInstancedANGLE(n, s, o, a);
      }, t.drawElementsInstanced = (n, s, o, a, c) => {
        r.drawElementsInstancedANGLE(n, s, o, a, c);
      }, t.vertexAttribDivisor = (n, s) => r.vertexAttribDivisorANGLE(n, s)), this._activeGeometry = null, this._activeVao = null, this._geometryVaoHash = /* @__PURE__ */ Object.create(null);
    }
    bind(t, e) {
      const r = this.gl;
      this._activeGeometry = t;
      const n = this.getVao(t, e);
      this._activeVao !== n && (this._activeVao = n, r.bindVertexArray(n)), this.updateBuffers();
    }
    reset() {
      this.unbind();
    }
    updateBuffers() {
      const t = this._activeGeometry, e = this._renderer.buffer;
      for (let r = 0; r < t.buffers.length; r++) {
        const n = t.buffers[r];
        e.updateBuffer(n);
      }
    }
    checkCompatibility(t, e) {
      const r = t.attributes, n = e._attributeData;
      for (const s in n) if (!r[s]) throw new Error(`shader and geometry incompatible, geometry missing the "${s}" attribute`);
    }
    getSignature(t, e) {
      const r = t.attributes, n = e._attributeData, s = [
        "g",
        t.uid
      ];
      for (const o in r) n[o] && s.push(o, n[o].location);
      return s.join("-");
    }
    getVao(t, e) {
      var _a2;
      return ((_a2 = this._geometryVaoHash[t.uid]) == null ? void 0 : _a2[e._key]) || this.initGeometryVao(t, e);
    }
    initGeometryVao(t, e, r = true) {
      const n = this._renderer.gl, s = this._renderer.buffer;
      this._renderer.shader._getProgramData(e), this.checkCompatibility(t, e);
      const o = this.getSignature(t, e);
      this._geometryVaoHash[t.uid] || (this._geometryVaoHash[t.uid] = /* @__PURE__ */ Object.create(null), t.on("destroy", this.onGeometryDestroy, this));
      const a = this._geometryVaoHash[t.uid];
      let c = a[o];
      if (c) return a[e._key] = c, c;
      Td(t, e._attributeData);
      const u = t.buffers;
      c = n.createVertexArray(), n.bindVertexArray(c);
      for (let l = 0; l < u.length; l++) {
        const h = u[l];
        s.bind(h);
      }
      return this.activateVao(t, e), a[e._key] = c, a[o] = c, n.bindVertexArray(null), c;
    }
    onGeometryDestroy(t, e) {
      const r = this._geometryVaoHash[t.uid], n = this.gl;
      if (r) {
        if (e) for (const s in r) this._activeVao !== r[s] && this.unbind(), n.deleteVertexArray(r[s]);
        this._geometryVaoHash[t.uid] = null;
      }
    }
    destroyAll(t = false) {
      const e = this.gl;
      for (const r in this._geometryVaoHash) {
        if (t) for (const n in this._geometryVaoHash[r]) {
          const s = this._geometryVaoHash[r];
          this._activeVao !== s && this.unbind(), e.deleteVertexArray(s[n]);
        }
        this._geometryVaoHash[r] = null;
      }
    }
    activateVao(t, e) {
      var _a2;
      const r = this._renderer.gl, n = this._renderer.buffer, s = t.attributes;
      t.indexBuffer && n.bind(t.indexBuffer);
      let o = null;
      for (const a in s) {
        const c = s[a], u = c.buffer, l = n.getGlBuffer(u), h = e._attributeData[a];
        if (h) {
          o !== l && (n.bind(u), o = l);
          const f = c.location;
          r.enableVertexAttribArray(f);
          const p = Ti(c.format), m = gy(c.format);
          if (((_a2 = h.format) == null ? void 0 : _a2.substring(1, 4)) === "int" ? r.vertexAttribIPointer(f, p.size, m, c.stride, c.offset) : r.vertexAttribPointer(f, p.size, m, p.normalised, c.stride, c.offset), c.instance) if (this.hasInstance) {
            const y = c.divisor ?? 1;
            r.vertexAttribDivisor(f, y);
          } else throw new Error("geometry error, GPU Instancing is not supported on this device");
        }
      }
    }
    draw(t, e, r, n) {
      const { gl: s } = this._renderer, o = this._activeGeometry, a = my[o.topology || t];
      if (n || (n = o.instanceCount), o.indexBuffer) {
        const c = o.indexBuffer.data.BYTES_PER_ELEMENT, u = c === 2 ? s.UNSIGNED_SHORT : s.UNSIGNED_INT;
        n > 1 ? s.drawElementsInstanced(a, e || o.indexBuffer.data.length, u, (r || 0) * c, n) : s.drawElements(a, e || o.indexBuffer.data.length, u, (r || 0) * c);
      } else n > 1 ? s.drawArraysInstanced(a, r || 0, e || o.getSize(), n) : s.drawArrays(a, r || 0, e || o.getSize());
      return this;
    }
    unbind() {
      this.gl.bindVertexArray(null), this._activeVao = null, this._activeGeometry = null;
    }
    destroy() {
      this._renderer = null, this.gl = null, this._activeVao = null, this._activeGeometry = null;
    }
  }
  Rd.extension = {
    type: [
      P.WebGLSystem
    ],
    name: "geometry"
  };
  const by = new Ii({
    attributes: {
      aPosition: [
        -1,
        -1,
        3,
        -1,
        -1,
        3
      ]
    }
  }), Sa = class Pd {
    constructor(t) {
      this.useBackBuffer = false, this._useBackBufferThisRender = false, this._renderer = t;
    }
    init(t = {}) {
      const { useBackBuffer: e, antialias: r } = {
        ...Pd.defaultOptions,
        ...t
      };
      this.useBackBuffer = e, this._antialias = r, this._renderer.context.supports.msaa || (ut("antialiasing, is not supported on when using the back buffer"), this._antialias = false), this._state = Le.for2d();
      const n = new rr({
        vertex: `
                attribute vec2 aPosition;
                out vec2 vUv;

                void main() {
                    gl_Position = vec4(aPosition, 0.0, 1.0);

                    vUv = (aPosition + 1.0) / 2.0;

                    // flip dem UVs
                    vUv.y = 1.0 - vUv.y;
                }`,
        fragment: `
                in vec2 vUv;
                out vec4 finalColor;

                uniform sampler2D uTexture;

                void main() {
                    finalColor = texture(uTexture, vUv);
                }`,
        name: "big-triangle"
      });
      this._bigTriangleShader = new Se({
        glProgram: n,
        resources: {
          uTexture: J.WHITE.source
        }
      });
    }
    renderStart(t) {
      const e = this._renderer.renderTarget.getRenderTarget(t.target);
      if (this._useBackBufferThisRender = this.useBackBuffer && !!e.isRoot, this._useBackBufferThisRender) {
        const r = this._renderer.renderTarget.getRenderTarget(t.target);
        this._targetTexture = r.colorTexture, t.target = this._getBackBufferTexture(r.colorTexture);
      }
    }
    renderEnd() {
      this._presentBackBuffer();
    }
    _presentBackBuffer() {
      const t = this._renderer;
      t.renderTarget.finishRenderPass(), this._useBackBufferThisRender && (t.renderTarget.bind(this._targetTexture, false), this._bigTriangleShader.resources.uTexture = this._backBufferTexture.source, t.encoder.draw({
        geometry: by,
        shader: this._bigTriangleShader,
        state: this._state
      }));
    }
    _getBackBufferTexture(t) {
      return this._backBufferTexture = this._backBufferTexture || new J({
        source: new Ht({
          width: t.width,
          height: t.height,
          resolution: t._resolution,
          antialias: this._antialias
        })
      }), this._backBufferTexture.source.resize(t.width, t.height, t._resolution), this._backBufferTexture;
    }
    destroy() {
      this._backBufferTexture && (this._backBufferTexture.destroy(), this._backBufferTexture = null);
    }
  };
  Sa.extension = {
    type: [
      P.WebGLSystem
    ],
    name: "backBuffer",
    priority: 1
  };
  Sa.defaultOptions = {
    useBackBuffer: false
  };
  let wy = Sa;
  class Bd {
    constructor(t) {
      this._colorMaskCache = 15, this._renderer = t;
    }
    setMask(t) {
      this._colorMaskCache !== t && (this._colorMaskCache = t, this._renderer.gl.colorMask(!!(t & 8), !!(t & 4), !!(t & 2), !!(t & 1)));
    }
  }
  Bd.extension = {
    type: [
      P.WebGLSystem
    ],
    name: "colorMask"
  };
  class Md {
    constructor(t) {
      this.commandFinished = Promise.resolve(), this._renderer = t;
    }
    setGeometry(t, e) {
      this._renderer.geometry.bind(t, e.glProgram);
    }
    finishRenderPass() {
    }
    draw(t) {
      const e = this._renderer, { geometry: r, shader: n, state: s, skipSync: o, topology: a, size: c, start: u, instanceCount: l } = t;
      e.shader.bind(n, o), e.geometry.bind(r, e.shader._activeProgram), s && e.state.set(s), e.geometry.draw(a, c, u, l ?? r.instanceCount);
    }
    destroy() {
      this._renderer = null;
    }
  }
  Md.extension = {
    type: [
      P.WebGLSystem
    ],
    name: "encoder"
  };
  class yy {
    constructor() {
      this.width = -1, this.height = -1, this.msaa = false, this.msaaRenderBuffer = [];
    }
  }
  const Ur = [];
  Ur[Kt.NONE] = void 0;
  Ur[Kt.DISABLED] = {
    stencilWriteMask: 0,
    stencilReadMask: 0
  };
  Ur[Kt.RENDERING_MASK_ADD] = {
    stencilFront: {
      compare: "equal",
      passOp: "increment-clamp"
    },
    stencilBack: {
      compare: "equal",
      passOp: "increment-clamp"
    }
  };
  Ur[Kt.RENDERING_MASK_REMOVE] = {
    stencilFront: {
      compare: "equal",
      passOp: "decrement-clamp"
    },
    stencilBack: {
      compare: "equal",
      passOp: "decrement-clamp"
    }
  };
  Ur[Kt.MASK_ACTIVE] = {
    stencilWriteMask: 0,
    stencilFront: {
      compare: "equal",
      passOp: "keep"
    },
    stencilBack: {
      compare: "equal",
      passOp: "keep"
    }
  };
  class Dd {
    constructor(t) {
      this._stencilCache = {
        enabled: false,
        stencilReference: 0,
        stencilMode: Kt.NONE
      }, this._renderTargetStencilState = /* @__PURE__ */ Object.create(null), t.renderTarget.onRenderTargetChange.add(this);
    }
    contextChange(t) {
      this._gl = t, this._comparisonFuncMapping = {
        always: t.ALWAYS,
        never: t.NEVER,
        equal: t.EQUAL,
        "not-equal": t.NOTEQUAL,
        less: t.LESS,
        "less-equal": t.LEQUAL,
        greater: t.GREATER,
        "greater-equal": t.GEQUAL
      }, this._stencilOpsMapping = {
        keep: t.KEEP,
        zero: t.ZERO,
        replace: t.REPLACE,
        invert: t.INVERT,
        "increment-clamp": t.INCR,
        "decrement-clamp": t.DECR,
        "increment-wrap": t.INCR_WRAP,
        "decrement-wrap": t.DECR_WRAP
      }, this._stencilCache.enabled = false, this._stencilCache.stencilMode = Kt.NONE, this._stencilCache.stencilReference = 0;
    }
    onRenderTargetChange(t) {
      if (this._activeRenderTarget === t) return;
      this._activeRenderTarget = t;
      let e = this._renderTargetStencilState[t.uid];
      e || (e = this._renderTargetStencilState[t.uid] = {
        stencilMode: Kt.DISABLED,
        stencilReference: 0
      }), this.setStencilMode(e.stencilMode, e.stencilReference);
    }
    setStencilMode(t, e) {
      const r = this._renderTargetStencilState[this._activeRenderTarget.uid], n = this._gl, s = Ur[t], o = this._stencilCache;
      if (r.stencilMode = t, r.stencilReference = e, t === Kt.DISABLED) {
        this._stencilCache.enabled && (this._stencilCache.enabled = false, n.disable(n.STENCIL_TEST));
        return;
      }
      this._stencilCache.enabled || (this._stencilCache.enabled = true, n.enable(n.STENCIL_TEST)), (t !== o.stencilMode || o.stencilReference !== e) && (o.stencilMode = t, o.stencilReference = e, n.stencilFunc(this._comparisonFuncMapping[s.stencilBack.compare], e, 255), n.stencilOp(n.KEEP, n.KEEP, this._stencilOpsMapping[s.stencilBack.passOp]));
    }
  }
  Dd.extension = {
    type: [
      P.WebGLSystem
    ],
    name: "stencil"
  };
  class Id {
    constructor(t) {
      this._syncFunctionHash = /* @__PURE__ */ Object.create(null), this._adaptor = t, this._systemCheck();
    }
    _systemCheck() {
      if (!ch()) throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");
    }
    ensureUniformGroup(t) {
      const e = this.getUniformGroupData(t);
      t.buffer || (t.buffer = new Pe({
        data: new Float32Array(e.layout.size / 4),
        usage: yt.UNIFORM | yt.COPY_DST
      }));
    }
    getUniformGroupData(t) {
      return this._syncFunctionHash[t._signature] || this._initUniformGroup(t);
    }
    _initUniformGroup(t) {
      const e = t._signature;
      let r = this._syncFunctionHash[e];
      if (!r) {
        const n = Object.keys(t.uniformStructures).map((a) => t.uniformStructures[a]), s = this._adaptor.createUboElements(n), o = this._generateUboSync(s.uboElements);
        r = this._syncFunctionHash[e] = {
          layout: s,
          syncFunction: o
        };
      }
      return this._syncFunctionHash[e];
    }
    _generateUboSync(t) {
      return this._adaptor.generateUboSync(t);
    }
    syncUniformGroup(t, e, r) {
      const n = this.getUniformGroupData(t);
      return t.buffer || (t.buffer = new Pe({
        data: new Float32Array(n.layout.size / 4),
        usage: yt.UNIFORM | yt.COPY_DST
      })), e || (e = t.buffer.data), r || (r = 0), n.syncFunction(t.uniforms, e, r), true;
    }
    updateUniformGroup(t) {
      if (t.isStatic && !t._dirtyId) return false;
      t._dirtyId = 0;
      const e = this.syncUniformGroup(t);
      return t.buffer.update(), e;
    }
    destroy() {
      this._syncFunctionHash = null;
    }
  }
  const Fd = {
    f32: 4,
    "vec2<f32>": 8,
    "vec3<f32>": 12,
    "vec4<f32>": 16,
    "mat2x2<f32>": 16 * 2,
    "mat3x3<f32>": 16 * 3,
    "mat4x4<f32>": 16 * 4
  };
  function xy(i) {
    const t = i.map((s) => ({
      data: s,
      offset: 0,
      size: 0
    }));
    let e = 0, r = 0, n = 0;
    for (let s = 0; s < t.length; s++) {
      const o = t[s];
      if (e = Fd[o.data.type], !e) throw new Error(`Unknown type ${o.data.type}`);
      if (o.data.size > 1 && (e = Math.max(e, 16) * o.data.size), o.size = e, r % e !== 0 && r < 16) {
        const a = r % e % 16;
        r += a, n += a;
      }
      r + e > 16 ? (n = Math.ceil(n / 16) * 16, o.offset = n, n += e, r = e) : (o.offset = n, r += e, n += e);
    }
    return n = Math.ceil(n / 16) * 16, {
      uboElements: t,
      size: n
    };
  }
  const Pr = [
    {
      type: "mat3x3<f32>",
      test: (i) => i.value.a !== void 0,
      ubo: `
            var matrix = uv[name].toArray(true);
            data[offset] = matrix[0];
            data[offset + 1] = matrix[1];
            data[offset + 2] = matrix[2];
            data[offset + 4] = matrix[3];
            data[offset + 5] = matrix[4];
            data[offset + 6] = matrix[5];
            data[offset + 8] = matrix[6];
            data[offset + 9] = matrix[7];
            data[offset + 10] = matrix[8];
        `,
      uniform: `
            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));
        `
    },
    {
      type: "vec4<f32>",
      test: (i) => i.type === "vec4<f32>" && i.size === 1 && i.value.width !== void 0,
      ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
            data[offset + 2] = v.width;
            data[offset + 3] = v.height;
        `,
      uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {
                cv[0] = v.x;
                cv[1] = v.y;
                cv[2] = v.width;
                cv[3] = v.height;
                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);
            }
        `
    },
    {
      type: "vec2<f32>",
      test: (i) => i.type === "vec2<f32>" && i.size === 1 && i.value.x !== void 0,
      ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
        `,
      uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y) {
                cv[0] = v.x;
                cv[1] = v.y;
                gl.uniform2f(ud[name].location, v.x, v.y);
            }
        `
    },
    {
      type: "vec4<f32>",
      test: (i) => i.type === "vec4<f32>" && i.size === 1 && i.value.red !== void 0,
      ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
            data[offset + 3] = v.alpha;
        `,
      uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                cv[3] = v.alpha;
                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);
            }
        `
    },
    {
      type: "vec3<f32>",
      test: (i) => i.type === "vec3<f32>" && i.size === 1 && i.value.red !== void 0,
      ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
        `,
      uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);
            }
        `
    }
  ];
  function Ud(i, t, e, r) {
    const n = [
      `
        var v = null;
        var v2 = null;
        var t = 0;
        var index = 0;
        var name = null;
        var arrayOffset = null;
    `
    ];
    let s = 0;
    for (let a = 0; a < i.length; a++) {
      const c = i[a], u = c.data.name;
      let l = false, h = 0;
      for (let f = 0; f < Pr.length; f++) if (Pr[f].test(c.data)) {
        h = c.offset / 4, n.push(`name = "${u}";`, `offset += ${h - s};`, Pr[f][t] || Pr[f].ubo), l = true;
        break;
      }
      if (!l) if (c.data.size > 1) h = c.offset / 4, n.push(e(c, h - s));
      else {
        const f = r[c.data.type];
        h = c.offset / 4, n.push(`
                    v = uv.${u};
                    offset += ${h - s};
                    ${f};
                `);
      }
      s = h;
    }
    const o = n.join(`
`);
    return new Function("uv", "data", "offset", o);
  }
  function Hr(i, t) {
    return `
        for (let i = 0; i < ${i * t}; i++) {
            data[offset + (((i / ${i})|0) * 4) + (i % ${i})] = v[i];
        }
    `;
  }
  const kd = {
    f32: `
        data[offset] = v;`,
    i32: `
        data[offset] = v;`,
    "vec2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];`,
    "vec3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];`,
    "vec4<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];`,
    "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 4] = v[2];
        data[offset + 5] = v[3];`,
    "mat3x3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];
        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];`,
    "mat4x4<f32>": `
        for (let i = 0; i < 16; i++) {
            data[offset + i] = v[i];
        }`,
    "mat3x2<f32>": Hr(3, 2),
    "mat4x2<f32>": Hr(4, 2),
    "mat2x3<f32>": Hr(2, 3),
    "mat4x3<f32>": Hr(4, 3),
    "mat2x4<f32>": Hr(2, 4),
    "mat3x4<f32>": Hr(3, 4)
  }, vy = {
    ...kd,
    "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];
    `
  };
  function Sy(i, t) {
    const e = Math.max(Fd[i.data.type] / 16, 1), r = i.data.value.length / i.data.size, n = (4 - r % 4) % 4;
    return `
        v = uv.${i.data.name};
        offset += ${t};

        arrayOffset = offset;

        t = 0;

        for(var i=0; i < ${i.data.size * e}; i++)
        {
            for(var j = 0; j < ${r}; j++)
            {
                data[arrayOffset++] = v[t++];
            }
            ${n !== 0 ? `arrayOffset += ${n};` : ""}
        }
    `;
  }
  function Ey(i) {
    return Ud(i, "uboStd40", Sy, kd);
  }
  class Gd extends Id {
    constructor() {
      super({
        createUboElements: xy,
        generateUboSync: Ey
      });
    }
  }
  Gd.extension = {
    type: [
      P.WebGLSystem
    ],
    name: "ubo"
  };
  class Ay {
    constructor() {
      this._clearColorCache = [
        0,
        0,
        0,
        0
      ], this._viewPortCache = new Et();
    }
    init(t, e) {
      this._renderer = t, this._renderTargetSystem = e, t.runners.contextChange.add(this);
    }
    contextChange() {
      this._clearColorCache = [
        0,
        0,
        0,
        0
      ], this._viewPortCache = new Et();
    }
    copyToTexture(t, e, r, n, s) {
      const o = this._renderTargetSystem, a = this._renderer, c = o.getGpuRenderTarget(t), u = a.gl;
      return this.finishRenderPass(t), u.bindFramebuffer(u.FRAMEBUFFER, c.resolveTargetFramebuffer), a.texture.bind(e, 0), u.copyTexSubImage2D(u.TEXTURE_2D, 0, s.x, s.y, r.x, r.y, n.width, n.height), e;
    }
    startRenderPass(t, e = true, r, n) {
      const s = this._renderTargetSystem, o = t.colorTexture, a = s.getGpuRenderTarget(t);
      let c = n.y;
      t.isRoot && (c = o.pixelHeight - n.height), t.colorTextures.forEach((h) => {
        this._renderer.texture.unbind(h);
      });
      const u = this._renderer.gl;
      u.bindFramebuffer(u.FRAMEBUFFER, a.framebuffer);
      const l = this._viewPortCache;
      (l.x !== n.x || l.y !== c || l.width !== n.width || l.height !== n.height) && (l.x = n.x, l.y = c, l.width = n.width, l.height = n.height, u.viewport(n.x, c, n.width, n.height)), !a.depthStencilRenderBuffer && (t.stencil || t.depth) && this._initStencil(a), this.clear(t, e, r);
    }
    finishRenderPass(t) {
      const r = this._renderTargetSystem.getGpuRenderTarget(t);
      if (!r.msaa) return;
      const n = this._renderer.gl;
      n.bindFramebuffer(n.FRAMEBUFFER, r.resolveTargetFramebuffer), n.bindFramebuffer(n.READ_FRAMEBUFFER, r.framebuffer), n.blitFramebuffer(0, 0, r.width, r.height, 0, 0, r.width, r.height, n.COLOR_BUFFER_BIT, n.NEAREST), n.bindFramebuffer(n.FRAMEBUFFER, r.framebuffer);
    }
    initGpuRenderTarget(t) {
      const e = this._renderer, r = e.gl, n = new yy();
      return t.colorTexture.resource === e.gl.canvas ? (n.framebuffer = null, n) : (this._initColor(t, n), r.bindFramebuffer(r.FRAMEBUFFER, null), n);
    }
    destroyGpuRenderTarget(t) {
      const e = this._renderer.gl;
      t.framebuffer && (e.deleteFramebuffer(t.framebuffer), t.framebuffer = null), t.resolveTargetFramebuffer && (e.deleteFramebuffer(t.resolveTargetFramebuffer), t.resolveTargetFramebuffer = null), t.depthStencilRenderBuffer && (e.deleteRenderbuffer(t.depthStencilRenderBuffer), t.depthStencilRenderBuffer = null), t.msaaRenderBuffer.forEach((r) => {
        e.deleteRenderbuffer(r);
      }), t.msaaRenderBuffer = null;
    }
    clear(t, e, r) {
      if (!e) return;
      const n = this._renderTargetSystem;
      typeof e == "boolean" && (e = e ? pe.ALL : pe.NONE);
      const s = this._renderer.gl;
      if (e & pe.COLOR) {
        r ?? (r = n.defaultClearColor);
        const o = this._clearColorCache, a = r;
        (o[0] !== a[0] || o[1] !== a[1] || o[2] !== a[2] || o[3] !== a[3]) && (o[0] = a[0], o[1] = a[1], o[2] = a[2], o[3] = a[3], s.clearColor(a[0], a[1], a[2], a[3]));
      }
      s.clear(e);
    }
    resizeGpuRenderTarget(t) {
      if (t.isRoot) return;
      const r = this._renderTargetSystem.getGpuRenderTarget(t);
      this._resizeColor(t, r), (t.stencil || t.depth) && this._resizeStencil(r);
    }
    _initColor(t, e) {
      const r = this._renderer, n = r.gl, s = n.createFramebuffer();
      if (e.resolveTargetFramebuffer = s, n.bindFramebuffer(n.FRAMEBUFFER, s), e.width = t.colorTexture.source.pixelWidth, e.height = t.colorTexture.source.pixelHeight, t.colorTextures.forEach((o, a) => {
        const c = o.source;
        c.antialias && (r.context.supports.msaa ? e.msaa = true : ut("[RenderTexture] Antialiasing on textures is not supported in WebGL1")), r.texture.bindSource(c, 0);
        const l = r.texture.getGlSource(c).texture;
        n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + a, 3553, l, 0);
      }), e.msaa) {
        const o = n.createFramebuffer();
        e.framebuffer = o, n.bindFramebuffer(n.FRAMEBUFFER, o), t.colorTextures.forEach((a, c) => {
          const u = n.createRenderbuffer();
          e.msaaRenderBuffer[c] = u;
        });
      } else e.framebuffer = s;
      this._resizeColor(t, e);
    }
    _resizeColor(t, e) {
      const r = t.colorTexture.source;
      if (e.width = r.pixelWidth, e.height = r.pixelHeight, t.colorTextures.forEach((n, s) => {
        s !== 0 && n.source.resize(r.width, r.height, r._resolution);
      }), e.msaa) {
        const n = this._renderer, s = n.gl, o = e.framebuffer;
        s.bindFramebuffer(s.FRAMEBUFFER, o), t.colorTextures.forEach((a, c) => {
          const u = a.source;
          n.texture.bindSource(u, 0);
          const h = n.texture.getGlSource(u).internalFormat, f = e.msaaRenderBuffer[c];
          s.bindRenderbuffer(s.RENDERBUFFER, f), s.renderbufferStorageMultisample(s.RENDERBUFFER, 4, h, u.pixelWidth, u.pixelHeight), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + c, s.RENDERBUFFER, f);
        });
      }
    }
    _initStencil(t) {
      if (t.framebuffer === null) return;
      const e = this._renderer.gl, r = e.createRenderbuffer();
      t.depthStencilRenderBuffer = r, e.bindRenderbuffer(e.RENDERBUFFER, r), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.RENDERBUFFER, r), this._resizeStencil(t);
    }
    _resizeStencil(t) {
      const e = this._renderer.gl;
      e.bindRenderbuffer(e.RENDERBUFFER, t.depthStencilRenderBuffer), t.msaa ? e.renderbufferStorageMultisample(e.RENDERBUFFER, 4, e.DEPTH24_STENCIL8, t.width, t.height) : e.renderbufferStorage(e.RENDERBUFFER, this._renderer.context.webGLVersion === 2 ? e.DEPTH24_STENCIL8 : e.DEPTH_STENCIL, t.width, t.height);
    }
  }
  function Ty(i, t, e, r, n, s) {
    const o = s ? 1 : -1;
    return i.identity(), i.a = 1 / r * 2, i.d = o * (1 / n * 2), i.tx = -1 - t * i.a, i.ty = -o - e * i.d, i;
  }
  const pi = /* @__PURE__ */ new Map();
  function Od(i, t) {
    if (!pi.has(i)) {
      const e = new J({
        source: new Kr({
          resource: i,
          ...t
        })
      }), r = () => {
        pi.get(i) === e && pi.delete(i);
      };
      e.once("destroy", r), e.source.once("destroy", r), pi.set(i, e);
    }
    return pi.get(i);
  }
  function Cy(i) {
    const t = i.colorTexture.source.resource;
    return globalThis.HTMLCanvasElement && t instanceof HTMLCanvasElement && document.body.contains(t);
  }
  const Nd = class Ld {
    constructor(t = {}) {
      if (this.uid = Ot("renderTarget"), this.colorTextures = [], this.dirtyId = 0, this.isRoot = false, this._size = new Float32Array(2), this._managedColorTextures = false, t = {
        ...Ld.defaultOptions,
        ...t
      }, this.stencil = t.stencil, this.depth = t.depth, this.isRoot = t.isRoot, typeof t.colorTextures == "number") {
        this._managedColorTextures = true;
        for (let e = 0; e < t.colorTextures; e++) this.colorTextures.push(new Ht({
          width: t.width,
          height: t.height,
          resolution: t.resolution,
          antialias: t.antialias
        }));
      } else {
        this.colorTextures = [
          ...t.colorTextures.map((r) => r.source)
        ];
        const e = this.colorTexture.source;
        this.resize(e.width, e.height, e._resolution);
      }
      this.colorTexture.source.on("resize", this.onSourceResize, this), (t.depthStencilTexture || this.stencil) && (t.depthStencilTexture instanceof J || t.depthStencilTexture instanceof Ht ? this.depthStencilTexture = t.depthStencilTexture.source : this.ensureDepthStencilTexture());
    }
    get size() {
      const t = this._size;
      return t[0] = this.pixelWidth, t[1] = this.pixelHeight, t;
    }
    get width() {
      return this.colorTexture.source.width;
    }
    get height() {
      return this.colorTexture.source.height;
    }
    get pixelWidth() {
      return this.colorTexture.source.pixelWidth;
    }
    get pixelHeight() {
      return this.colorTexture.source.pixelHeight;
    }
    get resolution() {
      return this.colorTexture.source._resolution;
    }
    get colorTexture() {
      return this.colorTextures[0];
    }
    onSourceResize(t) {
      this.resize(t.width, t.height, t._resolution, true);
    }
    ensureDepthStencilTexture() {
      this.depthStencilTexture || (this.depthStencilTexture = new Ht({
        width: this.width,
        height: this.height,
        resolution: this.resolution,
        format: "depth24plus-stencil8",
        autoGenerateMipmaps: false,
        antialias: false,
        mipLevelCount: 1
      }));
    }
    resize(t, e, r = this.resolution, n = false) {
      this.dirtyId++, this.colorTextures.forEach((s, o) => {
        n && o === 0 || s.source.resize(t, e, r);
      }), this.depthStencilTexture && this.depthStencilTexture.source.resize(t, e, r);
    }
    destroy() {
      this.colorTexture.source.off("resize", this.onSourceResize, this), this._managedColorTextures && this.colorTextures.forEach((t) => {
        t.destroy();
      }), this.depthStencilTexture && (this.depthStencilTexture.destroy(), delete this.depthStencilTexture);
    }
  };
  Nd.defaultOptions = {
    width: 0,
    height: 0,
    resolution: 1,
    colorTextures: 1,
    stencil: false,
    depth: false,
    antialias: false,
    isRoot: false
  };
  let No = Nd;
  class Hd {
    constructor(t) {
      this.rootViewPort = new Et(), this.viewport = new Et(), this.onRenderTargetChange = new uh("onRenderTargetChange"), this.projectionMatrix = new nt(), this.defaultClearColor = [
        0,
        0,
        0,
        0
      ], this._renderSurfaceToRenderTargetHash = /* @__PURE__ */ new Map(), this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null), this._renderTargetStack = [], this._renderer = t;
    }
    finishRenderPass() {
      this.adaptor.finishRenderPass(this.renderTarget);
    }
    renderStart({ target: t, clear: e, clearColor: r, frame: n }) {
      this._renderTargetStack.length = 0, this.push(t, e, r, n), this.rootViewPort.copyFrom(this.viewport), this.rootRenderTarget = this.renderTarget, this.renderingToScreen = Cy(this.rootRenderTarget);
    }
    bind(t, e = true, r, n) {
      const s = this.getRenderTarget(t), o = this.renderTarget !== s;
      this.renderTarget = s, this.renderSurface = t;
      const a = this.getGpuRenderTarget(s);
      (s.pixelWidth !== a.width || s.pixelHeight !== a.height) && (this.adaptor.resizeGpuRenderTarget(s), a.width = s.pixelWidth, a.height = s.pixelHeight);
      const c = s.colorTexture, u = this.viewport, l = c.pixelWidth, h = c.pixelHeight;
      if (!n && t instanceof J && (n = t.frame), n) {
        const f = c._resolution;
        u.x = n.x * f + 0.5 | 0, u.y = n.y * f + 0.5 | 0, u.width = n.width * f + 0.5 | 0, u.height = n.height * f + 0.5 | 0;
      } else u.x = 0, u.y = 0, u.width = l, u.height = h;
      return Ty(this.projectionMatrix, 0, 0, u.width / c.resolution, u.height / c.resolution, !s.isRoot), this.adaptor.startRenderPass(s, e, r, u), o && this.onRenderTargetChange.emit(s), s;
    }
    clear(t, e = pe.ALL, r) {
      e && (t && (t = this.getRenderTarget(t)), this.adaptor.clear(t || this.renderTarget, e, r, this.viewport));
    }
    contextChange() {
      this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);
    }
    push(t, e = pe.ALL, r, n) {
      const s = this.bind(t, e, r, n);
      return this._renderTargetStack.push({
        renderTarget: s,
        frame: n
      }), s;
    }
    pop() {
      this._renderTargetStack.pop();
      const t = this._renderTargetStack[this._renderTargetStack.length - 1];
      this.bind(t.renderTarget, false, null, t.frame);
    }
    getRenderTarget(t) {
      return t.isTexture && (t = t.source), this._renderSurfaceToRenderTargetHash.get(t) ?? this._initRenderTarget(t);
    }
    copyToTexture(t, e, r, n, s) {
      r.x < 0 && (n.width += r.x, s.x -= r.x, r.x = 0), r.y < 0 && (n.height += r.y, s.y -= r.y, r.y = 0);
      const { pixelWidth: o, pixelHeight: a } = t;
      return n.width = Math.min(n.width, o - r.x), n.height = Math.min(n.height, a - r.y), this.adaptor.copyToTexture(t, e, r, n, s);
    }
    ensureDepthStencil() {
      this.renderTarget.stencil || (this.renderTarget.stencil = true, this.adaptor.startRenderPass(this.renderTarget, false, null, this.viewport));
    }
    destroy() {
      this._renderer = null, this._renderSurfaceToRenderTargetHash.forEach((t, e) => {
        t !== e && t.destroy();
      }), this._renderSurfaceToRenderTargetHash.clear(), this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);
    }
    _initRenderTarget(t) {
      let e = null;
      return Kr.test(t) && (t = Od(t).source), t instanceof No ? e = t : t instanceof Ht && (e = new No({
        colorTextures: [
          t
        ]
      }), Kr.test(t.source.resource) && (e.isRoot = true), t.once("destroy", () => {
        e.destroy();
        const r = this._gpuRenderTargetHash[e.uid];
        r && (this._gpuRenderTargetHash[e.uid] = null, this.adaptor.destroyGpuRenderTarget(r));
      })), this._renderSurfaceToRenderTargetHash.set(t, e), e;
    }
    getGpuRenderTarget(t) {
      return this._gpuRenderTargetHash[t.uid] || (this._gpuRenderTargetHash[t.uid] = this.adaptor.initGpuRenderTarget(t));
    }
  }
  class zd extends Hd {
    constructor(t) {
      super(t), this.adaptor = new Ay(), this.adaptor.init(t, this);
    }
  }
  zd.extension = {
    type: [
      P.WebGLSystem
    ],
    name: "renderTarget"
  };
  class Ea extends me {
    constructor({ buffer: t, offset: e, size: r }) {
      super(), this.uid = Ot("buffer"), this._resourceType = "bufferResource", this._touched = 0, this._resourceId = Ot("resource"), this._bufferResource = true, this.destroyed = false, this.buffer = t, this.offset = e | 0, this.size = r, this.buffer.on("change", this.onBufferChange, this);
    }
    onBufferChange() {
      this._resourceId = Ot("resource"), this.emit("change", this);
    }
    destroy(t = false) {
      this.destroyed = true, t && this.buffer.destroy(), this.emit("change", this), this.buffer = null;
    }
  }
  function Ry(i, t) {
    const e = [], r = [
      `
        var g = s.groups;
        var sS = r.shader;
        var p = s.glProgram;
        var ugS = r.uniformGroup;
        var resources;
    `
    ];
    let n = false, s = 0, o = 0;
    const a = t._getProgramData(i.glProgram);
    for (const u in i.groups) {
      const l = i.groups[u];
      e.push(`
            resources = g[${u}].resources;
        `);
      for (const h in l.resources) {
        const f = l.resources[h];
        if (f instanceof Qt) f.ubo ? e.push(`
                        sS.bindUniformBlock(
                            resources[${h}],
                            sS._uniformBindMap[${u}[${h}],
                            ${s++}
                        );
                    `) : e.push(`
                        ugS.updateUniformGroup(resources[${h}], p, sD);
                    `);
        else if (f instanceof Ea) e.push(`
                    sS.bindUniformBlock(
                        resources[${h}],
                        sS._uniformBindMap[${u}[${h}],
                        ${s++}
                    );
                `);
        else if (f instanceof Ht) {
          const p = i._uniformBindMap[u][h], m = a.uniformData[p];
          m && (n || (n = true, r.push(`
                        var tS = r.texture;
                        `)), t._gl.uniform1i(m.location, o), e.push(`
                        tS.bind(resources[${h}], ${o});
                    `), o++);
        }
      }
    }
    const c = [
      ...r,
      ...e
    ].join(`
`);
    return new Function("r", "s", "sD", c);
  }
  class Py {
    constructor(t, e) {
      this.program = t, this.uniformData = e, this.uniformGroups = {}, this.uniformDirtyGroups = {}, this.uniformBlockBindings = {};
    }
    destroy() {
      this.uniformData = null, this.uniformGroups = null, this.uniformDirtyGroups = null, this.uniformBlockBindings = null, this.program = null;
    }
  }
  function Du(i, t, e) {
    const r = i.createShader(t);
    return i.shaderSource(r, e), i.compileShader(r), r;
  }
  function oo(i) {
    const t = new Array(i);
    for (let e = 0; e < t.length; e++) t[e] = false;
    return t;
  }
  function jd(i, t) {
    switch (i) {
      case "float":
        return 0;
      case "vec2":
        return new Float32Array(2 * t);
      case "vec3":
        return new Float32Array(3 * t);
      case "vec4":
        return new Float32Array(4 * t);
      case "int":
      case "uint":
      case "sampler2D":
      case "sampler2DArray":
        return 0;
      case "ivec2":
        return new Int32Array(2 * t);
      case "ivec3":
        return new Int32Array(3 * t);
      case "ivec4":
        return new Int32Array(4 * t);
      case "uvec2":
        return new Uint32Array(2 * t);
      case "uvec3":
        return new Uint32Array(3 * t);
      case "uvec4":
        return new Uint32Array(4 * t);
      case "bool":
        return false;
      case "bvec2":
        return oo(2 * t);
      case "bvec3":
        return oo(3 * t);
      case "bvec4":
        return oo(4 * t);
      case "mat2":
        return new Float32Array([
          1,
          0,
          0,
          1
        ]);
      case "mat3":
        return new Float32Array([
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1
        ]);
      case "mat4":
        return new Float32Array([
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1
        ]);
    }
    return null;
  }
  let dn = null;
  const Iu = {
    FLOAT: "float",
    FLOAT_VEC2: "vec2",
    FLOAT_VEC3: "vec3",
    FLOAT_VEC4: "vec4",
    INT: "int",
    INT_VEC2: "ivec2",
    INT_VEC3: "ivec3",
    INT_VEC4: "ivec4",
    UNSIGNED_INT: "uint",
    UNSIGNED_INT_VEC2: "uvec2",
    UNSIGNED_INT_VEC3: "uvec3",
    UNSIGNED_INT_VEC4: "uvec4",
    BOOL: "bool",
    BOOL_VEC2: "bvec2",
    BOOL_VEC3: "bvec3",
    BOOL_VEC4: "bvec4",
    FLOAT_MAT2: "mat2",
    FLOAT_MAT3: "mat3",
    FLOAT_MAT4: "mat4",
    SAMPLER_2D: "sampler2D",
    INT_SAMPLER_2D: "sampler2D",
    UNSIGNED_INT_SAMPLER_2D: "sampler2D",
    SAMPLER_CUBE: "samplerCube",
    INT_SAMPLER_CUBE: "samplerCube",
    UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
    SAMPLER_2D_ARRAY: "sampler2DArray",
    INT_SAMPLER_2D_ARRAY: "sampler2DArray",
    UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
  }, By = {
    float: "float32",
    vec2: "float32x2",
    vec3: "float32x3",
    vec4: "float32x4",
    int: "sint32",
    ivec2: "sint32x2",
    ivec3: "sint32x3",
    ivec4: "sint32x4",
    uint: "uint32",
    uvec2: "uint32x2",
    uvec3: "uint32x3",
    uvec4: "uint32x4",
    bool: "uint32",
    bvec2: "uint32x2",
    bvec3: "uint32x3",
    bvec4: "uint32x4"
  };
  function Wd(i, t) {
    if (!dn) {
      const e = Object.keys(Iu);
      dn = {};
      for (let r = 0; r < e.length; ++r) {
        const n = e[r];
        dn[i[n]] = Iu[n];
      }
    }
    return dn[t];
  }
  function My(i, t) {
    const e = Wd(i, t);
    return By[e] || "float32";
  }
  function Dy(i, t, e = false) {
    const r = {}, n = t.getProgramParameter(i, t.ACTIVE_ATTRIBUTES);
    for (let o = 0; o < n; o++) {
      const a = t.getActiveAttrib(i, o);
      if (a.name.startsWith("gl_")) continue;
      const c = My(t, a.type);
      r[a.name] = {
        location: 0,
        format: c,
        stride: Ti(c).stride,
        offset: 0,
        instance: false,
        start: 0
      };
    }
    const s = Object.keys(r);
    if (e) {
      s.sort((o, a) => o > a ? 1 : -1);
      for (let o = 0; o < s.length; o++) r[s[o]].location = o, t.bindAttribLocation(i, o, s[o]);
      t.linkProgram(i);
    } else for (let o = 0; o < s.length; o++) r[s[o]].location = t.getAttribLocation(i, s[o]);
    return r;
  }
  function Iy(i, t) {
    if (!t.ACTIVE_UNIFORM_BLOCKS) return {};
    const e = {}, r = t.getProgramParameter(i, t.ACTIVE_UNIFORM_BLOCKS);
    for (let n = 0; n < r; n++) {
      const s = t.getActiveUniformBlockName(i, n), o = t.getUniformBlockIndex(i, s), a = t.getActiveUniformBlockParameter(i, n, t.UNIFORM_BLOCK_DATA_SIZE);
      e[s] = {
        name: s,
        index: o,
        size: a
      };
    }
    return e;
  }
  function Fy(i, t) {
    const e = {}, r = t.getProgramParameter(i, t.ACTIVE_UNIFORMS);
    for (let n = 0; n < r; n++) {
      const s = t.getActiveUniform(i, n), o = s.name.replace(/\[.*?\]$/, ""), a = !!s.name.match(/\[.*?\]$/), c = Wd(t, s.type);
      e[o] = {
        name: o,
        index: n,
        type: c,
        size: s.size,
        isArray: a,
        value: jd(c, s.size)
      };
    }
    return e;
  }
  function Fu(i, t) {
    const e = i.getShaderSource(t).split(`
`).map((u, l) => `${l}: ${u}`), r = i.getShaderInfoLog(t), n = r.split(`
`), s = {}, o = n.map((u) => parseFloat(u.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))).filter((u) => u && !s[u] ? (s[u] = true, true) : false), a = [
      ""
    ];
    o.forEach((u) => {
      e[u - 1] = `%c${e[u - 1]}%c`, a.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
    });
    const c = e.join(`
`);
    a[0] = c, console.error(r), console.groupCollapsed("click to view full shader code"), console.warn(...a), console.groupEnd();
  }
  function Uy(i, t, e, r) {
    i.getProgramParameter(t, i.LINK_STATUS) || (i.getShaderParameter(e, i.COMPILE_STATUS) || Fu(i, e), i.getShaderParameter(r, i.COMPILE_STATUS) || Fu(i, r), console.error("PixiJS Error: Could not initialize shader."), i.getProgramInfoLog(t) !== "" && console.warn("PixiJS Warning: gl.getProgramInfoLog()", i.getProgramInfoLog(t)));
  }
  function ky(i, t) {
    const e = Du(i, i.VERTEX_SHADER, t.vertex), r = Du(i, i.FRAGMENT_SHADER, t.fragment), n = i.createProgram();
    i.attachShader(n, e), i.attachShader(n, r);
    const s = t.transformFeedbackVaryings;
    s && (typeof i.transformFeedbackVaryings != "function" ? ut("TransformFeedback is not supported but TransformFeedbackVaryings are given.") : i.transformFeedbackVaryings(n, s.names, s.bufferMode === "separate" ? i.SEPARATE_ATTRIBS : i.INTERLEAVED_ATTRIBS)), i.linkProgram(n), i.getProgramParameter(n, i.LINK_STATUS) || Uy(i, n, e, r), t._attributeData = Dy(n, i, !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(t.vertex)), t._uniformData = Fy(n, i), t._uniformBlockData = Iy(n, i), i.deleteShader(e), i.deleteShader(r);
    const o = {};
    for (const c in t._uniformData) {
      const u = t._uniformData[c];
      o[c] = {
        location: i.getUniformLocation(n, c),
        value: jd(u.type, u.size)
      };
    }
    return new Py(n, o);
  }
  const fn = {
    textureCount: 0,
    blockIndex: 0
  };
  class Vd {
    constructor(t) {
      this._activeProgram = null, this._programDataHash = /* @__PURE__ */ Object.create(null), this._nextIndex = 0, this._boundUniformsIdsToIndexHash = /* @__PURE__ */ Object.create(null), this._boundIndexToUniformsHash = /* @__PURE__ */ Object.create(null), this._shaderSyncFunctions = /* @__PURE__ */ Object.create(null), this._renderer = t;
    }
    contextChange(t) {
      this._gl = t, this._maxBindings = t.MAX_UNIFORM_BUFFER_BINDINGS ? t.getParameter(t.MAX_UNIFORM_BUFFER_BINDINGS) : 0, this._programDataHash = /* @__PURE__ */ Object.create(null), this._boundUniformsIdsToIndexHash = /* @__PURE__ */ Object.create(null), this._boundIndexToUniformsHash = /* @__PURE__ */ Object.create(null), this._shaderSyncFunctions = /* @__PURE__ */ Object.create(null), this._activeProgram = null;
    }
    bind(t, e) {
      if (this._setProgram(t.glProgram), e) return;
      fn.textureCount = 0, fn.blockIndex = 0;
      let r = this._shaderSyncFunctions[t.glProgram._key];
      r || (r = this._shaderSyncFunctions[t.glProgram._key] = this._generateShaderSync(t, this)), r(this._renderer, t, fn);
    }
    updateUniformGroup(t) {
      this._renderer.uniformGroup.updateUniformGroup(t, this._activeProgram, fn);
    }
    bindUniformBlock(t, e, r = 0) {
      const n = this._renderer.buffer, s = this._getProgramData(this._activeProgram), o = t._bufferResource;
      o && this._renderer.ubo.updateUniformGroup(t), n.updateBuffer(t.buffer);
      let a = this._boundUniformsIdsToIndexHash[t.uid];
      if (a === void 0) {
        const l = this._nextIndex++ % this._maxBindings, h = this._boundIndexToUniformsHash[l];
        h && (this._boundUniformsIdsToIndexHash[h.uid] = void 0), a = this._boundUniformsIdsToIndexHash[t.uid] = l, this._boundIndexToUniformsHash[l] = t, o ? n.bindBufferRange(t.buffer, l, t.offset) : n.bindBufferBase(t.buffer, l);
      }
      const c = this._gl, u = this._activeProgram._uniformBlockData[e].index;
      s.uniformBlockBindings[r] !== a && (s.uniformBlockBindings[r] = a, c.uniformBlockBinding(s.program, u, a));
    }
    _setProgram(t) {
      if (this._activeProgram === t) return;
      this._activeProgram = t;
      const e = this._getProgramData(t);
      this._gl.useProgram(e.program);
    }
    _getProgramData(t) {
      return this._programDataHash[t._key] || this._createProgramData(t);
    }
    _createProgramData(t) {
      const e = t._key;
      return this._programDataHash[e] = ky(this._gl, t), this._programDataHash[e];
    }
    destroy() {
      for (const t of Object.keys(this._programDataHash)) this._programDataHash[t].destroy(), this._programDataHash[t] = null;
      this._programDataHash = null, this._boundUniformsIdsToIndexHash = null;
    }
    _generateShaderSync(t, e) {
      return Ry(t, e);
    }
  }
  Vd.extension = {
    type: [
      P.WebGLSystem
    ],
    name: "shader"
  };
  const Gy = {
    f32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1f(location, v);
        }`,
    "vec2<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2f(location, v[0], v[1]);
        }`,
    "vec3<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3f(location, v[0], v[1], v[2]);
        }`,
    "vec4<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4f(location, v[0], v[1], v[2], v[3]);
        }`,
    i32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,
    "vec2<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,
    "vec3<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,
    "vec4<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,
    u32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1ui(location, v);
        }`,
    "vec2<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2ui(location, v[0], v[1]);
        }`,
    "vec3<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3ui(location, v[0], v[1], v[2]);
        }`,
    "vec4<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
        }`,
    bool: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,
    "vec2<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,
    "vec3<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,
    "vec4<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,
    "mat2x2<f32>": "gl.uniformMatrix2fv(location, false, v);",
    "mat3x3<f32>": "gl.uniformMatrix3fv(location, false, v);",
    "mat4x4<f32>": "gl.uniformMatrix4fv(location, false, v);"
  }, Oy = {
    f32: "gl.uniform1fv(location, v);",
    "vec2<f32>": "gl.uniform2fv(location, v);",
    "vec3<f32>": "gl.uniform3fv(location, v);",
    "vec4<f32>": "gl.uniform4fv(location, v);",
    "mat2x2<f32>": "gl.uniformMatrix2fv(location, false, v);",
    "mat3x3<f32>": "gl.uniformMatrix3fv(location, false, v);",
    "mat4x4<f32>": "gl.uniformMatrix4fv(location, false, v);",
    i32: "gl.uniform1iv(location, v);",
    "vec2<i32>": "gl.uniform2iv(location, v);",
    "vec3<i32>": "gl.uniform3iv(location, v);",
    "vec4<i32>": "gl.uniform4iv(location, v);",
    u32: "gl.uniform1iv(location, v);",
    "vec2<u32>": "gl.uniform2iv(location, v);",
    "vec3<u32>": "gl.uniform3iv(location, v);",
    "vec4<u32>": "gl.uniform4iv(location, v);",
    bool: "gl.uniform1iv(location, v);",
    "vec2<bool>": "gl.uniform2iv(location, v);",
    "vec3<bool>": "gl.uniform3iv(location, v);",
    "vec4<bool>": "gl.uniform4iv(location, v);"
  };
  function Ny(i, t) {
    const e = [
      `
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
        var name = null;
    `
    ];
    for (const r in i.uniforms) {
      if (!t[r]) {
        i.uniforms[r] instanceof Qt ? i.uniforms[r].ubo ? e.push(`
                        renderer.shader.bindUniformBlock(uv.${r}, "${r}");
                    `) : e.push(`
                        renderer.shader.updateUniformGroup(uv.${r});
                    `) : i.uniforms[r] instanceof Ea && e.push(`
                        renderer.shader.bindBufferResource(uv.${r}, "${r}");
                    `);
        continue;
      }
      const n = i.uniformStructures[r];
      let s = false;
      for (let o = 0; o < Pr.length; o++) {
        const a = Pr[o];
        if (n.type === a.type && a.test(n)) {
          e.push(`name = "${r}";`, Pr[o].uniform), s = true;
          break;
        }
      }
      if (!s) {
        const a = (n.size === 1 ? Gy : Oy)[n.type].replace("location", `ud["${r}"].location`);
        e.push(`
            cu = ud["${r}"];
            cv = cu.value;
            v = uv["${r}"];
            ${a};`);
      }
    }
    return new Function("ud", "uv", "renderer", "syncData", e.join(`
`));
  }
  class Xd {
    constructor(t) {
      this._cache = {}, this._uniformGroupSyncHash = {}, this._renderer = t, this.gl = null, this._cache = {};
    }
    contextChange(t) {
      this.gl = t;
    }
    updateUniformGroup(t, e, r) {
      const n = this._renderer.shader._getProgramData(e);
      (!t.isStatic || t._dirtyId !== n.uniformDirtyGroups[t.uid]) && (n.uniformDirtyGroups[t.uid] = t._dirtyId, this._getUniformSyncFunction(t, e)(n.uniformData, t.uniforms, this._renderer, r));
    }
    _getUniformSyncFunction(t, e) {
      var _a2;
      return ((_a2 = this._uniformGroupSyncHash[t._signature]) == null ? void 0 : _a2[e._key]) || this._createUniformSyncFunction(t, e);
    }
    _createUniformSyncFunction(t, e) {
      const r = this._uniformGroupSyncHash[t._signature] || (this._uniformGroupSyncHash[t._signature] = {}), n = this._getSignature(t, e._uniformData, "u");
      return this._cache[n] || (this._cache[n] = this._generateUniformsSync(t, e._uniformData)), r[e._key] = this._cache[n], r[e._key];
    }
    _generateUniformsSync(t, e) {
      return Ny(t, e);
    }
    _getSignature(t, e, r) {
      const n = t.uniforms, s = [
        `${r}-`
      ];
      for (const o in n) s.push(o), e[o] && s.push(e[o].type);
      return s.join("-");
    }
    destroy() {
      this._renderer = null, this._cache = null;
    }
  }
  Xd.extension = {
    type: [
      P.WebGLSystem
    ],
    name: "uniformGroup"
  };
  function Ly(i) {
    const t = {};
    return t.normal = [
      i.ONE,
      i.ONE_MINUS_SRC_ALPHA
    ], t.add = [
      i.ONE,
      i.ONE
    ], t.multiply = [
      i.DST_COLOR,
      i.ONE_MINUS_SRC_ALPHA,
      i.ONE,
      i.ONE_MINUS_SRC_ALPHA
    ], t.screen = [
      i.ONE,
      i.ONE_MINUS_SRC_COLOR,
      i.ONE,
      i.ONE_MINUS_SRC_ALPHA
    ], t.none = [
      0,
      0
    ], t["normal-npm"] = [
      i.SRC_ALPHA,
      i.ONE_MINUS_SRC_ALPHA,
      i.ONE,
      i.ONE_MINUS_SRC_ALPHA
    ], t["add-npm"] = [
      i.SRC_ALPHA,
      i.ONE,
      i.ONE,
      i.ONE
    ], t["screen-npm"] = [
      i.SRC_ALPHA,
      i.ONE_MINUS_SRC_COLOR,
      i.ONE,
      i.ONE_MINUS_SRC_ALPHA
    ], t.erase = [
      i.ZERO,
      i.ONE_MINUS_SRC_ALPHA
    ], t;
  }
  const Hy = 0, zy = 1, jy = 2, Wy = 3, Vy = 4, Xy = 5, qd = class Lo {
    constructor() {
      this.gl = null, this.stateId = 0, this.polygonOffset = 0, this.blendMode = "none", this._blendEq = false, this.map = [], this.map[Hy] = this.setBlend, this.map[zy] = this.setOffset, this.map[jy] = this.setCullFace, this.map[Wy] = this.setDepthTest, this.map[Vy] = this.setFrontFace, this.map[Xy] = this.setDepthMask, this.checks = [], this.defaultState = Le.for2d();
    }
    contextChange(t) {
      this.gl = t, this.blendModesMap = Ly(t), this.reset();
    }
    set(t) {
      if (t = t || this.defaultState, this.stateId !== t.data) {
        let e = this.stateId ^ t.data, r = 0;
        for (; e; ) e & 1 && this.map[r].call(this, !!(t.data & 1 << r)), e = e >> 1, r++;
        this.stateId = t.data;
      }
      for (let e = 0; e < this.checks.length; e++) this.checks[e](this, t);
    }
    forceState(t) {
      t = t || this.defaultState;
      for (let e = 0; e < this.map.length; e++) this.map[e].call(this, !!(t.data & 1 << e));
      for (let e = 0; e < this.checks.length; e++) this.checks[e](this, t);
      this.stateId = t.data;
    }
    setBlend(t) {
      this._updateCheck(Lo._checkBlendMode, t), this.gl[t ? "enable" : "disable"](this.gl.BLEND);
    }
    setOffset(t) {
      this._updateCheck(Lo._checkPolygonOffset, t), this.gl[t ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
    }
    setDepthTest(t) {
      this.gl[t ? "enable" : "disable"](this.gl.DEPTH_TEST);
    }
    setDepthMask(t) {
      this.gl.depthMask(t);
    }
    setCullFace(t) {
      this.gl[t ? "enable" : "disable"](this.gl.CULL_FACE);
    }
    setFrontFace(t) {
      this.gl.frontFace(this.gl[t ? "CW" : "CCW"]);
    }
    setBlendMode(t) {
      if (this.blendModesMap[t] || (t = "normal"), t === this.blendMode) return;
      this.blendMode = t;
      const e = this.blendModesMap[t], r = this.gl;
      e.length === 2 ? r.blendFunc(e[0], e[1]) : r.blendFuncSeparate(e[0], e[1], e[2], e[3]), e.length === 6 ? (this._blendEq = true, r.blendEquationSeparate(e[4], e[5])) : this._blendEq && (this._blendEq = false, r.blendEquationSeparate(r.FUNC_ADD, r.FUNC_ADD));
    }
    setPolygonOffset(t, e) {
      this.gl.polygonOffset(t, e);
    }
    reset() {
      this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false), this.forceState(this.defaultState), this._blendEq = true, this.blendMode = "", this.setBlendMode("normal");
    }
    _updateCheck(t, e) {
      const r = this.checks.indexOf(t);
      e && r === -1 ? this.checks.push(t) : !e && r !== -1 && this.checks.splice(r, 1);
    }
    static _checkBlendMode(t, e) {
      t.setBlendMode(e.blendMode);
    }
    static _checkPolygonOffset(t, e) {
      t.setPolygonOffset(1, e.polygonOffset);
    }
    destroy() {
      this.gl = null, this.checks.length = 0;
    }
  };
  qd.extension = {
    type: [
      P.WebGLSystem
    ],
    name: "state"
  };
  let qy = qd;
  class $y {
    constructor(t) {
      this.target = Cd.TEXTURE_2D, this.texture = t, this.width = -1, this.height = -1, this.type = wt.UNSIGNED_BYTE, this.internalFormat = Oo.RGBA, this.format = Oo.RGBA, this.samplerType = 0;
    }
  }
  const Yy = {
    id: "buffer",
    upload(i, t, e) {
      t.width === i.width || t.height === i.height ? e.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, i.width, i.height, t.format, t.type, i.resource) : e.texImage2D(t.target, 0, t.internalFormat, i.width, i.height, 0, t.format, t.type, i.resource), t.width = i.width, t.height = i.height;
    }
  }, Ky = {
    "bc1-rgba-unorm": true,
    "bc1-rgba-unorm-srgb": true,
    "bc2-rgba-unorm": true,
    "bc2-rgba-unorm-srgb": true,
    "bc3-rgba-unorm": true,
    "bc3-rgba-unorm-srgb": true,
    "bc4-r-unorm": true,
    "bc4-r-snorm": true,
    "bc5-rg-unorm": true,
    "bc5-rg-snorm": true,
    "bc6h-rgb-ufloat": true,
    "bc6h-rgb-float": true,
    "bc7-rgba-unorm": true,
    "bc7-rgba-unorm-srgb": true,
    "etc2-rgb8unorm": true,
    "etc2-rgb8unorm-srgb": true,
    "etc2-rgb8a1unorm": true,
    "etc2-rgb8a1unorm-srgb": true,
    "etc2-rgba8unorm": true,
    "etc2-rgba8unorm-srgb": true,
    "eac-r11unorm": true,
    "eac-r11snorm": true,
    "eac-rg11unorm": true,
    "eac-rg11snorm": true,
    "astc-4x4-unorm": true,
    "astc-4x4-unorm-srgb": true,
    "astc-5x4-unorm": true,
    "astc-5x4-unorm-srgb": true,
    "astc-5x5-unorm": true,
    "astc-5x5-unorm-srgb": true,
    "astc-6x5-unorm": true,
    "astc-6x5-unorm-srgb": true,
    "astc-6x6-unorm": true,
    "astc-6x6-unorm-srgb": true,
    "astc-8x5-unorm": true,
    "astc-8x5-unorm-srgb": true,
    "astc-8x6-unorm": true,
    "astc-8x6-unorm-srgb": true,
    "astc-8x8-unorm": true,
    "astc-8x8-unorm-srgb": true,
    "astc-10x5-unorm": true,
    "astc-10x5-unorm-srgb": true,
    "astc-10x6-unorm": true,
    "astc-10x6-unorm-srgb": true,
    "astc-10x8-unorm": true,
    "astc-10x8-unorm-srgb": true,
    "astc-10x10-unorm": true,
    "astc-10x10-unorm-srgb": true,
    "astc-12x10-unorm": true,
    "astc-12x10-unorm-srgb": true,
    "astc-12x12-unorm": true,
    "astc-12x12-unorm-srgb": true
  }, Zy = {
    id: "compressed",
    upload(i, t, e) {
      e.pixelStorei(e.UNPACK_ALIGNMENT, 4);
      let r = i.pixelWidth, n = i.pixelHeight;
      const s = !!Ky[i.format];
      for (let o = 0; o < i.resource.length; o++) {
        const a = i.resource[o];
        s ? e.compressedTexImage2D(e.TEXTURE_2D, o, t.internalFormat, r, n, 0, a) : e.texImage2D(e.TEXTURE_2D, o, t.internalFormat, r, n, 0, t.format, t.type, a), r = Math.max(r >> 1, 1), n = Math.max(n >> 1, 1);
      }
    }
  }, $d = {
    id: "image",
    upload(i, t, e, r) {
      const n = i.alphaMode === "premultiply-alpha-on-upload";
      e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, n);
      const s = t.width, o = t.height, a = i.pixelWidth, c = i.pixelHeight, u = i.resourceWidth, l = i.resourceHeight;
      u < a || l < c ? ((s !== a || o !== c) && e.texImage2D(t.target, 0, t.internalFormat, a, c, 0, t.format, t.type, null), r === 2 ? e.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, u, l, t.format, t.type, i.resource) : e.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, t.format, t.type, i.resource)) : s === a || o === c ? e.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, t.format, t.type, i.resource) : r === 2 ? e.texImage2D(t.target, 0, t.internalFormat, a, c, 0, t.format, t.type, i.resource) : e.texImage2D(t.target, 0, t.internalFormat, t.format, t.type, i.resource), t.width = a, t.height = c;
    }
  }, Jy = {
    id: "video",
    upload(i, t, e, r) {
      if (!i.isValid) {
        e.texImage2D(t.target, 0, t.internalFormat, 1, 1, 0, t.format, t.type, null);
        return;
      }
      $d.upload(i, t, e, r);
    }
  }, Uu = {
    linear: 9729,
    nearest: 9728
  }, Qy = {
    linear: {
      linear: 9987,
      nearest: 9985
    },
    nearest: {
      linear: 9986,
      nearest: 9984
    }
  }, ao = {
    "clamp-to-edge": 33071,
    repeat: 10497,
    "mirror-repeat": 33648
  }, t0 = {
    never: 512,
    less: 513,
    equal: 514,
    "less-equal": 515,
    greater: 516,
    "not-equal": 517,
    "greater-equal": 518,
    always: 519
  };
  function ku(i, t, e, r, n, s, o, a) {
    const c = s;
    if (!a || i.addressModeU !== "repeat" || i.addressModeV !== "repeat" || i.addressModeW !== "repeat") {
      const u = ao[o ? "clamp-to-edge" : i.addressModeU], l = ao[o ? "clamp-to-edge" : i.addressModeV], h = ao[o ? "clamp-to-edge" : i.addressModeW];
      t[n](c, t.TEXTURE_WRAP_S, u), t[n](c, t.TEXTURE_WRAP_T, l), t.TEXTURE_WRAP_R && t[n](c, t.TEXTURE_WRAP_R, h);
    }
    if ((!a || i.magFilter !== "linear") && t[n](c, t.TEXTURE_MAG_FILTER, Uu[i.magFilter]), e) {
      if (!a || i.mipmapFilter !== "linear") {
        const u = Qy[i.minFilter][i.mipmapFilter];
        t[n](c, t.TEXTURE_MIN_FILTER, u);
      }
    } else t[n](c, t.TEXTURE_MIN_FILTER, Uu[i.minFilter]);
    if (r && i.maxAnisotropy > 1) {
      const u = Math.min(i.maxAnisotropy, t.getParameter(r.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
      t[n](c, r.TEXTURE_MAX_ANISOTROPY_EXT, u);
    }
    i.compare && t[n](c, t.TEXTURE_COMPARE_FUNC, t0[i.compare]);
  }
  function e0(i) {
    return {
      r8unorm: i.RED,
      r8snorm: i.RED,
      r8uint: i.RED,
      r8sint: i.RED,
      r16uint: i.RED,
      r16sint: i.RED,
      r16float: i.RED,
      rg8unorm: i.RG,
      rg8snorm: i.RG,
      rg8uint: i.RG,
      rg8sint: i.RG,
      r32uint: i.RED,
      r32sint: i.RED,
      r32float: i.RED,
      rg16uint: i.RG,
      rg16sint: i.RG,
      rg16float: i.RG,
      rgba8unorm: i.RGBA,
      "rgba8unorm-srgb": i.RGBA,
      rgba8snorm: i.RGBA,
      rgba8uint: i.RGBA,
      rgba8sint: i.RGBA,
      bgra8unorm: i.RGBA,
      "bgra8unorm-srgb": i.RGBA,
      rgb9e5ufloat: i.RGB,
      rgb10a2unorm: i.RGBA,
      rg11b10ufloat: i.RGB,
      rg32uint: i.RG,
      rg32sint: i.RG,
      rg32float: i.RG,
      rgba16uint: i.RGBA,
      rgba16sint: i.RGBA,
      rgba16float: i.RGBA,
      rgba32uint: i.RGBA,
      rgba32sint: i.RGBA,
      rgba32float: i.RGBA,
      stencil8: i.STENCIL_INDEX8,
      depth16unorm: i.DEPTH_COMPONENT,
      depth24plus: i.DEPTH_COMPONENT,
      "depth24plus-stencil8": i.DEPTH_STENCIL,
      depth32float: i.DEPTH_COMPONENT,
      "depth32float-stencil8": i.DEPTH_STENCIL
    };
  }
  function r0(i, t) {
    let e = {}, r = i.RGBA;
    return i instanceof St.get().getWebGLRenderingContext() ? t.srgb && (e = {
      "rgba8unorm-srgb": t.srgb.SRGB8_ALPHA8_EXT,
      "bgra8unorm-srgb": t.srgb.SRGB8_ALPHA8_EXT
    }) : (e = {
      "rgba8unorm-srgb": i.SRGB8_ALPHA8,
      "bgra8unorm-srgb": i.SRGB8_ALPHA8
    }, r = i.RGBA8), {
      r8unorm: i.R8,
      r8snorm: i.R8_SNORM,
      r8uint: i.R8UI,
      r8sint: i.R8I,
      r16uint: i.R16UI,
      r16sint: i.R16I,
      r16float: i.R16F,
      rg8unorm: i.RG8,
      rg8snorm: i.RG8_SNORM,
      rg8uint: i.RG8UI,
      rg8sint: i.RG8I,
      r32uint: i.R32UI,
      r32sint: i.R32I,
      r32float: i.R32F,
      rg16uint: i.RG16UI,
      rg16sint: i.RG16I,
      rg16float: i.RG16F,
      rgba8unorm: i.RGBA,
      ...e,
      rgba8snorm: i.RGBA8_SNORM,
      rgba8uint: i.RGBA8UI,
      rgba8sint: i.RGBA8I,
      bgra8unorm: r,
      rgb9e5ufloat: i.RGB9_E5,
      rgb10a2unorm: i.RGB10_A2,
      rg11b10ufloat: i.R11F_G11F_B10F,
      rg32uint: i.RG32UI,
      rg32sint: i.RG32I,
      rg32float: i.RG32F,
      rgba16uint: i.RGBA16UI,
      rgba16sint: i.RGBA16I,
      rgba16float: i.RGBA16F,
      rgba32uint: i.RGBA32UI,
      rgba32sint: i.RGBA32I,
      rgba32float: i.RGBA32F,
      stencil8: i.STENCIL_INDEX8,
      depth16unorm: i.DEPTH_COMPONENT16,
      depth24plus: i.DEPTH_COMPONENT24,
      "depth24plus-stencil8": i.DEPTH24_STENCIL8,
      depth32float: i.DEPTH_COMPONENT32F,
      "depth32float-stencil8": i.DEPTH32F_STENCIL8,
      ...t.s3tc ? {
        "bc1-rgba-unorm": t.s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT,
        "bc2-rgba-unorm": t.s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT,
        "bc3-rgba-unorm": t.s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT
      } : {},
      ...t.s3tc_sRGB ? {
        "bc1-rgba-unorm-srgb": t.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
        "bc2-rgba-unorm-srgb": t.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
        "bc3-rgba-unorm-srgb": t.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
      } : {},
      ...t.rgtc ? {
        "bc4-r-unorm": t.rgtc.COMPRESSED_RED_RGTC1_EXT,
        "bc4-r-snorm": t.rgtc.COMPRESSED_SIGNED_RED_RGTC1_EXT,
        "bc5-rg-unorm": t.rgtc.COMPRESSED_RED_GREEN_RGTC2_EXT,
        "bc5-rg-snorm": t.rgtc.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
      } : {},
      ...t.bptc ? {
        "bc6h-rgb-float": t.bptc.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT,
        "bc6h-rgb-ufloat": t.bptc.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT,
        "bc7-rgba-unorm": t.bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT,
        "bc7-rgba-unorm-srgb": t.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
      } : {},
      ...t.etc ? {
        "etc2-rgb8unorm": t.etc.COMPRESSED_RGB8_ETC2,
        "etc2-rgb8unorm-srgb": t.etc.COMPRESSED_SRGB8_ETC2,
        "etc2-rgb8a1unorm": t.etc.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,
        "etc2-rgb8a1unorm-srgb": t.etc.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,
        "etc2-rgba8unorm": t.etc.COMPRESSED_RGBA8_ETC2_EAC,
        "etc2-rgba8unorm-srgb": t.etc.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,
        "eac-r11unorm": t.etc.COMPRESSED_R11_EAC,
        "eac-rg11unorm": t.etc.COMPRESSED_SIGNED_RG11_EAC
      } : {},
      ...t.astc ? {
        "astc-4x4-unorm": t.astc.COMPRESSED_RGBA_ASTC_4x4_KHR,
        "astc-4x4-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,
        "astc-5x4-unorm": t.astc.COMPRESSED_RGBA_ASTC_5x4_KHR,
        "astc-5x4-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR,
        "astc-5x5-unorm": t.astc.COMPRESSED_RGBA_ASTC_5x5_KHR,
        "astc-5x5-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,
        "astc-6x5-unorm": t.astc.COMPRESSED_RGBA_ASTC_6x5_KHR,
        "astc-6x5-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,
        "astc-6x6-unorm": t.astc.COMPRESSED_RGBA_ASTC_6x6_KHR,
        "astc-6x6-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,
        "astc-8x5-unorm": t.astc.COMPRESSED_RGBA_ASTC_8x5_KHR,
        "astc-8x5-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,
        "astc-8x6-unorm": t.astc.COMPRESSED_RGBA_ASTC_8x6_KHR,
        "astc-8x6-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,
        "astc-8x8-unorm": t.astc.COMPRESSED_RGBA_ASTC_8x8_KHR,
        "astc-8x8-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,
        "astc-10x5-unorm": t.astc.COMPRESSED_RGBA_ASTC_10x5_KHR,
        "astc-10x5-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,
        "astc-10x6-unorm": t.astc.COMPRESSED_RGBA_ASTC_10x6_KHR,
        "astc-10x6-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,
        "astc-10x8-unorm": t.astc.COMPRESSED_RGBA_ASTC_10x8_KHR,
        "astc-10x8-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,
        "astc-10x10-unorm": t.astc.COMPRESSED_RGBA_ASTC_10x10_KHR,
        "astc-10x10-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,
        "astc-12x10-unorm": t.astc.COMPRESSED_RGBA_ASTC_12x10_KHR,
        "astc-12x10-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,
        "astc-12x12-unorm": t.astc.COMPRESSED_RGBA_ASTC_12x12_KHR,
        "astc-12x12-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
      } : {}
    };
  }
  function i0(i) {
    return {
      r8unorm: i.UNSIGNED_BYTE,
      r8snorm: i.BYTE,
      r8uint: i.UNSIGNED_BYTE,
      r8sint: i.BYTE,
      r16uint: i.UNSIGNED_SHORT,
      r16sint: i.SHORT,
      r16float: i.HALF_FLOAT,
      rg8unorm: i.UNSIGNED_BYTE,
      rg8snorm: i.BYTE,
      rg8uint: i.UNSIGNED_BYTE,
      rg8sint: i.BYTE,
      r32uint: i.UNSIGNED_INT,
      r32sint: i.INT,
      r32float: i.FLOAT,
      rg16uint: i.UNSIGNED_SHORT,
      rg16sint: i.SHORT,
      rg16float: i.HALF_FLOAT,
      rgba8unorm: i.UNSIGNED_BYTE,
      "rgba8unorm-srgb": i.UNSIGNED_BYTE,
      rgba8snorm: i.BYTE,
      rgba8uint: i.UNSIGNED_BYTE,
      rgba8sint: i.BYTE,
      bgra8unorm: i.UNSIGNED_BYTE,
      "bgra8unorm-srgb": i.UNSIGNED_BYTE,
      rgb9e5ufloat: i.UNSIGNED_INT_5_9_9_9_REV,
      rgb10a2unorm: i.UNSIGNED_INT_2_10_10_10_REV,
      rg11b10ufloat: i.UNSIGNED_INT_10F_11F_11F_REV,
      rg32uint: i.UNSIGNED_INT,
      rg32sint: i.INT,
      rg32float: i.FLOAT,
      rgba16uint: i.UNSIGNED_SHORT,
      rgba16sint: i.SHORT,
      rgba16float: i.HALF_FLOAT,
      rgba32uint: i.UNSIGNED_INT,
      rgba32sint: i.INT,
      rgba32float: i.FLOAT,
      stencil8: i.UNSIGNED_BYTE,
      depth16unorm: i.UNSIGNED_SHORT,
      depth24plus: i.UNSIGNED_INT,
      "depth24plus-stencil8": i.UNSIGNED_INT_24_8,
      depth32float: i.FLOAT,
      "depth32float-stencil8": i.FLOAT_32_UNSIGNED_INT_24_8_REV
    };
  }
  const n0 = 4;
  class Yd {
    constructor(t) {
      this.managedTextures = [], this._glTextures = /* @__PURE__ */ Object.create(null), this._glSamplers = /* @__PURE__ */ Object.create(null), this._boundTextures = [], this._activeTextureLocation = -1, this._boundSamplers = /* @__PURE__ */ Object.create(null), this._uploads = {
        image: $d,
        buffer: Yy,
        video: Jy,
        compressed: Zy
      }, this._useSeparateSamplers = false, this._renderer = t;
    }
    contextChange(t) {
      this._gl = t, this._mapFormatToInternalFormat || (this._mapFormatToInternalFormat = r0(t, this._renderer.context.extensions), this._mapFormatToType = i0(t), this._mapFormatToFormat = e0(t)), this._glTextures = /* @__PURE__ */ Object.create(null), this._glSamplers = /* @__PURE__ */ Object.create(null), this._boundSamplers = /* @__PURE__ */ Object.create(null);
      for (let e = 0; e < 16; e++) this.bind(J.EMPTY, e);
    }
    initSource(t) {
      this.bind(t);
    }
    bind(t, e = 0) {
      const r = t.source;
      t ? (this.bindSource(r, e), this._useSeparateSamplers && this._bindSampler(r.style, e)) : (this.bindSource(null, e), this._useSeparateSamplers && this._bindSampler(null, e));
    }
    bindSource(t, e = 0) {
      const r = this._gl;
      if (t._touched = this._renderer.textureGC.count, this._boundTextures[e] !== t) {
        this._boundTextures[e] = t, this._activateLocation(e), t = t || J.EMPTY.source;
        const n = this.getGlSource(t);
        r.bindTexture(n.target, n.texture);
      }
    }
    _bindSampler(t, e = 0) {
      const r = this._gl;
      if (!t) {
        this._boundSamplers[e] = null, r.bindSampler(e, null);
        return;
      }
      const n = this._getGlSampler(t);
      this._boundSamplers[e] !== n && (this._boundSamplers[e] = n, r.bindSampler(e, n));
    }
    unbind(t) {
      const e = t.source, r = this._boundTextures, n = this._gl;
      for (let s = 0; s < r.length; s++) if (r[s] === e) {
        this._activateLocation(s);
        const o = this.getGlSource(e);
        n.bindTexture(o.target, null), r[s] = null;
      }
    }
    _activateLocation(t) {
      this._activeTextureLocation !== t && (this._activeTextureLocation = t, this._gl.activeTexture(this._gl.TEXTURE0 + t));
    }
    _initSource(t) {
      const e = this._gl, r = new $y(e.createTexture());
      if (r.type = this._mapFormatToType[t.format], r.internalFormat = this._mapFormatToInternalFormat[t.format], r.format = this._mapFormatToFormat[t.format], t.autoGenerateMipmaps && (this._renderer.context.supports.nonPowOf2mipmaps || t.isPowerOfTwo)) {
        const n = Math.max(t.width, t.height);
        t.mipLevelCount = Math.floor(Math.log2(n)) + 1;
      }
      return this._glTextures[t.uid] = r, this.managedTextures.includes(t) || (t.on("update", this.onSourceUpdate, this), t.on("resize", this.onSourceUpdate, this), t.on("styleChange", this.onStyleChange, this), t.on("destroy", this.onSourceDestroy, this), t.on("unload", this.onSourceUnload, this), t.on("updateMipmaps", this.onUpdateMipmaps, this), this.managedTextures.push(t)), this.onSourceUpdate(t), this.updateStyle(t, false), r;
    }
    onStyleChange(t) {
      this.updateStyle(t, false);
    }
    updateStyle(t, e) {
      const r = this._gl, n = this.getGlSource(t);
      r.bindTexture(r.TEXTURE_2D, n.texture), this._boundTextures[this._activeTextureLocation] = t, ku(t.style, r, t.mipLevelCount > 1, this._renderer.context.extensions.anisotropicFiltering, "texParameteri", r.TEXTURE_2D, !this._renderer.context.supports.nonPowOf2wrapping && !t.isPowerOfTwo, e);
    }
    onSourceUnload(t) {
      const e = this._glTextures[t.uid];
      e && (this.unbind(t), this._glTextures[t.uid] = null, this._gl.deleteTexture(e.texture));
    }
    onSourceUpdate(t) {
      const e = this._gl, r = this.getGlSource(t);
      e.bindTexture(e.TEXTURE_2D, r.texture), this._boundTextures[this._activeTextureLocation] = t, this._uploads[t.uploadMethodId] ? this._uploads[t.uploadMethodId].upload(t, r, e, this._renderer.context.webGLVersion) : e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, t.pixelWidth, t.pixelHeight, 0, e.RGBA, e.UNSIGNED_BYTE, null), t.autoGenerateMipmaps && t.mipLevelCount > 1 && this.onUpdateMipmaps(t, false);
    }
    onUpdateMipmaps(t, e = true) {
      e && this.bindSource(t, 0);
      const r = this.getGlSource(t);
      this._gl.generateMipmap(r.target);
    }
    onSourceDestroy(t) {
      t.off("destroy", this.onSourceDestroy, this), t.off("update", this.onSourceUpdate, this), t.off("resize", this.onSourceUpdate, this), t.off("unload", this.onSourceUnload, this), t.off("styleChange", this.onStyleChange, this), t.off("updateMipmaps", this.onUpdateMipmaps, this), this.managedTextures.splice(this.managedTextures.indexOf(t), 1), this.onSourceUnload(t);
    }
    _initSampler(t) {
      const e = this._gl, r = this._gl.createSampler();
      return this._glSamplers[t._resourceId] = r, ku(t, e, this._boundTextures[this._activeTextureLocation].mipLevelCount > 1, this._renderer.context.extensions.anisotropicFiltering, "samplerParameteri", r, false, true), this._glSamplers[t._resourceId];
    }
    _getGlSampler(t) {
      return this._glSamplers[t._resourceId] || this._initSampler(t);
    }
    getGlSource(t) {
      return this._glTextures[t.uid] || this._initSource(t);
    }
    generateCanvas(t) {
      const { pixels: e, width: r, height: n } = this.getPixels(t), s = St.get().createCanvas();
      s.width = r, s.height = n;
      const o = s.getContext("2d");
      if (o) {
        const a = o.createImageData(r, n);
        a.data.set(e), o.putImageData(a, 0, 0);
      }
      return s;
    }
    getPixels(t) {
      const e = t.source.resolution, r = t.frame, n = Math.max(Math.round(r.width * e), 1), s = Math.max(Math.round(r.height * e), 1), o = new Uint8Array(n0 * n * s), a = this._renderer, c = a.renderTarget.getRenderTarget(t), u = a.renderTarget.getGpuRenderTarget(c), l = a.gl;
      return l.bindFramebuffer(l.FRAMEBUFFER, u.resolveTargetFramebuffer), l.readPixels(Math.round(r.x * e), Math.round(r.y * e), n, s, l.RGBA, l.UNSIGNED_BYTE, o), {
        pixels: new Uint8ClampedArray(o.buffer),
        width: n,
        height: s
      };
    }
    destroy() {
      this.managedTextures.slice().forEach((t) => this.onSourceDestroy(t)), this.managedTextures = null, this._renderer = null;
    }
  }
  Yd.extension = {
    type: [
      P.WebGLSystem
    ],
    name: "texture"
  };
  class Kd {
    init() {
      const t = new Qt({
        uColor: {
          value: new Float32Array([
            1,
            1,
            1,
            1
          ]),
          type: "vec4<f32>"
        },
        uTransformMatrix: {
          value: new nt(),
          type: "mat3x3<f32>"
        },
        uRound: {
          value: 0,
          type: "f32"
        }
      }), e = Ir(), r = ki({
        name: "graphics",
        bits: [
          ma,
          wa(e),
          xa,
          Oi
        ]
      });
      this.shader = new Se({
        glProgram: r,
        resources: {
          localUniforms: t,
          batchSamplers: ya(e)
        }
      });
    }
    execute(t, e) {
      const r = e.context, n = r.customShader || this.shader, s = t.renderer, o = s.graphicsContext, { geometry: a, instructions: c } = o.getContextRenderData(r);
      n.groups[0] = s.globalUniforms.bindGroup, s.state.set(t.state), s.shader.bind(n), s.geometry.bind(a, n.glProgram);
      const u = c.instructions;
      for (let l = 0; l < c.instructionSize; l++) {
        const h = u[l];
        if (h.size) {
          for (let f = 0; f < h.textures.count; f++) s.texture.bind(h.textures.textures[f], f);
          s.geometry.draw("triangle-list", h.size, h.start);
        }
      }
    }
    destroy() {
      this.shader.destroy(true), this.shader = null;
    }
  }
  Kd.extension = {
    type: [
      P.WebGLPipesAdaptor
    ],
    name: "graphics"
  };
  class Zd {
    init() {
      const t = ki({
        name: "mesh",
        bits: [
          xa,
          cy,
          Oi
        ]
      });
      this._shader = new Se({
        glProgram: t,
        resources: {
          uTexture: J.EMPTY.source,
          textureUniforms: {
            uTextureMatrix: {
              type: "mat3x3<f32>",
              value: new nt()
            }
          }
        }
      });
    }
    execute(t, e) {
      const r = t.renderer;
      let n = e._shader;
      if (n) {
        if (!n.glProgram) {
          ut("Mesh shader has no glProgram", e.shader);
          return;
        }
      } else {
        n = this._shader;
        const s = e.texture, o = s.source;
        n.resources.uTexture = o, n.resources.uSampler = o.style, n.resources.textureUniforms.uniforms.uTextureMatrix = s.textureMatrix.mapCoord;
      }
      n.groups[100] = r.globalUniforms.bindGroup, n.groups[101] = t.localUniformsBindGroup, r.encoder.draw({
        geometry: e._geometry,
        shader: n,
        state: e.state
      });
    }
    destroy() {
      this._shader.destroy(true), this._shader = null;
    }
  }
  Zd.extension = {
    type: [
      P.WebGLPipesAdaptor
    ],
    name: "mesh"
  };
  class Jd {
    constructor(t) {
      this._renderer = t;
    }
    addRenderable(t, e) {
      this._renderer.renderPipes.batch.break(e), e.add(t);
    }
    execute(t) {
      t.isRenderable && t.render(this._renderer);
    }
    destroy() {
      this._renderer = null;
    }
  }
  Jd.extension = {
    type: [
      P.WebGLPipes,
      P.WebGPUPipes,
      P.CanvasPipes
    ],
    name: "customRender"
  };
  function Qd(i, t) {
    const e = i.instructionSet, r = e.instructions;
    for (let n = 0; n < e.instructionSize; n++) {
      const s = r[n];
      t[s.renderPipeId].execute(s);
    }
  }
  class tf {
    constructor(t) {
      this._renderer = t;
    }
    addRenderGroup(t, e) {
      this._renderer.renderPipes.batch.break(e), e.add(t);
    }
    execute(t) {
      t.isRenderable && (this._renderer.globalUniforms.push({
        worldTransformMatrix: t.worldTransform,
        worldColor: t.worldColorAlpha
      }), Qd(t, this._renderer.renderPipes), this._renderer.globalUniforms.pop());
    }
    destroy() {
      this._renderer = null;
    }
  }
  tf.extension = {
    type: [
      P.WebGLPipes,
      P.WebGPUPipes,
      P.CanvasPipes
    ],
    name: "renderGroup"
  };
  function Aa(i, t) {
    t || (t = 0);
    for (let e = t; e < i.length && i[e]; e++) i[e] = null;
  }
  function ef(i, t = []) {
    t.push(i);
    for (let e = 0; e < i.renderGroupChildren.length; e++) ef(i.renderGroupChildren[e], t);
    return t;
  }
  function s0(i, t, e) {
    const r = i >> 16 & 255, n = i >> 8 & 255, s = i & 255, o = t >> 16 & 255, a = t >> 8 & 255, c = t & 255, u = r + (o - r) * e, l = n + (a - n) * e, h = s + (c - s) * e;
    return (u << 16) + (l << 8) + h;
  }
  const co = 16777215;
  function rf(i, t) {
    return i === co || t === co ? i + t - co : s0(i, t, 0.5);
  }
  const o0 = new Dt(), Gu = yi | Bn | ta;
  function nf(i, t = false) {
    a0(i);
    const e = i.childrenToUpdate, r = i.updateTick++;
    for (const n in e) {
      const s = Number(n), o = e[n], a = o.list, c = o.index;
      for (let u = 0; u < c; u++) {
        const l = a[u];
        l.parentRenderGroup === i && l.relativeRenderGroupDepth === s && sf(l, r, 0);
      }
      Aa(a, c), o.index = 0;
    }
    if (t) for (let n = 0; n < i.renderGroupChildren.length; n++) nf(i.renderGroupChildren[n], t);
  }
  function a0(i) {
    const t = i.root;
    let e;
    if (i.renderGroupParent) {
      const r = i.renderGroupParent;
      i.worldTransform.appendFrom(t.relativeGroupTransform, r.worldTransform), i.worldColor = rf(t.groupColor, r.worldColor), e = t.groupAlpha * r.worldAlpha;
    } else i.worldTransform.copyFrom(t.localTransform), i.worldColor = t.localColor, e = t.localAlpha;
    e = e < 0 ? 0 : e > 1 ? 1 : e, i.worldAlpha = e, i.worldColorAlpha = i.worldColor + ((e * 255 | 0) << 24);
  }
  function sf(i, t, e) {
    if (t === i.updateTick) return;
    i.updateTick = t, i.didChange = false;
    const r = i.localTransform;
    i.updateLocalTransform();
    const n = i.parent;
    if (n && !n.renderGroup ? (e = e | i._updateFlags, i.relativeGroupTransform.appendFrom(r, n.relativeGroupTransform), e & Gu && Ou(i, n, e)) : (e = i._updateFlags, i.relativeGroupTransform.copyFrom(r), e & Gu && Ou(i, o0, e)), !i.renderGroup) {
      const s = i.children, o = s.length;
      for (let c = 0; c < o; c++) sf(s[c], t, e);
      const a = i.parentRenderGroup;
      i.renderPipeId && !a.structureDidChange && a.updateRenderable(i);
    }
  }
  function Ou(i, t, e) {
    if (e & Bn) {
      i.groupColor = rf(i.localColor, t.groupColor);
      let r = i.localAlpha * t.groupAlpha;
      r = r < 0 ? 0 : r > 1 ? 1 : r, i.groupAlpha = r, i.groupColorAlpha = i.groupColor + ((r * 255 | 0) << 24);
    }
    e & ta && (i.groupBlendMode = i.localBlendMode === "inherit" ? t.groupBlendMode : i.localBlendMode), e & yi && (i.globalDisplayStatus = i.localDisplayStatus & t.globalDisplayStatus), i._updateFlags = 0;
  }
  function c0(i, t) {
    const { list: e, index: r } = i.childrenRenderablesToUpdate;
    let n = false;
    for (let s = 0; s < r; s++) {
      const o = e[s];
      if (n = t[o.renderPipeId].validateRenderable(o), n) break;
    }
    return i.structureDidChange = n, n;
  }
  const u0 = new nt();
  class of {
    constructor(t) {
      this._renderer = t;
    }
    render({ container: t, transform: e }) {
      t.isRenderGroup = true;
      const r = t.parent, n = t.renderGroup.renderGroupParent;
      t.parent = null, t.renderGroup.renderGroupParent = null;
      const s = this._renderer, o = ef(t.renderGroup, []);
      let a = u0;
      e && (a = a.copyFrom(t.renderGroup.localTransform), t.renderGroup.localTransform.copyFrom(e));
      const c = s.renderPipes;
      for (let u = 0; u < o.length; u++) {
        const l = o[u];
        l.runOnRender(), l.instructionSet.renderPipes = c, l.structureDidChange ? Aa(l.childrenRenderablesToUpdate.list, 0) : c0(l, c), nf(l), l.structureDidChange ? (l.structureDidChange = false, uy(l, c)) : l0(l), l.childrenRenderablesToUpdate.index = 0, s.renderPipes.batch.upload(l.instructionSet);
      }
      s.globalUniforms.start({
        worldTransformMatrix: e ? t.renderGroup.localTransform : t.renderGroup.worldTransform,
        worldColor: t.renderGroup.worldColorAlpha
      }), Qd(t.renderGroup, c), c.uniformBatch && c.uniformBatch.renderEnd(), e && t.renderGroup.localTransform.copyFrom(a), t.parent = r, t.renderGroup.renderGroupParent = n;
    }
    destroy() {
      this._renderer = null;
    }
  }
  of.extension = {
    type: [
      P.WebGLSystem,
      P.WebGPUSystem,
      P.CanvasSystem
    ],
    name: "renderGroup"
  };
  function l0(i) {
    const { list: t, index: e } = i.childrenRenderablesToUpdate;
    for (let r = 0; r < e; r++) {
      const n = t[r];
      n.didViewUpdate && i.updateRenderable(n);
    }
    Aa(t, e);
  }
  class Ta {
    constructor() {
      this.vertexSize = 4, this.indexSize = 6, this.location = 0, this.batcher = null, this.batch = null, this.roundPixels = 0;
    }
    get blendMode() {
      return this.renderable.groupBlendMode;
    }
    packAttributes(t, e, r, n) {
      const s = this.renderable, o = this.texture, a = s.groupTransform, c = a.a, u = a.b, l = a.c, h = a.d, f = a.tx, p = a.ty, m = this.bounds, y = m.maxX, b = m.minX, v = m.maxY, A = m.minY, T = o.uvs, G = s.groupColorAlpha, H = n << 16 | this.roundPixels & 65535;
      t[r + 0] = c * b + l * A + f, t[r + 1] = h * A + u * b + p, t[r + 2] = T.x0, t[r + 3] = T.y0, e[r + 4] = G, e[r + 5] = H, t[r + 6] = c * y + l * A + f, t[r + 7] = h * A + u * y + p, t[r + 8] = T.x1, t[r + 9] = T.y1, e[r + 10] = G, e[r + 11] = H, t[r + 12] = c * y + l * v + f, t[r + 13] = h * v + u * y + p, t[r + 14] = T.x2, t[r + 15] = T.y2, e[r + 16] = G, e[r + 17] = H, t[r + 18] = c * b + l * v + f, t[r + 19] = h * v + u * b + p, t[r + 20] = T.x3, t[r + 21] = T.y3, e[r + 22] = G, e[r + 23] = H;
    }
    packIndex(t, e, r) {
      t[e] = r + 0, t[e + 1] = r + 1, t[e + 2] = r + 2, t[e + 3] = r + 0, t[e + 4] = r + 2, t[e + 5] = r + 3;
    }
    reset() {
      this.renderable = null, this.texture = null, this.batcher = null, this.batch = null, this.bounds = null;
    }
  }
  class af {
    constructor(t) {
      this._gpuSpriteHash = /* @__PURE__ */ Object.create(null), this._renderer = t;
    }
    addRenderable(t, e) {
      const r = this._getGpuSprite(t);
      t._didSpriteUpdate && this._updateBatchableSprite(t, r), this._renderer.renderPipes.batch.addToBatch(r);
    }
    updateRenderable(t) {
      const e = this._gpuSpriteHash[t.uid];
      t._didSpriteUpdate && this._updateBatchableSprite(t, e), e.batcher.updateElement(e);
    }
    validateRenderable(t) {
      const e = t._texture, r = this._getGpuSprite(t);
      return r.texture._source !== e._source ? !r.batcher.checkAndUpdateTexture(r, e) : false;
    }
    destroyRenderable(t) {
      const e = this._gpuSpriteHash[t.uid];
      vt.return(e), this._gpuSpriteHash[t.uid] = null;
    }
    _updateBatchableSprite(t, e) {
      t._didSpriteUpdate = false, e.bounds = t.bounds, e.texture = t._texture;
    }
    _getGpuSprite(t) {
      return this._gpuSpriteHash[t.uid] || this._initGPUSprite(t);
    }
    _initGPUSprite(t) {
      const e = vt.get(Ta);
      return e.renderable = t, e.texture = t._texture, e.bounds = t.bounds, e.roundPixels = this._renderer._roundPixels | t._roundPixels, this._gpuSpriteHash[t.uid] = e, t._didSpriteUpdate = false, t.on("destroyed", () => {
        this.destroyRenderable(t);
      }), e;
    }
    destroy() {
      for (const t in this._gpuSpriteHash) vt.return(this._gpuSpriteHash[t]);
      this._gpuSpriteHash = null, this._renderer = null;
    }
  }
  af.extension = {
    type: [
      P.WebGLPipes,
      P.WebGPUPipes,
      P.CanvasPipes
    ],
    name: "sprite"
  };
  const Ca = class cf {
    constructor() {
      this.clearBeforeRender = true, this._backgroundColor = new At(0), this.color = this._backgroundColor, this.alpha = 1;
    }
    init(t) {
      t = {
        ...cf.defaultOptions,
        ...t
      }, this.clearBeforeRender = t.clearBeforeRender, this.color = t.background || t.backgroundColor || this._backgroundColor, this.alpha = t.backgroundAlpha, this._backgroundColor.setAlpha(t.backgroundAlpha);
    }
    get color() {
      return this._backgroundColor;
    }
    set color(t) {
      this._backgroundColor.setValue(t);
    }
    get alpha() {
      return this._backgroundColor.alpha;
    }
    set alpha(t) {
      this._backgroundColor.setAlpha(t);
    }
    get colorRgba() {
      return this._backgroundColor.toArray();
    }
    destroy() {
    }
  };
  Ca.extension = {
    type: [
      P.WebGLSystem,
      P.WebGPUSystem,
      P.CanvasSystem
    ],
    name: "background",
    priority: 0
  };
  Ca.defaultOptions = {
    backgroundAlpha: 1,
    backgroundColor: 0,
    clearBeforeRender: true
  };
  let h0 = Ca;
  const Ei = {};
  Mt.handle(P.BlendMode, (i) => {
    if (!i.name) throw new Error("BlendMode extension must have a name property");
    Ei[i.name] = i.ref;
  }, (i) => {
    delete Ei[i.name];
  });
  class uf {
    constructor(t) {
      this._isAdvanced = false, this._filterHash = /* @__PURE__ */ Object.create(null), this._renderer = t;
    }
    setBlendMode(t, e, r) {
      if (this._activeBlendMode === e) {
        this._isAdvanced && this._renderableList.push(t);
        return;
      }
      this._activeBlendMode = e, this._isAdvanced && this._endAdvancedBlendMode(r), this._isAdvanced = !!Ei[e], this._isAdvanced && (this._beginAdvancedBlendMode(r), this._renderableList.push(t));
    }
    _beginAdvancedBlendMode(t) {
      this._renderer.renderPipes.batch.break(t);
      const e = this._activeBlendMode;
      if (!Ei[e]) {
        ut(`Unable to assign BlendMode: '${e}'. You may want to include: import 'pixi.js/advanced-blend-modes'`);
        return;
      }
      let r = this._filterHash[e];
      r || (r = this._filterHash[e] = new Rn(), r.filters = [
        new Ei[e]()
      ]);
      const n = {
        renderPipeId: "filter",
        action: "pushFilter",
        renderables: [],
        filterEffect: r,
        canBundle: false
      };
      this._renderableList = n.renderables, t.add(n);
    }
    _endAdvancedBlendMode(t) {
      this._renderableList = null, this._renderer.renderPipes.batch.break(t), t.add({
        renderPipeId: "filter",
        action: "popFilter",
        canBundle: false
      });
    }
    buildStart() {
      this._isAdvanced = false;
    }
    buildEnd(t) {
      this._isAdvanced && this._endAdvancedBlendMode(t);
    }
    destroy() {
      this._renderer = null, this._renderableList = null;
      for (const t in this._filterHash) this._filterHash[t].destroy();
      this._filterHash = null;
    }
  }
  uf.extension = {
    type: [
      P.WebGLPipes,
      P.WebGPUPipes,
      P.CanvasPipes
    ],
    name: "blendMode"
  };
  const uo = {
    png: "image/png",
    jpg: "image/jpeg",
    webp: "image/webp"
  }, Ra = class lf {
    constructor(t) {
      this._renderer = t;
    }
    _normalizeOptions(t, e = {}) {
      return t instanceof Dt || t instanceof J ? {
        target: t,
        ...e
      } : {
        ...e,
        ...t
      };
    }
    async image(t) {
      const e = new Image();
      return e.src = await this.base64(t), e;
    }
    async base64(t) {
      t = this._normalizeOptions(t, lf.defaultImageOptions);
      const { format: e, quality: r } = t, n = this.canvas(t);
      if (n.toBlob !== void 0) return new Promise((s, o) => {
        n.toBlob((a) => {
          if (!a) {
            o(new Error("ICanvas.toBlob failed!"));
            return;
          }
          const c = new FileReader();
          c.onload = () => s(c.result), c.onerror = o, c.readAsDataURL(a);
        }, uo[e], r);
      });
      if (n.toDataURL !== void 0) return n.toDataURL(uo[e], r);
      if (n.convertToBlob !== void 0) {
        const s = await n.convertToBlob({
          type: uo[e],
          quality: r
        });
        return new Promise((o, a) => {
          const c = new FileReader();
          c.onload = () => o(c.result), c.onerror = a, c.readAsDataURL(s);
        });
      }
      throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented");
    }
    canvas(t) {
      t = this._normalizeOptions(t);
      const e = t.target, r = this._renderer;
      if (e instanceof J) return r.texture.generateCanvas(e);
      const n = r.textureGenerator.generateTexture(t), s = r.texture.generateCanvas(n);
      return n.destroy(), s;
    }
    pixels(t) {
      t = this._normalizeOptions(t);
      const e = t.target, r = this._renderer, n = e instanceof J ? e : r.textureGenerator.generateTexture(t), s = r.texture.getPixels(n);
      return e instanceof Dt && n.destroy(), s;
    }
    texture(t) {
      return t = this._normalizeOptions(t), t.target instanceof J ? t.target : this._renderer.textureGenerator.generateTexture(t);
    }
    download(t) {
      t = this._normalizeOptions(t);
      const e = this.canvas(t), r = document.createElement("a");
      r.download = t.filename ?? "image.png", r.href = e.toDataURL("image/png"), document.body.appendChild(r), r.click(), document.body.removeChild(r);
    }
    log(t) {
      const e = t.width ?? 200;
      t = this._normalizeOptions(t);
      const r = this.canvas(t), n = r.toDataURL();
      console.log(`[Pixi Texture] ${r.width}px ${r.height}px`);
      const s = [
        "font-size: 1px;",
        `padding: ${e}px 300px;`,
        `background: url(${n}) no-repeat;`,
        "background-size: contain;"
      ].join(" ");
      console.log("%c ", s);
    }
    destroy() {
      this._renderer = null;
    }
  };
  Ra.extension = {
    type: [
      P.WebGLSystem,
      P.WebGPUSystem
    ],
    name: "extract"
  };
  Ra.defaultImageOptions = {
    format: "png",
    quality: 1
  };
  let d0 = Ra;
  class f0 extends J {
    static create(t) {
      return new J({
        source: new Ht(t)
      });
    }
    resize(t, e, r) {
      return this.source.resize(t, e, r), this;
    }
  }
  const p0 = new Et(), _0 = new re(), g0 = [
    0,
    0,
    0,
    0
  ];
  class hf {
    constructor(t) {
      this._renderer = t;
    }
    generateTexture(t) {
      var _a2;
      t instanceof Dt && (t = {
        target: t,
        frame: void 0,
        textureSourceOptions: {},
        resolution: void 0
      });
      const e = t.resolution || this._renderer.resolution, r = t.antialias || this._renderer.view.antialias, n = t.target;
      let s = t.clearColor;
      s ? s = Array.isArray(s) && s.length === 4 ? s : At.shared.setValue(s).toArray() : s = g0;
      const o = ((_a2 = t.frame) == null ? void 0 : _a2.copyTo(p0)) || Qo(n, _0).rectangle;
      o.width = Math.max(o.width, 1 / e) | 0, o.height = Math.max(o.height, 1 / e) | 0;
      const a = f0.create({
        ...t.textureSourceOptions,
        width: o.width,
        height: o.height,
        resolution: e,
        antialias: r
      }), c = nt.shared.translate(-o.x, -o.y);
      return this._renderer.render({
        container: n,
        transform: c,
        target: a,
        clearColor: s
      }), a.source.updateMipmaps(), a;
    }
    destroy() {
      this._renderer = null;
    }
  }
  hf.extension = {
    type: [
      P.WebGLSystem,
      P.WebGPUSystem
    ],
    name: "textureGenerator"
  };
  function ns(i, t, e) {
    const r = (i >> 24 & 255) / 255;
    t[e++] = (i & 255) / 255 * r, t[e++] = (i >> 8 & 255) / 255 * r, t[e++] = (i >> 16 & 255) / 255 * r, t[e++] = r;
  }
  class df {
    constructor(t) {
      this._stackIndex = 0, this._globalUniformDataStack = [], this._uniformsPool = [], this._activeUniforms = [], this._bindGroupPool = [], this._activeBindGroups = [], this._renderer = t;
    }
    reset() {
      this._stackIndex = 0;
      for (let t = 0; t < this._activeUniforms.length; t++) this._uniformsPool.push(this._activeUniforms[t]);
      for (let t = 0; t < this._activeBindGroups.length; t++) this._bindGroupPool.push(this._activeBindGroups[t]);
      this._activeUniforms.length = 0, this._activeBindGroups.length = 0;
    }
    start(t) {
      this.reset(), this.push(t);
    }
    bind({ size: t, projectionMatrix: e, worldTransformMatrix: r, worldColor: n, offset: s }) {
      const o = this._renderer.renderTarget.renderTarget, a = this._stackIndex ? this._globalUniformDataStack[this._stackIndex - 1] : {
        projectionData: o,
        worldTransformMatrix: new nt(),
        worldColor: 4294967295,
        offset: new Ct()
      }, c = {
        projectionMatrix: e || this._renderer.renderTarget.projectionMatrix,
        resolution: t || o.size,
        worldTransformMatrix: r || a.worldTransformMatrix,
        worldColor: n || a.worldColor,
        offset: s || a.offset,
        bindGroup: null
      }, u = this._uniformsPool.pop() || this._createUniforms();
      this._activeUniforms.push(u);
      const l = u.uniforms;
      l.uProjectionMatrix = c.projectionMatrix, l.uResolution = c.resolution, l.uWorldTransformMatrix.copyFrom(c.worldTransformMatrix), l.uWorldTransformMatrix.tx -= c.offset.x, l.uWorldTransformMatrix.ty -= c.offset.y, ns(c.worldColor, l.uWorldColorAlpha, 0), u.update();
      let h;
      this._renderer.renderPipes.uniformBatch ? h = this._renderer.renderPipes.uniformBatch.getUniformBindGroup(u, false) : (h = this._bindGroupPool.pop() || new Ze(), this._activeBindGroups.push(h), h.setResource(u, 0)), c.bindGroup = h, this._currentGlobalUniformData = c;
    }
    push(t) {
      this.bind(t), this._globalUniformDataStack[this._stackIndex++] = this._currentGlobalUniformData;
    }
    pop() {
      this._currentGlobalUniformData = this._globalUniformDataStack[--this._stackIndex - 1], this._renderer.type === ge.WEBGL && this._currentGlobalUniformData.bindGroup.resources[0].update();
    }
    get bindGroup() {
      return this._currentGlobalUniformData.bindGroup;
    }
    get uniformGroup() {
      return this._currentGlobalUniformData.bindGroup.resources[0];
    }
    _createUniforms() {
      return new Qt({
        uProjectionMatrix: {
          value: new nt(),
          type: "mat3x3<f32>"
        },
        uWorldTransformMatrix: {
          value: new nt(),
          type: "mat3x3<f32>"
        },
        uWorldColorAlpha: {
          value: new Float32Array(4),
          type: "vec4<f32>"
        },
        uResolution: {
          value: [
            0,
            0
          ],
          type: "vec2<f32>"
        }
      }, {
        isStatic: true
      });
    }
    destroy() {
      this._renderer = null;
    }
  }
  df.extension = {
    type: [
      P.WebGLSystem,
      P.WebGPUSystem,
      P.CanvasSystem
    ],
    name: "globalUniforms"
  };
  let Nu = false;
  const Lu = "8.2.6";
  function m0(i) {
    if (!Nu) {
      if (St.get().getNavigator().userAgent.toLowerCase().indexOf("chrome") > -1) {
        const t = [
          `%c  %c  %c  %c  %c PixiJS %c v${Lu} (${i}) http://www.pixijs.com/

`,
          "background: #E72264; padding:5px 0;",
          "background: #6CA2EA; padding:5px 0;",
          "background: #B5D33D; padding:5px 0;",
          "background: #FED23F; padding:5px 0;",
          "color: #FFFFFF; background: #E72264; padding:5px 0;",
          "color: #E72264; background: #FFFFFF; padding:5px 0;"
        ];
        globalThis.console.log(...t);
      } else globalThis.console && globalThis.console.log(`PixiJS ${Lu} - ${i} - http://www.pixijs.com/`);
      Nu = true;
    }
  }
  class Pa {
    constructor(t) {
      this._renderer = t;
    }
    init(t) {
      if (t.hello) {
        let e = this._renderer.name;
        this._renderer.type === ge.WEBGL && (e += ` ${this._renderer.context.webGLVersion}`), m0(e);
      }
    }
  }
  Pa.extension = {
    type: [
      P.WebGLSystem,
      P.WebGPUSystem,
      P.CanvasSystem
    ],
    name: "hello",
    priority: -2
  };
  Pa.defaultOptions = {
    hello: false
  };
  const Ba = class ff {
    constructor(t) {
      this._renderer = t, this.count = 0, this.checkCount = 0;
    }
    init(t) {
      t = {
        ...ff.defaultOptions,
        ...t
      }, this.checkCountMax = t.textureGCCheckCountMax, this.maxIdle = t.textureGCAMaxIdle, this.active = t.textureGCActive;
    }
    postrender() {
      this._renderer.renderingToScreen && (this.count++, this.active && (this.checkCount++, this.checkCount > this.checkCountMax && (this.checkCount = 0, this.run())));
    }
    run() {
      const t = this._renderer.texture.managedTextures;
      for (let e = 0; e < t.length; e++) {
        const r = t[e];
        r.autoGarbageCollect && r.resource && r._touched > -1 && this.count - r._touched > this.maxIdle && (r._touched = -1, r.unload());
      }
    }
    destroy() {
      this._renderer = null;
    }
  };
  Ba.extension = {
    type: [
      P.WebGLSystem,
      P.WebGPUSystem
    ],
    name: "textureGC"
  };
  Ba.defaultOptions = {
    textureGCActive: true,
    textureGCAMaxIdle: 60 * 60,
    textureGCCheckCountMax: 600
  };
  let pf = Ba;
  Mt.add(pf);
  const Ma = class _f {
    get resolution() {
      return this.texture.source._resolution;
    }
    set resolution(t) {
      this.texture.source.resize(this.texture.source.width, this.texture.source.height, t);
    }
    init(t) {
      t = {
        ..._f.defaultOptions,
        ...t
      }, t.view && (lt(dt, "ViewSystem.view has been renamed to ViewSystem.canvas"), t.canvas = t.view), this.screen = new Et(0, 0, t.width, t.height), this.canvas = t.canvas || St.get().createCanvas(), this.antialias = !!t.antialias, this.texture = Od(this.canvas, t), this.renderTarget = new No({
        colorTextures: [
          this.texture
        ],
        depth: !!t.depth,
        isRoot: true
      }), this.texture.source.transparent = t.backgroundAlpha < 1, this.multiView = !!t.multiView, this.autoDensity && (this.canvas.style.width = `${this.texture.width}px`, this.canvas.style.height = `${this.texture.height}px`), this.resolution = t.resolution;
    }
    resize(t, e, r) {
      this.texture.source.resize(t, e, r), this.screen.width = this.texture.frame.width, this.screen.height = this.texture.frame.height, this.autoDensity && (this.canvas.style.width = `${t}px`, this.canvas.style.height = `${e}px`);
    }
    destroy(t = false) {
      (typeof t == "boolean" ? t : !!(t == null ? void 0 : t.removeView)) && this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas);
    }
  };
  Ma.extension = {
    type: [
      P.WebGLSystem,
      P.WebGPUSystem,
      P.CanvasSystem
    ],
    name: "view",
    priority: 0
  };
  Ma.defaultOptions = {
    width: 800,
    height: 600,
    autoDensity: false,
    antialias: false
  };
  let b0 = Ma;
  const gf = [
    h0,
    df,
    Pa,
    b0,
    of,
    pf,
    hf,
    d0,
    fh
  ], mf = [
    uf,
    wd,
    af,
    tf,
    xd,
    Sd,
    vd,
    Jd
  ], w0 = [
    ...gf,
    Gd,
    wy,
    py,
    Ed,
    Yd,
    zd,
    Rd,
    Xd,
    Vd,
    Md,
    qy,
    Dd,
    Bd
  ], y0 = [
    ...mf
  ], x0 = [
    md,
    Zd,
    Kd
  ], bf = [], wf = [], yf = [];
  Mt.handleByNamedList(P.WebGLSystem, bf);
  Mt.handleByNamedList(P.WebGLPipes, wf);
  Mt.handleByNamedList(P.WebGLPipesAdaptor, yf);
  Mt.add(...w0, ...y0, ...x0);
  class v0 extends $n {
    constructor() {
      const t = {
        name: "webgl",
        type: ge.WEBGL,
        systems: bf,
        renderPipes: wf,
        renderPipeAdaptors: yf
      };
      super(t);
    }
  }
  const S0 = Object.freeze(Object.defineProperty({
    __proto__: null,
    WebGLRenderer: v0
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  class xf {
    constructor(t) {
      this._hash = /* @__PURE__ */ Object.create(null), this._renderer = t;
    }
    contextChange(t) {
      this._gpu = t;
    }
    getBindGroup(t, e, r) {
      return t._updateKey(), this._hash[t._key] || this._createBindGroup(t, e, r);
    }
    _createBindGroup(t, e, r) {
      const n = this._gpu.device, s = e.layout[r], o = [], a = this._renderer;
      for (const l in s) {
        const h = t.resources[l] ?? t.resources[s[l]];
        let f;
        if (h._resourceType === "uniformGroup") {
          const p = h;
          a.ubo.updateUniformGroup(p);
          const m = p.buffer;
          f = {
            buffer: a.buffer.getGPUBuffer(m),
            offset: 0,
            size: m.descriptor.size
          };
        } else if (h._resourceType === "buffer") {
          const p = h;
          f = {
            buffer: a.buffer.getGPUBuffer(p),
            offset: 0,
            size: p.descriptor.size
          };
        } else if (h._resourceType === "bufferResource") {
          const p = h;
          f = {
            buffer: a.buffer.getGPUBuffer(p.buffer),
            offset: p.offset,
            size: p.size
          };
        } else if (h._resourceType === "textureSampler") {
          const p = h;
          f = a.texture.getGpuSampler(p);
        } else if (h._resourceType === "textureSource") {
          const p = h;
          f = a.texture.getGpuSource(p).createView({});
        }
        o.push({
          binding: s[l],
          resource: f
        });
      }
      const c = a.shader.getProgramData(e).bindGroups[r], u = n.createBindGroup({
        layout: c,
        entries: o
      });
      return this._hash[t._key] = u, u;
    }
    destroy() {
      for (const t of Object.keys(this._hash)) this._hash[t] = null;
      this._hash = null, this._renderer = null;
    }
  }
  xf.extension = {
    type: [
      P.WebGPUSystem
    ],
    name: "bindGroup"
  };
  class vf {
    constructor() {
      this._gpuBuffers = /* @__PURE__ */ Object.create(null), this._managedBuffers = [];
    }
    contextChange(t) {
      this._gpu = t;
    }
    getGPUBuffer(t) {
      return this._gpuBuffers[t.uid] || this.createGPUBuffer(t);
    }
    updateBuffer(t) {
      const e = this._gpuBuffers[t.uid] || this.createGPUBuffer(t), r = t.data;
      return t._updateID && r && (t._updateID = 0, this._gpu.device.queue.writeBuffer(e, 0, r.buffer, 0, (t._updateSize || r.byteLength) + 3 & -4)), e;
    }
    destroyAll() {
      for (const t in this._gpuBuffers) this._gpuBuffers[t].destroy();
      this._gpuBuffers = {};
    }
    createGPUBuffer(t) {
      this._gpuBuffers[t.uid] || (t.on("update", this.updateBuffer, this), t.on("change", this.onBufferChange, this), t.on("destroy", this.onBufferDestroy, this), this._managedBuffers.push(t));
      const e = this._gpu.device.createBuffer(t.descriptor);
      return t._updateID = 0, t.data && (Po(t.data.buffer, e.getMappedRange()), e.unmap()), this._gpuBuffers[t.uid] = e, e;
    }
    onBufferChange(t) {
      this._gpuBuffers[t.uid].destroy(), t._updateID = 0, this._gpuBuffers[t.uid] = this.createGPUBuffer(t);
    }
    onBufferDestroy(t) {
      this._managedBuffers.splice(this._managedBuffers.indexOf(t), 1), this._destroyBuffer(t);
    }
    destroy() {
      this._managedBuffers.forEach((t) => this._destroyBuffer(t)), this._managedBuffers = null, this._gpuBuffers = null;
    }
    _destroyBuffer(t) {
      this._gpuBuffers[t.uid].destroy(), t.off("update", this.updateBuffer, this), t.off("change", this.onBufferChange, this), t.off("destroy", this.onBufferDestroy, this), this._gpuBuffers[t.uid] = null;
    }
  }
  vf.extension = {
    type: [
      P.WebGPUSystem
    ],
    name: "buffer"
  };
  class E0 {
    constructor({ minUniformOffsetAlignment: t }) {
      this._minUniformOffsetAlignment = 256, this.byteIndex = 0, this._minUniformOffsetAlignment = t, this.data = new Float32Array(65535);
    }
    clear() {
      this.byteIndex = 0;
    }
    addEmptyGroup(t) {
      if (t > this._minUniformOffsetAlignment / 4) throw new Error(`UniformBufferBatch: array is too large: ${t * 4}`);
      const e = this.byteIndex;
      let r = e + t * 4;
      if (r = Math.ceil(r / this._minUniformOffsetAlignment) * this._minUniformOffsetAlignment, r > this.data.length * 4) throw new Error("UniformBufferBatch: ubo batch got too big");
      return this.byteIndex = r, e;
    }
    addGroup(t) {
      const e = this.addEmptyGroup(t.length);
      for (let r = 0; r < t.length; r++) this.data[e / 4 + r] = t[r];
      return e;
    }
    destroy() {
      this._buffer.destroy(), this._buffer = null, this.data = null;
    }
  }
  class Sf {
    constructor(t) {
      this._colorMaskCache = 15, this._renderer = t;
    }
    setMask(t) {
      this._colorMaskCache !== t && (this._colorMaskCache = t, this._renderer.pipeline.setColorMask(t));
    }
    destroy() {
      this._renderer = null, this._colorMaskCache = null;
    }
  }
  Sf.extension = {
    type: [
      P.WebGPUSystem
    ],
    name: "colorMask"
  };
  class Da {
    constructor(t) {
      this._renderer = t;
    }
    async init(t) {
      return this._initPromise ? this._initPromise : (this._initPromise = this._createDeviceAndAdaptor(t).then((e) => {
        this.gpu = e, this._renderer.runners.contextChange.emit(this.gpu);
      }), this._initPromise);
    }
    contextChange(t) {
      this._renderer.gpu = t;
    }
    async _createDeviceAndAdaptor(t) {
      const e = await navigator.gpu.requestAdapter({
        powerPreference: t.powerPreference,
        forceFallbackAdapter: t.forceFallbackAdapter
      }), r = [
        "texture-compression-bc",
        "texture-compression-astc",
        "texture-compression-etc2"
      ].filter((s) => e.features.has(s)), n = await e.requestDevice({
        requiredFeatures: r
      });
      return {
        adapter: e,
        device: n
      };
    }
    destroy() {
      this.gpu = null, this._renderer = null;
    }
  }
  Da.extension = {
    type: [
      P.WebGPUSystem
    ],
    name: "device"
  };
  Da.defaultOptions = {
    powerPreference: void 0,
    forceFallbackAdapter: false
  };
  class Ef {
    constructor(t) {
      this._boundBindGroup = /* @__PURE__ */ Object.create(null), this._boundVertexBuffer = /* @__PURE__ */ Object.create(null), this._renderer = t;
    }
    renderStart() {
      this.commandFinished = new Promise((t) => {
        this._resolveCommandFinished = t;
      }), this.commandEncoder = this._renderer.gpu.device.createCommandEncoder();
    }
    beginRenderPass(t) {
      this.endRenderPass(), this._clearCache(), this.renderPassEncoder = this.commandEncoder.beginRenderPass(t.descriptor);
    }
    endRenderPass() {
      this.renderPassEncoder && this.renderPassEncoder.end(), this.renderPassEncoder = null;
    }
    setViewport(t) {
      this.renderPassEncoder.setViewport(t.x, t.y, t.width, t.height, 0, 1);
    }
    setPipelineFromGeometryProgramAndState(t, e, r, n) {
      const s = this._renderer.pipeline.getPipeline(t, e, r, n);
      this.setPipeline(s);
    }
    setPipeline(t) {
      this._boundPipeline !== t && (this._boundPipeline = t, this.renderPassEncoder.setPipeline(t));
    }
    _setVertexBuffer(t, e) {
      this._boundVertexBuffer[t] !== e && (this._boundVertexBuffer[t] = e, this.renderPassEncoder.setVertexBuffer(t, this._renderer.buffer.updateBuffer(e)));
    }
    _setIndexBuffer(t) {
      if (this._boundIndexBuffer === t) return;
      this._boundIndexBuffer = t;
      const e = t.data.BYTES_PER_ELEMENT === 2 ? "uint16" : "uint32";
      this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(t), e);
    }
    resetBindGroup(t) {
      this._boundBindGroup[t] = null;
    }
    setBindGroup(t, e, r) {
      if (this._boundBindGroup[t] === e) return;
      this._boundBindGroup[t] = e, e._touch(this._renderer.textureGC.count);
      const n = this._renderer.bindGroup.getBindGroup(e, r, t);
      this.renderPassEncoder.setBindGroup(t, n);
    }
    setGeometry(t) {
      for (const e in t.attributes) {
        const r = t.attributes[e];
        this._setVertexBuffer(r.location, r.buffer);
      }
      t.indexBuffer && this._setIndexBuffer(t.indexBuffer);
    }
    _setShaderBindGroups(t, e) {
      for (const r in t.groups) {
        const n = t.groups[r];
        e || this._syncBindGroup(n), this.setBindGroup(r, n, t.gpuProgram);
      }
    }
    _syncBindGroup(t) {
      for (const e in t.resources) {
        const r = t.resources[e];
        r.isUniformGroup && this._renderer.ubo.updateUniformGroup(r);
      }
    }
    draw(t) {
      const { geometry: e, shader: r, state: n, topology: s, size: o, start: a, instanceCount: c, skipSync: u } = t;
      this.setPipelineFromGeometryProgramAndState(e, r.gpuProgram, n, s), this.setGeometry(e), this._setShaderBindGroups(r, u), e.indexBuffer ? this.renderPassEncoder.drawIndexed(o || e.indexBuffer.data.length, c || e.instanceCount, a || 0) : this.renderPassEncoder.draw(o || e.getSize(), c || e.instanceCount, a || 0);
    }
    finishRenderPass() {
      this.renderPassEncoder && (this.renderPassEncoder.end(), this.renderPassEncoder = null);
    }
    postrender() {
      this.finishRenderPass(), this._gpu.device.queue.submit([
        this.commandEncoder.finish()
      ]), this._resolveCommandFinished(), this.commandEncoder = null;
    }
    restoreRenderPass() {
      const t = this._renderer.renderTarget.adaptor.getDescriptor(this._renderer.renderTarget.renderTarget, false, [
        0,
        0,
        0,
        1
      ]);
      this.renderPassEncoder = this.commandEncoder.beginRenderPass(t);
      const e = this._boundPipeline, r = {
        ...this._boundVertexBuffer
      }, n = this._boundIndexBuffer, s = {
        ...this._boundBindGroup
      };
      this._clearCache();
      const o = this._renderer.renderTarget.viewport;
      this.renderPassEncoder.setViewport(o.x, o.y, o.width, o.height, 0, 1), this.setPipeline(e);
      for (const a in r) this._setVertexBuffer(a, r[a]);
      for (const a in s) this.setBindGroup(a, s[a], null);
      this._setIndexBuffer(n);
    }
    _clearCache() {
      for (let t = 0; t < 16; t++) this._boundBindGroup[t] = null, this._boundVertexBuffer[t] = null;
      this._boundIndexBuffer = null, this._boundPipeline = null;
    }
    destroy() {
      this._renderer = null, this._gpu = null, this._boundBindGroup = null, this._boundVertexBuffer = null, this._boundIndexBuffer = null, this._boundPipeline = null;
    }
    contextChange(t) {
      this._gpu = t;
    }
  }
  Ef.extension = {
    type: [
      P.WebGPUSystem
    ],
    name: "encoder",
    priority: 1
  };
  class Af {
    constructor(t) {
      this._renderTargetStencilState = /* @__PURE__ */ Object.create(null), this._renderer = t, t.renderTarget.onRenderTargetChange.add(this);
    }
    onRenderTargetChange(t) {
      let e = this._renderTargetStencilState[t.uid];
      e || (e = this._renderTargetStencilState[t.uid] = {
        stencilMode: Kt.DISABLED,
        stencilReference: 0
      }), this._activeRenderTarget = t, this.setStencilMode(e.stencilMode, e.stencilReference);
    }
    setStencilMode(t, e) {
      const r = this._renderTargetStencilState[this._activeRenderTarget.uid];
      r.stencilMode = t, r.stencilReference = e;
      const n = this._renderer;
      n.pipeline.setStencilMode(t), n.encoder.renderPassEncoder.setStencilReference(e);
    }
    destroy() {
      this._renderer.renderTarget.onRenderTargetChange.remove(this), this._renderer = null, this._activeRenderTarget = null, this._renderTargetStencilState = null;
    }
  }
  Af.extension = {
    type: [
      P.WebGPUSystem
    ],
    name: "stencil"
  };
  const An = {
    i32: {
      align: 4,
      size: 4
    },
    u32: {
      align: 4,
      size: 4
    },
    f32: {
      align: 4,
      size: 4
    },
    f16: {
      align: 2,
      size: 2
    },
    "vec2<i32>": {
      align: 8,
      size: 8
    },
    "vec2<u32>": {
      align: 8,
      size: 8
    },
    "vec2<f32>": {
      align: 8,
      size: 8
    },
    "vec2<f16>": {
      align: 4,
      size: 4
    },
    "vec3<i32>": {
      align: 16,
      size: 12
    },
    "vec3<u32>": {
      align: 16,
      size: 12
    },
    "vec3<f32>": {
      align: 16,
      size: 12
    },
    "vec3<f16>": {
      align: 8,
      size: 6
    },
    "vec4<i32>": {
      align: 16,
      size: 16
    },
    "vec4<u32>": {
      align: 16,
      size: 16
    },
    "vec4<f32>": {
      align: 16,
      size: 16
    },
    "vec4<f16>": {
      align: 8,
      size: 8
    },
    "mat2x2<f32>": {
      align: 8,
      size: 16
    },
    "mat2x2<f16>": {
      align: 4,
      size: 8
    },
    "mat3x2<f32>": {
      align: 8,
      size: 24
    },
    "mat3x2<f16>": {
      align: 4,
      size: 12
    },
    "mat4x2<f32>": {
      align: 8,
      size: 32
    },
    "mat4x2<f16>": {
      align: 4,
      size: 16
    },
    "mat2x3<f32>": {
      align: 16,
      size: 32
    },
    "mat2x3<f16>": {
      align: 8,
      size: 16
    },
    "mat3x3<f32>": {
      align: 16,
      size: 48
    },
    "mat3x3<f16>": {
      align: 8,
      size: 24
    },
    "mat4x3<f32>": {
      align: 16,
      size: 64
    },
    "mat4x3<f16>": {
      align: 8,
      size: 32
    },
    "mat2x4<f32>": {
      align: 16,
      size: 32
    },
    "mat2x4<f16>": {
      align: 8,
      size: 16
    },
    "mat3x4<f32>": {
      align: 16,
      size: 48
    },
    "mat3x4<f16>": {
      align: 8,
      size: 24
    },
    "mat4x4<f32>": {
      align: 16,
      size: 64
    },
    "mat4x4<f16>": {
      align: 8,
      size: 32
    }
  };
  function A0(i) {
    const t = i.map((r) => ({
      data: r,
      offset: 0,
      size: 0
    }));
    let e = 0;
    for (let r = 0; r < t.length; r++) {
      const n = t[r];
      let s = An[n.data.type].size;
      const o = An[n.data.type].align;
      if (!An[n.data.type]) throw new Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${n.data.type}`);
      n.data.size > 1 && (s = Math.max(s, o) * n.data.size), e = Math.ceil(e / o) * o, n.size = s, n.offset = e, e += s;
    }
    return e = Math.ceil(e / 16) * 16, {
      uboElements: t,
      size: e
    };
  }
  function T0(i, t) {
    const { size: e, align: r } = An[i.data.type], n = (r - e) / 4;
    return `
         v = uv.${i.data.name};
         ${t !== 0 ? `offset += ${t};` : ""}

         arrayOffset = offset;

         t = 0;

         for(var i=0; i < ${i.data.size * (e / 4)}; i++)
         {
             for(var j = 0; j < ${e / 4}; j++)
             {
                 data[arrayOffset++] = v[t++];
             }
             ${n !== 0 ? `arrayOffset += ${n};` : ""}
         }
     `;
  }
  function C0(i) {
    return Ud(i, "uboWgsl", T0, vy);
  }
  class Tf extends Id {
    constructor() {
      super({
        createUboElements: A0,
        generateUboSync: C0
      });
    }
  }
  Tf.extension = {
    type: [
      P.WebGPUSystem
    ],
    name: "ubo"
  };
  const sr = 128;
  class Cf {
    constructor(t) {
      this._bindGroupHash = /* @__PURE__ */ Object.create(null), this._buffers = [], this._bindGroups = [], this._bufferResources = [], this._renderer = t, this._batchBuffer = new E0({
        minUniformOffsetAlignment: sr
      });
      const e = 256 / sr;
      for (let r = 0; r < e; r++) {
        let n = yt.UNIFORM | yt.COPY_DST;
        r === 0 && (n |= yt.COPY_SRC), this._buffers.push(new Pe({
          data: this._batchBuffer.data,
          usage: n
        }));
      }
    }
    renderEnd() {
      this._uploadBindGroups(), this._resetBindGroups();
    }
    _resetBindGroups() {
      for (const t in this._bindGroupHash) this._bindGroupHash[t] = null;
      this._batchBuffer.clear();
    }
    getUniformBindGroup(t, e) {
      if (!e && this._bindGroupHash[t.uid]) return this._bindGroupHash[t.uid];
      this._renderer.ubo.ensureUniformGroup(t);
      const r = t.buffer.data, n = this._batchBuffer.addEmptyGroup(r.length);
      return this._renderer.ubo.syncUniformGroup(t, this._batchBuffer.data, n / 4), this._bindGroupHash[t.uid] = this._getBindGroup(n / sr), this._bindGroupHash[t.uid];
    }
    getUboResource(t) {
      this._renderer.ubo.updateUniformGroup(t);
      const e = t.buffer.data, r = this._batchBuffer.addGroup(e);
      return this._getBufferResource(r / sr);
    }
    getArrayBindGroup(t) {
      const e = this._batchBuffer.addGroup(t);
      return this._getBindGroup(e / sr);
    }
    getArrayBufferResource(t) {
      const r = this._batchBuffer.addGroup(t) / sr;
      return this._getBufferResource(r);
    }
    _getBufferResource(t) {
      if (!this._bufferResources[t]) {
        const e = this._buffers[t % 2];
        this._bufferResources[t] = new Ea({
          buffer: e,
          offset: (t / 2 | 0) * 256,
          size: sr
        });
      }
      return this._bufferResources[t];
    }
    _getBindGroup(t) {
      if (!this._bindGroups[t]) {
        const e = new Ze({
          0: this._getBufferResource(t)
        });
        this._bindGroups[t] = e;
      }
      return this._bindGroups[t];
    }
    _uploadBindGroups() {
      const t = this._renderer.buffer, e = this._buffers[0];
      e.update(this._batchBuffer.byteIndex), t.updateBuffer(e);
      const r = this._renderer.gpu.device.createCommandEncoder();
      for (let n = 1; n < this._buffers.length; n++) {
        const s = this._buffers[n];
        r.copyBufferToBuffer(t.getGPUBuffer(e), sr, t.getGPUBuffer(s), 0, this._batchBuffer.byteIndex);
      }
      this._renderer.gpu.device.queue.submit([
        r.finish()
      ]);
    }
    destroy() {
      for (let t = 0; t < this._bindGroups.length; t++) this._bindGroups[t].destroy();
      this._bindGroups = null, this._bindGroupHash = null;
      for (let t = 0; t < this._buffers.length; t++) this._buffers[t].destroy();
      this._buffers = null;
      for (let t = 0; t < this._bufferResources.length; t++) this._bufferResources[t].destroy();
      this._bufferResources = null, this._batchBuffer.destroy(), this._bindGroupHash = null, this._renderer = null;
    }
  }
  Cf.extension = {
    type: [
      P.WebGPUPipes
    ],
    name: "uniformBatch"
  };
  const R0 = {
    "point-list": 0,
    "line-list": 1,
    "line-strip": 2,
    "triangle-list": 3,
    "triangle-strip": 4
  };
  function P0(i, t, e, r, n) {
    return i << 24 | t << 16 | e << 10 | r << 5 | n;
  }
  function B0(i, t, e, r) {
    return e << 6 | i << 3 | r << 1 | t;
  }
  class Rf {
    constructor(t) {
      this._moduleCache = /* @__PURE__ */ Object.create(null), this._bufferLayoutsCache = /* @__PURE__ */ Object.create(null), this._pipeCache = /* @__PURE__ */ Object.create(null), this._pipeStateCaches = /* @__PURE__ */ Object.create(null), this._colorMask = 15, this._multisampleCount = 1, this._renderer = t;
    }
    contextChange(t) {
      this._gpu = t, this.setStencilMode(Kt.DISABLED), this._updatePipeHash();
    }
    setMultisampleCount(t) {
      this._multisampleCount !== t && (this._multisampleCount = t, this._updatePipeHash());
    }
    setRenderTarget(t) {
      this._multisampleCount = t.msaaSamples, this._depthStencilAttachment = t.descriptor.depthStencilAttachment ? 1 : 0, this._updatePipeHash();
    }
    setColorMask(t) {
      this._colorMask !== t && (this._colorMask = t, this._updatePipeHash());
    }
    setStencilMode(t) {
      this._stencilMode !== t && (this._stencilMode = t, this._stencilState = Ur[t], this._updatePipeHash());
    }
    setPipeline(t, e, r, n) {
      const s = this.getPipeline(t, e, r);
      n.setPipeline(s);
    }
    getPipeline(t, e, r, n) {
      t._layoutKey || (Td(t, e.attributeData), this._generateBufferKey(t)), n = n || t.topology;
      const s = P0(t._layoutKey, e._layoutKey, r.data, r._blendModeId, R0[n]);
      return this._pipeCache[s] ? this._pipeCache[s] : (this._pipeCache[s] = this._createPipeline(t, e, r, n), this._pipeCache[s]);
    }
    _createPipeline(t, e, r, n) {
      const s = this._gpu.device, o = this._createVertexBufferLayouts(t), a = this._renderer.state.getColorTargets(r);
      a[0].writeMask = this._stencilMode === Kt.RENDERING_MASK_ADD ? 0 : this._colorMask;
      const c = this._renderer.shader.getProgramData(e).pipeline, u = {
        vertex: {
          module: this._getModule(e.vertex.source),
          entryPoint: e.vertex.entryPoint,
          buffers: o
        },
        fragment: {
          module: this._getModule(e.fragment.source),
          entryPoint: e.fragment.entryPoint,
          targets: a
        },
        primitive: {
          topology: n,
          cullMode: r.cullMode
        },
        layout: c,
        multisample: {
          count: this._multisampleCount
        },
        label: "PIXI Pipeline"
      };
      return this._depthStencilAttachment && (u.depthStencil = {
        ...this._stencilState,
        format: "depth24plus-stencil8",
        depthWriteEnabled: r.depthTest,
        depthCompare: r.depthTest ? "less" : "always"
      }), s.createRenderPipeline(u);
    }
    _getModule(t) {
      return this._moduleCache[t] || this._createModule(t);
    }
    _createModule(t) {
      const e = this._gpu.device;
      return this._moduleCache[t] = e.createShaderModule({
        code: t
      }), this._moduleCache[t];
    }
    _generateBufferKey(t) {
      const e = [];
      let r = 0;
      const n = Object.keys(t.attributes).sort();
      for (let o = 0; o < n.length; o++) {
        const a = t.attributes[n[o]];
        e[r++] = a.location, e[r++] = a.offset, e[r++] = a.format, e[r++] = a.stride;
      }
      const s = e.join("");
      return t._layoutKey = qn(s, "geometry"), t._layoutKey;
    }
    _createVertexBufferLayouts(t) {
      if (this._bufferLayoutsCache[t._layoutKey]) return this._bufferLayoutsCache[t._layoutKey];
      const e = [];
      return t.buffers.forEach((r) => {
        const n = {
          arrayStride: 0,
          stepMode: "vertex",
          attributes: []
        }, s = n.attributes;
        for (const o in t.attributes) {
          const a = t.attributes[o];
          (a.divisor ?? 1) !== 1 && ut(`Attribute ${o} has an invalid divisor value of '${a.divisor}'. WebGPU only supports a divisor value of 1`), a.buffer === r && (n.arrayStride = a.stride, n.stepMode = a.instance ? "instance" : "vertex", s.push({
            shaderLocation: a.location,
            offset: a.offset,
            format: a.format
          }));
        }
        s.length && e.push(n);
      }), this._bufferLayoutsCache[t._layoutKey] = e, e;
    }
    _updatePipeHash() {
      const t = B0(this._stencilMode, this._multisampleCount, this._colorMask, this._depthStencilAttachment);
      this._pipeStateCaches[t] || (this._pipeStateCaches[t] = /* @__PURE__ */ Object.create(null)), this._pipeCache = this._pipeStateCaches[t];
    }
    destroy() {
      this._renderer = null, this._bufferLayoutsCache = null;
    }
  }
  Rf.extension = {
    type: [
      P.WebGPUSystem
    ],
    name: "pipeline"
  };
  class M0 {
    constructor() {
      this.contexts = [], this.msaaTextures = [], this.msaaSamples = 1;
    }
  }
  class D0 {
    init(t, e) {
      this._renderer = t, this._renderTargetSystem = e;
    }
    copyToTexture(t, e, r, n, s) {
      const o = this._renderer, a = this._getGpuColorTexture(t), c = o.texture.getGpuSource(e.source);
      return o.encoder.commandEncoder.copyTextureToTexture({
        texture: a,
        origin: r
      }, {
        texture: c,
        origin: s
      }, n), e;
    }
    startRenderPass(t, e = true, r, n) {
      const o = this._renderTargetSystem.getGpuRenderTarget(t), a = this.getDescriptor(t, e, r);
      o.descriptor = a, this._renderer.pipeline.setRenderTarget(o), this._renderer.encoder.beginRenderPass(o), this._renderer.encoder.setViewport(n);
    }
    finishRenderPass() {
      this._renderer.encoder.endRenderPass();
    }
    _getGpuColorTexture(t) {
      const e = this._renderTargetSystem.getGpuRenderTarget(t);
      return e.contexts[0] ? e.contexts[0].getCurrentTexture() : this._renderer.texture.getGpuSource(t.colorTextures[0].source);
    }
    getDescriptor(t, e, r) {
      typeof e == "boolean" && (e = e ? pe.ALL : pe.NONE);
      const n = this._renderTargetSystem, s = n.getGpuRenderTarget(t), o = t.colorTextures.map((u, l) => {
        const h = s.contexts[l];
        let f, p;
        h ? f = h.getCurrentTexture().createView() : f = this._renderer.texture.getGpuSource(u).createView({
          mipLevelCount: 1
        }), s.msaaTextures[l] && (p = f, f = this._renderer.texture.getTextureView(s.msaaTextures[l]));
        const m = e & pe.COLOR ? "clear" : "load";
        return r ?? (r = n.defaultClearColor), {
          view: f,
          resolveTarget: p,
          clearValue: r,
          storeOp: "store",
          loadOp: m
        };
      });
      let a;
      if ((t.stencil || t.depth) && !t.depthStencilTexture && (t.ensureDepthStencilTexture(), t.depthStencilTexture.source.sampleCount = s.msaa ? 4 : 1), t.depthStencilTexture) {
        const u = e & pe.STENCIL ? "clear" : "load", l = e & pe.DEPTH ? "clear" : "load";
        a = {
          view: this._renderer.texture.getGpuSource(t.depthStencilTexture.source).createView(),
          stencilStoreOp: "store",
          stencilLoadOp: u,
          depthClearValue: 1,
          depthLoadOp: l,
          depthStoreOp: "store"
        };
      }
      return {
        colorAttachments: o,
        depthStencilAttachment: a
      };
    }
    clear(t, e = true, r, n) {
      if (!e) return;
      const { gpu: s, encoder: o } = this._renderer, a = s.device;
      if (o.commandEncoder === null) {
        const u = a.createCommandEncoder(), l = this.getDescriptor(t, e, r), h = u.beginRenderPass(l);
        h.setViewport(n.x, n.y, n.width, n.height, 0, 1), h.end();
        const f = u.finish();
        a.queue.submit([
          f
        ]);
      } else this.startRenderPass(t, e, r, n);
    }
    initGpuRenderTarget(t) {
      t.isRoot = true;
      const e = new M0();
      return t.colorTextures.forEach((r, n) => {
        if (Kr.test(r.resource)) {
          const s = r.resource.getContext("webgpu"), o = r.transparent ? "premultiplied" : "opaque";
          try {
            s.configure({
              device: this._renderer.gpu.device,
              usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
              format: "bgra8unorm",
              alphaMode: o
            });
          } catch (a) {
            console.error(a);
          }
          e.contexts[n] = s;
        }
        if (e.msaa = r.source.antialias, r.source.antialias) {
          const s = new Ht({
            width: 0,
            height: 0,
            sampleCount: 4
          });
          e.msaaTextures[n] = s;
        }
      }), e.msaa && (e.msaaSamples = 4, t.depthStencilTexture && (t.depthStencilTexture.source.sampleCount = 4)), e;
    }
    destroyGpuRenderTarget(t) {
      t.contexts.forEach((e) => {
        e.unconfigure();
      }), t.msaaTextures.forEach((e) => {
        e.destroy();
      }), t.msaaTextures.length = 0, t.contexts.length = 0;
    }
    ensureDepthStencilTexture(t) {
      const e = this._renderTargetSystem.getGpuRenderTarget(t);
      t.depthStencilTexture && e.msaa && (t.depthStencilTexture.source.sampleCount = 4);
    }
    resizeGpuRenderTarget(t) {
      const e = this._renderTargetSystem.getGpuRenderTarget(t);
      e.width = t.width, e.height = t.height, e.msaa && t.colorTextures.forEach((r, n) => {
        var _a2;
        (_a2 = e.msaaTextures[n]) == null ? void 0 : _a2.resize(r.source.width, r.source.height, r.source._resolution);
      });
    }
  }
  class Pf extends Hd {
    constructor(t) {
      super(t), this.adaptor = new D0(), this.adaptor.init(t, this);
    }
  }
  Pf.extension = {
    type: [
      P.WebGPUSystem
    ],
    name: "renderTarget"
  };
  class Bf {
    constructor() {
      this._gpuProgramData = /* @__PURE__ */ Object.create(null);
    }
    contextChange(t) {
      this._gpu = t;
    }
    getProgramData(t) {
      return this._gpuProgramData[t._layoutKey] || this._createGPUProgramData(t);
    }
    _createGPUProgramData(t) {
      const e = this._gpu.device, r = t.gpuLayout.map((s) => e.createBindGroupLayout({
        entries: s
      })), n = {
        bindGroupLayouts: r
      };
      return this._gpuProgramData[t._layoutKey] = {
        bindGroups: r,
        pipeline: e.createPipelineLayout(n)
      }, this._gpuProgramData[t._layoutKey];
    }
    destroy() {
      this._gpu = null, this._gpuProgramData = null;
    }
  }
  Bf.extension = {
    type: [
      P.WebGPUSystem
    ],
    name: "shader"
  };
  const xe = {};
  xe.normal = {
    alpha: {
      srcFactor: "one",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    },
    color: {
      srcFactor: "one",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    }
  };
  xe.add = {
    alpha: {
      srcFactor: "src-alpha",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    },
    color: {
      srcFactor: "one",
      dstFactor: "one",
      operation: "add"
    }
  };
  xe.multiply = {
    alpha: {
      srcFactor: "one",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    },
    color: {
      srcFactor: "dst",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    }
  };
  xe.screen = {
    alpha: {
      srcFactor: "one",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    },
    color: {
      srcFactor: "one",
      dstFactor: "one-minus-src",
      operation: "add"
    }
  };
  xe.overlay = {
    alpha: {
      srcFactor: "one",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    },
    color: {
      srcFactor: "one",
      dstFactor: "one-minus-src",
      operation: "add"
    }
  };
  xe.none = {
    alpha: {
      srcFactor: "one",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    },
    color: {
      srcFactor: "zero",
      dstFactor: "zero",
      operation: "add"
    }
  };
  xe["normal-npm"] = {
    alpha: {
      srcFactor: "one",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    },
    color: {
      srcFactor: "src-alpha",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    }
  };
  xe["add-npm"] = {
    alpha: {
      srcFactor: "one",
      dstFactor: "one",
      operation: "add"
    },
    color: {
      srcFactor: "src-alpha",
      dstFactor: "one",
      operation: "add"
    }
  };
  xe["screen-npm"] = {
    alpha: {
      srcFactor: "one",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    },
    color: {
      srcFactor: "src-alpha",
      dstFactor: "one-minus-src",
      operation: "add"
    }
  };
  xe.erase = {
    alpha: {
      srcFactor: "zero",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    },
    color: {
      srcFactor: "zero",
      dstFactor: "one-minus-src",
      operation: "add"
    }
  };
  class Mf {
    constructor() {
      this.defaultState = new Le(), this.defaultState.blend = true;
    }
    contextChange(t) {
      this.gpu = t;
    }
    getColorTargets(t) {
      return [
        {
          format: "bgra8unorm",
          writeMask: 0,
          blend: xe[t.blendMode] || xe.normal
        }
      ];
    }
    destroy() {
      this.gpu = null;
    }
  }
  Mf.extension = {
    type: [
      P.WebGPUSystem
    ],
    name: "state"
  };
  const I0 = {
    type: "image",
    upload(i, t, e) {
      const r = i.resource, n = (i.pixelWidth | 0) * (i.pixelHeight | 0), s = r.byteLength / n;
      e.device.queue.writeTexture({
        texture: t
      }, r, {
        offset: 0,
        rowsPerImage: i.pixelHeight,
        bytesPerRow: i.pixelHeight * s
      }, {
        width: i.pixelWidth,
        height: i.pixelHeight,
        depthOrArrayLayers: 1
      });
    }
  }, Df = {
    "bc1-rgba-unorm": {
      blockBytes: 8,
      blockWidth: 4,
      blockHeight: 4
    },
    "bc2-rgba-unorm": {
      blockBytes: 16,
      blockWidth: 4,
      blockHeight: 4
    },
    "bc3-rgba-unorm": {
      blockBytes: 16,
      blockWidth: 4,
      blockHeight: 4
    },
    "bc7-rgba-unorm": {
      blockBytes: 16,
      blockWidth: 4,
      blockHeight: 4
    },
    "etc1-rgb-unorm": {
      blockBytes: 8,
      blockWidth: 4,
      blockHeight: 4
    },
    "etc2-rgba8unorm": {
      blockBytes: 16,
      blockWidth: 4,
      blockHeight: 4
    },
    "astc-4x4-unorm": {
      blockBytes: 16,
      blockWidth: 4,
      blockHeight: 4
    }
  }, F0 = {
    blockBytes: 4,
    blockWidth: 1,
    blockHeight: 1
  }, U0 = {
    type: "compressed",
    upload(i, t, e) {
      let r = i.pixelWidth, n = i.pixelHeight;
      const s = Df[i.format] || F0;
      for (let o = 0; o < i.resource.length; o++) {
        const a = i.resource[o], c = Math.ceil(r / s.blockWidth) * s.blockBytes;
        e.device.queue.writeTexture({
          texture: t,
          mipLevel: o
        }, a, {
          offset: 0,
          bytesPerRow: c
        }, {
          width: Math.ceil(r / s.blockWidth) * s.blockWidth,
          height: Math.ceil(n / s.blockHeight) * s.blockHeight,
          depthOrArrayLayers: 1
        }), r = Math.max(r >> 1, 1), n = Math.max(n >> 1, 1);
      }
    }
  }, If = {
    type: "image",
    upload(i, t, e) {
      const r = i.resource;
      if (!r) return;
      const n = Math.min(t.width, i.resourceWidth || i.pixelWidth), s = Math.min(t.height, i.resourceHeight || i.pixelHeight), o = i.alphaMode === "premultiply-alpha-on-upload";
      e.device.queue.copyExternalImageToTexture({
        source: r
      }, {
        texture: t,
        premultipliedAlpha: o
      }, {
        width: n,
        height: s
      });
    }
  }, k0 = {
    type: "video",
    upload(i, t, e) {
      If.upload(i, t, e);
    }
  };
  class G0 {
    constructor(t) {
      this.device = t, this.sampler = t.createSampler({
        minFilter: "linear"
      }), this.pipelines = {};
    }
    _getMipmapPipeline(t) {
      let e = this.pipelines[t];
      return e || (this.mipmapShaderModule || (this.mipmapShaderModule = this.device.createShaderModule({
        code: `
                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(
                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));

                        struct VertexOutput {
                        @builtin(position) position : vec4<f32>,
                        @location(0) texCoord : vec2<f32>,
                        };

                        @vertex
                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
                        var output : VertexOutput;
                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
                        return output;
                        }

                        @group(0) @binding(0) var imgSampler : sampler;
                        @group(0) @binding(1) var img : texture_2d<f32>;

                        @fragment
                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
                        return textureSample(img, imgSampler, texCoord);
                        }
                    `
      })), e = this.device.createRenderPipeline({
        layout: "auto",
        vertex: {
          module: this.mipmapShaderModule,
          entryPoint: "vertexMain"
        },
        fragment: {
          module: this.mipmapShaderModule,
          entryPoint: "fragmentMain",
          targets: [
            {
              format: t
            }
          ]
        }
      }), this.pipelines[t] = e), e;
    }
    generateMipmap(t) {
      const e = this._getMipmapPipeline(t.format);
      if (t.dimension === "3d" || t.dimension === "1d") throw new Error("Generating mipmaps for non-2d textures is currently unsupported!");
      let r = t;
      const n = t.depthOrArrayLayers || 1, s = t.usage & GPUTextureUsage.RENDER_ATTACHMENT;
      if (!s) {
        const c = {
          size: {
            width: Math.ceil(t.width / 2),
            height: Math.ceil(t.height / 2),
            depthOrArrayLayers: n
          },
          format: t.format,
          usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,
          mipLevelCount: t.mipLevelCount - 1
        };
        r = this.device.createTexture(c);
      }
      const o = this.device.createCommandEncoder({}), a = e.getBindGroupLayout(0);
      for (let c = 0; c < n; ++c) {
        let u = t.createView({
          baseMipLevel: 0,
          mipLevelCount: 1,
          dimension: "2d",
          baseArrayLayer: c,
          arrayLayerCount: 1
        }), l = s ? 1 : 0;
        for (let h = 1; h < t.mipLevelCount; ++h) {
          const f = r.createView({
            baseMipLevel: l++,
            mipLevelCount: 1,
            dimension: "2d",
            baseArrayLayer: c,
            arrayLayerCount: 1
          }), p = o.beginRenderPass({
            colorAttachments: [
              {
                view: f,
                storeOp: "store",
                loadOp: "clear",
                clearValue: {
                  r: 0,
                  g: 0,
                  b: 0,
                  a: 0
                }
              }
            ]
          }), m = this.device.createBindGroup({
            layout: a,
            entries: [
              {
                binding: 0,
                resource: this.sampler
              },
              {
                binding: 1,
                resource: u
              }
            ]
          });
          p.setPipeline(e), p.setBindGroup(0, m), p.draw(3, 1, 0, 0), p.end(), u = f;
        }
      }
      if (!s) {
        const c = {
          width: Math.ceil(t.width / 2),
          height: Math.ceil(t.height / 2),
          depthOrArrayLayers: n
        };
        for (let u = 1; u < t.mipLevelCount; ++u) o.copyTextureToTexture({
          texture: r,
          mipLevel: u - 1
        }, {
          texture: t,
          mipLevel: u
        }, c), c.width = Math.ceil(c.width / 2), c.height = Math.ceil(c.height / 2);
      }
      return this.device.queue.submit([
        o.finish()
      ]), s || r.destroy(), t;
    }
  }
  class Ff {
    constructor(t) {
      this.managedTextures = [], this._gpuSources = /* @__PURE__ */ Object.create(null), this._gpuSamplers = /* @__PURE__ */ Object.create(null), this._bindGroupHash = /* @__PURE__ */ Object.create(null), this._textureViewHash = /* @__PURE__ */ Object.create(null), this._uploads = {
        image: If,
        buffer: I0,
        video: k0,
        compressed: U0
      }, this._renderer = t;
    }
    contextChange(t) {
      this._gpu = t;
    }
    initSource(t) {
      if (t.autoGenerateMipmaps) {
        const c = Math.max(t.pixelWidth, t.pixelHeight);
        t.mipLevelCount = Math.floor(Math.log2(c)) + 1;
      }
      let e = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;
      t.uploadMethodId !== "compressed" && (e |= GPUTextureUsage.RENDER_ATTACHMENT, e |= GPUTextureUsage.COPY_SRC);
      const r = Df[t.format] || {
        blockBytes: 4,
        blockWidth: 1,
        blockHeight: 1
      }, n = Math.ceil(t.pixelWidth / r.blockWidth) * r.blockWidth, s = Math.ceil(t.pixelHeight / r.blockHeight) * r.blockHeight, o = {
        label: t.label,
        size: {
          width: n,
          height: s
        },
        format: t.format,
        sampleCount: t.sampleCount,
        mipLevelCount: t.mipLevelCount,
        dimension: t.dimension,
        usage: e
      }, a = this._gpu.device.createTexture(o);
      return this._gpuSources[t.uid] = a, this.managedTextures.includes(t) || (t.on("update", this.onSourceUpdate, this), t.on("resize", this.onSourceResize, this), t.on("destroy", this.onSourceDestroy, this), t.on("unload", this.onSourceUnload, this), t.on("updateMipmaps", this.onUpdateMipmaps, this), this.managedTextures.push(t)), this.onSourceUpdate(t), a;
    }
    onSourceUpdate(t) {
      const e = this.getGpuSource(t);
      e && (this._uploads[t.uploadMethodId] && this._uploads[t.uploadMethodId].upload(t, e, this._gpu), t.autoGenerateMipmaps && t.mipLevelCount > 1 && this.onUpdateMipmaps(t));
    }
    onSourceUnload(t) {
      const e = this._gpuSources[t.uid];
      e && (this._gpuSources[t.uid] = null, e.destroy());
    }
    onUpdateMipmaps(t) {
      this._mipmapGenerator || (this._mipmapGenerator = new G0(this._gpu.device));
      const e = this.getGpuSource(t);
      this._mipmapGenerator.generateMipmap(e);
    }
    onSourceDestroy(t) {
      t.off("update", this.onSourceUpdate, this), t.off("unload", this.onSourceUnload, this), t.off("destroy", this.onSourceDestroy, this), t.off("resize", this.onSourceResize, this), t.off("updateMipmaps", this.onUpdateMipmaps, this), this.managedTextures.splice(this.managedTextures.indexOf(t), 1), this.onSourceUnload(t);
    }
    onSourceResize(t) {
      const e = this._gpuSources[t.uid];
      e ? (e.width !== t.pixelWidth || e.height !== t.pixelHeight) && (this._textureViewHash[t.uid] = null, this._bindGroupHash[t.uid] = null, this.onSourceUnload(t), this.initSource(t)) : this.initSource(t);
    }
    _initSampler(t) {
      return this._gpuSamplers[t._resourceId] = this._gpu.device.createSampler(t), this._gpuSamplers[t._resourceId];
    }
    getGpuSampler(t) {
      return this._gpuSamplers[t._resourceId] || this._initSampler(t);
    }
    getGpuSource(t) {
      return this._gpuSources[t.uid] || this.initSource(t);
    }
    getTextureBindGroup(t) {
      return this._bindGroupHash[t.uid] ?? this._createTextureBindGroup(t);
    }
    _createTextureBindGroup(t) {
      const e = t.source, r = e.uid;
      return this._bindGroupHash[r] = new Ze({
        0: e,
        1: e.style
      }), this._bindGroupHash[r];
    }
    getTextureView(t) {
      const e = t.source;
      return this._textureViewHash[e.uid] ?? this._createTextureView(e);
    }
    _createTextureView(t) {
      return this._textureViewHash[t.uid] = this.getGpuSource(t).createView(), this._textureViewHash[t.uid];
    }
    generateCanvas(t) {
      const e = this._renderer, r = e.gpu.device.createCommandEncoder(), n = St.get().createCanvas();
      n.width = t.source.pixelWidth, n.height = t.source.pixelHeight;
      const s = n.getContext("webgpu");
      return s.configure({
        device: e.gpu.device,
        usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,
        format: navigator.gpu.getPreferredCanvasFormat(),
        alphaMode: "premultiplied"
      }), r.copyTextureToTexture({
        texture: e.texture.getGpuSource(t.source),
        origin: {
          x: 0,
          y: 0
        }
      }, {
        texture: s.getCurrentTexture()
      }, {
        width: n.width,
        height: n.height
      }), e.gpu.device.queue.submit([
        r.finish()
      ]), n;
    }
    getPixels(t) {
      const e = this.generateCanvas(t), r = Je.getOptimalCanvasAndContext(e.width, e.height), n = r.context;
      n.drawImage(e, 0, 0);
      const { width: s, height: o } = e, a = n.getImageData(0, 0, s, o), c = new Uint8ClampedArray(a.data.buffer);
      return Je.returnCanvasAndContext(r), {
        pixels: c,
        width: s,
        height: o
      };
    }
    destroy() {
      var _a2;
      this.managedTextures.slice().forEach((t) => this.onSourceDestroy(t)), this.managedTextures = null;
      for (const t of Object.keys(this._bindGroupHash)) {
        const e = Number(t);
        (_a2 = this._bindGroupHash[e]) == null ? void 0 : _a2.destroy(), this._bindGroupHash[e] = null;
      }
      this._gpu = null, this._mipmapGenerator = null, this._gpuSources = null, this._bindGroupHash = null, this._textureViewHash = null, this._gpuSamplers = null;
    }
  }
  Ff.extension = {
    type: [
      P.WebGPUSystem
    ],
    name: "texture"
  };
  class Uf {
    init() {
      const t = new Qt({
        uTransformMatrix: {
          value: new nt(),
          type: "mat3x3<f32>"
        },
        uColor: {
          value: new Float32Array([
            1,
            1,
            1,
            1
          ]),
          type: "vec4<f32>"
        },
        uRound: {
          value: 0,
          type: "f32"
        }
      }), e = Ui({
        name: "graphics",
        bits: [
          ga,
          ba(Ir()),
          oy,
          Gi
        ]
      });
      this.shader = new Se({
        gpuProgram: e,
        resources: {
          localUniforms: t
        }
      });
    }
    execute(t, e) {
      const r = e.context, n = r.customShader || this.shader, s = t.renderer, o = s.graphicsContext, { geometry: a, instructions: c } = o.getContextRenderData(r), u = s.encoder;
      u.setPipelineFromGeometryProgramAndState(a, n.gpuProgram, t.state), u.setGeometry(a);
      const l = s.globalUniforms.bindGroup;
      u.setBindGroup(0, l, n.gpuProgram);
      const h = s.renderPipes.uniformBatch.getUniformBindGroup(n.resources.localUniforms, true);
      u.setBindGroup(2, h, n.gpuProgram);
      const f = c.instructions;
      for (let p = 0; p < c.instructionSize; p++) {
        const m = f[p];
        if (n.groups[1] = m.bindGroup, !m.gpuBindGroup) {
          const y = m.textures;
          m.bindGroup = oa(y.textures, y.count), m.gpuBindGroup = s.bindGroup.getBindGroup(m.bindGroup, n.gpuProgram, 1);
        }
        u.setBindGroup(1, m.bindGroup, n.gpuProgram), u.renderPassEncoder.drawIndexed(m.size, 1, m.start);
      }
    }
    destroy() {
      this.shader.destroy(true), this.shader = null;
    }
  }
  Uf.extension = {
    type: [
      P.WebGPUPipesAdaptor
    ],
    name: "graphics"
  };
  class kf {
    init() {
      const t = Ui({
        name: "mesh",
        bits: [
          Si,
          ay,
          Gi
        ]
      });
      this._shader = new Se({
        gpuProgram: t,
        resources: {
          uTexture: J.EMPTY._source,
          uSampler: J.EMPTY._source.style,
          textureUniforms: {
            uTextureMatrix: {
              type: "mat3x3<f32>",
              value: new nt()
            }
          }
        }
      });
    }
    execute(t, e) {
      const r = t.renderer;
      let n = e._shader;
      if (!n) n = this._shader, n.resources.uTexture = e.texture.source, n.resources.uSampler = e.texture.source.style, n.resources.textureUniforms.uniforms.uTextureMatrix = e.texture.textureMatrix.mapCoord;
      else if (!n.gpuProgram) {
        ut("Mesh shader has no gpuProgram", e.shader);
        return;
      }
      const s = n.gpuProgram;
      if (s.autoAssignGlobalUniforms && (n.groups[0] = r.globalUniforms.bindGroup), s.autoAssignLocalUniforms) {
        const o = t.localUniforms;
        n.groups[1] = r.renderPipes.uniformBatch.getUniformBindGroup(o, true);
      }
      r.encoder.draw({
        geometry: e._geometry,
        shader: n,
        state: e.state
      });
    }
    destroy() {
      this._shader.destroy(true), this._shader = null;
    }
  }
  kf.extension = {
    type: [
      P.WebGPUPipesAdaptor
    ],
    name: "mesh"
  };
  const O0 = [
    ...gf,
    Tf,
    Ef,
    Da,
    vf,
    Ff,
    Pf,
    Bf,
    Mf,
    Rf,
    Sf,
    Af,
    xf
  ], N0 = [
    ...mf,
    Cf
  ], L0 = [
    bd,
    kf,
    Uf
  ], Gf = [], Of = [], Nf = [];
  Mt.handleByNamedList(P.WebGPUSystem, Gf);
  Mt.handleByNamedList(P.WebGPUPipes, Of);
  Mt.handleByNamedList(P.WebGPUPipesAdaptor, Nf);
  Mt.add(...O0, ...N0, ...L0);
  class H0 extends $n {
    constructor() {
      const t = {
        name: "webgpu",
        type: ge.WEBGPU,
        systems: Gf,
        renderPipes: Of,
        renderPipeAdaptors: Nf
      };
      super(t);
    }
  }
  const z0 = Object.freeze(Object.defineProperty({
    __proto__: null,
    WebGPURenderer: H0
  }, Symbol.toStringTag, {
    value: "Module"
  })), Hu = {
    POINTS: "point-list",
    LINES: "line-list",
    LINE_STRIP: "line-strip",
    TRIANGLES: "triangle-list",
    TRIANGLE_STRIP: "triangle-strip"
  }, cR = new Proxy(Hu, {
    get(i, t) {
      return lt(dt, `DRAW_MODES.${t} is deprecated, use '${Hu[t]}' instead`), i[t];
    }
  }), uR = new Et(0, 0, 1, 1);
  var Ho = ((i) => (i.CLAMP = "clamp-to-edge", i.REPEAT = "repeat", i.MIRRORED_REPEAT = "mirror-repeat", i))(Ho || {});
  const lR = new Proxy(Ho, {
    get(i, t) {
      return lt(dt, `DRAW_MODES.${t} is deprecated, use '${Ho[t]}' instead`), i[t];
    }
  });
  var zo = ((i) => (i.NEAREST = "nearest", i.LINEAR = "linear", i))(zo || {});
  const hR = new Proxy(zo, {
    get(i, t) {
      return lt(dt, `DRAW_MODES.${t} is deprecated, use '${zo[t]}' instead`), i[t];
    }
  });
  j0 = class {
    constructor(t, e) {
      this.state = Le.for2d(), this._graphicsBatchesHash = /* @__PURE__ */ Object.create(null), this.renderer = t, this._adaptor = e, this._adaptor.init();
    }
    validateRenderable(t) {
      const e = t.context, r = !!this._graphicsBatchesHash[t.uid], n = this.renderer.graphicsContext.updateGpuContext(e);
      return !!(n.isBatchable || r !== n.isBatchable);
    }
    addRenderable(t, e) {
      const r = this.renderer.graphicsContext.updateGpuContext(t.context);
      t._didGraphicsUpdate && (t._didGraphicsUpdate = false, this._rebuild(t)), r.isBatchable ? this._addToBatcher(t) : (this.renderer.renderPipes.batch.break(e), e.add(t));
    }
    updateRenderable(t) {
      const e = this._graphicsBatchesHash[t.uid];
      if (e) for (let r = 0; r < e.length; r++) {
        const n = e[r];
        n.batcher.updateElement(n);
      }
    }
    destroyRenderable(t) {
      this._graphicsBatchesHash[t.uid] && this._removeBatchForRenderable(t.uid);
    }
    execute(t) {
      if (!t.isRenderable) return;
      const e = this.renderer, r = t.context;
      if (!e.graphicsContext.getGpuContext(r).batches.length) return;
      const s = r.customShader || this._adaptor.shader;
      this.state.blendMode = t.groupBlendMode;
      const o = s.resources.localUniforms.uniforms;
      o.uTransformMatrix = t.groupTransform, o.uRound = e._roundPixels | t._roundPixels, ns(t.groupColorAlpha, o.uColor, 0), this._adaptor.execute(this, t);
    }
    _rebuild(t) {
      const e = !!this._graphicsBatchesHash[t.uid], r = this.renderer.graphicsContext.updateGpuContext(t.context);
      e && this._removeBatchForRenderable(t.uid), r.isBatchable && this._initBatchesForRenderable(t), t.batched = r.isBatchable;
    }
    _addToBatcher(t) {
      const e = this.renderer.renderPipes.batch, r = this._getBatchesForRenderable(t);
      for (let n = 0; n < r.length; n++) {
        const s = r[n];
        e.addToBatch(s);
      }
    }
    _getBatchesForRenderable(t) {
      return this._graphicsBatchesHash[t.uid] || this._initBatchesForRenderable(t);
    }
    _initBatchesForRenderable(t) {
      const e = t.context, r = this.renderer.graphicsContext.getGpuContext(e), n = this.renderer._roundPixels | t._roundPixels, s = r.batches.map((o) => {
        const a = vt.get(aa);
        return o.copyTo(a), a.renderable = t, a.roundPixels = n, a;
      });
      return this._graphicsBatchesHash[t.uid] === void 0 && t.on("destroyed", () => {
        this.destroyRenderable(t);
      }), this._graphicsBatchesHash[t.uid] = s, s;
    }
    _removeBatchForRenderable(t) {
      this._graphicsBatchesHash[t].forEach((e) => {
        vt.return(e);
      }), this._graphicsBatchesHash[t] = null;
    }
    destroy() {
      this.renderer = null, this._adaptor.destroy(), this._adaptor = null, this.state = null;
      for (const t in this._graphicsBatchesHash) this._removeBatchForRenderable(t);
      this._graphicsBatchesHash = null;
    }
  };
  j0.extension = {
    type: [
      P.WebGLPipes,
      P.WebGPUPipes,
      P.CanvasPipes
    ],
    name: "graphics"
  };
  const Lf = class Hf extends Fi {
    constructor(...t) {
      super({});
      let e = t[0] ?? {};
      typeof e == "number" && (lt(dt, "PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead"), e = {
        width: e,
        height: t[1],
        verticesX: t[2],
        verticesY: t[3]
      }), this.build(e);
    }
    build(t) {
      t = {
        ...Hf.defaultOptions,
        ...t
      }, this.verticesX = this.verticesX ?? t.verticesX, this.verticesY = this.verticesY ?? t.verticesY, this.width = this.width ?? t.width, this.height = this.height ?? t.height;
      const e = this.verticesX * this.verticesY, r = [], n = [], s = [], o = this.verticesX - 1, a = this.verticesY - 1, c = this.width / o, u = this.height / a;
      for (let h = 0; h < e; h++) {
        const f = h % this.verticesX, p = h / this.verticesX | 0;
        r.push(f * c, p * u), n.push(f / o, p / a);
      }
      const l = o * a;
      for (let h = 0; h < l; h++) {
        const f = h % o, p = h / o | 0, m = p * this.verticesX + f, y = p * this.verticesX + f + 1, b = (p + 1) * this.verticesX + f, v = (p + 1) * this.verticesX + f + 1;
        s.push(m, y, b, y, v, b);
      }
      this.buffers[0].data = new Float32Array(r), this.buffers[1].data = new Float32Array(n), this.indexBuffer.data = new Uint32Array(s), this.buffers[0].update(), this.buffers[1].update(), this.indexBuffer.update();
    }
  };
  Lf.defaultOptions = {
    width: 100,
    height: 100,
    verticesX: 10,
    verticesY: 10
  };
  let W0 = Lf;
  const zf = class jf extends Fi {
    constructor(t) {
      const { width: e, points: r, textureScale: n } = {
        ...jf.defaultOptions,
        ...t
      };
      super({
        positions: new Float32Array(r.length * 4),
        uvs: new Float32Array(r.length * 4),
        indices: new Uint32Array((r.length - 1) * 6)
      }), this.points = r, this._width = e, this.textureScale = n, this._build();
    }
    get width() {
      return this._width;
    }
    _build() {
      const t = this.points;
      if (!t) return;
      const e = this.getBuffer("aPosition"), r = this.getBuffer("aUV"), n = this.getIndex();
      if (t.length < 1) return;
      e.data.length / 4 !== t.length && (e.data = new Float32Array(t.length * 4), r.data = new Float32Array(t.length * 4), n.data = new Uint16Array((t.length - 1) * 6));
      const s = r.data, o = n.data;
      s[0] = 0, s[1] = 0, s[2] = 0, s[3] = 1;
      let a = 0, c = t[0];
      const u = this._width * this.textureScale, l = t.length;
      for (let f = 0; f < l; f++) {
        const p = f * 4;
        if (this.textureScale > 0) {
          const m = c.x - t[f].x, y = c.y - t[f].y, b = Math.sqrt(m * m + y * y);
          c = t[f], a += b / u;
        } else a = f / (l - 1);
        s[p] = a, s[p + 1] = 0, s[p + 2] = a, s[p + 3] = 1;
      }
      let h = 0;
      for (let f = 0; f < l - 1; f++) {
        const p = f * 2;
        o[h++] = p, o[h++] = p + 1, o[h++] = p + 2, o[h++] = p + 2, o[h++] = p + 1, o[h++] = p + 3;
      }
      r.update(), n.update(), this.updateVertices();
    }
    updateVertices() {
      const t = this.points;
      if (t.length < 1) return;
      let e = t[0], r, n = 0, s = 0;
      const o = this.buffers[0].data, a = t.length, c = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;
      for (let u = 0; u < a; u++) {
        const l = t[u], h = u * 4;
        u < t.length - 1 ? r = t[u + 1] : r = l, s = -(r.x - e.x), n = r.y - e.y;
        let f = (1 - u / (a - 1)) * 10;
        f > 1 && (f = 1);
        const p = Math.sqrt(n * n + s * s);
        p < 1e-6 ? (n = 0, s = 0) : (n /= p, s /= p, n *= c, s *= c), o[h] = l.x + n, o[h + 1] = l.y + s, o[h + 2] = l.x - n, o[h + 3] = l.y - s, e = l;
      }
      this.buffers[0].update();
    }
    update() {
      this.textureScale > 0 ? this._build() : this.updateVertices();
    }
  };
  zf.defaultOptions = {
    width: 200,
    points: [],
    textureScale: 0
  };
  let V0 = zf;
  const X0 = class Wf extends cd {
    constructor(t) {
      const { texture: e, points: r, textureScale: n, ...s } = {
        ...Wf.defaultOptions,
        ...t
      }, o = new V0(mo({
        width: e.height,
        points: r,
        textureScale: n
      }));
      n > 0 && (e.source.style.addressMode = "repeat"), super(mo({
        ...s,
        texture: e,
        geometry: o
      })), this.autoUpdate = true, this.onRender = this._render;
    }
    _render() {
      const t = this.geometry;
      (this.autoUpdate || t._width !== this.texture.height) && (t._width = this.texture.height, t.update());
    }
  };
  X0.defaultOptions = {
    textureScale: 0
  };
  class Ia {
    constructor() {
      this.batcher = null, this.batch = null, this.roundPixels = 0, this._uvUpdateId = -1, this._textureMatrixUpdateId = -1;
    }
    get blendMode() {
      return this.mesh.groupBlendMode;
    }
    reset() {
      this.mesh = null, this.texture = null, this.batcher = null, this.batch = null;
    }
    packIndex(t, e, r) {
      const n = this.geometry.indices;
      for (let s = 0; s < n.length; s++) t[e++] = n[s] + r;
    }
    packAttributes(t, e, r, n) {
      const s = this.mesh, o = this.geometry, a = s.groupTransform, c = n << 16 | this.roundPixels & 65535, u = a.a, l = a.b, h = a.c, f = a.d, p = a.tx, m = a.ty, y = o.positions, b = o.getBuffer("aUV"), v = b.data;
      let A = v;
      const T = this.texture.textureMatrix;
      T.isSimple || (A = this._transformedUvs, (this._textureMatrixUpdateId !== T._updateID || this._uvUpdateId !== b._updateID) && ((!A || A.length < v.length) && (A = this._transformedUvs = new Float32Array(v.length)), this._textureMatrixUpdateId = T._updateID, this._uvUpdateId = b._updateID, T.multiplyUvs(v, A)));
      const G = s.groupColorAlpha;
      for (let H = 0; H < y.length; H += 2) {
        const Y = y[H], L = y[H + 1];
        t[r] = u * Y + h * L + p, t[r + 1] = l * Y + f * L + m, t[r + 2] = A[H], t[r + 3] = A[H + 1], e[r + 4] = G, e[r + 5] = c, r += 6;
      }
    }
    get vertexSize() {
      return this.geometry.positions.length / 2;
    }
    get indexSize() {
      return this.geometry.indices.length;
    }
  }
  q0 = class {
    constructor(t, e) {
      this.localUniforms = new Qt({
        uTransformMatrix: {
          value: new nt(),
          type: "mat3x3<f32>"
        },
        uColor: {
          value: new Float32Array([
            1,
            1,
            1,
            1
          ]),
          type: "vec4<f32>"
        },
        uRound: {
          value: 0,
          type: "f32"
        }
      }), this.localUniformsBindGroup = new Ze({
        0: this.localUniforms
      }), this._meshDataHash = /* @__PURE__ */ Object.create(null), this._gpuBatchableMeshHash = /* @__PURE__ */ Object.create(null), this.renderer = t, this._adaptor = e, this._adaptor.init();
    }
    validateRenderable(t) {
      const e = this._getMeshData(t), r = e.batched, n = t.batched;
      if (e.batched = n, r !== n) return true;
      if (n) {
        const s = t._geometry;
        if (s.indices.length !== e.indexSize || s.positions.length !== e.vertexSize) return e.indexSize = s.indices.length, e.vertexSize = s.positions.length, true;
        const o = this._getBatchableMesh(t), a = t.texture;
        if (o.texture._source !== a._source && o.texture._source !== a._source) return !o.batcher.checkAndUpdateTexture(o, a);
      }
      return false;
    }
    addRenderable(t, e) {
      const r = this.renderer.renderPipes.batch, { batched: n } = this._getMeshData(t);
      if (n) {
        const s = this._getBatchableMesh(t);
        s.texture = t._texture, s.geometry = t._geometry, r.addToBatch(s);
      } else r.break(e), e.add(t);
    }
    updateRenderable(t) {
      if (t.batched) {
        const e = this._gpuBatchableMeshHash[t.uid];
        e.texture = t._texture, e.geometry = t._geometry, e.batcher.updateElement(e);
      }
    }
    destroyRenderable(t) {
      this._meshDataHash[t.uid] = null;
      const e = this._gpuBatchableMeshHash[t.uid];
      e && (vt.return(e), this._gpuBatchableMeshHash[t.uid] = null);
    }
    execute(t) {
      if (!t.isRenderable) return;
      t.state.blendMode = Dn(t.groupBlendMode, t.texture._source);
      const e = this.localUniforms;
      e.uniforms.uTransformMatrix = t.groupTransform, e.uniforms.uRound = this.renderer._roundPixels | t._roundPixels, e.update(), ns(t.groupColorAlpha, e.uniforms.uColor, 0), this._adaptor.execute(this, t);
    }
    _getMeshData(t) {
      return this._meshDataHash[t.uid] || this._initMeshData(t);
    }
    _initMeshData(t) {
      var _a2, _b2;
      return this._meshDataHash[t.uid] = {
        batched: t.batched,
        indexSize: (_a2 = t._geometry.indices) == null ? void 0 : _a2.length,
        vertexSize: (_b2 = t._geometry.positions) == null ? void 0 : _b2.length
      }, t.on("destroyed", () => {
        this.destroyRenderable(t);
      }), this._meshDataHash[t.uid];
    }
    _getBatchableMesh(t) {
      return this._gpuBatchableMeshHash[t.uid] || this._initBatchableMesh(t);
    }
    _initBatchableMesh(t) {
      const e = vt.get(Ia);
      return e.mesh = t, e.texture = t._texture, e.roundPixels = this.renderer._roundPixels | t._roundPixels, this._gpuBatchableMeshHash[t.uid] = e, e.mesh = t, e;
    }
    destroy() {
      for (const t in this._gpuBatchableMeshHash) this._gpuBatchableMeshHash[t] && vt.return(this._gpuBatchableMeshHash[t]);
      this._gpuBatchableMeshHash = null, this._meshDataHash = null, this.localUniforms = null, this.localUniformsBindGroup = null, this._adaptor.destroy(), this._adaptor = null, this.renderer = null;
    }
  };
  q0.extension = {
    type: [
      P.WebGLPipes,
      P.WebGPUPipes,
      P.CanvasPipes
    ],
    name: "mesh"
  };
  const Vf = class Xf extends W0 {
    constructor(t = {}) {
      t = {
        ...Xf.defaultOptions,
        ...t
      }, super({
        width: t.width,
        height: t.height,
        verticesX: 4,
        verticesY: 4
      }), this.update(t);
    }
    update(t) {
      this.width = t.width ?? this.width, this.height = t.height ?? this.height, this._originalWidth = t.originalWidth ?? this._originalWidth, this._originalHeight = t.originalHeight ?? this._originalHeight, this._leftWidth = t.leftWidth ?? this._leftWidth, this._rightWidth = t.rightWidth ?? this._rightWidth, this._topHeight = t.topHeight ?? this._topHeight, this._bottomHeight = t.bottomHeight ?? this._bottomHeight, this.updateUvs(), this.updatePositions();
    }
    updatePositions() {
      const t = this.positions, e = this._leftWidth + this._rightWidth, r = this.width > e ? 1 : this.width / e, n = this._topHeight + this._bottomHeight, s = this.height > n ? 1 : this.height / n, o = Math.min(r, s);
      t[9] = t[11] = t[13] = t[15] = this._topHeight * o, t[17] = t[19] = t[21] = t[23] = this.height - this._bottomHeight * o, t[25] = t[27] = t[29] = t[31] = this.height, t[2] = t[10] = t[18] = t[26] = this._leftWidth * o, t[4] = t[12] = t[20] = t[28] = this.width - this._rightWidth * o, t[6] = t[14] = t[22] = t[30] = this.width, this.getBuffer("aPosition").update();
    }
    updateUvs() {
      const t = this.uvs;
      t[0] = t[8] = t[16] = t[24] = 0, t[1] = t[3] = t[5] = t[7] = 0, t[6] = t[14] = t[22] = t[30] = 1, t[25] = t[27] = t[29] = t[31] = 1;
      const e = 1 / this._originalWidth, r = 1 / this._originalHeight;
      t[2] = t[10] = t[18] = t[26] = e * this._leftWidth, t[9] = t[11] = t[13] = t[15] = r * this._topHeight, t[4] = t[12] = t[20] = t[28] = 1 - e * this._rightWidth, t[17] = t[19] = t[21] = t[23] = 1 - r * this._bottomHeight, this.getBuffer("aUV").update();
    }
  };
  Vf.defaultOptions = {
    width: 100,
    height: 100,
    leftWidth: 10,
    topHeight: 10,
    rightWidth: 10,
    bottomHeight: 10,
    originalWidth: 100,
    originalHeight: 100
  };
  let Cr = Vf;
  const $0 = class qf extends Dt {
    constructor(t) {
      var _a2, _b2, _c2, _d2;
      t instanceof J && (t = {
        texture: t
      });
      const { width: e, height: r, leftWidth: n, rightWidth: s, topHeight: o, bottomHeight: a, texture: c, roundPixels: u, ...l } = t;
      super({
        label: "NineSliceSprite",
        ...l
      }), this._roundPixels = 0, this.renderPipeId = "nineSliceSprite", this.batched = true, this._didSpriteUpdate = true, this.bounds = {
        minX: 0,
        minY: 0,
        maxX: 0,
        maxY: 0
      }, this._leftWidth = n ?? ((_a2 = c == null ? void 0 : c.defaultBorders) == null ? void 0 : _a2.left) ?? Cr.defaultOptions.leftWidth, this._topHeight = o ?? ((_b2 = c == null ? void 0 : c.defaultBorders) == null ? void 0 : _b2.top) ?? Cr.defaultOptions.topHeight, this._rightWidth = s ?? ((_c2 = c == null ? void 0 : c.defaultBorders) == null ? void 0 : _c2.right) ?? Cr.defaultOptions.rightWidth, this._bottomHeight = a ?? ((_d2 = c == null ? void 0 : c.defaultBorders) == null ? void 0 : _d2.bottom) ?? Cr.defaultOptions.bottomHeight, this.bounds.maxX = this._width = e ?? c.width ?? Cr.defaultOptions.width, this.bounds.maxY = this._height = r ?? c.height ?? Cr.defaultOptions.height, this.allowChildren = false, this.texture = c ?? qf.defaultOptions.texture, this.roundPixels = u ?? false;
    }
    get width() {
      return this._width;
    }
    set width(t) {
      this.bounds.maxX = this._width = t, this.onViewUpdate();
    }
    get height() {
      return this._height;
    }
    set height(t) {
      this.bounds.maxY = this._height = t, this.onViewUpdate();
    }
    get leftWidth() {
      return this._leftWidth;
    }
    set leftWidth(t) {
      this._leftWidth = t, this.onViewUpdate();
    }
    get topHeight() {
      return this._topHeight;
    }
    set topHeight(t) {
      this._topHeight = t, this.onViewUpdate();
    }
    get rightWidth() {
      return this._rightWidth;
    }
    set rightWidth(t) {
      this._rightWidth = t, this.onViewUpdate();
    }
    get bottomHeight() {
      return this._bottomHeight;
    }
    set bottomHeight(t) {
      this._bottomHeight = t, this.onViewUpdate();
    }
    get texture() {
      return this._texture;
    }
    set texture(t) {
      t || (t = J.EMPTY);
      const e = this._texture;
      e !== t && (e && e.dynamic && e.off("update", this.onViewUpdate, this), t.dynamic && t.on("update", this.onViewUpdate, this), this._texture = t, this.onViewUpdate());
    }
    get roundPixels() {
      return !!this._roundPixels;
    }
    set roundPixels(t) {
      this._roundPixels = t ? 1 : 0;
    }
    get originalWidth() {
      return this._texture.width;
    }
    get originalHeight() {
      return this._texture.height;
    }
    onViewUpdate() {
      if (this._didChangeId += 4096, this._didSpriteUpdate = true, this.didViewUpdate) return;
      this.didViewUpdate = true;
      const t = this.renderGroup || this.parentRenderGroup;
      t && t.onChildViewUpdate(this);
    }
    addBounds(t) {
      const e = this.bounds;
      t.addFrame(e.minX, e.minY, e.maxX, e.maxY);
    }
    containsPoint(t) {
      const e = this.bounds;
      return t.x >= e.minX && t.x <= e.maxX && t.y >= e.minY && t.y <= e.maxY;
    }
    destroy(t) {
      if (super.destroy(t), typeof t == "boolean" ? t : t == null ? void 0 : t.texture) {
        const r = typeof t == "boolean" ? t : t == null ? void 0 : t.textureSource;
        this._texture.destroy(r);
      }
      this._texture = null, this.bounds = null;
    }
  };
  $0.defaultOptions = {
    texture: J.EMPTY
  };
  Y0 = class {
    constructor(t) {
      this._gpuSpriteHash = /* @__PURE__ */ Object.create(null), this._renderer = t;
    }
    addRenderable(t, e) {
      const r = this._getGpuSprite(t);
      t._didSpriteUpdate && this._updateBatchableSprite(t, r), this._renderer.renderPipes.batch.addToBatch(r);
    }
    updateRenderable(t) {
      const e = this._gpuSpriteHash[t.uid];
      t._didSpriteUpdate && this._updateBatchableSprite(t, e), e.batcher.updateElement(e);
    }
    validateRenderable(t) {
      const e = t._texture, r = this._getGpuSprite(t);
      return r.texture._source !== e._source ? !r.batcher.checkAndUpdateTexture(r, e) : false;
    }
    destroyRenderable(t) {
      const e = this._gpuSpriteHash[t.uid];
      vt.return(e), this._gpuSpriteHash[t.uid] = null;
    }
    _updateBatchableSprite(t, e) {
      t._didSpriteUpdate = false, e.geometry.update(t), e.texture = t._texture;
    }
    _getGpuSprite(t) {
      return this._gpuSpriteHash[t.uid] || this._initGPUSprite(t);
    }
    _initGPUSprite(t) {
      const e = new Ia();
      return e.geometry = new Cr(), e.mesh = t, e.texture = t._texture, e.roundPixels = this._renderer._roundPixels | t._roundPixels, this._gpuSpriteHash[t.uid] = e, t.on("destroyed", () => {
        this.destroyRenderable(t);
      }), e;
    }
    destroy() {
      for (const t in this._gpuSpriteHash) this._gpuSpriteHash[t].geometry.destroy();
      this._gpuSpriteHash = null, this._renderer = null;
    }
  };
  Y0.extension = {
    type: [
      P.WebGLPipes,
      P.WebGPUPipes,
      P.CanvasPipes
    ],
    name: "nineSliceSprite"
  };
  const K0 = {
    name: "tiling-bit",
    vertex: {
      header: `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `,
      main: `
            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;

            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;
        `
    },
    fragment: {
      header: `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `,
      main: `

            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);
            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;
            var unclamped = coord;
            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);

            var bias = 0.;

            if(unclamped.x == coord.x && unclamped.y == coord.y)
            {
                bias = -32.;
            } 

            outColor = textureSampleBias(uTexture, uSampler, coord, bias);
        `
    }
  }, Z0 = {
    name: "tiling-bit",
    vertex: {
      header: `
            uniform mat3 uTextureTransform;
            uniform vec4 uSizeAnchor;
        
        `,
      main: `
            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;

            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;
        `
    },
    fragment: {
      header: `
            uniform sampler2D uTexture;
            uniform mat3 uMapCoord;
            uniform vec4 uClampFrame;
            uniform vec2 uClampOffset;
        `,
      main: `

        vec2 coord = vUV + ceil(uClampOffset - vUV);
        coord = (uMapCoord * vec3(coord, 1.0)).xy;
        vec2 unclamped = coord;
        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);
        
        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0
    
        `
    }
  };
  let lo, ho;
  class J0 extends Se {
    constructor() {
      lo ?? (lo = Ui({
        name: "tiling-sprite-shader",
        bits: [
          Si,
          K0,
          Gi
        ]
      })), ho ?? (ho = ki({
        name: "tiling-sprite-shader",
        bits: [
          xa,
          Z0,
          Oi
        ]
      }));
      const t = new Qt({
        uMapCoord: {
          value: new nt(),
          type: "mat3x3<f32>"
        },
        uClampFrame: {
          value: new Float32Array([
            0,
            0,
            1,
            1
          ]),
          type: "vec4<f32>"
        },
        uClampOffset: {
          value: new Float32Array([
            0,
            0
          ]),
          type: "vec2<f32>"
        },
        uTextureTransform: {
          value: new nt(),
          type: "mat3x3<f32>"
        },
        uSizeAnchor: {
          value: new Float32Array([
            100,
            100,
            0.5,
            0.5
          ]),
          type: "vec4<f32>"
        }
      });
      super({
        glProgram: ho,
        gpuProgram: lo,
        resources: {
          localUniforms: new Qt({
            uTransformMatrix: {
              value: new nt(),
              type: "mat3x3<f32>"
            },
            uColor: {
              value: new Float32Array([
                1,
                1,
                1,
                1
              ]),
              type: "vec4<f32>"
            },
            uRound: {
              value: 0,
              type: "f32"
            }
          }),
          tilingUniforms: t,
          uTexture: J.EMPTY.source,
          uSampler: J.EMPTY.source.style
        }
      });
    }
    updateUniforms(t, e, r, n, s, o) {
      const a = this.resources.tilingUniforms, c = o.width, u = o.height, l = o.textureMatrix, h = a.uniforms.uTextureTransform;
      h.set(r.a * c / t, r.b * c / e, r.c * u / t, r.d * u / e, r.tx / t, r.ty / e), h.invert(), a.uniforms.uMapCoord = l.mapCoord, a.uniforms.uClampFrame = l.uClampFrame, a.uniforms.uClampOffset = l.uClampOffset, a.uniforms.uTextureTransform = h, a.uniforms.uSizeAnchor[0] = t, a.uniforms.uSizeAnchor[1] = e, a.uniforms.uSizeAnchor[2] = n, a.uniforms.uSizeAnchor[3] = s, o && (this.resources.uTexture = o.source, this.resources.uSampler = o.source.style);
    }
  }
  class Q0 extends Fi {
    constructor() {
      super({
        positions: new Float32Array([
          0,
          0,
          1,
          0,
          1,
          1,
          0,
          1
        ]),
        uvs: new Float32Array([
          0,
          0,
          1,
          0,
          1,
          1,
          0,
          1
        ]),
        indices: new Uint32Array([
          0,
          1,
          2,
          0,
          2,
          3
        ])
      });
    }
  }
  function tx(i, t) {
    const e = i.anchor.x, r = i.anchor.y;
    t[0] = -e * i.width, t[1] = -r * i.height, t[2] = (1 - e) * i.width, t[3] = -r * i.height, t[4] = (1 - e) * i.width, t[5] = (1 - r) * i.height, t[6] = -e * i.width, t[7] = (1 - r) * i.height;
  }
  function ex(i, t, e, r) {
    let n = 0;
    const s = i.length / (t || 2), o = r.a, a = r.b, c = r.c, u = r.d, l = r.tx, h = r.ty;
    for (e *= t; n < s; ) {
      const f = i[e], p = i[e + 1];
      i[e] = o * f + c * p + l, i[e + 1] = a * f + u * p + h, e += t, n++;
    }
  }
  function rx(i, t) {
    const e = i.texture, r = e.frame.width, n = e.frame.height;
    let s = 0, o = 0;
    i._applyAnchorToTexture && (s = i.anchor.x, o = i.anchor.y), t[0] = t[6] = -s, t[2] = t[4] = 1 - s, t[1] = t[3] = -o, t[5] = t[7] = 1 - o;
    const a = nt.shared;
    a.copyFrom(i._tileTransform.matrix), a.tx /= i.width, a.ty /= i.height, a.invert(), a.scale(i.width / r, i.height / n), ex(t, 2, 0, a);
  }
  const pn = new Q0();
  ix = class {
    constructor(t) {
      this._state = Le.default2d, this._tilingSpriteDataHash = /* @__PURE__ */ Object.create(null), this._renderer = t;
    }
    validateRenderable(t) {
      const e = this._getTilingSpriteData(t), r = e.canBatch;
      this._updateCanBatch(t);
      const n = e.canBatch;
      if (n && n === r) {
        const { batchableMesh: s } = e;
        if (s && s.texture._source !== t.texture._source) return !s.batcher.checkAndUpdateTexture(s, t.texture);
      }
      return r !== n;
    }
    addRenderable(t, e) {
      const r = this._renderer.renderPipes.batch;
      this._updateCanBatch(t);
      const n = this._getTilingSpriteData(t), { geometry: s, canBatch: o } = n;
      if (o) {
        n.batchableMesh || (n.batchableMesh = new Ia());
        const a = n.batchableMesh;
        t._didTilingSpriteUpdate && (t._didTilingSpriteUpdate = false, this._updateBatchableMesh(t), a.geometry = s, a.mesh = t, a.texture = t._texture), a.roundPixels = this._renderer._roundPixels | t._roundPixels, r.addToBatch(a);
      } else r.break(e), n.shader || (n.shader = new J0()), this.updateRenderable(t), e.add(t);
    }
    execute(t) {
      const { shader: e } = this._tilingSpriteDataHash[t.uid];
      e.groups[0] = this._renderer.globalUniforms.bindGroup;
      const r = e.resources.localUniforms.uniforms;
      r.uTransformMatrix = t.groupTransform, r.uRound = this._renderer._roundPixels | t._roundPixels, ns(t.groupColorAlpha, r.uColor, 0), this._state.blendMode = Dn(t.groupBlendMode, t.texture._source), this._renderer.encoder.draw({
        geometry: pn,
        shader: e,
        state: this._state
      });
    }
    updateRenderable(t) {
      const e = this._getTilingSpriteData(t), { canBatch: r } = e;
      if (r) {
        const { batchableMesh: n } = e;
        t._didTilingSpriteUpdate && this._updateBatchableMesh(t), n.batcher.updateElement(n);
      } else if (t._didTilingSpriteUpdate) {
        const { shader: n } = e;
        n.updateUniforms(t.width, t.height, t._tileTransform.matrix, t.anchor.x, t.anchor.y, t.texture);
      }
      t._didTilingSpriteUpdate = false;
    }
    destroyRenderable(t) {
      var _a2;
      const e = this._getTilingSpriteData(t);
      e.batchableMesh = null, (_a2 = e.shader) == null ? void 0 : _a2.destroy(), this._tilingSpriteDataHash[t.uid] = null;
    }
    _getTilingSpriteData(t) {
      return this._tilingSpriteDataHash[t.uid] || this._initTilingSpriteData(t);
    }
    _initTilingSpriteData(t) {
      const e = new Fi({
        indices: pn.indices,
        positions: pn.positions.slice(),
        uvs: pn.uvs.slice()
      });
      return this._tilingSpriteDataHash[t.uid] = {
        canBatch: true,
        renderable: t,
        geometry: e
      }, t.on("destroyed", () => {
        this.destroyRenderable(t);
      }), this._tilingSpriteDataHash[t.uid];
    }
    _updateBatchableMesh(t) {
      const e = this._getTilingSpriteData(t), { geometry: r } = e, n = t.texture.source.style;
      n.addressMode !== "repeat" && (n.addressMode = "repeat", n.update()), rx(t, r.uvs), tx(t, r.positions);
    }
    destroy() {
      for (const t in this._tilingSpriteDataHash) this.destroyRenderable(this._tilingSpriteDataHash[t].renderable);
      this._tilingSpriteDataHash = null, this._renderer = null;
    }
    _updateCanBatch(t) {
      const e = this._getTilingSpriteData(t), r = t.texture;
      let n = true;
      return this._renderer.type === ge.WEBGL && (n = this._renderer.context.supports.nonPowOf2wrapping), e.canBatch = r.textureMatrix.isSimple && (n || r.source.isPowerOfTwo), e.canBatch;
    }
  };
  ix.extension = {
    type: [
      P.WebGLPipes,
      P.WebGPUPipes,
      P.CanvasPipes
    ],
    name: "tilingSprite"
  };
  const nx = {
    name: "local-uniform-msdf-bit",
    vertex: {
      header: `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32,
                uRound:f32,
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `,
      main: `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `,
      end: `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `
    },
    fragment: {
      header: `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
         `,
      main: ` 
            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));
        `
    }
  }, sx = {
    name: "local-uniform-msdf-bit",
    vertex: {
      header: `
            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `,
      main: `
            vColor *= uColor;
            modelMatrix *= uTransformMatrix;
        `,
      end: `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `
    },
    fragment: {
      header: `
            uniform float uDistance;
         `,
      main: ` 
            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));
        `
    }
  }, ox = {
    name: "msdf-bit",
    fragment: {
      header: `
            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {
                
                // MSDF
                var median = msdfColor.r + msdfColor.g + msdfColor.b -
                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));
            
                // SDF
                median = min(median, msdfColor.a);

                var screenPxDistance = distance * (median - 0.5);
                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));
                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);
                var coverage: f32 = pow(shapeColor.a * alpha, gamma);

                return coverage;
             
            }
        `
    }
  }, ax = {
    name: "msdf-bit",
    fragment: {
      header: `
            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {
                
                // MSDF
                float median = msdfColor.r + msdfColor.g + msdfColor.b -
                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));
               
                // SDF
                median = min(median, msdfColor.a);
            
                float screenPxDistance = distance * (median - 0.5);
                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
           
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));
                float gamma = mix(1.0, 1.0 / 2.2, luma);
                float coverage = pow(shapeColor.a * alpha, gamma);  
              
                return coverage;
            }
        `
    }
  };
  let fo, po;
  class cx extends Se {
    constructor() {
      const t = new Qt({
        uColor: {
          value: new Float32Array([
            1,
            1,
            1,
            1
          ]),
          type: "vec4<f32>"
        },
        uTransformMatrix: {
          value: new nt(),
          type: "mat3x3<f32>"
        },
        uDistance: {
          value: 4,
          type: "f32"
        },
        uRound: {
          value: 0,
          type: "f32"
        }
      }), e = Ir();
      fo ?? (fo = Ui({
        name: "sdf-shader",
        bits: [
          ga,
          ba(e),
          nx,
          ox,
          Gi
        ]
      })), po ?? (po = ki({
        name: "sdf-shader",
        bits: [
          ma,
          wa(e),
          sx,
          ax,
          Oi
        ]
      })), super({
        glProgram: po,
        gpuProgram: fo,
        resources: {
          localUniforms: t,
          batchSamplers: ya(e)
        }
      });
    }
  }
  ux = class {
    constructor(t) {
      this._gpuBitmapText = {}, this._renderer = t;
    }
    validateRenderable(t) {
      const e = this._getGpuBitmapText(t);
      return t._didTextUpdate && (t._didTextUpdate = false, this._updateContext(t, e)), this._renderer.renderPipes.graphics.validateRenderable(e);
    }
    addRenderable(t, e) {
      const r = this._getGpuBitmapText(t);
      zu(t, r), t._didTextUpdate && (t._didTextUpdate = false, this._updateContext(t, r)), this._renderer.renderPipes.graphics.addRenderable(r, e), r.context.customShader && this._updateDistanceField(t);
    }
    destroyRenderable(t) {
      this._destroyRenderableByUid(t.uid);
    }
    _destroyRenderableByUid(t) {
      const e = this._gpuBitmapText[t].context;
      e.customShader && (vt.return(e.customShader), e.customShader = null), vt.return(this._gpuBitmapText[t]), this._gpuBitmapText[t] = null;
    }
    updateRenderable(t) {
      const e = this._getGpuBitmapText(t);
      zu(t, e), this._renderer.renderPipes.graphics.updateRenderable(e), e.context.customShader && this._updateDistanceField(t);
    }
    _updateContext(t, e) {
      const { context: r } = e, n = kn.getFont(t.text, t._style);
      r.clear(), n.distanceField.type !== "none" && (r.customShader || (r.customShader = vt.get(cx)));
      const s = Array.from(t.text), o = t._style;
      let a = n.baseLineOffset;
      const c = kh(s, o, n);
      let u = 0;
      const l = o.padding, h = c.scale;
      let f = c.width, p = c.height + c.offsetY;
      o._stroke && (f += o._stroke.width / h, p += o._stroke.width / h), r.translate(-t._anchor._x * f - l, -t._anchor._y * p - l).scale(h, h);
      const m = n.applyFillAsTint ? o._fill.color : 16777215;
      for (let y = 0; y < c.lines.length; y++) {
        const b = c.lines[y];
        for (let v = 0; v < b.charPositions.length; v++) {
          const A = s[u++], T = n.chars[A];
          (T == null ? void 0 : T.texture) && r.texture(T.texture, m || "black", Math.round(b.charPositions[v] + T.xOffset), Math.round(a + T.yOffset));
        }
        a += n.lineHeight;
      }
    }
    _getGpuBitmapText(t) {
      return this._gpuBitmapText[t.uid] || this.initGpuText(t);
    }
    initGpuText(t) {
      const e = vt.get($e);
      return this._gpuBitmapText[t.uid] = e, this._updateContext(t, e), t.on("destroyed", () => {
        this.destroyRenderable(t);
      }), this._gpuBitmapText[t.uid];
    }
    _updateDistanceField(t) {
      const e = this._getGpuBitmapText(t).context, r = t._style.fontFamily, n = Tt.get(`${r}-bitmap`), { a: s, b: o, c: a, d: c } = t.groupTransform, u = Math.sqrt(s * s + o * o), l = Math.sqrt(a * a + c * c), h = (Math.abs(u) + Math.abs(l)) / 2, f = n.baseRenderedFontSize / t._style.fontSize, p = h * n.distanceField.range * (1 / f);
      e.customShader.resources.localUniforms.uniforms.uDistance = p;
    }
    destroy() {
      for (const t in this._gpuBitmapText) this._destroyRenderableByUid(t);
      this._gpuBitmapText = null, this._renderer = null;
    }
  };
  ux.extension = {
    type: [
      P.WebGLPipes,
      P.WebGPUPipes,
      P.CanvasPipes
    ],
    name: "bitmapText"
  };
  function zu(i, t) {
    t.groupTransform = i.groupTransform, t.groupColorAlpha = i.groupColorAlpha, t.groupColor = i.groupColor, t.groupBlendMode = i.groupBlendMode, t.globalDisplayStatus = i.globalDisplayStatus, t.groupTransform = i.groupTransform, t.localDisplayStatus = i.localDisplayStatus, t.groupAlpha = i.groupAlpha, t._roundPixels = i._roundPixels;
  }
  lx = class {
    constructor(t) {
      this._gpuText = /* @__PURE__ */ Object.create(null), this._renderer = t, this._renderer.runners.resolutionChange.add(this);
    }
    resolutionChange() {
      for (const t in this._gpuText) {
        const r = this._gpuText[t].batchableSprite.renderable;
        r._autoResolution && (r._resolution = this._renderer.resolution, r.onViewUpdate());
      }
    }
    validateRenderable(t) {
      const e = this._getGpuText(t), r = t._getKey();
      return e.textureNeedsUploading ? (e.textureNeedsUploading = false, true) : e.currentKey !== r;
    }
    addRenderable(t, e) {
      const n = this._getGpuText(t).batchableSprite;
      t._didTextUpdate && this._updateText(t), this._renderer.renderPipes.batch.addToBatch(n);
    }
    updateRenderable(t) {
      const r = this._getGpuText(t).batchableSprite;
      t._didTextUpdate && this._updateText(t), r.batcher.updateElement(r);
    }
    destroyRenderable(t) {
      this._destroyRenderableById(t.uid);
    }
    _destroyRenderableById(t) {
      const e = this._gpuText[t];
      this._renderer.htmlText.decreaseReferenceCount(e.currentKey), vt.return(e.batchableSprite), this._gpuText[t] = null;
    }
    _updateText(t) {
      const e = t._getKey(), r = this._getGpuText(t), n = r.batchableSprite;
      r.currentKey !== e && this._updateGpuText(t).catch((o) => {
        console.error(o);
      }), t._didTextUpdate = false;
      const s = t._style.padding;
      Cn(n.bounds, t._anchor, n.texture, s);
    }
    async _updateGpuText(t) {
      t._didTextUpdate = false;
      const e = this._getGpuText(t);
      if (e.generatingTexture) return;
      const r = t._getKey();
      this._renderer.htmlText.decreaseReferenceCount(e.currentKey), e.generatingTexture = true, e.currentKey = r;
      const n = t.resolution ?? this._renderer.resolution, s = await this._renderer.htmlText.getManagedTexture(t.text, n, t._style, t._getKey()), o = e.batchableSprite;
      o.texture = e.texture = s, e.generatingTexture = false, e.textureNeedsUploading = true, t.onViewUpdate();
      const a = t._style.padding;
      Cn(o.bounds, t._anchor, o.texture, a);
    }
    _getGpuText(t) {
      return this._gpuText[t.uid] || this.initGpuText(t);
    }
    initGpuText(t) {
      const e = {
        texture: J.EMPTY,
        currentKey: "--",
        batchableSprite: vt.get(Ta),
        textureNeedsUploading: false,
        generatingTexture: false
      }, r = e.batchableSprite;
      return r.renderable = t, r.texture = J.EMPTY, r.bounds = {
        minX: 0,
        maxX: 1,
        minY: 0,
        maxY: 0
      }, r.roundPixels = this._renderer._roundPixels | t._roundPixels, t._resolution = t._autoResolution ? this._renderer.resolution : t.resolution, this._gpuText[t.uid] = e, t.on("destroyed", () => {
        this.destroyRenderable(t);
      }), e;
    }
    destroy() {
      for (const t in this._gpuText) this._destroyRenderableById(t);
      this._gpuText = null, this._renderer = null;
    }
  };
  lx.extension = {
    type: [
      P.WebGLPipes,
      P.WebGPUPipes,
      P.CanvasPipes
    ],
    name: "htmlText"
  };
  function hx() {
    const { userAgent: i } = St.get().getNavigator();
    return /^((?!chrome|android).)*safari/i.test(i);
  }
  const dx = new re();
  function $f(i, t, e, r) {
    const n = dx;
    n.minX = 0, n.minY = 0, n.maxX = i.width / r | 0, n.maxY = i.height / r | 0;
    const s = Jt.getOptimalTexture(n.width, n.height, r, false);
    return s.source.uploadMethodId = "image", s.source.resource = i, s.source.alphaMode = "premultiply-alpha-on-upload", s.frame.width = t / r, s.frame.height = e / r, s.source.emit("update", s.source), s.updateUvs(), s;
  }
  function fx(i, t) {
    const e = t.fontFamily, r = [], n = {}, s = /font-family:([^;"\s]+)/g, o = i.match(s);
    function a(c) {
      n[c] || (r.push(c), n[c] = true);
    }
    if (Array.isArray(e)) for (let c = 0; c < e.length; c++) a(e[c]);
    else a(e);
    o && o.forEach((c) => {
      const u = c.split(":")[1].trim();
      a(u);
    });
    for (const c in t.tagStyles) {
      const u = t.tagStyles[c].fontFamily;
      a(u);
    }
    return r;
  }
  async function px(i) {
    const e = await (await St.get().fetch(i)).blob(), r = new FileReader();
    return await new Promise((s, o) => {
      r.onloadend = () => s(r.result), r.onerror = o, r.readAsDataURL(e);
    });
  }
  async function ju(i, t) {
    const e = await px(t);
    return `@font-face {
        font-family: "${i.fontFamily}";
        src: url('${e}');
        font-weight: ${i.fontWeight};
        font-style: ${i.fontStyle};
    }`;
  }
  const _n = /* @__PURE__ */ new Map();
  async function _x(i, t, e) {
    const r = i.filter((n) => Tt.has(`${n}-and-url`)).map((n, s) => {
      if (!_n.has(n)) {
        const { url: o } = Tt.get(`${n}-and-url`);
        s === 0 ? _n.set(n, ju({
          fontWeight: t.fontWeight,
          fontStyle: t.fontStyle,
          fontFamily: n
        }, o)) : _n.set(n, ju({
          fontWeight: e.fontWeight,
          fontStyle: e.fontStyle,
          fontFamily: n
        }, o));
      }
      return _n.get(n);
    });
    return (await Promise.all(r)).join(`
`);
  }
  function gx(i, t, e, r, n) {
    const { domElement: s, styleElement: o, svgRoot: a } = n;
    s.innerHTML = `<style>${t.cssStyle}</style><div style='padding:0;'>${i}</div>`, s.setAttribute("style", `transform: scale(${e});transform-origin: top left; display: inline-block`), o.textContent = r;
    const { width: c, height: u } = n.image;
    return a.setAttribute("width", c.toString()), a.setAttribute("height", u.toString()), new XMLSerializer().serializeToString(a);
  }
  function mx(i, t) {
    const e = Je.getOptimalCanvasAndContext(i.width, i.height, t), { context: r } = e;
    return r.clearRect(0, 0, i.width, i.height), r.drawImage(i, 0, 0), Je.returnCanvasAndContext(e), e.canvas;
  }
  function bx(i, t, e) {
    return new Promise(async (r) => {
      e && await new Promise((n) => setTimeout(n, 100)), i.onload = () => {
        r();
      }, i.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(t)}`, i.crossOrigin = "anonymous";
    });
  }
  Yf = class {
    constructor(t) {
      this._activeTextures = {}, this._renderer = t, this._createCanvas = t.type === ge.WEBGPU;
    }
    getTexture(t) {
      return this._buildTexturePromise(t.text, t.resolution, t.style);
    }
    getManagedTexture(t, e, r, n) {
      if (this._activeTextures[n]) return this._increaseReferenceCount(n), this._activeTextures[n].promise;
      const s = this._buildTexturePromise(t, e, r).then((o) => (this._activeTextures[n].texture = o, o));
      return this._activeTextures[n] = {
        texture: null,
        promise: s,
        usageCount: 1
      }, s;
    }
    async _buildTexturePromise(t, e, r) {
      const n = vt.get(fd), s = fx(t, r), o = await _x(s, r, rs.defaultTextStyle), a = pd(t, r, o, n), c = Math.ceil(Math.ceil(Math.max(1, a.width) + r.padding * 2) * e), u = Math.ceil(Math.ceil(Math.max(1, a.height) + r.padding * 2) * e), l = n.image, h = 2;
      l.width = (c | 0) + h, l.height = (u | 0) + h;
      const f = gx(t, r, e, o, n);
      await bx(l, f, hx() && s.length > 0);
      let p = l;
      this._createCanvas && (p = mx(l, e));
      const m = $f(p, l.width - h, l.height - h, e);
      return this._createCanvas && this._renderer.texture.initSource(m.source), vt.return(n), m;
    }
    _increaseReferenceCount(t) {
      this._activeTextures[t].usageCount++;
    }
    decreaseReferenceCount(t) {
      const e = this._activeTextures[t];
      e && (e.usageCount--, e.usageCount === 0 && (e.texture ? this._cleanUp(e) : e.promise.then((r) => {
        e.texture = r, this._cleanUp(e);
      }).catch(() => {
        ut("HTMLTextSystem: Failed to clean texture");
      }), this._activeTextures[t] = null));
    }
    _cleanUp(t) {
      Jt.returnTexture(t.texture), t.texture.source.resource = null, t.texture.source.uploadMethodId = "unknown";
    }
    getReferenceCount(t) {
      return this._activeTextures[t].usageCount;
    }
    destroy() {
      this._activeTextures = null;
    }
  };
  Yf.extension = {
    type: [
      P.WebGLSystem,
      P.WebGPUSystem,
      P.CanvasSystem
    ],
    name: "htmlText"
  };
  Yf.defaultFontOptions = {
    fontFamily: "Arial",
    fontStyle: "normal",
    fontWeight: "normal"
  };
  wx = class {
    constructor(t) {
      this._gpuText = /* @__PURE__ */ Object.create(null), this._renderer = t, this._renderer.runners.resolutionChange.add(this);
    }
    resolutionChange() {
      for (const t in this._gpuText) {
        const r = this._gpuText[t].batchableSprite.renderable;
        r._autoResolution && (r._resolution = this._renderer.resolution, r.onViewUpdate());
      }
    }
    validateRenderable(t) {
      const e = this._getGpuText(t), r = t._getKey();
      if (e.currentKey !== r) {
        const { width: n, height: s } = this._renderer.canvasText.getTextureSize(t.text, t.resolution, t._style);
        return !(this._renderer.canvasText.getReferenceCount(e.currentKey) === 1 && n === e.texture._source.width && s === e.texture._source.height);
      }
      return false;
    }
    addRenderable(t, e) {
      const n = this._getGpuText(t).batchableSprite;
      t._didTextUpdate && this._updateText(t), this._renderer.renderPipes.batch.addToBatch(n);
    }
    updateRenderable(t) {
      const r = this._getGpuText(t).batchableSprite;
      t._didTextUpdate && this._updateText(t), r.batcher.updateElement(r);
    }
    destroyRenderable(t) {
      this._destroyRenderableById(t.uid);
    }
    _destroyRenderableById(t) {
      const e = this._gpuText[t];
      this._renderer.canvasText.decreaseReferenceCount(e.currentKey), vt.return(e.batchableSprite), this._gpuText[t] = null;
    }
    _updateText(t) {
      const e = t._getKey(), r = this._getGpuText(t), n = r.batchableSprite;
      r.currentKey !== e && this._updateGpuText(t), t._didTextUpdate = false;
      const s = t._style.padding;
      Cn(n.bounds, t._anchor, n.texture, s);
    }
    _updateGpuText(t) {
      const e = this._getGpuText(t), r = e.batchableSprite;
      e.texture && this._renderer.canvasText.decreaseReferenceCount(e.currentKey), e.texture = r.texture = this._renderer.canvasText.getManagedTexture(t), e.currentKey = t._getKey(), r.texture = e.texture;
    }
    _getGpuText(t) {
      return this._gpuText[t.uid] || this.initGpuText(t);
    }
    initGpuText(t) {
      const e = {
        texture: null,
        currentKey: "--",
        batchableSprite: vt.get(Ta)
      };
      return e.batchableSprite.renderable = t, e.batchableSprite.bounds = {
        minX: 0,
        maxX: 1,
        minY: 0,
        maxY: 0
      }, e.batchableSprite.roundPixels = this._renderer._roundPixels | t._roundPixels, this._gpuText[t.uid] = e, t._resolution = t._autoResolution ? this._renderer.resolution : t.resolution, this._updateText(t), t.on("destroyed", () => {
        this.destroyRenderable(t);
      }), e;
    }
    destroy() {
      for (const t in this._gpuText) this._destroyRenderableById(t);
      this._gpuText = null, this._renderer = null;
    }
  };
  wx.extension = {
    type: [
      P.WebGLPipes,
      P.WebGPUPipes,
      P.CanvasPipes
    ],
    name: "text"
  };
  function Wu(i, t, e) {
    for (let r = 0, n = 4 * e * t; r < t; ++r, n += 4) if (i[n + 3] !== 0) return false;
    return true;
  }
  function Vu(i, t, e, r, n) {
    const s = 4 * t;
    for (let o = r, a = r * s + 4 * e; o <= n; ++o, a += s) if (i[a + 3] !== 0) return false;
    return true;
  }
  function yx(i, t = 1) {
    const { width: e, height: r } = i, n = i.getContext("2d", {
      willReadFrequently: true
    });
    if (n === null) throw new TypeError("Failed to get canvas 2D context");
    const o = n.getImageData(0, 0, e, r).data;
    let a = 0, c = 0, u = e - 1, l = r - 1;
    for (; c < r && Wu(o, e, c); ) ++c;
    if (c === r) return Et.EMPTY;
    for (; Wu(o, e, l); ) --l;
    for (; Vu(o, e, a, c, l); ) ++a;
    for (; Vu(o, e, u, c, l); ) --u;
    return ++u, ++l, new Et(a / t, c / t, (u - a) / t, (l - c) / t);
  }
  xx = class {
    constructor(t) {
      this._activeTextures = {}, this._renderer = t;
    }
    getTextureSize(t, e, r) {
      const n = Ge.measureText(t || " ", r);
      let s = Math.ceil(Math.ceil(Math.max(1, n.width) + r.padding * 2) * e), o = Math.ceil(Math.ceil(Math.max(1, n.height) + r.padding * 2) * e);
      return s = Math.ceil(s - 1e-6), o = Math.ceil(o - 1e-6), s = $r(s), o = $r(o), {
        width: s,
        height: o
      };
    }
    getTexture(t, e, r, n) {
      typeof t == "string" && (lt("8.0.0", "CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments"), t = {
        text: t,
        style: r,
        resolution: e
      }), t.style instanceof Oe || (t.style = new Oe(t.style));
      const { texture: s, canvasAndContext: o } = this.createTextureAndCanvas(t);
      return this._renderer.texture.initSource(s._source), Je.returnCanvasAndContext(o), s;
    }
    createTextureAndCanvas(t) {
      const { text: e, style: r } = t, n = t.resolution ?? this._renderer.resolution, s = Ge.measureText(e || " ", r), o = Math.ceil(Math.ceil(Math.max(1, s.width) + r.padding * 2) * n), a = Math.ceil(Math.ceil(Math.max(1, s.height) + r.padding * 2) * n), c = Je.getOptimalCanvasAndContext(o, a), { canvas: u } = c;
      this.renderTextToCanvas(e, r, n, c);
      const l = $f(u, o, a, n);
      if (r.trim) {
        const h = yx(u, n);
        l.frame.copyFrom(h), l.updateUvs();
      }
      return {
        texture: l,
        canvasAndContext: c
      };
    }
    getManagedTexture(t) {
      t._resolution = t._autoResolution ? this._renderer.resolution : t.resolution;
      const e = t._getKey();
      if (this._activeTextures[e]) return this._increaseReferenceCount(e), this._activeTextures[e].texture;
      const { texture: r, canvasAndContext: n } = this.createTextureAndCanvas(t);
      return this._activeTextures[e] = {
        canvasAndContext: n,
        texture: r,
        usageCount: 1
      }, r;
    }
    _increaseReferenceCount(t) {
      this._activeTextures[t].usageCount++;
    }
    decreaseReferenceCount(t) {
      const e = this._activeTextures[t];
      if (e.usageCount--, e.usageCount === 0) {
        Je.returnCanvasAndContext(e.canvasAndContext), Jt.returnTexture(e.texture);
        const r = e.texture.source;
        r.resource = null, r.uploadMethodId = "unknown", r.alphaMode = "no-premultiply-alpha", this._activeTextures[t] = null;
      }
    }
    getReferenceCount(t) {
      return this._activeTextures[t].usageCount;
    }
    renderTextToCanvas(t, e, r, n) {
      var _a2, _b2, _c2, _d2, _e2;
      const { canvas: s, context: o } = n, a = Fn(e), c = Ge.measureText(t || " ", e), u = c.lines, l = c.lineHeight, h = c.lineWidths, f = c.maxLineWidth, p = c.fontProperties, m = s.height;
      o.resetTransform(), o.scale(r, r);
      const y = e.padding * 2;
      if (o.clearRect(0, 0, c.width + 4 + y, c.height + 4 + y), (_a2 = e._stroke) == null ? void 0 : _a2.width) {
        const T = e._stroke;
        o.lineWidth = T.width, o.miterLimit = T.miterLimit, o.lineJoin = T.join, o.lineCap = T.cap;
      }
      o.font = a;
      let b, v;
      const A = e.dropShadow ? 2 : 1;
      for (let T = 0; T < A; ++T) {
        const G = e.dropShadow && T === 0, H = G ? Math.ceil(Math.max(1, m) + e.padding * 2) : 0, Y = H * r;
        if (G) {
          o.fillStyle = "black", o.strokeStyle = "black";
          const C = e.dropShadow, I = C.color, z = C.alpha;
          o.shadowColor = At.shared.setValue(I).setAlpha(z).toRgbaString();
          const Z = C.blur * r, j = C.distance * r;
          o.shadowBlur = Z, o.shadowOffsetX = Math.cos(C.angle) * j, o.shadowOffsetY = Math.sin(C.angle) * j + Y;
        } else o.globalAlpha = ((_b2 = e._fill) == null ? void 0 : _b2.alpha) ?? 1, o.fillStyle = e._fill ? Un(e._fill, o) : null, ((_c2 = e._stroke) == null ? void 0 : _c2.width) && (o.strokeStyle = Un(e._stroke, o)), o.shadowColor = "black";
        let L = (l - p.fontSize) / 2;
        l - p.fontSize < 0 && (L = 0);
        const W = ((_d2 = e._stroke) == null ? void 0 : _d2.width) ?? 0;
        for (let C = 0; C < u.length; C++) b = W / 2, v = W / 2 + C * l + p.ascent + L, e.align === "right" ? b += f - h[C] : e.align === "center" && (b += (f - h[C]) / 2), ((_e2 = e._stroke) == null ? void 0 : _e2.width) && this._drawLetterSpacing(u[C], e, n, b + e.padding, v + e.padding - H, true), e._fill !== void 0 && this._drawLetterSpacing(u[C], e, n, b + e.padding, v + e.padding - H);
      }
    }
    _drawLetterSpacing(t, e, r, n, s, o = false) {
      const { context: a } = r, c = e.letterSpacing;
      let u = false;
      if (Ge.experimentalLetterSpacingSupported && (Ge.experimentalLetterSpacing ? (a.letterSpacing = `${c}px`, a.textLetterSpacing = `${c}px`, u = true) : (a.letterSpacing = "0px", a.textLetterSpacing = "0px")), c === 0 || u) {
        o ? a.strokeText(t, n, s) : a.fillText(t, n, s);
        return;
      }
      let l = n;
      const h = Ge.graphemeSegmenter(t);
      let f = a.measureText(t).width, p = 0;
      for (let m = 0; m < h.length; ++m) {
        const y = h[m];
        o ? a.strokeText(y, l, s) : a.fillText(y, l, s);
        let b = "";
        for (let v = m + 1; v < h.length; ++v) b += h[v];
        p = a.measureText(b).width, l += f - p + c, f = p;
      }
    }
    destroy() {
      this._activeTextures = null;
    }
  };
  xx.extension = {
    type: [
      P.WebGLSystem,
      P.WebGPUSystem,
      P.CanvasSystem
    ],
    name: "canvasText"
  };
  Mt.add(yp, xp);
  const vx = "" + new URL("rapier_wasm2d_bg-BXUr3HkR.wasm", import.meta.url).href, Sx = async (i = {}, t) => {
    let e;
    if (t.startsWith("data:")) {
      const r = t.replace(/^data:.*?base64,/, "");
      let n;
      if (typeof Buffer == "function" && typeof Buffer.from == "function") n = Buffer.from(r, "base64");
      else if (typeof atob == "function") {
        const s = atob(r);
        n = new Uint8Array(s.length);
        for (let o = 0; o < s.length; o++) n[o] = s.charCodeAt(o);
      } else throw new Error("Cannot decode base64-encoded data URL");
      e = await WebAssembly.instantiate(n, i);
    } else {
      const r = await fetch(t), n = r.headers.get("Content-Type") || "";
      if ("instantiateStreaming" in WebAssembly && n.startsWith("application/wasm")) e = await WebAssembly.instantiateStreaming(r, i);
      else {
        const s = await r.arrayBuffer();
        e = await WebAssembly.instantiate(s, i);
      }
    }
    return e.instance.exports;
  };
  let d;
  function Ex(i) {
    d = i;
  }
  const mt = new Array(128).fill(void 0);
  mt.push(void 0, null, true, false);
  let Ai = mt.length;
  function Vt(i) {
    Ai === mt.length && mt.push(mt.length + 1);
    const t = Ai;
    return Ai = mt[t], mt[t] = i, t;
  }
  function xt(i) {
    return mt[i];
  }
  function Ax(i) {
    i < 132 || (mt[i] = Ai, Ai = i);
  }
  function Nn(i) {
    const t = xt(i);
    return Ax(i), t;
  }
  function et(i) {
    return i == null;
  }
  let gn = null;
  function Ln() {
    return (gn === null || gn.byteLength === 0) && (gn = new Float64Array(d.memory.buffer)), gn;
  }
  let mn = null;
  function It() {
    return (mn === null || mn.byteLength === 0) && (mn = new Int32Array(d.memory.buffer)), mn;
  }
  const Tx = typeof TextDecoder > "u" ? (0, module.require)("util").TextDecoder : TextDecoder;
  let Kf = new Tx("utf-8", {
    ignoreBOM: true,
    fatal: true
  });
  Kf.decode();
  let bn = null;
  function Cx() {
    return (bn === null || bn.byteLength === 0) && (bn = new Uint8Array(d.memory.buffer)), bn;
  }
  function Rx(i, t) {
    return i = i >>> 0, Kf.decode(Cx().subarray(i, i + t));
  }
  function M(i, t) {
    if (!(i instanceof t)) throw new Error(`expected instance of ${t.name}`);
    return i.ptr;
  }
  let wn = null;
  function ur() {
    return (wn === null || wn.byteLength === 0) && (wn = new Float32Array(d.memory.buffer)), wn;
  }
  let Rt = 128;
  function Gt(i) {
    if (Rt == 1) throw new Error("out of js stack");
    return mt[--Rt] = i, Rt;
  }
  function Xu(i, t) {
    return i = i >>> 0, ur().subarray(i / 4, i / 4 + t);
  }
  let yn = null;
  function Zf() {
    return (yn === null || yn.byteLength === 0) && (yn = new Uint32Array(d.memory.buffer)), yn;
  }
  function Px(i, t) {
    return i = i >>> 0, Zf().subarray(i / 4, i / 4 + t);
  }
  let Ce = 0;
  function vr(i, t) {
    const e = t(i.length * 4, 4) >>> 0;
    return ur().set(i, e / 4), Ce = i.length, e;
  }
  function qu(i, t) {
    const e = t(i.length * 4, 4) >>> 0;
    return Zf().set(i, e / 4), Ce = i.length, e;
  }
  function Fa(i, t) {
    try {
      return i.apply(this, t);
    } catch (e) {
      d.__wbindgen_exn_store(Vt(e));
    }
  }
  const dR = Object.freeze({
    Dynamic: 0,
    0: "Dynamic",
    Fixed: 1,
    1: "Fixed",
    KinematicPositionBased: 2,
    2: "KinematicPositionBased",
    KinematicVelocityBased: 3,
    3: "KinematicVelocityBased"
  }), ue = Object.freeze({
    Ball: 0,
    0: "Ball",
    Cuboid: 1,
    1: "Cuboid",
    Capsule: 2,
    2: "Capsule",
    Segment: 3,
    3: "Segment",
    Polyline: 4,
    4: "Polyline",
    Triangle: 5,
    5: "Triangle",
    TriMesh: 6,
    6: "TriMesh",
    HeightField: 7,
    7: "HeightField",
    Compound: 8,
    8: "Compound",
    ConvexPolygon: 9,
    9: "ConvexPolygon",
    RoundCuboid: 10,
    10: "RoundCuboid",
    RoundTriangle: 11,
    11: "RoundTriangle",
    RoundConvexPolygon: 12,
    12: "RoundConvexPolygon",
    HalfSpace: 13,
    13: "HalfSpace"
  }), ar = Object.freeze({
    Revolute: 0,
    0: "Revolute",
    Fixed: 1,
    1: "Fixed",
    Prismatic: 2,
    2: "Prismatic",
    Rope: 3,
    3: "Rope",
    Spring: 4,
    4: "Spring",
    Generic: 5,
    5: "Generic"
  }), fR = Object.freeze({
    AccelerationBased: 0,
    0: "AccelerationBased",
    ForceBased: 1,
    1: "ForceBased"
  }), pR = Object.freeze({
    Vertex: 0,
    0: "Vertex",
    Face: 1,
    1: "Face",
    Unknown: 2,
    2: "Unknown"
  }), ss = Object.freeze({
    LinX: 0,
    0: "LinX",
    LinY: 1,
    1: "LinY",
    AngX: 2,
    2: "AngX"
  }), $u = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => d.__wbg_rawbroadphase_free(i >>> 0));
  class Br {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(Br.prototype);
      return e.__wbg_ptr = t, $u.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, $u.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      d.__wbg_rawbroadphase_free(t);
    }
    constructor() {
      const t = d.rawbroadphase_new();
      return this.__wbg_ptr = t >>> 0, this;
    }
  }
  const Bx = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => d.__wbg_rawccdsolver_free(i >>> 0));
  class jo {
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, Bx.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      d.__wbg_rawccdsolver_free(t);
    }
    constructor() {
      const t = d.rawccdsolver_new();
      return this.__wbg_ptr = t >>> 0, this;
    }
  }
  const Mx = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => d.__wbg_rawcharactercollision_free(i >>> 0));
  class Jf {
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, Mx.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      d.__wbg_rawcharactercollision_free(t);
    }
    constructor() {
      const t = d.rawcharactercollision_new();
      return this.__wbg_ptr = t >>> 0, this;
    }
    handle() {
      return d.rawcharactercollision_handle(this.__wbg_ptr);
    }
    translationDeltaApplied() {
      const t = d.rawcharactercollision_translationDeltaApplied(this.__wbg_ptr);
      return F.__wrap(t);
    }
    translationDeltaRemaining() {
      const t = d.rawcharactercollision_translationDeltaRemaining(this.__wbg_ptr);
      return F.__wrap(t);
    }
    toi() {
      return d.rawcharactercollision_toi(this.__wbg_ptr);
    }
    worldWitness1() {
      const t = d.rawcharactercollision_worldWitness1(this.__wbg_ptr);
      return F.__wrap(t);
    }
    worldWitness2() {
      const t = d.rawcharactercollision_worldWitness2(this.__wbg_ptr);
      return F.__wrap(t);
    }
    worldNormal1() {
      const t = d.rawcharactercollision_worldNormal1(this.__wbg_ptr);
      return F.__wrap(t);
    }
    worldNormal2() {
      const t = d.rawcharactercollision_worldNormal2(this.__wbg_ptr);
      return F.__wrap(t);
    }
  }
  const Yu = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => d.__wbg_rawcolliderset_free(i >>> 0));
  class Nt {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(Nt.prototype);
      return e.__wbg_ptr = t, Yu.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, Yu.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      d.__wbg_rawcolliderset_free(t);
    }
    coTranslation(t) {
      const e = d.rawcolliderset_coTranslation(this.__wbg_ptr, t);
      return F.__wrap(e);
    }
    coRotation(t) {
      const e = d.rawcolliderset_coRotation(this.__wbg_ptr, t);
      return bt.__wrap(e);
    }
    coSetTranslation(t, e, r) {
      d.rawcolliderset_coSetTranslation(this.__wbg_ptr, t, e, r);
    }
    coSetTranslationWrtParent(t, e, r) {
      d.rawcolliderset_coSetTranslationWrtParent(this.__wbg_ptr, t, e, r);
    }
    coSetRotation(t, e) {
      d.rawcolliderset_coSetRotation(this.__wbg_ptr, t, e);
    }
    coSetRotationWrtParent(t, e) {
      d.rawcolliderset_coSetRotationWrtParent(this.__wbg_ptr, t, e);
    }
    coIsSensor(t) {
      return d.rawcolliderset_coIsSensor(this.__wbg_ptr, t) !== 0;
    }
    coShapeType(t) {
      return d.rawcolliderset_coShapeType(this.__wbg_ptr, t);
    }
    coHalfspaceNormal(t) {
      const e = d.rawcolliderset_coHalfspaceNormal(this.__wbg_ptr, t);
      return e === 0 ? void 0 : F.__wrap(e);
    }
    coHalfExtents(t) {
      const e = d.rawcolliderset_coHalfExtents(this.__wbg_ptr, t);
      return e === 0 ? void 0 : F.__wrap(e);
    }
    coSetHalfExtents(t, e) {
      M(e, F), d.rawcolliderset_coSetHalfExtents(this.__wbg_ptr, t, e.__wbg_ptr);
    }
    coRadius(t) {
      try {
        const n = d.__wbindgen_add_to_stack_pointer(-16);
        d.rawcolliderset_coRadius(n, this.__wbg_ptr, t);
        var e = It()[n / 4 + 0], r = ur()[n / 4 + 1];
        return e === 0 ? void 0 : r;
      } finally {
        d.__wbindgen_add_to_stack_pointer(16);
      }
    }
    coSetRadius(t, e) {
      d.rawcolliderset_coSetRadius(this.__wbg_ptr, t, e);
    }
    coHalfHeight(t) {
      try {
        const n = d.__wbindgen_add_to_stack_pointer(-16);
        d.rawcolliderset_coHalfHeight(n, this.__wbg_ptr, t);
        var e = It()[n / 4 + 0], r = ur()[n / 4 + 1];
        return e === 0 ? void 0 : r;
      } finally {
        d.__wbindgen_add_to_stack_pointer(16);
      }
    }
    coSetHalfHeight(t, e) {
      d.rawcolliderset_coSetHalfHeight(this.__wbg_ptr, t, e);
    }
    coRoundRadius(t) {
      try {
        const n = d.__wbindgen_add_to_stack_pointer(-16);
        d.rawcolliderset_coRoundRadius(n, this.__wbg_ptr, t);
        var e = It()[n / 4 + 0], r = ur()[n / 4 + 1];
        return e === 0 ? void 0 : r;
      } finally {
        d.__wbindgen_add_to_stack_pointer(16);
      }
    }
    coSetRoundRadius(t, e) {
      d.rawcolliderset_coSetRoundRadius(this.__wbg_ptr, t, e);
    }
    coVertices(t) {
      try {
        const n = d.__wbindgen_add_to_stack_pointer(-16);
        d.rawcolliderset_coVertices(n, this.__wbg_ptr, t);
        var e = It()[n / 4 + 0], r = It()[n / 4 + 1];
        let s;
        return e !== 0 && (s = Xu(e, r).slice(), d.__wbindgen_free(e, r * 4, 4)), s;
      } finally {
        d.__wbindgen_add_to_stack_pointer(16);
      }
    }
    coIndices(t) {
      try {
        const n = d.__wbindgen_add_to_stack_pointer(-16);
        d.rawcolliderset_coIndices(n, this.__wbg_ptr, t);
        var e = It()[n / 4 + 0], r = It()[n / 4 + 1];
        let s;
        return e !== 0 && (s = Px(e, r).slice(), d.__wbindgen_free(e, r * 4, 4)), s;
      } finally {
        d.__wbindgen_add_to_stack_pointer(16);
      }
    }
    coTriMeshFlags(t) {
      try {
        const n = d.__wbindgen_add_to_stack_pointer(-16);
        d.rawcolliderset_coTriMeshFlags(n, this.__wbg_ptr, t);
        var e = It()[n / 4 + 0], r = It()[n / 4 + 1];
        return e === 0 ? void 0 : r >>> 0;
      } finally {
        d.__wbindgen_add_to_stack_pointer(16);
      }
    }
    coHeightfieldHeights(t) {
      try {
        const n = d.__wbindgen_add_to_stack_pointer(-16);
        d.rawcolliderset_coHeightfieldHeights(n, this.__wbg_ptr, t);
        var e = It()[n / 4 + 0], r = It()[n / 4 + 1];
        let s;
        return e !== 0 && (s = Xu(e, r).slice(), d.__wbindgen_free(e, r * 4, 4)), s;
      } finally {
        d.__wbindgen_add_to_stack_pointer(16);
      }
    }
    coHeightfieldScale(t) {
      const e = d.rawcolliderset_coHeightfieldScale(this.__wbg_ptr, t);
      return e === 0 ? void 0 : F.__wrap(e);
    }
    coParent(t) {
      try {
        const n = d.__wbindgen_add_to_stack_pointer(-16);
        d.rawcolliderset_coParent(n, this.__wbg_ptr, t);
        var e = It()[n / 4 + 0], r = Ln()[n / 8 + 1];
        return e === 0 ? void 0 : r;
      } finally {
        d.__wbindgen_add_to_stack_pointer(16);
      }
    }
    coSetEnabled(t, e) {
      d.rawcolliderset_coSetEnabled(this.__wbg_ptr, t, e);
    }
    coIsEnabled(t) {
      return d.rawcolliderset_coIsEnabled(this.__wbg_ptr, t) !== 0;
    }
    coSetContactSkin(t, e) {
      d.rawcolliderset_coSetContactSkin(this.__wbg_ptr, t, e);
    }
    coContactSkin(t) {
      return d.rawcolliderset_coContactSkin(this.__wbg_ptr, t);
    }
    coFriction(t) {
      return d.rawcolliderset_coFriction(this.__wbg_ptr, t);
    }
    coRestitution(t) {
      return d.rawcolliderset_coRestitution(this.__wbg_ptr, t);
    }
    coDensity(t) {
      return d.rawcolliderset_coDensity(this.__wbg_ptr, t);
    }
    coMass(t) {
      return d.rawcolliderset_coMass(this.__wbg_ptr, t);
    }
    coVolume(t) {
      return d.rawcolliderset_coVolume(this.__wbg_ptr, t);
    }
    coCollisionGroups(t) {
      return d.rawcolliderset_coCollisionGroups(this.__wbg_ptr, t) >>> 0;
    }
    coSolverGroups(t) {
      return d.rawcolliderset_coSolverGroups(this.__wbg_ptr, t) >>> 0;
    }
    coActiveHooks(t) {
      return d.rawcolliderset_coActiveHooks(this.__wbg_ptr, t) >>> 0;
    }
    coActiveCollisionTypes(t) {
      return d.rawcolliderset_coActiveCollisionTypes(this.__wbg_ptr, t);
    }
    coActiveEvents(t) {
      return d.rawcolliderset_coActiveEvents(this.__wbg_ptr, t) >>> 0;
    }
    coContactForceEventThreshold(t) {
      return d.rawcolliderset_coContactForceEventThreshold(this.__wbg_ptr, t);
    }
    coContainsPoint(t, e) {
      return M(e, F), d.rawcolliderset_coContainsPoint(this.__wbg_ptr, t, e.__wbg_ptr) !== 0;
    }
    coCastShape(t, e, r, n, s, o, a, c, u) {
      M(e, F), M(r, ct), M(n, F), M(s, bt), M(o, F);
      const l = d.rawcolliderset_coCastShape(this.__wbg_ptr, t, e.__wbg_ptr, r.__wbg_ptr, n.__wbg_ptr, s.__wbg_ptr, o.__wbg_ptr, a, c, u);
      return l === 0 ? void 0 : ls.__wrap(l);
    }
    coCastCollider(t, e, r, n, s, o, a) {
      M(e, F), M(n, F);
      const c = d.rawcolliderset_coCastCollider(this.__wbg_ptr, t, e.__wbg_ptr, r, n.__wbg_ptr, s, o, a);
      return c === 0 ? void 0 : os.__wrap(c);
    }
    coIntersectsShape(t, e, r, n) {
      return M(e, ct), M(r, F), M(n, bt), d.rawcolliderset_coIntersectsShape(this.__wbg_ptr, t, e.__wbg_ptr, r.__wbg_ptr, n.__wbg_ptr) !== 0;
    }
    coContactShape(t, e, r, n, s) {
      M(e, ct), M(r, F), M(n, bt);
      const o = d.rawcolliderset_coContactShape(this.__wbg_ptr, t, e.__wbg_ptr, r.__wbg_ptr, n.__wbg_ptr, s);
      return o === 0 ? void 0 : Pi.__wrap(o);
    }
    coContactCollider(t, e, r) {
      const n = d.rawcolliderset_coContactCollider(this.__wbg_ptr, t, e, r);
      return n === 0 ? void 0 : Pi.__wrap(n);
    }
    coProjectPoint(t, e, r) {
      M(e, F);
      const n = d.rawcolliderset_coProjectPoint(this.__wbg_ptr, t, e.__wbg_ptr, r);
      return as.__wrap(n);
    }
    coIntersectsRay(t, e, r, n) {
      return M(e, F), M(r, F), d.rawcolliderset_coIntersectsRay(this.__wbg_ptr, t, e.__wbg_ptr, r.__wbg_ptr, n) !== 0;
    }
    coCastRay(t, e, r, n, s) {
      return M(e, F), M(r, F), d.rawcolliderset_coCastRay(this.__wbg_ptr, t, e.__wbg_ptr, r.__wbg_ptr, n, s);
    }
    coCastRayAndGetNormal(t, e, r, n, s) {
      M(e, F), M(r, F);
      const o = d.rawcolliderset_coCastRayAndGetNormal(this.__wbg_ptr, t, e.__wbg_ptr, r.__wbg_ptr, n, s);
      return o === 0 ? void 0 : us.__wrap(o);
    }
    coSetSensor(t, e) {
      d.rawcolliderset_coSetSensor(this.__wbg_ptr, t, e);
    }
    coSetRestitution(t, e) {
      d.rawcolliderset_coSetRestitution(this.__wbg_ptr, t, e);
    }
    coSetFriction(t, e) {
      d.rawcolliderset_coSetFriction(this.__wbg_ptr, t, e);
    }
    coFrictionCombineRule(t) {
      return d.rawcolliderset_coFrictionCombineRule(this.__wbg_ptr, t) >>> 0;
    }
    coSetFrictionCombineRule(t, e) {
      d.rawcolliderset_coSetFrictionCombineRule(this.__wbg_ptr, t, e);
    }
    coRestitutionCombineRule(t) {
      return d.rawcolliderset_coRestitutionCombineRule(this.__wbg_ptr, t) >>> 0;
    }
    coSetRestitutionCombineRule(t, e) {
      d.rawcolliderset_coSetRestitutionCombineRule(this.__wbg_ptr, t, e);
    }
    coSetCollisionGroups(t, e) {
      d.rawcolliderset_coSetCollisionGroups(this.__wbg_ptr, t, e);
    }
    coSetSolverGroups(t, e) {
      d.rawcolliderset_coSetSolverGroups(this.__wbg_ptr, t, e);
    }
    coSetActiveHooks(t, e) {
      d.rawcolliderset_coSetActiveHooks(this.__wbg_ptr, t, e);
    }
    coSetActiveEvents(t, e) {
      d.rawcolliderset_coSetActiveEvents(this.__wbg_ptr, t, e);
    }
    coSetActiveCollisionTypes(t, e) {
      d.rawcolliderset_coSetActiveCollisionTypes(this.__wbg_ptr, t, e);
    }
    coSetShape(t, e) {
      M(e, ct), d.rawcolliderset_coSetShape(this.__wbg_ptr, t, e.__wbg_ptr);
    }
    coSetContactForceEventThreshold(t, e) {
      d.rawcolliderset_coSetContactForceEventThreshold(this.__wbg_ptr, t, e);
    }
    coSetDensity(t, e) {
      d.rawcolliderset_coSetDensity(this.__wbg_ptr, t, e);
    }
    coSetMass(t, e) {
      d.rawcolliderset_coSetMass(this.__wbg_ptr, t, e);
    }
    coSetMassProperties(t, e, r, n) {
      M(r, F), d.rawcolliderset_coSetMassProperties(this.__wbg_ptr, t, e, r.__wbg_ptr, n);
    }
    constructor() {
      const t = d.rawcolliderset_new();
      return this.__wbg_ptr = t >>> 0, this;
    }
    len() {
      return d.rawcolliderset_len(this.__wbg_ptr) >>> 0;
    }
    contains(t) {
      return d.rawcolliderset_contains(this.__wbg_ptr, t) !== 0;
    }
    createCollider(t, e, r, n, s, o, a, c, u, l, h, f, p, m, y, b, v, A, T, G, H, Y, L, W) {
      try {
        const z = d.__wbindgen_add_to_stack_pointer(-16);
        M(e, ct), M(r, F), M(n, bt), M(a, F), M(W, Wt), d.rawcolliderset_createCollider(z, this.__wbg_ptr, t, e.__wbg_ptr, r.__wbg_ptr, n.__wbg_ptr, s, o, a.__wbg_ptr, c, u, l, h, f, p, m, y, b, v, A, T, G, H, Y, L, W.__wbg_ptr);
        var C = It()[z / 4 + 0], I = Ln()[z / 8 + 1];
        return C === 0 ? void 0 : I;
      } finally {
        d.__wbindgen_add_to_stack_pointer(16);
      }
    }
    remove(t, e, r, n) {
      M(e, tr), M(r, Wt), d.rawcolliderset_remove(this.__wbg_ptr, t, e.__wbg_ptr, r.__wbg_ptr, n);
    }
    isHandleValid(t) {
      return d.rawcolliderset_contains(this.__wbg_ptr, t) !== 0;
    }
    forEachColliderHandle(t) {
      try {
        d.rawcolliderset_forEachColliderHandle(this.__wbg_ptr, Gt(t));
      } finally {
        mt[Rt++] = void 0;
      }
    }
  }
  const Ku = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => d.__wbg_rawcollidershapecasthit_free(i >>> 0));
  class os {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(os.prototype);
      return e.__wbg_ptr = t, Ku.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, Ku.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      d.__wbg_rawcollidershapecasthit_free(t);
    }
    colliderHandle() {
      return d.rawcollidershapecasthit_colliderHandle(this.__wbg_ptr);
    }
    time_of_impact() {
      return d.rawcollidershapecasthit_time_of_impact(this.__wbg_ptr);
    }
    witness1() {
      const t = d.rawcollidershapecasthit_witness1(this.__wbg_ptr);
      return F.__wrap(t);
    }
    witness2() {
      const t = d.rawcollidershapecasthit_witness2(this.__wbg_ptr);
      return F.__wrap(t);
    }
    normal1() {
      const t = d.rawcollidershapecasthit_normal1(this.__wbg_ptr);
      return F.__wrap(t);
    }
    normal2() {
      const t = d.rawcollidershapecasthit_normal2(this.__wbg_ptr);
      return F.__wrap(t);
    }
  }
  const Zu = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => d.__wbg_rawcontactforceevent_free(i >>> 0));
  class Ua {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(Ua.prototype);
      return e.__wbg_ptr = t, Zu.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, Zu.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      d.__wbg_rawcontactforceevent_free(t);
    }
    collider1() {
      return d.rawcollidershapecasthit_colliderHandle(this.__wbg_ptr);
    }
    collider2() {
      return d.rawcontactforceevent_collider2(this.__wbg_ptr);
    }
    total_force() {
      const t = d.rawcontactforceevent_total_force(this.__wbg_ptr);
      return F.__wrap(t);
    }
    total_force_magnitude() {
      return d.rawcontactforceevent_total_force_magnitude(this.__wbg_ptr);
    }
    max_force_direction() {
      const t = d.rawcharactercollision_translationDeltaApplied(this.__wbg_ptr);
      return F.__wrap(t);
    }
    max_force_magnitude() {
      return d.rawcontactforceevent_max_force_magnitude(this.__wbg_ptr);
    }
  }
  const Ju = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => d.__wbg_rawcontactmanifold_free(i >>> 0));
  class ka {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(ka.prototype);
      return e.__wbg_ptr = t, Ju.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, Ju.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      d.__wbg_rawcontactmanifold_free(t);
    }
    normal() {
      const t = d.rawcontactmanifold_normal(this.__wbg_ptr);
      return F.__wrap(t);
    }
    local_n1() {
      const t = d.rawcontactmanifold_local_n1(this.__wbg_ptr);
      return F.__wrap(t);
    }
    local_n2() {
      const t = d.rawcontactmanifold_local_n2(this.__wbg_ptr);
      return F.__wrap(t);
    }
    subshape1() {
      return d.rawcontactmanifold_subshape1(this.__wbg_ptr) >>> 0;
    }
    subshape2() {
      return d.rawcontactmanifold_subshape2(this.__wbg_ptr) >>> 0;
    }
    num_contacts() {
      return d.rawcontactmanifold_num_contacts(this.__wbg_ptr) >>> 0;
    }
    contact_local_p1(t) {
      const e = d.rawcontactmanifold_contact_local_p1(this.__wbg_ptr, t);
      return e === 0 ? void 0 : F.__wrap(e);
    }
    contact_local_p2(t) {
      const e = d.rawcontactmanifold_contact_local_p2(this.__wbg_ptr, t);
      return e === 0 ? void 0 : F.__wrap(e);
    }
    contact_dist(t) {
      return d.rawcontactmanifold_contact_dist(this.__wbg_ptr, t);
    }
    contact_fid1(t) {
      return d.rawcontactmanifold_contact_fid1(this.__wbg_ptr, t) >>> 0;
    }
    contact_fid2(t) {
      return d.rawcontactmanifold_contact_fid2(this.__wbg_ptr, t) >>> 0;
    }
    contact_impulse(t) {
      return d.rawcontactmanifold_contact_impulse(this.__wbg_ptr, t);
    }
    contact_tangent_impulse(t) {
      return d.rawcontactmanifold_contact_tangent_impulse(this.__wbg_ptr, t);
    }
    num_solver_contacts() {
      return d.rawcontactmanifold_num_solver_contacts(this.__wbg_ptr) >>> 0;
    }
    solver_contact_point(t) {
      const e = d.rawcontactmanifold_solver_contact_point(this.__wbg_ptr, t);
      return e === 0 ? void 0 : F.__wrap(e);
    }
    solver_contact_dist(t) {
      return d.rawcontactmanifold_solver_contact_dist(this.__wbg_ptr, t);
    }
    solver_contact_friction(t) {
      return d.rawcontactmanifold_solver_contact_friction(this.__wbg_ptr, t);
    }
    solver_contact_restitution(t) {
      return d.rawcontactmanifold_solver_contact_restitution(this.__wbg_ptr, t);
    }
    solver_contact_tangent_velocity(t) {
      const e = d.rawcontactmanifold_solver_contact_tangent_velocity(this.__wbg_ptr, t);
      return F.__wrap(e);
    }
  }
  const Qu = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => d.__wbg_rawcontactpair_free(i >>> 0));
  class Ga {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(Ga.prototype);
      return e.__wbg_ptr = t, Qu.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, Qu.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      d.__wbg_rawcontactpair_free(t);
    }
    collider1() {
      return d.rawcontactpair_collider1(this.__wbg_ptr);
    }
    collider2() {
      return d.rawcontactpair_collider2(this.__wbg_ptr);
    }
    numContactManifolds() {
      return d.rawcontactpair_numContactManifolds(this.__wbg_ptr) >>> 0;
    }
    contactManifold(t) {
      const e = d.rawcontactpair_contactManifold(this.__wbg_ptr, t);
      return e === 0 ? void 0 : ka.__wrap(e);
    }
  }
  const Dx = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => d.__wbg_rawdebugrenderpipeline_free(i >>> 0));
  class Ix {
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, Dx.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      d.__wbg_rawdebugrenderpipeline_free(t);
    }
    constructor() {
      const t = d.rawdebugrenderpipeline_new();
      return this.__wbg_ptr = t >>> 0, this;
    }
    vertices() {
      const t = d.rawdebugrenderpipeline_vertices(this.__wbg_ptr);
      return Nn(t);
    }
    colors() {
      const t = d.rawdebugrenderpipeline_colors(this.__wbg_ptr);
      return Nn(t);
    }
    render(t, e, r, n, s) {
      M(t, Wt), M(e, Nt), M(r, Qe), M(n, er), M(s, dr), d.rawdebugrenderpipeline_render(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, r.__wbg_ptr, n.__wbg_ptr, s.__wbg_ptr);
    }
  }
  const tl = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => d.__wbg_rawdeserializedworld_free(i >>> 0));
  class Oa {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(Oa.prototype);
      return e.__wbg_ptr = t, tl.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, tl.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      d.__wbg_rawdeserializedworld_free(t);
    }
    takeGravity() {
      const t = d.rawdeserializedworld_takeGravity(this.__wbg_ptr);
      return t === 0 ? void 0 : F.__wrap(t);
    }
    takeIntegrationParameters() {
      const t = d.rawdeserializedworld_takeIntegrationParameters(this.__wbg_ptr);
      return t === 0 ? void 0 : Mr.__wrap(t);
    }
    takeIslandManager() {
      const t = d.rawdeserializedworld_takeIslandManager(this.__wbg_ptr);
      return t === 0 ? void 0 : tr.__wrap(t);
    }
    takeBroadPhase() {
      const t = d.rawdeserializedworld_takeBroadPhase(this.__wbg_ptr);
      return t === 0 ? void 0 : Br.__wrap(t);
    }
    takeNarrowPhase() {
      const t = d.rawdeserializedworld_takeNarrowPhase(this.__wbg_ptr);
      return t === 0 ? void 0 : dr.__wrap(t);
    }
    takeBodies() {
      const t = d.rawdeserializedworld_takeBodies(this.__wbg_ptr);
      return t === 0 ? void 0 : Wt.__wrap(t);
    }
    takeColliders() {
      const t = d.rawdeserializedworld_takeColliders(this.__wbg_ptr);
      return t === 0 ? void 0 : Nt.__wrap(t);
    }
    takeImpulseJoints() {
      const t = d.rawdeserializedworld_takeImpulseJoints(this.__wbg_ptr);
      return t === 0 ? void 0 : Qe.__wrap(t);
    }
    takeMultibodyJoints() {
      const t = d.rawdeserializedworld_takeMultibodyJoints(this.__wbg_ptr);
      return t === 0 ? void 0 : er.__wrap(t);
    }
  }
  const Fx = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => d.__wbg_raweventqueue_free(i >>> 0));
  class Ux {
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, Fx.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      d.__wbg_raweventqueue_free(t);
    }
    constructor(t) {
      const e = d.raweventqueue_new(t);
      return this.__wbg_ptr = e >>> 0, this;
    }
    drainCollisionEvents(t) {
      try {
        d.raweventqueue_drainCollisionEvents(this.__wbg_ptr, Gt(t));
      } finally {
        mt[Rt++] = void 0;
      }
    }
    drainContactForceEvents(t) {
      try {
        d.raweventqueue_drainContactForceEvents(this.__wbg_ptr, Gt(t));
      } finally {
        mt[Rt++] = void 0;
      }
    }
    clear() {
      d.raweventqueue_clear(this.__wbg_ptr);
    }
  }
  const el = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => d.__wbg_rawgenericjoint_free(i >>> 0));
  class qe {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(qe.prototype);
      return e.__wbg_ptr = t, el.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, el.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      d.__wbg_rawgenericjoint_free(t);
    }
    static spring(t, e, r, n, s) {
      M(n, F), M(s, F);
      const o = d.rawgenericjoint_spring(t, e, r, n.__wbg_ptr, s.__wbg_ptr);
      return qe.__wrap(o);
    }
    static rope(t, e, r) {
      M(e, F), M(r, F);
      const n = d.rawgenericjoint_rope(t, e.__wbg_ptr, r.__wbg_ptr);
      return qe.__wrap(n);
    }
    static prismatic(t, e, r, n, s, o) {
      M(t, F), M(e, F), M(r, F);
      const a = d.rawgenericjoint_prismatic(t.__wbg_ptr, e.__wbg_ptr, r.__wbg_ptr, n, s, o);
      return a === 0 ? void 0 : qe.__wrap(a);
    }
    static fixed(t, e, r, n) {
      M(t, F), M(e, bt), M(r, F), M(n, bt);
      const s = d.rawgenericjoint_fixed(t.__wbg_ptr, e.__wbg_ptr, r.__wbg_ptr, n.__wbg_ptr);
      return qe.__wrap(s);
    }
    static revolute(t, e) {
      M(t, F), M(e, F);
      const r = d.rawgenericjoint_revolute(t.__wbg_ptr, e.__wbg_ptr);
      return r === 0 ? void 0 : qe.__wrap(r);
    }
  }
  const rl = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => d.__wbg_rawimpulsejointset_free(i >>> 0));
  class Qe {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(Qe.prototype);
      return e.__wbg_ptr = t, rl.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, rl.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      d.__wbg_rawimpulsejointset_free(t);
    }
    jointType(t) {
      return d.rawimpulsejointset_jointType(this.__wbg_ptr, t);
    }
    jointBodyHandle1(t) {
      return d.rawimpulsejointset_jointBodyHandle1(this.__wbg_ptr, t);
    }
    jointBodyHandle2(t) {
      return d.rawimpulsejointset_jointBodyHandle2(this.__wbg_ptr, t);
    }
    jointFrameX1(t) {
      const e = d.rawimpulsejointset_jointFrameX1(this.__wbg_ptr, t);
      return bt.__wrap(e);
    }
    jointFrameX2(t) {
      const e = d.rawimpulsejointset_jointFrameX2(this.__wbg_ptr, t);
      return bt.__wrap(e);
    }
    jointAnchor1(t) {
      const e = d.rawimpulsejointset_jointAnchor1(this.__wbg_ptr, t);
      return F.__wrap(e);
    }
    jointAnchor2(t) {
      const e = d.rawimpulsejointset_jointAnchor2(this.__wbg_ptr, t);
      return F.__wrap(e);
    }
    jointSetAnchor1(t, e) {
      M(e, F), d.rawimpulsejointset_jointSetAnchor1(this.__wbg_ptr, t, e.__wbg_ptr);
    }
    jointSetAnchor2(t, e) {
      M(e, F), d.rawimpulsejointset_jointSetAnchor2(this.__wbg_ptr, t, e.__wbg_ptr);
    }
    jointContactsEnabled(t) {
      return d.rawimpulsejointset_jointContactsEnabled(this.__wbg_ptr, t) !== 0;
    }
    jointSetContactsEnabled(t, e) {
      d.rawimpulsejointset_jointSetContactsEnabled(this.__wbg_ptr, t, e);
    }
    jointLimitsEnabled(t, e) {
      return d.rawimpulsejointset_jointLimitsEnabled(this.__wbg_ptr, t, e) !== 0;
    }
    jointLimitsMin(t, e) {
      return d.rawimpulsejointset_jointLimitsMin(this.__wbg_ptr, t, e);
    }
    jointLimitsMax(t, e) {
      return d.rawimpulsejointset_jointLimitsMax(this.__wbg_ptr, t, e);
    }
    jointSetLimits(t, e, r, n) {
      d.rawimpulsejointset_jointSetLimits(this.__wbg_ptr, t, e, r, n);
    }
    jointConfigureMotorModel(t, e, r) {
      d.rawimpulsejointset_jointConfigureMotorModel(this.__wbg_ptr, t, e, r);
    }
    jointConfigureMotorVelocity(t, e, r, n) {
      d.rawimpulsejointset_jointConfigureMotorVelocity(this.__wbg_ptr, t, e, r, n);
    }
    jointConfigureMotorPosition(t, e, r, n, s) {
      d.rawimpulsejointset_jointConfigureMotorPosition(this.__wbg_ptr, t, e, r, n, s);
    }
    jointConfigureMotor(t, e, r, n, s, o) {
      d.rawimpulsejointset_jointConfigureMotor(this.__wbg_ptr, t, e, r, n, s, o);
    }
    constructor() {
      const t = d.rawimpulsejointset_new();
      return this.__wbg_ptr = t >>> 0, this;
    }
    createJoint(t, e, r, n) {
      return M(t, qe), d.rawimpulsejointset_createJoint(this.__wbg_ptr, t.__wbg_ptr, e, r, n);
    }
    remove(t, e) {
      d.rawimpulsejointset_remove(this.__wbg_ptr, t, e);
    }
    len() {
      return d.rawimpulsejointset_len(this.__wbg_ptr) >>> 0;
    }
    contains(t) {
      return d.rawimpulsejointset_contains(this.__wbg_ptr, t) !== 0;
    }
    forEachJointHandle(t) {
      try {
        d.rawimpulsejointset_forEachJointHandle(this.__wbg_ptr, Gt(t));
      } finally {
        mt[Rt++] = void 0;
      }
    }
    forEachJointAttachedToRigidBody(t, e) {
      try {
        d.rawimpulsejointset_forEachJointAttachedToRigidBody(this.__wbg_ptr, t, Gt(e));
      } finally {
        mt[Rt++] = void 0;
      }
    }
  }
  const il = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => d.__wbg_rawintegrationparameters_free(i >>> 0));
  class Mr {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(Mr.prototype);
      return e.__wbg_ptr = t, il.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, il.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      d.__wbg_rawintegrationparameters_free(t);
    }
    constructor() {
      const t = d.rawintegrationparameters_new();
      return this.__wbg_ptr = t >>> 0, this;
    }
    get dt() {
      return d.rawintegrationparameters_dt(this.__wbg_ptr);
    }
    get contact_erp() {
      return d.rawintegrationparameters_contact_erp(this.__wbg_ptr);
    }
    get normalizedAllowedLinearError() {
      return d.rawcontactforceevent_max_force_magnitude(this.__wbg_ptr);
    }
    get normalizedPredictionDistance() {
      return d.rawintegrationparameters_normalizedPredictionDistance(this.__wbg_ptr);
    }
    get numSolverIterations() {
      return d.rawintegrationparameters_numSolverIterations(this.__wbg_ptr) >>> 0;
    }
    get numAdditionalFrictionIterations() {
      return d.rawintegrationparameters_numAdditionalFrictionIterations(this.__wbg_ptr) >>> 0;
    }
    get numInternalPgsIterations() {
      return d.rawintegrationparameters_numInternalPgsIterations(this.__wbg_ptr) >>> 0;
    }
    get minIslandSize() {
      return d.rawimpulsejointset_len(this.__wbg_ptr) >>> 0;
    }
    get maxCcdSubsteps() {
      return d.rawintegrationparameters_maxCcdSubsteps(this.__wbg_ptr) >>> 0;
    }
    get lengthUnit() {
      return d.rawcontactforceevent_total_force_magnitude(this.__wbg_ptr);
    }
    set dt(t) {
      d.rawintegrationparameters_set_dt(this.__wbg_ptr, t);
    }
    set contact_natural_frequency(t) {
      d.rawintegrationparameters_set_contact_natural_frequency(this.__wbg_ptr, t);
    }
    set normalizedAllowedLinearError(t) {
      d.rawintegrationparameters_set_normalizedAllowedLinearError(this.__wbg_ptr, t);
    }
    set normalizedPredictionDistance(t) {
      d.rawintegrationparameters_set_normalizedPredictionDistance(this.__wbg_ptr, t);
    }
    set numSolverIterations(t) {
      d.rawintegrationparameters_set_numSolverIterations(this.__wbg_ptr, t);
    }
    set numAdditionalFrictionIterations(t) {
      d.rawintegrationparameters_set_numAdditionalFrictionIterations(this.__wbg_ptr, t);
    }
    set numInternalPgsIterations(t) {
      d.rawintegrationparameters_set_numInternalPgsIterations(this.__wbg_ptr, t);
    }
    set minIslandSize(t) {
      d.rawintegrationparameters_set_minIslandSize(this.__wbg_ptr, t);
    }
    set maxCcdSubsteps(t) {
      d.rawintegrationparameters_set_maxCcdSubsteps(this.__wbg_ptr, t);
    }
    set lengthUnit(t) {
      d.rawintegrationparameters_set_lengthUnit(this.__wbg_ptr, t);
    }
    switchToStandardPgsSolver() {
      d.rawintegrationparameters_switchToStandardPgsSolver(this.__wbg_ptr);
    }
    switchToSmallStepsPgsSolver() {
      d.rawintegrationparameters_switchToSmallStepsPgsSolver(this.__wbg_ptr);
    }
    switchToSmallStepsPgsSolverWithoutWarmstart() {
      d.rawintegrationparameters_switchToSmallStepsPgsSolverWithoutWarmstart(this.__wbg_ptr);
    }
  }
  const nl = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => d.__wbg_rawislandmanager_free(i >>> 0));
  class tr {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(tr.prototype);
      return e.__wbg_ptr = t, nl.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, nl.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      d.__wbg_rawislandmanager_free(t);
    }
    constructor() {
      const t = d.rawislandmanager_new();
      return this.__wbg_ptr = t >>> 0, this;
    }
    forEachActiveRigidBodyHandle(t) {
      try {
        d.rawislandmanager_forEachActiveRigidBodyHandle(this.__wbg_ptr, Gt(t));
      } finally {
        mt[Rt++] = void 0;
      }
    }
  }
  const kx = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => d.__wbg_rawkinematiccharactercontroller_free(i >>> 0));
  class Gx {
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, kx.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      d.__wbg_rawkinematiccharactercontroller_free(t);
    }
    constructor(t) {
      const e = d.rawkinematiccharactercontroller_new(t);
      return this.__wbg_ptr = e >>> 0, this;
    }
    up() {
      const t = d.rawcollidershapecasthit_normal2(this.__wbg_ptr);
      return F.__wrap(t);
    }
    setUp(t) {
      M(t, F), d.rawkinematiccharactercontroller_setUp(this.__wbg_ptr, t.__wbg_ptr);
    }
    normalNudgeFactor() {
      return d.rawkinematiccharactercontroller_normalNudgeFactor(this.__wbg_ptr);
    }
    setNormalNudgeFactor(t) {
      d.rawkinematiccharactercontroller_setNormalNudgeFactor(this.__wbg_ptr, t);
    }
    offset() {
      return d.rawintegrationparameters_dt(this.__wbg_ptr);
    }
    setOffset(t) {
      d.rawkinematiccharactercontroller_setOffset(this.__wbg_ptr, t);
    }
    slideEnabled() {
      return d.rawkinematiccharactercontroller_slideEnabled(this.__wbg_ptr) !== 0;
    }
    setSlideEnabled(t) {
      d.rawkinematiccharactercontroller_setSlideEnabled(this.__wbg_ptr, t);
    }
    autostepMaxHeight() {
      try {
        const r = d.__wbindgen_add_to_stack_pointer(-16);
        d.rawkinematiccharactercontroller_autostepMaxHeight(r, this.__wbg_ptr);
        var t = It()[r / 4 + 0], e = ur()[r / 4 + 1];
        return t === 0 ? void 0 : e;
      } finally {
        d.__wbindgen_add_to_stack_pointer(16);
      }
    }
    autostepMinWidth() {
      try {
        const r = d.__wbindgen_add_to_stack_pointer(-16);
        d.rawkinematiccharactercontroller_autostepMinWidth(r, this.__wbg_ptr);
        var t = It()[r / 4 + 0], e = ur()[r / 4 + 1];
        return t === 0 ? void 0 : e;
      } finally {
        d.__wbindgen_add_to_stack_pointer(16);
      }
    }
    autostepIncludesDynamicBodies() {
      const t = d.rawkinematiccharactercontroller_autostepIncludesDynamicBodies(this.__wbg_ptr);
      return t === 16777215 ? void 0 : t !== 0;
    }
    autostepEnabled() {
      return d.rawkinematiccharactercontroller_autostepEnabled(this.__wbg_ptr) !== 0;
    }
    enableAutostep(t, e, r) {
      d.rawkinematiccharactercontroller_enableAutostep(this.__wbg_ptr, t, e, r);
    }
    disableAutostep() {
      d.rawkinematiccharactercontroller_disableAutostep(this.__wbg_ptr);
    }
    maxSlopeClimbAngle() {
      return d.rawintegrationparameters_normalizedPredictionDistance(this.__wbg_ptr);
    }
    setMaxSlopeClimbAngle(t) {
      d.rawintegrationparameters_set_normalizedPredictionDistance(this.__wbg_ptr, t);
    }
    minSlopeSlideAngle() {
      return d.rawkinematiccharactercontroller_minSlopeSlideAngle(this.__wbg_ptr);
    }
    setMinSlopeSlideAngle(t) {
      d.rawkinematiccharactercontroller_setMinSlopeSlideAngle(this.__wbg_ptr, t);
    }
    snapToGroundDistance() {
      try {
        const r = d.__wbindgen_add_to_stack_pointer(-16);
        d.rawkinematiccharactercontroller_snapToGroundDistance(r, this.__wbg_ptr);
        var t = It()[r / 4 + 0], e = ur()[r / 4 + 1];
        return t === 0 ? void 0 : e;
      } finally {
        d.__wbindgen_add_to_stack_pointer(16);
      }
    }
    enableSnapToGround(t) {
      d.rawkinematiccharactercontroller_enableSnapToGround(this.__wbg_ptr, t);
    }
    disableSnapToGround() {
      d.rawkinematiccharactercontroller_disableSnapToGround(this.__wbg_ptr);
    }
    snapToGroundEnabled() {
      return d.rawkinematiccharactercontroller_snapToGroundEnabled(this.__wbg_ptr) !== 0;
    }
    computeColliderMovement(t, e, r, n, s, o, a, c, u, l, h) {
      try {
        M(e, Wt), M(r, Nt), M(n, Qf), M(o, F), d.rawkinematiccharactercontroller_computeColliderMovement(this.__wbg_ptr, t, e.__wbg_ptr, r.__wbg_ptr, n.__wbg_ptr, s, o.__wbg_ptr, a, !et(c), et(c) ? 0 : c, u, !et(l), et(l) ? 0 : l, Gt(h));
      } finally {
        mt[Rt++] = void 0;
      }
    }
    computedMovement() {
      const t = d.rawkinematiccharactercontroller_computedMovement(this.__wbg_ptr);
      return F.__wrap(t);
    }
    computedGrounded() {
      return d.rawkinematiccharactercontroller_computedGrounded(this.__wbg_ptr) !== 0;
    }
    numComputedCollisions() {
      return d.rawkinematiccharactercontroller_numComputedCollisions(this.__wbg_ptr) >>> 0;
    }
    computedCollision(t, e) {
      return M(e, Jf), d.rawkinematiccharactercontroller_computedCollision(this.__wbg_ptr, t, e.__wbg_ptr) !== 0;
    }
  }
  const sl = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => d.__wbg_rawmultibodyjointset_free(i >>> 0));
  class er {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(er.prototype);
      return e.__wbg_ptr = t, sl.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, sl.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      d.__wbg_rawmultibodyjointset_free(t);
    }
    jointType(t) {
      return d.rawmultibodyjointset_jointType(this.__wbg_ptr, t);
    }
    jointFrameX1(t) {
      const e = d.rawmultibodyjointset_jointFrameX1(this.__wbg_ptr, t);
      return bt.__wrap(e);
    }
    jointFrameX2(t) {
      const e = d.rawmultibodyjointset_jointFrameX2(this.__wbg_ptr, t);
      return bt.__wrap(e);
    }
    jointAnchor1(t) {
      const e = d.rawmultibodyjointset_jointAnchor1(this.__wbg_ptr, t);
      return F.__wrap(e);
    }
    jointAnchor2(t) {
      const e = d.rawmultibodyjointset_jointAnchor2(this.__wbg_ptr, t);
      return F.__wrap(e);
    }
    jointContactsEnabled(t) {
      return d.rawmultibodyjointset_jointContactsEnabled(this.__wbg_ptr, t) !== 0;
    }
    jointSetContactsEnabled(t, e) {
      d.rawmultibodyjointset_jointSetContactsEnabled(this.__wbg_ptr, t, e);
    }
    jointLimitsEnabled(t, e) {
      return d.rawmultibodyjointset_jointLimitsEnabled(this.__wbg_ptr, t, e) !== 0;
    }
    jointLimitsMin(t, e) {
      return d.rawmultibodyjointset_jointLimitsMin(this.__wbg_ptr, t, e);
    }
    jointLimitsMax(t, e) {
      return d.rawmultibodyjointset_jointLimitsMax(this.__wbg_ptr, t, e);
    }
    constructor() {
      const t = d.rawmultibodyjointset_new();
      return this.__wbg_ptr = t >>> 0, this;
    }
    createJoint(t, e, r, n) {
      return M(t, qe), d.rawmultibodyjointset_createJoint(this.__wbg_ptr, t.__wbg_ptr, e, r, n);
    }
    remove(t, e) {
      d.rawmultibodyjointset_remove(this.__wbg_ptr, t, e);
    }
    contains(t) {
      return d.rawmultibodyjointset_contains(this.__wbg_ptr, t) !== 0;
    }
    forEachJointHandle(t) {
      try {
        d.rawmultibodyjointset_forEachJointHandle(this.__wbg_ptr, Gt(t));
      } finally {
        mt[Rt++] = void 0;
      }
    }
    forEachJointAttachedToRigidBody(t, e) {
      try {
        d.rawmultibodyjointset_forEachJointAttachedToRigidBody(this.__wbg_ptr, t, Gt(e));
      } finally {
        mt[Rt++] = void 0;
      }
    }
  }
  const ol = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => d.__wbg_rawnarrowphase_free(i >>> 0));
  class dr {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(dr.prototype);
      return e.__wbg_ptr = t, ol.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, ol.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      d.__wbg_rawnarrowphase_free(t);
    }
    constructor() {
      const t = d.rawnarrowphase_new();
      return this.__wbg_ptr = t >>> 0, this;
    }
    contact_pairs_with(t, e) {
      d.rawnarrowphase_contact_pairs_with(this.__wbg_ptr, t, Vt(e));
    }
    contact_pair(t, e) {
      const r = d.rawnarrowphase_contact_pair(this.__wbg_ptr, t, e);
      return r === 0 ? void 0 : Ga.__wrap(r);
    }
    intersection_pairs_with(t, e) {
      d.rawnarrowphase_intersection_pairs_with(this.__wbg_ptr, t, Vt(e));
    }
    intersection_pair(t, e) {
      return d.rawnarrowphase_intersection_pair(this.__wbg_ptr, t, e) !== 0;
    }
  }
  const Ox = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => d.__wbg_rawphysicspipeline_free(i >>> 0));
  class Nx {
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, Ox.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      d.__wbg_rawphysicspipeline_free(t);
    }
    constructor() {
      const t = d.rawphysicspipeline_new();
      return this.__wbg_ptr = t >>> 0, this;
    }
    step(t, e, r, n, s, o, a, c, u, l) {
      M(t, F), M(e, Mr), M(r, tr), M(n, Br), M(s, dr), M(o, Wt), M(a, Nt), M(c, Qe), M(u, er), M(l, jo), d.rawphysicspipeline_step(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, r.__wbg_ptr, n.__wbg_ptr, s.__wbg_ptr, o.__wbg_ptr, a.__wbg_ptr, c.__wbg_ptr, u.__wbg_ptr, l.__wbg_ptr);
    }
    stepWithEvents(t, e, r, n, s, o, a, c, u, l, h, f, p, m) {
      M(t, F), M(e, Mr), M(r, tr), M(n, Br), M(s, dr), M(o, Wt), M(a, Nt), M(c, Qe), M(u, er), M(l, jo), M(h, Ux), d.rawphysicspipeline_stepWithEvents(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, r.__wbg_ptr, n.__wbg_ptr, s.__wbg_ptr, o.__wbg_ptr, a.__wbg_ptr, c.__wbg_ptr, u.__wbg_ptr, l.__wbg_ptr, h.__wbg_ptr, Vt(f), Vt(p), Vt(m));
    }
  }
  const al = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => d.__wbg_rawpointcolliderprojection_free(i >>> 0));
  class Hn {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(Hn.prototype);
      return e.__wbg_ptr = t, al.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, al.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      d.__wbg_rawpointcolliderprojection_free(t);
    }
    colliderHandle() {
      return d.rawpointcolliderprojection_colliderHandle(this.__wbg_ptr);
    }
    point() {
      const t = d.rawpointcolliderprojection_point(this.__wbg_ptr);
      return F.__wrap(t);
    }
    isInside() {
      return d.rawpointcolliderprojection_isInside(this.__wbg_ptr) !== 0;
    }
    featureType() {
      return d.rawpointcolliderprojection_featureType(this.__wbg_ptr);
    }
    featureId() {
      try {
        const r = d.__wbindgen_add_to_stack_pointer(-16);
        d.rawpointcolliderprojection_featureId(r, this.__wbg_ptr);
        var t = It()[r / 4 + 0], e = It()[r / 4 + 1];
        return t === 0 ? void 0 : e >>> 0;
      } finally {
        d.__wbindgen_add_to_stack_pointer(16);
      }
    }
  }
  const cl = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => d.__wbg_rawpointprojection_free(i >>> 0));
  class as {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(as.prototype);
      return e.__wbg_ptr = t, cl.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, cl.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      d.__wbg_rawpointprojection_free(t);
    }
    point() {
      const t = d.rawpointprojection_point(this.__wbg_ptr);
      return F.__wrap(t);
    }
    isInside() {
      return d.rawpointprojection_isInside(this.__wbg_ptr) !== 0;
    }
  }
  const Lx = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => d.__wbg_rawquerypipeline_free(i >>> 0));
  class Qf {
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, Lx.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      d.__wbg_rawquerypipeline_free(t);
    }
    constructor() {
      const t = d.rawquerypipeline_new();
      return this.__wbg_ptr = t >>> 0, this;
    }
    update(t) {
      M(t, Nt), d.rawquerypipeline_update(this.__wbg_ptr, t.__wbg_ptr);
    }
    castRay(t, e, r, n, s, o, a, c, u, l, h) {
      try {
        M(t, Wt), M(e, Nt), M(r, F), M(n, F);
        const f = d.rawquerypipeline_castRay(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, r.__wbg_ptr, n.__wbg_ptr, s, o, a, !et(c), et(c) ? 0 : c, !et(u), et(u) ? 0 : u, !et(l), et(l) ? 0 : l, Gt(h));
        return f === 0 ? void 0 : Na.__wrap(f);
      } finally {
        mt[Rt++] = void 0;
      }
    }
    castRayAndGetNormal(t, e, r, n, s, o, a, c, u, l, h) {
      try {
        M(t, Wt), M(e, Nt), M(r, F), M(n, F);
        const f = d.rawquerypipeline_castRayAndGetNormal(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, r.__wbg_ptr, n.__wbg_ptr, s, o, a, !et(c), et(c) ? 0 : c, !et(u), et(u) ? 0 : u, !et(l), et(l) ? 0 : l, Gt(h));
        return f === 0 ? void 0 : cs.__wrap(f);
      } finally {
        mt[Rt++] = void 0;
      }
    }
    intersectionsWithRay(t, e, r, n, s, o, a, c, u, l, h, f) {
      try {
        M(t, Wt), M(e, Nt), M(r, F), M(n, F), d.rawquerypipeline_intersectionsWithRay(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, r.__wbg_ptr, n.__wbg_ptr, s, o, Gt(a), c, !et(u), et(u) ? 0 : u, !et(l), et(l) ? 0 : l, !et(h), et(h) ? 0 : h, Gt(f));
      } finally {
        mt[Rt++] = void 0, mt[Rt++] = void 0;
      }
    }
    intersectionWithShape(t, e, r, n, s, o, a, c, u, l) {
      try {
        const p = d.__wbindgen_add_to_stack_pointer(-16);
        M(t, Wt), M(e, Nt), M(r, F), M(n, bt), M(s, ct), d.rawquerypipeline_intersectionWithShape(p, this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, r.__wbg_ptr, n.__wbg_ptr, s.__wbg_ptr, o, !et(a), et(a) ? 0 : a, !et(c), et(c) ? 0 : c, !et(u), et(u) ? 0 : u, Gt(l));
        var h = It()[p / 4 + 0], f = Ln()[p / 8 + 1];
        return h === 0 ? void 0 : f;
      } finally {
        d.__wbindgen_add_to_stack_pointer(16), mt[Rt++] = void 0;
      }
    }
    projectPoint(t, e, r, n, s, o, a, c, u) {
      try {
        M(t, Wt), M(e, Nt), M(r, F);
        const l = d.rawquerypipeline_projectPoint(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, r.__wbg_ptr, n, s, !et(o), et(o) ? 0 : o, !et(a), et(a) ? 0 : a, !et(c), et(c) ? 0 : c, Gt(u));
        return l === 0 ? void 0 : Hn.__wrap(l);
      } finally {
        mt[Rt++] = void 0;
      }
    }
    projectPointAndGetFeature(t, e, r, n, s, o, a, c) {
      try {
        M(t, Wt), M(e, Nt), M(r, F);
        const u = d.rawquerypipeline_projectPointAndGetFeature(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, r.__wbg_ptr, n, !et(s), et(s) ? 0 : s, !et(o), et(o) ? 0 : o, !et(a), et(a) ? 0 : a, Gt(c));
        return u === 0 ? void 0 : Hn.__wrap(u);
      } finally {
        mt[Rt++] = void 0;
      }
    }
    intersectionsWithPoint(t, e, r, n, s, o, a, c, u) {
      try {
        M(t, Wt), M(e, Nt), M(r, F), d.rawquerypipeline_intersectionsWithPoint(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, r.__wbg_ptr, Gt(n), s, !et(o), et(o) ? 0 : o, !et(a), et(a) ? 0 : a, !et(c), et(c) ? 0 : c, Gt(u));
      } finally {
        mt[Rt++] = void 0, mt[Rt++] = void 0;
      }
    }
    castShape(t, e, r, n, s, o, a, c, u, l, h, f, p, m) {
      try {
        M(t, Wt), M(e, Nt), M(r, F), M(n, bt), M(s, F), M(o, ct);
        const y = d.rawquerypipeline_castShape(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, r.__wbg_ptr, n.__wbg_ptr, s.__wbg_ptr, o.__wbg_ptr, a, c, u, l, !et(h), et(h) ? 0 : h, !et(f), et(f) ? 0 : f, !et(p), et(p) ? 0 : p, Gt(m));
        return y === 0 ? void 0 : os.__wrap(y);
      } finally {
        mt[Rt++] = void 0;
      }
    }
    intersectionsWithShape(t, e, r, n, s, o, a, c, u, l, h) {
      try {
        M(t, Wt), M(e, Nt), M(r, F), M(n, bt), M(s, ct), d.rawquerypipeline_intersectionsWithShape(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, r.__wbg_ptr, n.__wbg_ptr, s.__wbg_ptr, Gt(o), a, !et(c), et(c) ? 0 : c, !et(u), et(u) ? 0 : u, !et(l), et(l) ? 0 : l, Gt(h));
      } finally {
        mt[Rt++] = void 0, mt[Rt++] = void 0;
      }
    }
    collidersWithAabbIntersectingAabb(t, e, r) {
      try {
        M(t, F), M(e, F), d.rawquerypipeline_collidersWithAabbIntersectingAabb(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, Gt(r));
      } finally {
        mt[Rt++] = void 0;
      }
    }
  }
  const ul = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => d.__wbg_rawraycolliderhit_free(i >>> 0));
  class Na {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(Na.prototype);
      return e.__wbg_ptr = t, ul.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, ul.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      d.__wbg_rawraycolliderhit_free(t);
    }
    colliderHandle() {
      return d.rawcollidershapecasthit_colliderHandle(this.__wbg_ptr);
    }
    timeOfImpact() {
      return d.rawcollidershapecasthit_time_of_impact(this.__wbg_ptr);
    }
  }
  const ll = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => d.__wbg_rawraycolliderintersection_free(i >>> 0));
  class cs {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(cs.prototype);
      return e.__wbg_ptr = t, ll.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, ll.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      d.__wbg_rawraycolliderintersection_free(t);
    }
    colliderHandle() {
      return d.rawpointcolliderprojection_colliderHandle(this.__wbg_ptr);
    }
    normal() {
      const t = d.rawcollidershapecasthit_witness1(this.__wbg_ptr);
      return F.__wrap(t);
    }
    time_of_impact() {
      return d.rawcollidershapecasthit_time_of_impact(this.__wbg_ptr);
    }
    featureType() {
      return d.rawpointcolliderprojection_featureType(this.__wbg_ptr);
    }
    featureId() {
      try {
        const r = d.__wbindgen_add_to_stack_pointer(-16);
        d.rawpointcolliderprojection_featureId(r, this.__wbg_ptr);
        var t = It()[r / 4 + 0], e = It()[r / 4 + 1];
        return t === 0 ? void 0 : e >>> 0;
      } finally {
        d.__wbindgen_add_to_stack_pointer(16);
      }
    }
  }
  const hl = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => d.__wbg_rawrayintersection_free(i >>> 0));
  class us {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(us.prototype);
      return e.__wbg_ptr = t, hl.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, hl.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      d.__wbg_rawrayintersection_free(t);
    }
    normal() {
      const t = d.rawcollidershapecasthit_witness1(this.__wbg_ptr);
      return F.__wrap(t);
    }
    time_of_impact() {
      return d.rawcollidershapecasthit_time_of_impact(this.__wbg_ptr);
    }
    featureType() {
      return d.rawpointcolliderprojection_featureType(this.__wbg_ptr);
    }
    featureId() {
      try {
        const r = d.__wbindgen_add_to_stack_pointer(-16);
        d.rawpointcolliderprojection_featureId(r, this.__wbg_ptr);
        var t = It()[r / 4 + 0], e = It()[r / 4 + 1];
        return t === 0 ? void 0 : e >>> 0;
      } finally {
        d.__wbindgen_add_to_stack_pointer(16);
      }
    }
  }
  const dl = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => d.__wbg_rawrigidbodyset_free(i >>> 0));
  class Wt {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(Wt.prototype);
      return e.__wbg_ptr = t, dl.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, dl.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      d.__wbg_rawrigidbodyset_free(t);
    }
    rbTranslation(t) {
      const e = d.rawrigidbodyset_rbTranslation(this.__wbg_ptr, t);
      return F.__wrap(e);
    }
    rbRotation(t) {
      const e = d.rawrigidbodyset_rbRotation(this.__wbg_ptr, t);
      return bt.__wrap(e);
    }
    rbSleep(t) {
      d.rawrigidbodyset_rbSleep(this.__wbg_ptr, t);
    }
    rbIsSleeping(t) {
      return d.rawrigidbodyset_rbIsSleeping(this.__wbg_ptr, t) !== 0;
    }
    rbIsMoving(t) {
      return d.rawrigidbodyset_rbIsMoving(this.__wbg_ptr, t) !== 0;
    }
    rbNextTranslation(t) {
      const e = d.rawrigidbodyset_rbNextTranslation(this.__wbg_ptr, t);
      return F.__wrap(e);
    }
    rbNextRotation(t) {
      const e = d.rawrigidbodyset_rbNextRotation(this.__wbg_ptr, t);
      return bt.__wrap(e);
    }
    rbSetTranslation(t, e, r, n) {
      d.rawrigidbodyset_rbSetTranslation(this.__wbg_ptr, t, e, r, n);
    }
    rbSetRotation(t, e, r) {
      d.rawrigidbodyset_rbSetRotation(this.__wbg_ptr, t, e, r);
    }
    rbSetLinvel(t, e, r) {
      M(e, F), d.rawrigidbodyset_rbSetLinvel(this.__wbg_ptr, t, e.__wbg_ptr, r);
    }
    rbSetAngvel(t, e, r) {
      d.rawrigidbodyset_rbSetAngvel(this.__wbg_ptr, t, e, r);
    }
    rbSetNextKinematicTranslation(t, e, r) {
      d.rawrigidbodyset_rbSetNextKinematicTranslation(this.__wbg_ptr, t, e, r);
    }
    rbSetNextKinematicRotation(t, e) {
      d.rawrigidbodyset_rbSetNextKinematicRotation(this.__wbg_ptr, t, e);
    }
    rbRecomputeMassPropertiesFromColliders(t, e) {
      M(e, Nt), d.rawrigidbodyset_rbRecomputeMassPropertiesFromColliders(this.__wbg_ptr, t, e.__wbg_ptr);
    }
    rbSetAdditionalMass(t, e, r) {
      d.rawrigidbodyset_rbSetAdditionalMass(this.__wbg_ptr, t, e, r);
    }
    rbSetAdditionalMassProperties(t, e, r, n, s) {
      M(r, F), d.rawrigidbodyset_rbSetAdditionalMassProperties(this.__wbg_ptr, t, e, r.__wbg_ptr, n, s);
    }
    rbLinvel(t) {
      const e = d.rawrigidbodyset_rbLinvel(this.__wbg_ptr, t);
      return F.__wrap(e);
    }
    rbAngvel(t) {
      return d.rawrigidbodyset_rbAngvel(this.__wbg_ptr, t);
    }
    rbLockTranslations(t, e, r) {
      d.rawrigidbodyset_rbLockTranslations(this.__wbg_ptr, t, e, r);
    }
    rbSetEnabledTranslations(t, e, r, n) {
      d.rawrigidbodyset_rbSetEnabledTranslations(this.__wbg_ptr, t, e, r, n);
    }
    rbLockRotations(t, e, r) {
      d.rawrigidbodyset_rbLockRotations(this.__wbg_ptr, t, e, r);
    }
    rbDominanceGroup(t) {
      return d.rawrigidbodyset_rbDominanceGroup(this.__wbg_ptr, t);
    }
    rbSetDominanceGroup(t, e) {
      d.rawrigidbodyset_rbSetDominanceGroup(this.__wbg_ptr, t, e);
    }
    rbEnableCcd(t, e) {
      d.rawrigidbodyset_rbEnableCcd(this.__wbg_ptr, t, e);
    }
    rbSetSoftCcdPrediction(t, e) {
      d.rawrigidbodyset_rbSetSoftCcdPrediction(this.__wbg_ptr, t, e);
    }
    rbMass(t) {
      return d.rawrigidbodyset_rbMass(this.__wbg_ptr, t);
    }
    rbInvMass(t) {
      return d.rawrigidbodyset_rbInvMass(this.__wbg_ptr, t);
    }
    rbEffectiveInvMass(t) {
      const e = d.rawrigidbodyset_rbEffectiveInvMass(this.__wbg_ptr, t);
      return F.__wrap(e);
    }
    rbLocalCom(t) {
      const e = d.rawrigidbodyset_rbLocalCom(this.__wbg_ptr, t);
      return F.__wrap(e);
    }
    rbWorldCom(t) {
      const e = d.rawrigidbodyset_rbWorldCom(this.__wbg_ptr, t);
      return F.__wrap(e);
    }
    rbInvPrincipalInertiaSqrt(t) {
      return d.rawrigidbodyset_rbInvPrincipalInertiaSqrt(this.__wbg_ptr, t);
    }
    rbPrincipalInertia(t) {
      return d.rawrigidbodyset_rbPrincipalInertia(this.__wbg_ptr, t);
    }
    rbEffectiveWorldInvInertiaSqrt(t) {
      return d.rawrigidbodyset_rbEffectiveWorldInvInertiaSqrt(this.__wbg_ptr, t);
    }
    rbEffectiveAngularInertia(t) {
      return d.rawrigidbodyset_rbEffectiveAngularInertia(this.__wbg_ptr, t);
    }
    rbWakeUp(t) {
      d.rawrigidbodyset_rbWakeUp(this.__wbg_ptr, t);
    }
    rbIsCcdEnabled(t) {
      return d.rawrigidbodyset_rbIsCcdEnabled(this.__wbg_ptr, t) !== 0;
    }
    rbSoftCcdPrediction(t) {
      return d.rawrigidbodyset_rbSoftCcdPrediction(this.__wbg_ptr, t);
    }
    rbNumColliders(t) {
      return d.rawrigidbodyset_rbNumColliders(this.__wbg_ptr, t) >>> 0;
    }
    rbCollider(t, e) {
      return d.rawrigidbodyset_rbCollider(this.__wbg_ptr, t, e);
    }
    rbBodyType(t) {
      return d.rawrigidbodyset_rbBodyType(this.__wbg_ptr, t);
    }
    rbSetBodyType(t, e, r) {
      d.rawrigidbodyset_rbSetBodyType(this.__wbg_ptr, t, e, r);
    }
    rbIsFixed(t) {
      return d.rawrigidbodyset_rbIsFixed(this.__wbg_ptr, t) !== 0;
    }
    rbIsKinematic(t) {
      return d.rawrigidbodyset_rbIsKinematic(this.__wbg_ptr, t) !== 0;
    }
    rbIsDynamic(t) {
      return d.rawrigidbodyset_rbIsDynamic(this.__wbg_ptr, t) !== 0;
    }
    rbLinearDamping(t) {
      return d.rawrigidbodyset_rbLinearDamping(this.__wbg_ptr, t);
    }
    rbAngularDamping(t) {
      return d.rawrigidbodyset_rbAngularDamping(this.__wbg_ptr, t);
    }
    rbSetLinearDamping(t, e) {
      d.rawrigidbodyset_rbSetLinearDamping(this.__wbg_ptr, t, e);
    }
    rbSetAngularDamping(t, e) {
      d.rawrigidbodyset_rbSetAngularDamping(this.__wbg_ptr, t, e);
    }
    rbSetEnabled(t, e) {
      d.rawrigidbodyset_rbSetEnabled(this.__wbg_ptr, t, e);
    }
    rbIsEnabled(t) {
      return d.rawrigidbodyset_rbIsEnabled(this.__wbg_ptr, t) !== 0;
    }
    rbGravityScale(t) {
      return d.rawrigidbodyset_rbGravityScale(this.__wbg_ptr, t);
    }
    rbSetGravityScale(t, e, r) {
      d.rawrigidbodyset_rbSetGravityScale(this.__wbg_ptr, t, e, r);
    }
    rbResetForces(t, e) {
      d.rawrigidbodyset_rbResetForces(this.__wbg_ptr, t, e);
    }
    rbResetTorques(t, e) {
      d.rawrigidbodyset_rbResetTorques(this.__wbg_ptr, t, e);
    }
    rbAddForce(t, e, r) {
      M(e, F), d.rawrigidbodyset_rbAddForce(this.__wbg_ptr, t, e.__wbg_ptr, r);
    }
    rbApplyImpulse(t, e, r) {
      M(e, F), d.rawrigidbodyset_rbApplyImpulse(this.__wbg_ptr, t, e.__wbg_ptr, r);
    }
    rbAddTorque(t, e, r) {
      d.rawrigidbodyset_rbAddTorque(this.__wbg_ptr, t, e, r);
    }
    rbApplyTorqueImpulse(t, e, r) {
      d.rawrigidbodyset_rbApplyTorqueImpulse(this.__wbg_ptr, t, e, r);
    }
    rbAddForceAtPoint(t, e, r, n) {
      M(e, F), M(r, F), d.rawrigidbodyset_rbAddForceAtPoint(this.__wbg_ptr, t, e.__wbg_ptr, r.__wbg_ptr, n);
    }
    rbApplyImpulseAtPoint(t, e, r, n) {
      M(e, F), M(r, F), d.rawrigidbodyset_rbApplyImpulseAtPoint(this.__wbg_ptr, t, e.__wbg_ptr, r.__wbg_ptr, n);
    }
    rbAdditionalSolverIterations(t) {
      return d.rawrigidbodyset_rbAdditionalSolverIterations(this.__wbg_ptr, t) >>> 0;
    }
    rbSetAdditionalSolverIterations(t, e) {
      d.rawrigidbodyset_rbSetAdditionalSolverIterations(this.__wbg_ptr, t, e);
    }
    rbUserData(t) {
      return d.rawrigidbodyset_rbUserData(this.__wbg_ptr, t) >>> 0;
    }
    rbSetUserData(t, e) {
      d.rawrigidbodyset_rbSetUserData(this.__wbg_ptr, t, e);
    }
    rbUserForce(t) {
      const e = d.rawrigidbodyset_rbUserForce(this.__wbg_ptr, t);
      return F.__wrap(e);
    }
    rbUserTorque(t) {
      return d.rawrigidbodyset_rbUserTorque(this.__wbg_ptr, t);
    }
    constructor() {
      const t = d.rawrigidbodyset_new();
      return this.__wbg_ptr = t >>> 0, this;
    }
    createRigidBody(t, e, r, n, s, o, a, c, u, l, h, f, p, m, y, b, v, A, T, G, H, Y) {
      return M(e, F), M(r, bt), M(a, F), M(c, F), d.rawrigidbodyset_createRigidBody(this.__wbg_ptr, t, e.__wbg_ptr, r.__wbg_ptr, n, s, o, a.__wbg_ptr, c.__wbg_ptr, u, l, h, f, p, m, y, b, v, A, T, G, H, Y);
    }
    remove(t, e, r, n, s) {
      M(e, tr), M(r, Nt), M(n, Qe), M(s, er), d.rawrigidbodyset_remove(this.__wbg_ptr, t, e.__wbg_ptr, r.__wbg_ptr, n.__wbg_ptr, s.__wbg_ptr);
    }
    len() {
      return d.rawcolliderset_len(this.__wbg_ptr) >>> 0;
    }
    contains(t) {
      return d.rawrigidbodyset_contains(this.__wbg_ptr, t) !== 0;
    }
    forEachRigidBodyHandle(t) {
      try {
        d.rawrigidbodyset_forEachRigidBodyHandle(this.__wbg_ptr, Gt(t));
      } finally {
        mt[Rt++] = void 0;
      }
    }
    propagateModifiedBodyPositionsToColliders(t) {
      M(t, Nt), d.rawrigidbodyset_propagateModifiedBodyPositionsToColliders(this.__wbg_ptr, t.__wbg_ptr);
    }
  }
  const fl = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => d.__wbg_rawrotation_free(i >>> 0));
  class bt {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(bt.prototype);
      return e.__wbg_ptr = t, fl.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, fl.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      d.__wbg_rawrotation_free(t);
    }
    static identity() {
      const t = d.rawrotation_identity();
      return bt.__wrap(t);
    }
    static fromAngle(t) {
      const e = d.rawrotation_fromAngle(t);
      return bt.__wrap(e);
    }
    get im() {
      return d.rawintegrationparameters_dt(this.__wbg_ptr);
    }
    get re() {
      return d.rawrotation_re(this.__wbg_ptr);
    }
    get angle() {
      return d.rawrotation_angle(this.__wbg_ptr);
    }
  }
  const Hx = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => d.__wbg_rawserializationpipeline_free(i >>> 0));
  class zx {
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, Hx.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      d.__wbg_rawserializationpipeline_free(t);
    }
    constructor() {
      const t = d.rawserializationpipeline_new();
      return this.__wbg_ptr = t >>> 0, this;
    }
    serializeAll(t, e, r, n, s, o, a, c, u) {
      M(t, F), M(e, Mr), M(r, tr), M(n, Br), M(s, dr), M(o, Wt), M(a, Nt), M(c, Qe), M(u, er);
      const l = d.rawserializationpipeline_serializeAll(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, r.__wbg_ptr, n.__wbg_ptr, s.__wbg_ptr, o.__wbg_ptr, a.__wbg_ptr, c.__wbg_ptr, u.__wbg_ptr);
      return Nn(l);
    }
    deserializeAll(t) {
      const e = d.rawserializationpipeline_deserializeAll(this.__wbg_ptr, Vt(t));
      return e === 0 ? void 0 : Oa.__wrap(e);
    }
  }
  const pl = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => d.__wbg_rawshape_free(i >>> 0));
  class ct {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(ct.prototype);
      return e.__wbg_ptr = t, pl.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, pl.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      d.__wbg_rawshape_free(t);
    }
    static cuboid(t, e) {
      const r = d.rawshape_cuboid(t, e);
      return ct.__wrap(r);
    }
    static roundCuboid(t, e, r) {
      const n = d.rawshape_roundCuboid(t, e, r);
      return ct.__wrap(n);
    }
    static ball(t) {
      const e = d.rawshape_ball(t);
      return ct.__wrap(e);
    }
    static halfspace(t) {
      M(t, F);
      const e = d.rawshape_halfspace(t.__wbg_ptr);
      return ct.__wrap(e);
    }
    static capsule(t, e) {
      const r = d.rawshape_capsule(t, e);
      return ct.__wrap(r);
    }
    static polyline(t, e) {
      const r = vr(t, d.__wbindgen_malloc), n = Ce, s = qu(e, d.__wbindgen_malloc), o = Ce, a = d.rawshape_polyline(r, n, s, o);
      return ct.__wrap(a);
    }
    static trimesh(t, e, r) {
      const n = vr(t, d.__wbindgen_malloc), s = Ce, o = qu(e, d.__wbindgen_malloc), a = Ce, c = d.rawshape_trimesh(n, s, o, a, r);
      return ct.__wrap(c);
    }
    static heightfield(t, e) {
      const r = vr(t, d.__wbindgen_malloc), n = Ce;
      M(e, F);
      const s = d.rawshape_heightfield(r, n, e.__wbg_ptr);
      return ct.__wrap(s);
    }
    static segment(t, e) {
      M(t, F), M(e, F);
      const r = d.rawshape_segment(t.__wbg_ptr, e.__wbg_ptr);
      return ct.__wrap(r);
    }
    static triangle(t, e, r) {
      M(t, F), M(e, F), M(r, F);
      const n = d.rawshape_triangle(t.__wbg_ptr, e.__wbg_ptr, r.__wbg_ptr);
      return ct.__wrap(n);
    }
    static roundTriangle(t, e, r, n) {
      M(t, F), M(e, F), M(r, F);
      const s = d.rawshape_roundTriangle(t.__wbg_ptr, e.__wbg_ptr, r.__wbg_ptr, n);
      return ct.__wrap(s);
    }
    static convexHull(t) {
      const e = vr(t, d.__wbindgen_malloc), r = Ce, n = d.rawshape_convexHull(e, r);
      return n === 0 ? void 0 : ct.__wrap(n);
    }
    static roundConvexHull(t, e) {
      const r = vr(t, d.__wbindgen_malloc), n = Ce, s = d.rawshape_roundConvexHull(r, n, e);
      return s === 0 ? void 0 : ct.__wrap(s);
    }
    static convexPolyline(t) {
      const e = vr(t, d.__wbindgen_malloc), r = Ce, n = d.rawshape_convexPolyline(e, r);
      return n === 0 ? void 0 : ct.__wrap(n);
    }
    static roundConvexPolyline(t, e) {
      const r = vr(t, d.__wbindgen_malloc), n = Ce, s = d.rawshape_roundConvexPolyline(r, n, e);
      return s === 0 ? void 0 : ct.__wrap(s);
    }
    castShape(t, e, r, n, s, o, a, c, u, l) {
      M(t, F), M(e, bt), M(r, F), M(n, ct), M(s, F), M(o, bt), M(a, F);
      const h = d.rawshape_castShape(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, r.__wbg_ptr, n.__wbg_ptr, s.__wbg_ptr, o.__wbg_ptr, a.__wbg_ptr, c, u, l);
      return h === 0 ? void 0 : ls.__wrap(h);
    }
    intersectsShape(t, e, r, n, s) {
      return M(t, F), M(e, bt), M(r, ct), M(n, F), M(s, bt), d.rawshape_intersectsShape(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, r.__wbg_ptr, n.__wbg_ptr, s.__wbg_ptr) !== 0;
    }
    contactShape(t, e, r, n, s, o) {
      M(t, F), M(e, bt), M(r, ct), M(n, F), M(s, bt);
      const a = d.rawshape_contactShape(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, r.__wbg_ptr, n.__wbg_ptr, s.__wbg_ptr, o);
      return a === 0 ? void 0 : Pi.__wrap(a);
    }
    containsPoint(t, e, r) {
      return M(t, F), M(e, bt), M(r, F), d.rawshape_containsPoint(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, r.__wbg_ptr) !== 0;
    }
    projectPoint(t, e, r, n) {
      M(t, F), M(e, bt), M(r, F);
      const s = d.rawshape_projectPoint(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, r.__wbg_ptr, n);
      return as.__wrap(s);
    }
    intersectsRay(t, e, r, n, s) {
      return M(t, F), M(e, bt), M(r, F), M(n, F), d.rawshape_intersectsRay(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, r.__wbg_ptr, n.__wbg_ptr, s) !== 0;
    }
    castRay(t, e, r, n, s, o) {
      return M(t, F), M(e, bt), M(r, F), M(n, F), d.rawshape_castRay(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, r.__wbg_ptr, n.__wbg_ptr, s, o);
    }
    castRayAndGetNormal(t, e, r, n, s, o) {
      M(t, F), M(e, bt), M(r, F), M(n, F);
      const a = d.rawshape_castRayAndGetNormal(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, r.__wbg_ptr, n.__wbg_ptr, s, o);
      return a === 0 ? void 0 : us.__wrap(a);
    }
  }
  const _l = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => d.__wbg_rawshapecasthit_free(i >>> 0));
  class ls {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(ls.prototype);
      return e.__wbg_ptr = t, _l.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, _l.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      d.__wbg_rawshapecasthit_free(t);
    }
    time_of_impact() {
      return d.rawrotation_re(this.__wbg_ptr);
    }
    witness1() {
      const t = d.rawshapecasthit_witness1(this.__wbg_ptr);
      return F.__wrap(t);
    }
    witness2() {
      const t = d.rawcollidershapecasthit_witness1(this.__wbg_ptr);
      return F.__wrap(t);
    }
    normal1() {
      const t = d.rawcollidershapecasthit_witness2(this.__wbg_ptr);
      return F.__wrap(t);
    }
    normal2() {
      const t = d.rawcollidershapecasthit_normal1(this.__wbg_ptr);
      return F.__wrap(t);
    }
  }
  const gl = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => d.__wbg_rawshapecontact_free(i >>> 0));
  class Pi {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(Pi.prototype);
      return e.__wbg_ptr = t, gl.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, gl.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      d.__wbg_rawshapecontact_free(t);
    }
    distance() {
      return d.rawcontactforceevent_total_force_magnitude(this.__wbg_ptr);
    }
    point1() {
      const t = d.rawpointprojection_point(this.__wbg_ptr);
      return F.__wrap(t);
    }
    point2() {
      const t = d.rawpointcolliderprojection_point(this.__wbg_ptr);
      return F.__wrap(t);
    }
    normal1() {
      const t = d.rawcontactforceevent_total_force(this.__wbg_ptr);
      return F.__wrap(t);
    }
    normal2() {
      const t = d.rawcharactercollision_translationDeltaApplied(this.__wbg_ptr);
      return F.__wrap(t);
    }
  }
  const ml = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((i) => d.__wbg_rawvector_free(i >>> 0));
  class F {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(F.prototype);
      return e.__wbg_ptr = t, ml.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, ml.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      d.__wbg_rawvector_free(t);
    }
    static zero() {
      const t = d.rawvector_zero();
      return F.__wrap(t);
    }
    constructor(t, e) {
      const r = d.rawvector_new(t, e);
      return this.__wbg_ptr = r >>> 0, this;
    }
    get x() {
      return d.rawrotation_re(this.__wbg_ptr);
    }
    set x(t) {
      d.rawvector_set_x(this.__wbg_ptr, t);
    }
    get y() {
      return d.rawintegrationparameters_dt(this.__wbg_ptr);
    }
    set y(t) {
      d.rawintegrationparameters_set_dt(this.__wbg_ptr, t);
    }
    xy() {
      const t = d.rawvector_xy(this.__wbg_ptr);
      return F.__wrap(t);
    }
    yx() {
      const t = d.rawvector_yx(this.__wbg_ptr);
      return F.__wrap(t);
    }
  }
  function jx(i) {
    return Vt(i);
  }
  function Wx(i) {
    const t = xt(i);
    return typeof t == "boolean" ? t ? 1 : 0 : 2;
  }
  function Vx(i) {
    Nn(i);
  }
  function Xx(i, t) {
    const e = xt(t), r = typeof e == "number" ? e : void 0;
    Ln()[i / 8 + 1] = et(r) ? 0 : r, It()[i / 4 + 0] = !et(r);
  }
  function qx(i) {
    return typeof xt(i) == "function";
  }
  function $x(i) {
    const t = cs.__wrap(i);
    return Vt(t);
  }
  function Yx(i) {
    const t = Ua.__wrap(i);
    return Vt(t);
  }
  function Kx() {
    return Fa(function(i, t, e) {
      const r = xt(i).call(xt(t), xt(e));
      return Vt(r);
    }, arguments);
  }
  function Zx() {
    return Fa(function(i, t, e, r) {
      const n = xt(i).call(xt(t), xt(e), xt(r));
      return Vt(n);
    }, arguments);
  }
  function Jx() {
    return Fa(function(i, t, e, r, n) {
      const s = xt(i).call(xt(t), xt(e), xt(r), xt(n));
      return Vt(s);
    }, arguments);
  }
  function Qx(i, t, e, r) {
    const n = xt(i).bind(xt(t), xt(e), xt(r));
    return Vt(n);
  }
  function t2(i) {
    const t = xt(i).buffer;
    return Vt(t);
  }
  function e2(i, t, e) {
    const r = new Uint8Array(xt(i), t >>> 0, e >>> 0);
    return Vt(r);
  }
  function r2(i) {
    const t = new Uint8Array(xt(i));
    return Vt(t);
  }
  function i2(i, t, e) {
    xt(i).set(xt(t), e >>> 0);
  }
  function n2(i) {
    return xt(i).length;
  }
  function s2(i, t, e) {
    const r = new Float32Array(xt(i), t >>> 0, e >>> 0);
    return Vt(r);
  }
  function o2(i, t, e) {
    xt(i).set(xt(t), e >>> 0);
  }
  function a2(i) {
    return xt(i).length;
  }
  function c2(i) {
    const t = new Float32Array(i >>> 0);
    return Vt(t);
  }
  function u2(i, t) {
    throw new Error(Rx(i, t));
  }
  function l2() {
    const i = d.memory;
    return Vt(i);
  }
  URL = globalThis.URL;
  const _ = await Sx({
    "./rapier_wasm2d_bg.js": {
      __wbindgen_number_new: jx,
      __wbindgen_boolean_get: Wx,
      __wbindgen_object_drop_ref: Vx,
      __wbindgen_number_get: Xx,
      __wbindgen_is_function: qx,
      __wbg_rawraycolliderintersection_new: $x,
      __wbg_rawcontactforceevent_new: Yx,
      __wbg_call_b3ca7c6051f9bec1: Kx,
      __wbg_call_8e7cb608789c2528: Zx,
      __wbg_call_938992c832f74314: Jx,
      __wbg_bind_4d857b598695205e: Qx,
      __wbg_buffer_12d079cc21e14bdb: t2,
      __wbg_newwithbyteoffsetandlength_aa4a17c33a06e5cb: e2,
      __wbg_new_63b92bc8671ed464: r2,
      __wbg_set_a47bac70306a19a7: i2,
      __wbg_length_c20a40f15020d68a: n2,
      __wbg_newwithbyteoffsetandlength_4a659d079a1650e0: s2,
      __wbg_set_bd975934d1b1fddb: o2,
      __wbg_length_d25bbcbc3367f684: a2,
      __wbg_newwithlength_1e8b839a06de01c5: c2,
      __wbindgen_throw: u2,
      __wbindgen_memory: l2
    }
  }, vx), h2 = _.memory, d2 = _.version, f2 = _.__wbg_rawkinematiccharactercontroller_free, p2 = _.rawkinematiccharactercontroller_new, _2 = _.rawkinematiccharactercontroller_setUp, g2 = _.rawkinematiccharactercontroller_normalNudgeFactor, m2 = _.rawkinematiccharactercontroller_setNormalNudgeFactor, b2 = _.rawkinematiccharactercontroller_setOffset, w2 = _.rawkinematiccharactercontroller_slideEnabled, y2 = _.rawkinematiccharactercontroller_setSlideEnabled, x2 = _.rawkinematiccharactercontroller_autostepMaxHeight, v2 = _.rawkinematiccharactercontroller_autostepMinWidth, S2 = _.rawkinematiccharactercontroller_autostepIncludesDynamicBodies, E2 = _.rawkinematiccharactercontroller_autostepEnabled, A2 = _.rawkinematiccharactercontroller_enableAutostep, T2 = _.rawkinematiccharactercontroller_disableAutostep, C2 = _.rawkinematiccharactercontroller_minSlopeSlideAngle, R2 = _.rawkinematiccharactercontroller_setMinSlopeSlideAngle, P2 = _.rawkinematiccharactercontroller_snapToGroundDistance, B2 = _.rawkinematiccharactercontroller_enableSnapToGround, M2 = _.rawkinematiccharactercontroller_disableSnapToGround, D2 = _.rawkinematiccharactercontroller_snapToGroundEnabled, I2 = _.rawkinematiccharactercontroller_computeColliderMovement, F2 = _.rawkinematiccharactercontroller_computedMovement, U2 = _.rawkinematiccharactercontroller_computedGrounded, k2 = _.rawkinematiccharactercontroller_numComputedCollisions, G2 = _.rawkinematiccharactercontroller_computedCollision, O2 = _.__wbg_rawcharactercollision_free, N2 = _.rawcharactercollision_new, L2 = _.rawcharactercollision_handle, H2 = _.rawcharactercollision_translationDeltaApplied, z2 = _.rawcharactercollision_translationDeltaRemaining, j2 = _.rawcharactercollision_toi, W2 = _.rawcharactercollision_worldWitness1, V2 = _.rawcharactercollision_worldWitness2, X2 = _.rawcharactercollision_worldNormal1, q2 = _.rawcharactercollision_worldNormal2, $2 = _.__wbg_rawccdsolver_free, Y2 = _.rawccdsolver_new, K2 = _.rawimpulsejointset_jointType, Z2 = _.rawimpulsejointset_jointBodyHandle1, J2 = _.rawimpulsejointset_jointBodyHandle2, Q2 = _.rawimpulsejointset_jointFrameX1, tv = _.rawimpulsejointset_jointFrameX2, ev = _.rawimpulsejointset_jointAnchor1, rv = _.rawimpulsejointset_jointAnchor2, iv = _.rawimpulsejointset_jointSetAnchor1, nv = _.rawimpulsejointset_jointSetAnchor2, sv = _.rawimpulsejointset_jointContactsEnabled, ov = _.rawimpulsejointset_jointSetContactsEnabled, av = _.rawimpulsejointset_jointLimitsEnabled, cv = _.rawimpulsejointset_jointLimitsMin, uv = _.rawimpulsejointset_jointLimitsMax, lv = _.rawimpulsejointset_jointSetLimits, hv = _.rawimpulsejointset_jointConfigureMotorModel, dv = _.rawimpulsejointset_jointConfigureMotorVelocity, fv = _.rawimpulsejointset_jointConfigureMotorPosition, pv = _.rawimpulsejointset_jointConfigureMotor, _v = _.__wbg_rawimpulsejointset_free, gv = _.rawimpulsejointset_new, mv = _.rawimpulsejointset_createJoint, bv = _.rawimpulsejointset_remove, wv = _.rawimpulsejointset_len, yv = _.rawimpulsejointset_contains, xv = _.rawimpulsejointset_forEachJointHandle, vv = _.rawimpulsejointset_forEachJointAttachedToRigidBody, Sv = _.__wbg_rawintegrationparameters_free, Ev = _.rawintegrationparameters_new, Av = _.rawintegrationparameters_dt, Tv = _.rawintegrationparameters_contact_erp, Cv = _.rawintegrationparameters_normalizedPredictionDistance, Rv = _.rawintegrationparameters_numSolverIterations, Pv = _.rawintegrationparameters_numAdditionalFrictionIterations, Bv = _.rawintegrationparameters_numInternalPgsIterations, Mv = _.rawintegrationparameters_maxCcdSubsteps, Dv = _.rawintegrationparameters_set_dt, Iv = _.rawintegrationparameters_set_contact_natural_frequency, Fv = _.rawintegrationparameters_set_normalizedAllowedLinearError, Uv = _.rawintegrationparameters_set_normalizedPredictionDistance, kv = _.rawintegrationparameters_set_numSolverIterations, Gv = _.rawintegrationparameters_set_numAdditionalFrictionIterations, Ov = _.rawintegrationparameters_set_numInternalPgsIterations, Nv = _.rawintegrationparameters_set_minIslandSize, Lv = _.rawintegrationparameters_set_maxCcdSubsteps, Hv = _.rawintegrationparameters_set_lengthUnit, zv = _.rawintegrationparameters_switchToStandardPgsSolver, jv = _.rawintegrationparameters_switchToSmallStepsPgsSolver, Wv = _.rawintegrationparameters_switchToSmallStepsPgsSolverWithoutWarmstart, Vv = _.__wbg_rawislandmanager_free, Xv = _.rawislandmanager_new, qv = _.rawislandmanager_forEachActiveRigidBodyHandle, $v = _.__wbg_rawgenericjoint_free, Yv = _.rawgenericjoint_spring, Kv = _.rawgenericjoint_rope, Zv = _.rawgenericjoint_prismatic, Jv = _.rawgenericjoint_fixed, Qv = _.rawgenericjoint_revolute, t1 = _.rawmultibodyjointset_jointType, e1 = _.rawmultibodyjointset_jointFrameX1, r1 = _.rawmultibodyjointset_jointFrameX2, i1 = _.rawmultibodyjointset_jointAnchor1, n1 = _.rawmultibodyjointset_jointAnchor2, s1 = _.rawmultibodyjointset_jointContactsEnabled, o1 = _.rawmultibodyjointset_jointSetContactsEnabled, a1 = _.rawmultibodyjointset_jointLimitsEnabled, c1 = _.rawmultibodyjointset_jointLimitsMin, u1 = _.rawmultibodyjointset_jointLimitsMax, l1 = _.__wbg_rawmultibodyjointset_free, h1 = _.rawmultibodyjointset_new, d1 = _.rawmultibodyjointset_createJoint, f1 = _.rawmultibodyjointset_remove, p1 = _.rawmultibodyjointset_contains, _1 = _.rawmultibodyjointset_forEachJointHandle, g1 = _.rawmultibodyjointset_forEachJointAttachedToRigidBody, m1 = _.rawrigidbodyset_rbTranslation, b1 = _.rawrigidbodyset_rbRotation, w1 = _.rawrigidbodyset_rbSleep, y1 = _.rawrigidbodyset_rbIsSleeping, x1 = _.rawrigidbodyset_rbIsMoving, v1 = _.rawrigidbodyset_rbNextTranslation, S1 = _.rawrigidbodyset_rbNextRotation, E1 = _.rawrigidbodyset_rbSetTranslation, A1 = _.rawrigidbodyset_rbSetRotation, T1 = _.rawrigidbodyset_rbSetLinvel, C1 = _.rawrigidbodyset_rbSetAngvel, R1 = _.rawrigidbodyset_rbSetNextKinematicTranslation, P1 = _.rawrigidbodyset_rbSetNextKinematicRotation, B1 = _.rawrigidbodyset_rbRecomputeMassPropertiesFromColliders, M1 = _.rawrigidbodyset_rbSetAdditionalMass, D1 = _.rawrigidbodyset_rbSetAdditionalMassProperties, I1 = _.rawrigidbodyset_rbLinvel, F1 = _.rawrigidbodyset_rbAngvel, U1 = _.rawrigidbodyset_rbLockTranslations, k1 = _.rawrigidbodyset_rbSetEnabledTranslations, G1 = _.rawrigidbodyset_rbLockRotations, O1 = _.rawrigidbodyset_rbDominanceGroup, N1 = _.rawrigidbodyset_rbSetDominanceGroup, L1 = _.rawrigidbodyset_rbEnableCcd, H1 = _.rawrigidbodyset_rbSetSoftCcdPrediction, z1 = _.rawrigidbodyset_rbMass, j1 = _.rawrigidbodyset_rbInvMass, W1 = _.rawrigidbodyset_rbEffectiveInvMass, V1 = _.rawrigidbodyset_rbLocalCom, X1 = _.rawrigidbodyset_rbWorldCom, q1 = _.rawrigidbodyset_rbInvPrincipalInertiaSqrt, $1 = _.rawrigidbodyset_rbPrincipalInertia, Y1 = _.rawrigidbodyset_rbEffectiveWorldInvInertiaSqrt, K1 = _.rawrigidbodyset_rbEffectiveAngularInertia, Z1 = _.rawrigidbodyset_rbWakeUp, J1 = _.rawrigidbodyset_rbIsCcdEnabled, Q1 = _.rawrigidbodyset_rbSoftCcdPrediction, tS = _.rawrigidbodyset_rbNumColliders, eS = _.rawrigidbodyset_rbCollider, rS = _.rawrigidbodyset_rbBodyType, iS = _.rawrigidbodyset_rbSetBodyType, nS = _.rawrigidbodyset_rbIsFixed, sS = _.rawrigidbodyset_rbIsKinematic, oS = _.rawrigidbodyset_rbIsDynamic, aS = _.rawrigidbodyset_rbLinearDamping, cS = _.rawrigidbodyset_rbAngularDamping, uS = _.rawrigidbodyset_rbSetLinearDamping, lS = _.rawrigidbodyset_rbSetAngularDamping, hS = _.rawrigidbodyset_rbSetEnabled, dS = _.rawrigidbodyset_rbIsEnabled, fS = _.rawrigidbodyset_rbGravityScale, pS = _.rawrigidbodyset_rbSetGravityScale, _S = _.rawrigidbodyset_rbResetForces, gS = _.rawrigidbodyset_rbResetTorques, mS = _.rawrigidbodyset_rbAddForce, bS = _.rawrigidbodyset_rbApplyImpulse, wS = _.rawrigidbodyset_rbAddTorque, yS = _.rawrigidbodyset_rbApplyTorqueImpulse, xS = _.rawrigidbodyset_rbAddForceAtPoint, vS = _.rawrigidbodyset_rbApplyImpulseAtPoint, SS = _.rawrigidbodyset_rbAdditionalSolverIterations, ES = _.rawrigidbodyset_rbSetAdditionalSolverIterations, AS = _.rawrigidbodyset_rbUserData, TS = _.rawrigidbodyset_rbSetUserData, CS = _.rawrigidbodyset_rbUserForce, RS = _.rawrigidbodyset_rbUserTorque, PS = _.__wbg_rawrigidbodyset_free, BS = _.rawrigidbodyset_new, MS = _.rawrigidbodyset_createRigidBody, DS = _.rawrigidbodyset_remove, IS = _.rawrigidbodyset_contains, FS = _.rawrigidbodyset_forEachRigidBodyHandle, US = _.rawrigidbodyset_propagateModifiedBodyPositionsToColliders, kS = _.__wbg_rawbroadphase_free, GS = _.rawbroadphase_new, OS = _.rawcolliderset_coTranslation, NS = _.rawcolliderset_coRotation, LS = _.rawcolliderset_coSetTranslation, HS = _.rawcolliderset_coSetTranslationWrtParent, zS = _.rawcolliderset_coSetRotation, jS = _.rawcolliderset_coSetRotationWrtParent, WS = _.rawcolliderset_coIsSensor, VS = _.rawcolliderset_coShapeType, XS = _.rawcolliderset_coHalfspaceNormal, qS = _.rawcolliderset_coHalfExtents, $S = _.rawcolliderset_coSetHalfExtents, YS = _.rawcolliderset_coRadius, KS = _.rawcolliderset_coSetRadius, ZS = _.rawcolliderset_coHalfHeight, JS = _.rawcolliderset_coSetHalfHeight, QS = _.rawcolliderset_coRoundRadius, tE = _.rawcolliderset_coSetRoundRadius, eE = _.rawcolliderset_coVertices, rE = _.rawcolliderset_coIndices, iE = _.rawcolliderset_coTriMeshFlags, nE = _.rawcolliderset_coHeightfieldHeights, sE = _.rawcolliderset_coHeightfieldScale, oE = _.rawcolliderset_coParent, aE = _.rawcolliderset_coSetEnabled, cE = _.rawcolliderset_coIsEnabled, uE = _.rawcolliderset_coSetContactSkin, lE = _.rawcolliderset_coContactSkin, hE = _.rawcolliderset_coFriction, dE = _.rawcolliderset_coRestitution, fE = _.rawcolliderset_coDensity, pE = _.rawcolliderset_coMass, _E = _.rawcolliderset_coVolume, gE = _.rawcolliderset_coCollisionGroups, mE = _.rawcolliderset_coSolverGroups, bE = _.rawcolliderset_coActiveHooks, wE = _.rawcolliderset_coActiveCollisionTypes, yE = _.rawcolliderset_coActiveEvents, xE = _.rawcolliderset_coContactForceEventThreshold, vE = _.rawcolliderset_coContainsPoint, SE = _.rawcolliderset_coCastShape, EE = _.rawcolliderset_coCastCollider, AE = _.rawcolliderset_coIntersectsShape, TE = _.rawcolliderset_coContactShape, CE = _.rawcolliderset_coContactCollider, RE = _.rawcolliderset_coProjectPoint, PE = _.rawcolliderset_coIntersectsRay, BE = _.rawcolliderset_coCastRay, ME = _.rawcolliderset_coCastRayAndGetNormal, DE = _.rawcolliderset_coSetSensor, IE = _.rawcolliderset_coSetRestitution, FE = _.rawcolliderset_coSetFriction, UE = _.rawcolliderset_coFrictionCombineRule, kE = _.rawcolliderset_coSetFrictionCombineRule, GE = _.rawcolliderset_coRestitutionCombineRule, OE = _.rawcolliderset_coSetRestitutionCombineRule, NE = _.rawcolliderset_coSetCollisionGroups, LE = _.rawcolliderset_coSetSolverGroups, HE = _.rawcolliderset_coSetActiveHooks, zE = _.rawcolliderset_coSetActiveEvents, jE = _.rawcolliderset_coSetActiveCollisionTypes, WE = _.rawcolliderset_coSetShape, VE = _.rawcolliderset_coSetContactForceEventThreshold, XE = _.rawcolliderset_coSetDensity, qE = _.rawcolliderset_coSetMass, $E = _.rawcolliderset_coSetMassProperties, YE = _.__wbg_rawcolliderset_free, KE = _.rawcolliderset_new, ZE = _.rawcolliderset_len, JE = _.rawcolliderset_contains, QE = _.rawcolliderset_createCollider, tA = _.rawcolliderset_remove, eA = _.rawcolliderset_forEachColliderHandle, rA = _.__wbg_rawshapecontact_free, iA = _.__wbg_rawnarrowphase_free, nA = _.rawnarrowphase_new, sA = _.rawnarrowphase_contact_pairs_with, oA = _.rawnarrowphase_contact_pair, aA = _.rawnarrowphase_intersection_pairs_with, cA = _.rawnarrowphase_intersection_pair, uA = _.__wbg_rawcontactmanifold_free, lA = _.rawcontactpair_collider1, hA = _.rawcontactpair_collider2, dA = _.rawcontactpair_numContactManifolds, fA = _.rawcontactpair_contactManifold, pA = _.rawcontactmanifold_normal, _A = _.rawcontactmanifold_local_n1, gA = _.rawcontactmanifold_local_n2, mA = _.rawcontactmanifold_subshape1, bA = _.rawcontactmanifold_subshape2, wA = _.rawcontactmanifold_num_contacts, yA = _.rawcontactmanifold_contact_local_p1, xA = _.rawcontactmanifold_contact_local_p2, vA = _.rawcontactmanifold_contact_dist, SA = _.rawcontactmanifold_contact_fid1, EA = _.rawcontactmanifold_contact_fid2, AA = _.rawcontactmanifold_contact_impulse, TA = _.rawcontactmanifold_contact_tangent_impulse, CA = _.rawcontactmanifold_num_solver_contacts, RA = _.rawcontactmanifold_solver_contact_point, PA = _.rawcontactmanifold_solver_contact_dist, BA = _.rawcontactmanifold_solver_contact_friction, MA = _.rawcontactmanifold_solver_contact_restitution, DA = _.rawcontactmanifold_solver_contact_tangent_velocity, IA = _.__wbg_rawpointprojection_free, FA = _.rawpointprojection_point, UA = _.rawpointprojection_isInside, kA = _.__wbg_rawpointcolliderprojection_free, GA = _.rawpointcolliderprojection_colliderHandle, OA = _.rawpointcolliderprojection_point, NA = _.rawpointcolliderprojection_isInside, LA = _.rawpointcolliderprojection_featureType, HA = _.rawpointcolliderprojection_featureId, zA = _.__wbg_rawrayintersection_free, jA = _.__wbg_rawshape_free, WA = _.rawshape_cuboid, VA = _.rawshape_roundCuboid, XA = _.rawshape_ball, qA = _.rawshape_halfspace, $A = _.rawshape_capsule, YA = _.rawshape_polyline, KA = _.rawshape_trimesh, ZA = _.rawshape_heightfield, JA = _.rawshape_segment, QA = _.rawshape_triangle, tT = _.rawshape_roundTriangle, eT = _.rawshape_convexHull, rT = _.rawshape_roundConvexHull, iT = _.rawshape_convexPolyline, nT = _.rawshape_roundConvexPolyline, sT = _.rawshape_castShape, oT = _.rawshape_intersectsShape, aT = _.rawshape_contactShape, cT = _.rawshape_containsPoint, uT = _.rawshape_projectPoint, lT = _.rawshape_intersectsRay, hT = _.rawshape_castRay, dT = _.rawshape_castRayAndGetNormal, fT = _.rawshapecasthit_witness1, pT = _.__wbg_rawcollidershapecasthit_free, _T = _.rawcollidershapecasthit_colliderHandle, gT = _.rawcollidershapecasthit_time_of_impact, mT = _.rawcollidershapecasthit_witness1, bT = _.rawcollidershapecasthit_witness2, wT = _.rawcollidershapecasthit_normal1, yT = _.rawcollidershapecasthit_normal2, xT = _.__wbg_rawrotation_free, vT = _.rawrotation_identity, ST = _.rawrotation_fromAngle, ET = _.rawrotation_re, AT = _.rawrotation_angle, TT = _.__wbg_rawvector_free, CT = _.rawvector_zero, RT = _.rawvector_new, PT = _.rawvector_set_x, BT = _.rawvector_xy, MT = _.rawvector_yx, DT = _.__wbg_rawdebugrenderpipeline_free, IT = _.rawdebugrenderpipeline_new, FT = _.rawdebugrenderpipeline_vertices, UT = _.rawdebugrenderpipeline_colors, kT = _.rawdebugrenderpipeline_render, GT = _.__wbg_raweventqueue_free, OT = _.__wbg_rawcontactforceevent_free, NT = _.rawcontactforceevent_collider2, LT = _.rawcontactforceevent_total_force, HT = _.rawcontactforceevent_total_force_magnitude, zT = _.rawcontactforceevent_max_force_magnitude, jT = _.raweventqueue_new, WT = _.raweventqueue_drainCollisionEvents, VT = _.raweventqueue_drainContactForceEvents, XT = _.raweventqueue_clear, qT = _.__wbg_rawphysicspipeline_free, $T = _.rawphysicspipeline_new, YT = _.rawphysicspipeline_step, KT = _.rawphysicspipeline_stepWithEvents, ZT = _.rawquerypipeline_new, JT = _.rawquerypipeline_update, QT = _.rawquerypipeline_castRay, tC = _.rawquerypipeline_castRayAndGetNormal, eC = _.rawquerypipeline_intersectionsWithRay, rC = _.rawquerypipeline_intersectionWithShape, iC = _.rawquerypipeline_projectPoint, nC = _.rawquerypipeline_projectPointAndGetFeature, sC = _.rawquerypipeline_intersectionsWithPoint, oC = _.rawquerypipeline_castShape, aC = _.rawquerypipeline_intersectionsWithShape, cC = _.rawquerypipeline_collidersWithAabbIntersectingAabb, uC = _.__wbg_rawdeserializedworld_free, lC = _.rawdeserializedworld_takeGravity, hC = _.rawdeserializedworld_takeIntegrationParameters, dC = _.rawdeserializedworld_takeIslandManager, fC = _.rawdeserializedworld_takeBroadPhase, pC = _.rawdeserializedworld_takeNarrowPhase, _C = _.rawdeserializedworld_takeBodies, gC = _.rawdeserializedworld_takeColliders, mC = _.rawdeserializedworld_takeImpulseJoints, bC = _.rawdeserializedworld_takeMultibodyJoints, wC = _.rawserializationpipeline_new, yC = _.rawserializationpipeline_serializeAll, xC = _.rawserializationpipeline_deserializeAll, vC = _.rawkinematiccharactercontroller_offset, SC = _.rawkinematiccharactercontroller_maxSlopeClimbAngle, EC = _.rawintegrationparameters_minIslandSize, AC = _.rawrigidbodyset_len, TC = _.rawshapecontact_distance, CC = _.rawrayintersection_featureType, RC = _.rawraycolliderintersection_colliderHandle, PC = _.rawrayintersection_time_of_impact, BC = _.rawraycolliderintersection_featureType, MC = _.rawraycolliderintersection_time_of_impact, DC = _.rawraycolliderhit_colliderHandle, IC = _.rawraycolliderhit_timeOfImpact, FC = _.rawrotation_im, UC = _.rawshapecasthit_time_of_impact, kC = _.rawvector_x, GC = _.rawvector_y, OC = _.rawcontactforceevent_collider1, NC = _.rawintegrationparameters_lengthUnit, LC = _.rawintegrationparameters_normalizedAllowedLinearError, HC = _.rawcolliderset_isHandleValid, zC = _.rawshapecontact_normal2, jC = _.rawshapecontact_point1, WC = _.rawshapecontact_point2, VC = _.rawrayintersection_normal, XC = _.rawshapecasthit_witness2, qC = _.rawraycolliderintersection_normal, $C = _.rawshapecasthit_normal1, YC = _.rawshapecasthit_normal2, KC = _.rawkinematiccharactercontroller_up, ZC = _.rawshapecontact_normal1, JC = _.rawcontactforceevent_max_force_direction, QC = _.rawkinematiccharactercontroller_setMaxSlopeClimbAngle, t3 = _.rawvector_set_y, e3 = _.__wbg_rawcontactpair_free, r3 = _.__wbg_rawraycolliderintersection_free, i3 = _.__wbg_rawraycolliderhit_free, n3 = _.__wbg_rawshapecasthit_free, s3 = _.__wbg_rawserializationpipeline_free, o3 = _.rawrayintersection_featureId, a3 = _.rawraycolliderintersection_featureId, c3 = _.__wbg_rawquerypipeline_free, u3 = _.__wbindgen_add_to_stack_pointer, l3 = _.__wbindgen_free, h3 = _.__wbindgen_malloc, d3 = _.__wbindgen_exn_store, f3 = Object.freeze(Object.defineProperty({
    __proto__: null,
    __wbg_rawbroadphase_free: kS,
    __wbg_rawccdsolver_free: $2,
    __wbg_rawcharactercollision_free: O2,
    __wbg_rawcolliderset_free: YE,
    __wbg_rawcollidershapecasthit_free: pT,
    __wbg_rawcontactforceevent_free: OT,
    __wbg_rawcontactmanifold_free: uA,
    __wbg_rawcontactpair_free: e3,
    __wbg_rawdebugrenderpipeline_free: DT,
    __wbg_rawdeserializedworld_free: uC,
    __wbg_raweventqueue_free: GT,
    __wbg_rawgenericjoint_free: $v,
    __wbg_rawimpulsejointset_free: _v,
    __wbg_rawintegrationparameters_free: Sv,
    __wbg_rawislandmanager_free: Vv,
    __wbg_rawkinematiccharactercontroller_free: f2,
    __wbg_rawmultibodyjointset_free: l1,
    __wbg_rawnarrowphase_free: iA,
    __wbg_rawphysicspipeline_free: qT,
    __wbg_rawpointcolliderprojection_free: kA,
    __wbg_rawpointprojection_free: IA,
    __wbg_rawquerypipeline_free: c3,
    __wbg_rawraycolliderhit_free: i3,
    __wbg_rawraycolliderintersection_free: r3,
    __wbg_rawrayintersection_free: zA,
    __wbg_rawrigidbodyset_free: PS,
    __wbg_rawrotation_free: xT,
    __wbg_rawserializationpipeline_free: s3,
    __wbg_rawshape_free: jA,
    __wbg_rawshapecasthit_free: n3,
    __wbg_rawshapecontact_free: rA,
    __wbg_rawvector_free: TT,
    __wbindgen_add_to_stack_pointer: u3,
    __wbindgen_exn_store: d3,
    __wbindgen_free: l3,
    __wbindgen_malloc: h3,
    memory: h2,
    rawbroadphase_new: GS,
    rawccdsolver_new: Y2,
    rawcharactercollision_handle: L2,
    rawcharactercollision_new: N2,
    rawcharactercollision_toi: j2,
    rawcharactercollision_translationDeltaApplied: H2,
    rawcharactercollision_translationDeltaRemaining: z2,
    rawcharactercollision_worldNormal1: X2,
    rawcharactercollision_worldNormal2: q2,
    rawcharactercollision_worldWitness1: W2,
    rawcharactercollision_worldWitness2: V2,
    rawcolliderset_coActiveCollisionTypes: wE,
    rawcolliderset_coActiveEvents: yE,
    rawcolliderset_coActiveHooks: bE,
    rawcolliderset_coCastCollider: EE,
    rawcolliderset_coCastRay: BE,
    rawcolliderset_coCastRayAndGetNormal: ME,
    rawcolliderset_coCastShape: SE,
    rawcolliderset_coCollisionGroups: gE,
    rawcolliderset_coContactCollider: CE,
    rawcolliderset_coContactForceEventThreshold: xE,
    rawcolliderset_coContactShape: TE,
    rawcolliderset_coContactSkin: lE,
    rawcolliderset_coContainsPoint: vE,
    rawcolliderset_coDensity: fE,
    rawcolliderset_coFriction: hE,
    rawcolliderset_coFrictionCombineRule: UE,
    rawcolliderset_coHalfExtents: qS,
    rawcolliderset_coHalfHeight: ZS,
    rawcolliderset_coHalfspaceNormal: XS,
    rawcolliderset_coHeightfieldHeights: nE,
    rawcolliderset_coHeightfieldScale: sE,
    rawcolliderset_coIndices: rE,
    rawcolliderset_coIntersectsRay: PE,
    rawcolliderset_coIntersectsShape: AE,
    rawcolliderset_coIsEnabled: cE,
    rawcolliderset_coIsSensor: WS,
    rawcolliderset_coMass: pE,
    rawcolliderset_coParent: oE,
    rawcolliderset_coProjectPoint: RE,
    rawcolliderset_coRadius: YS,
    rawcolliderset_coRestitution: dE,
    rawcolliderset_coRestitutionCombineRule: GE,
    rawcolliderset_coRotation: NS,
    rawcolliderset_coRoundRadius: QS,
    rawcolliderset_coSetActiveCollisionTypes: jE,
    rawcolliderset_coSetActiveEvents: zE,
    rawcolliderset_coSetActiveHooks: HE,
    rawcolliderset_coSetCollisionGroups: NE,
    rawcolliderset_coSetContactForceEventThreshold: VE,
    rawcolliderset_coSetContactSkin: uE,
    rawcolliderset_coSetDensity: XE,
    rawcolliderset_coSetEnabled: aE,
    rawcolliderset_coSetFriction: FE,
    rawcolliderset_coSetFrictionCombineRule: kE,
    rawcolliderset_coSetHalfExtents: $S,
    rawcolliderset_coSetHalfHeight: JS,
    rawcolliderset_coSetMass: qE,
    rawcolliderset_coSetMassProperties: $E,
    rawcolliderset_coSetRadius: KS,
    rawcolliderset_coSetRestitution: IE,
    rawcolliderset_coSetRestitutionCombineRule: OE,
    rawcolliderset_coSetRotation: zS,
    rawcolliderset_coSetRotationWrtParent: jS,
    rawcolliderset_coSetRoundRadius: tE,
    rawcolliderset_coSetSensor: DE,
    rawcolliderset_coSetShape: WE,
    rawcolliderset_coSetSolverGroups: LE,
    rawcolliderset_coSetTranslation: LS,
    rawcolliderset_coSetTranslationWrtParent: HS,
    rawcolliderset_coShapeType: VS,
    rawcolliderset_coSolverGroups: mE,
    rawcolliderset_coTranslation: OS,
    rawcolliderset_coTriMeshFlags: iE,
    rawcolliderset_coVertices: eE,
    rawcolliderset_coVolume: _E,
    rawcolliderset_contains: JE,
    rawcolliderset_createCollider: QE,
    rawcolliderset_forEachColliderHandle: eA,
    rawcolliderset_isHandleValid: HC,
    rawcolliderset_len: ZE,
    rawcolliderset_new: KE,
    rawcolliderset_remove: tA,
    rawcollidershapecasthit_colliderHandle: _T,
    rawcollidershapecasthit_normal1: wT,
    rawcollidershapecasthit_normal2: yT,
    rawcollidershapecasthit_time_of_impact: gT,
    rawcollidershapecasthit_witness1: mT,
    rawcollidershapecasthit_witness2: bT,
    rawcontactforceevent_collider1: OC,
    rawcontactforceevent_collider2: NT,
    rawcontactforceevent_max_force_direction: JC,
    rawcontactforceevent_max_force_magnitude: zT,
    rawcontactforceevent_total_force: LT,
    rawcontactforceevent_total_force_magnitude: HT,
    rawcontactmanifold_contact_dist: vA,
    rawcontactmanifold_contact_fid1: SA,
    rawcontactmanifold_contact_fid2: EA,
    rawcontactmanifold_contact_impulse: AA,
    rawcontactmanifold_contact_local_p1: yA,
    rawcontactmanifold_contact_local_p2: xA,
    rawcontactmanifold_contact_tangent_impulse: TA,
    rawcontactmanifold_local_n1: _A,
    rawcontactmanifold_local_n2: gA,
    rawcontactmanifold_normal: pA,
    rawcontactmanifold_num_contacts: wA,
    rawcontactmanifold_num_solver_contacts: CA,
    rawcontactmanifold_solver_contact_dist: PA,
    rawcontactmanifold_solver_contact_friction: BA,
    rawcontactmanifold_solver_contact_point: RA,
    rawcontactmanifold_solver_contact_restitution: MA,
    rawcontactmanifold_solver_contact_tangent_velocity: DA,
    rawcontactmanifold_subshape1: mA,
    rawcontactmanifold_subshape2: bA,
    rawcontactpair_collider1: lA,
    rawcontactpair_collider2: hA,
    rawcontactpair_contactManifold: fA,
    rawcontactpair_numContactManifolds: dA,
    rawdebugrenderpipeline_colors: UT,
    rawdebugrenderpipeline_new: IT,
    rawdebugrenderpipeline_render: kT,
    rawdebugrenderpipeline_vertices: FT,
    rawdeserializedworld_takeBodies: _C,
    rawdeserializedworld_takeBroadPhase: fC,
    rawdeserializedworld_takeColliders: gC,
    rawdeserializedworld_takeGravity: lC,
    rawdeserializedworld_takeImpulseJoints: mC,
    rawdeserializedworld_takeIntegrationParameters: hC,
    rawdeserializedworld_takeIslandManager: dC,
    rawdeserializedworld_takeMultibodyJoints: bC,
    rawdeserializedworld_takeNarrowPhase: pC,
    raweventqueue_clear: XT,
    raweventqueue_drainCollisionEvents: WT,
    raweventqueue_drainContactForceEvents: VT,
    raweventqueue_new: jT,
    rawgenericjoint_fixed: Jv,
    rawgenericjoint_prismatic: Zv,
    rawgenericjoint_revolute: Qv,
    rawgenericjoint_rope: Kv,
    rawgenericjoint_spring: Yv,
    rawimpulsejointset_contains: yv,
    rawimpulsejointset_createJoint: mv,
    rawimpulsejointset_forEachJointAttachedToRigidBody: vv,
    rawimpulsejointset_forEachJointHandle: xv,
    rawimpulsejointset_jointAnchor1: ev,
    rawimpulsejointset_jointAnchor2: rv,
    rawimpulsejointset_jointBodyHandle1: Z2,
    rawimpulsejointset_jointBodyHandle2: J2,
    rawimpulsejointset_jointConfigureMotor: pv,
    rawimpulsejointset_jointConfigureMotorModel: hv,
    rawimpulsejointset_jointConfigureMotorPosition: fv,
    rawimpulsejointset_jointConfigureMotorVelocity: dv,
    rawimpulsejointset_jointContactsEnabled: sv,
    rawimpulsejointset_jointFrameX1: Q2,
    rawimpulsejointset_jointFrameX2: tv,
    rawimpulsejointset_jointLimitsEnabled: av,
    rawimpulsejointset_jointLimitsMax: uv,
    rawimpulsejointset_jointLimitsMin: cv,
    rawimpulsejointset_jointSetAnchor1: iv,
    rawimpulsejointset_jointSetAnchor2: nv,
    rawimpulsejointset_jointSetContactsEnabled: ov,
    rawimpulsejointset_jointSetLimits: lv,
    rawimpulsejointset_jointType: K2,
    rawimpulsejointset_len: wv,
    rawimpulsejointset_new: gv,
    rawimpulsejointset_remove: bv,
    rawintegrationparameters_contact_erp: Tv,
    rawintegrationparameters_dt: Av,
    rawintegrationparameters_lengthUnit: NC,
    rawintegrationparameters_maxCcdSubsteps: Mv,
    rawintegrationparameters_minIslandSize: EC,
    rawintegrationparameters_new: Ev,
    rawintegrationparameters_normalizedAllowedLinearError: LC,
    rawintegrationparameters_normalizedPredictionDistance: Cv,
    rawintegrationparameters_numAdditionalFrictionIterations: Pv,
    rawintegrationparameters_numInternalPgsIterations: Bv,
    rawintegrationparameters_numSolverIterations: Rv,
    rawintegrationparameters_set_contact_natural_frequency: Iv,
    rawintegrationparameters_set_dt: Dv,
    rawintegrationparameters_set_lengthUnit: Hv,
    rawintegrationparameters_set_maxCcdSubsteps: Lv,
    rawintegrationparameters_set_minIslandSize: Nv,
    rawintegrationparameters_set_normalizedAllowedLinearError: Fv,
    rawintegrationparameters_set_normalizedPredictionDistance: Uv,
    rawintegrationparameters_set_numAdditionalFrictionIterations: Gv,
    rawintegrationparameters_set_numInternalPgsIterations: Ov,
    rawintegrationparameters_set_numSolverIterations: kv,
    rawintegrationparameters_switchToSmallStepsPgsSolver: jv,
    rawintegrationparameters_switchToSmallStepsPgsSolverWithoutWarmstart: Wv,
    rawintegrationparameters_switchToStandardPgsSolver: zv,
    rawislandmanager_forEachActiveRigidBodyHandle: qv,
    rawislandmanager_new: Xv,
    rawkinematiccharactercontroller_autostepEnabled: E2,
    rawkinematiccharactercontroller_autostepIncludesDynamicBodies: S2,
    rawkinematiccharactercontroller_autostepMaxHeight: x2,
    rawkinematiccharactercontroller_autostepMinWidth: v2,
    rawkinematiccharactercontroller_computeColliderMovement: I2,
    rawkinematiccharactercontroller_computedCollision: G2,
    rawkinematiccharactercontroller_computedGrounded: U2,
    rawkinematiccharactercontroller_computedMovement: F2,
    rawkinematiccharactercontroller_disableAutostep: T2,
    rawkinematiccharactercontroller_disableSnapToGround: M2,
    rawkinematiccharactercontroller_enableAutostep: A2,
    rawkinematiccharactercontroller_enableSnapToGround: B2,
    rawkinematiccharactercontroller_maxSlopeClimbAngle: SC,
    rawkinematiccharactercontroller_minSlopeSlideAngle: C2,
    rawkinematiccharactercontroller_new: p2,
    rawkinematiccharactercontroller_normalNudgeFactor: g2,
    rawkinematiccharactercontroller_numComputedCollisions: k2,
    rawkinematiccharactercontroller_offset: vC,
    rawkinematiccharactercontroller_setMaxSlopeClimbAngle: QC,
    rawkinematiccharactercontroller_setMinSlopeSlideAngle: R2,
    rawkinematiccharactercontroller_setNormalNudgeFactor: m2,
    rawkinematiccharactercontroller_setOffset: b2,
    rawkinematiccharactercontroller_setSlideEnabled: y2,
    rawkinematiccharactercontroller_setUp: _2,
    rawkinematiccharactercontroller_slideEnabled: w2,
    rawkinematiccharactercontroller_snapToGroundDistance: P2,
    rawkinematiccharactercontroller_snapToGroundEnabled: D2,
    rawkinematiccharactercontroller_up: KC,
    rawmultibodyjointset_contains: p1,
    rawmultibodyjointset_createJoint: d1,
    rawmultibodyjointset_forEachJointAttachedToRigidBody: g1,
    rawmultibodyjointset_forEachJointHandle: _1,
    rawmultibodyjointset_jointAnchor1: i1,
    rawmultibodyjointset_jointAnchor2: n1,
    rawmultibodyjointset_jointContactsEnabled: s1,
    rawmultibodyjointset_jointFrameX1: e1,
    rawmultibodyjointset_jointFrameX2: r1,
    rawmultibodyjointset_jointLimitsEnabled: a1,
    rawmultibodyjointset_jointLimitsMax: u1,
    rawmultibodyjointset_jointLimitsMin: c1,
    rawmultibodyjointset_jointSetContactsEnabled: o1,
    rawmultibodyjointset_jointType: t1,
    rawmultibodyjointset_new: h1,
    rawmultibodyjointset_remove: f1,
    rawnarrowphase_contact_pair: oA,
    rawnarrowphase_contact_pairs_with: sA,
    rawnarrowphase_intersection_pair: cA,
    rawnarrowphase_intersection_pairs_with: aA,
    rawnarrowphase_new: nA,
    rawphysicspipeline_new: $T,
    rawphysicspipeline_step: YT,
    rawphysicspipeline_stepWithEvents: KT,
    rawpointcolliderprojection_colliderHandle: GA,
    rawpointcolliderprojection_featureId: HA,
    rawpointcolliderprojection_featureType: LA,
    rawpointcolliderprojection_isInside: NA,
    rawpointcolliderprojection_point: OA,
    rawpointprojection_isInside: UA,
    rawpointprojection_point: FA,
    rawquerypipeline_castRay: QT,
    rawquerypipeline_castRayAndGetNormal: tC,
    rawquerypipeline_castShape: oC,
    rawquerypipeline_collidersWithAabbIntersectingAabb: cC,
    rawquerypipeline_intersectionWithShape: rC,
    rawquerypipeline_intersectionsWithPoint: sC,
    rawquerypipeline_intersectionsWithRay: eC,
    rawquerypipeline_intersectionsWithShape: aC,
    rawquerypipeline_new: ZT,
    rawquerypipeline_projectPoint: iC,
    rawquerypipeline_projectPointAndGetFeature: nC,
    rawquerypipeline_update: JT,
    rawraycolliderhit_colliderHandle: DC,
    rawraycolliderhit_timeOfImpact: IC,
    rawraycolliderintersection_colliderHandle: RC,
    rawraycolliderintersection_featureId: a3,
    rawraycolliderintersection_featureType: BC,
    rawraycolliderintersection_normal: qC,
    rawraycolliderintersection_time_of_impact: MC,
    rawrayintersection_featureId: o3,
    rawrayintersection_featureType: CC,
    rawrayintersection_normal: VC,
    rawrayintersection_time_of_impact: PC,
    rawrigidbodyset_contains: IS,
    rawrigidbodyset_createRigidBody: MS,
    rawrigidbodyset_forEachRigidBodyHandle: FS,
    rawrigidbodyset_len: AC,
    rawrigidbodyset_new: BS,
    rawrigidbodyset_propagateModifiedBodyPositionsToColliders: US,
    rawrigidbodyset_rbAddForce: mS,
    rawrigidbodyset_rbAddForceAtPoint: xS,
    rawrigidbodyset_rbAddTorque: wS,
    rawrigidbodyset_rbAdditionalSolverIterations: SS,
    rawrigidbodyset_rbAngularDamping: cS,
    rawrigidbodyset_rbAngvel: F1,
    rawrigidbodyset_rbApplyImpulse: bS,
    rawrigidbodyset_rbApplyImpulseAtPoint: vS,
    rawrigidbodyset_rbApplyTorqueImpulse: yS,
    rawrigidbodyset_rbBodyType: rS,
    rawrigidbodyset_rbCollider: eS,
    rawrigidbodyset_rbDominanceGroup: O1,
    rawrigidbodyset_rbEffectiveAngularInertia: K1,
    rawrigidbodyset_rbEffectiveInvMass: W1,
    rawrigidbodyset_rbEffectiveWorldInvInertiaSqrt: Y1,
    rawrigidbodyset_rbEnableCcd: L1,
    rawrigidbodyset_rbGravityScale: fS,
    rawrigidbodyset_rbInvMass: j1,
    rawrigidbodyset_rbInvPrincipalInertiaSqrt: q1,
    rawrigidbodyset_rbIsCcdEnabled: J1,
    rawrigidbodyset_rbIsDynamic: oS,
    rawrigidbodyset_rbIsEnabled: dS,
    rawrigidbodyset_rbIsFixed: nS,
    rawrigidbodyset_rbIsKinematic: sS,
    rawrigidbodyset_rbIsMoving: x1,
    rawrigidbodyset_rbIsSleeping: y1,
    rawrigidbodyset_rbLinearDamping: aS,
    rawrigidbodyset_rbLinvel: I1,
    rawrigidbodyset_rbLocalCom: V1,
    rawrigidbodyset_rbLockRotations: G1,
    rawrigidbodyset_rbLockTranslations: U1,
    rawrigidbodyset_rbMass: z1,
    rawrigidbodyset_rbNextRotation: S1,
    rawrigidbodyset_rbNextTranslation: v1,
    rawrigidbodyset_rbNumColliders: tS,
    rawrigidbodyset_rbPrincipalInertia: $1,
    rawrigidbodyset_rbRecomputeMassPropertiesFromColliders: B1,
    rawrigidbodyset_rbResetForces: _S,
    rawrigidbodyset_rbResetTorques: gS,
    rawrigidbodyset_rbRotation: b1,
    rawrigidbodyset_rbSetAdditionalMass: M1,
    rawrigidbodyset_rbSetAdditionalMassProperties: D1,
    rawrigidbodyset_rbSetAdditionalSolverIterations: ES,
    rawrigidbodyset_rbSetAngularDamping: lS,
    rawrigidbodyset_rbSetAngvel: C1,
    rawrigidbodyset_rbSetBodyType: iS,
    rawrigidbodyset_rbSetDominanceGroup: N1,
    rawrigidbodyset_rbSetEnabled: hS,
    rawrigidbodyset_rbSetEnabledTranslations: k1,
    rawrigidbodyset_rbSetGravityScale: pS,
    rawrigidbodyset_rbSetLinearDamping: uS,
    rawrigidbodyset_rbSetLinvel: T1,
    rawrigidbodyset_rbSetNextKinematicRotation: P1,
    rawrigidbodyset_rbSetNextKinematicTranslation: R1,
    rawrigidbodyset_rbSetRotation: A1,
    rawrigidbodyset_rbSetSoftCcdPrediction: H1,
    rawrigidbodyset_rbSetTranslation: E1,
    rawrigidbodyset_rbSetUserData: TS,
    rawrigidbodyset_rbSleep: w1,
    rawrigidbodyset_rbSoftCcdPrediction: Q1,
    rawrigidbodyset_rbTranslation: m1,
    rawrigidbodyset_rbUserData: AS,
    rawrigidbodyset_rbUserForce: CS,
    rawrigidbodyset_rbUserTorque: RS,
    rawrigidbodyset_rbWakeUp: Z1,
    rawrigidbodyset_rbWorldCom: X1,
    rawrigidbodyset_remove: DS,
    rawrotation_angle: AT,
    rawrotation_fromAngle: ST,
    rawrotation_identity: vT,
    rawrotation_im: FC,
    rawrotation_re: ET,
    rawserializationpipeline_deserializeAll: xC,
    rawserializationpipeline_new: wC,
    rawserializationpipeline_serializeAll: yC,
    rawshape_ball: XA,
    rawshape_capsule: $A,
    rawshape_castRay: hT,
    rawshape_castRayAndGetNormal: dT,
    rawshape_castShape: sT,
    rawshape_contactShape: aT,
    rawshape_containsPoint: cT,
    rawshape_convexHull: eT,
    rawshape_convexPolyline: iT,
    rawshape_cuboid: WA,
    rawshape_halfspace: qA,
    rawshape_heightfield: ZA,
    rawshape_intersectsRay: lT,
    rawshape_intersectsShape: oT,
    rawshape_polyline: YA,
    rawshape_projectPoint: uT,
    rawshape_roundConvexHull: rT,
    rawshape_roundConvexPolyline: nT,
    rawshape_roundCuboid: VA,
    rawshape_roundTriangle: tT,
    rawshape_segment: JA,
    rawshape_triangle: QA,
    rawshape_trimesh: KA,
    rawshapecasthit_normal1: $C,
    rawshapecasthit_normal2: YC,
    rawshapecasthit_time_of_impact: UC,
    rawshapecasthit_witness1: fT,
    rawshapecasthit_witness2: XC,
    rawshapecontact_distance: TC,
    rawshapecontact_normal1: ZC,
    rawshapecontact_normal2: zC,
    rawshapecontact_point1: jC,
    rawshapecontact_point2: WC,
    rawvector_new: RT,
    rawvector_set_x: PT,
    rawvector_set_y: t3,
    rawvector_x: kC,
    rawvector_xy: BT,
    rawvector_y: GC,
    rawvector_yx: MT,
    rawvector_zero: CT,
    version: d2
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  Ex(f3);
  class p3 {
    constructor(t, e) {
      this.x = t, this.y = e;
    }
  }
  class U {
    static new(t, e) {
      return new p3(t, e);
    }
    static zeros() {
      return U.new(0, 0);
    }
    static fromRaw(t) {
      if (!t) return null;
      let e = U.new(t.x, t.y);
      return t.free(), e;
    }
    static intoRaw(t) {
      return new F(t.x, t.y);
    }
    static copy(t, e) {
      t.x = e.x, t.y = e.y;
    }
  }
  class Ft {
    static identity() {
      return 0;
    }
    static fromRaw(t) {
      if (!t) return null;
      let e = t.angle;
      return t.free(), e;
    }
    static intoRaw(t) {
      return bt.fromAngle(t);
    }
  }
  var ke;
  (function(i) {
    i[i.Dynamic = 0] = "Dynamic", i[i.Fixed = 1] = "Fixed", i[i.KinematicPositionBased = 2] = "KinematicPositionBased", i[i.KinematicVelocityBased = 3] = "KinematicVelocityBased";
  })(ke || (ke = {}));
  class bl {
    constructor(t, e, r) {
      this.rawSet = t, this.colliderSet = e, this.handle = r;
    }
    finalizeDeserialization(t) {
      this.colliderSet = t;
    }
    isValid() {
      return this.rawSet.contains(this.handle);
    }
    lockTranslations(t, e) {
      return this.rawSet.rbLockTranslations(this.handle, t, e);
    }
    lockRotations(t, e) {
      return this.rawSet.rbLockRotations(this.handle, t, e);
    }
    setEnabledTranslations(t, e, r) {
      return this.rawSet.rbSetEnabledTranslations(this.handle, t, e, r);
    }
    restrictTranslations(t, e, r) {
      this.setEnabledTranslations(t, t, r);
    }
    dominanceGroup() {
      return this.rawSet.rbDominanceGroup(this.handle);
    }
    setDominanceGroup(t) {
      this.rawSet.rbSetDominanceGroup(this.handle, t);
    }
    additionalSolverIterations() {
      return this.rawSet.rbAdditionalSolverIterations(this.handle);
    }
    setAdditionalSolverIterations(t) {
      this.rawSet.rbSetAdditionalSolverIterations(this.handle, t);
    }
    enableCcd(t) {
      this.rawSet.rbEnableCcd(this.handle, t);
    }
    setSoftCcdPrediction(t) {
      this.rawSet.rbSetSoftCcdPrediction(this.handle, t);
    }
    softCcdPrediction() {
      return this.rawSet.rbSoftCcdPrediction(this.handle);
    }
    translation() {
      let t = this.rawSet.rbTranslation(this.handle);
      return U.fromRaw(t);
    }
    rotation() {
      let t = this.rawSet.rbRotation(this.handle);
      return Ft.fromRaw(t);
    }
    nextTranslation() {
      let t = this.rawSet.rbNextTranslation(this.handle);
      return U.fromRaw(t);
    }
    nextRotation() {
      let t = this.rawSet.rbNextRotation(this.handle);
      return Ft.fromRaw(t);
    }
    setTranslation(t, e) {
      this.rawSet.rbSetTranslation(this.handle, t.x, t.y, e);
    }
    setLinvel(t, e) {
      let r = U.intoRaw(t);
      this.rawSet.rbSetLinvel(this.handle, r, e), r.free();
    }
    gravityScale() {
      return this.rawSet.rbGravityScale(this.handle);
    }
    setGravityScale(t, e) {
      this.rawSet.rbSetGravityScale(this.handle, t, e);
    }
    setRotation(t, e) {
      this.rawSet.rbSetRotation(this.handle, t, e);
    }
    setAngvel(t, e) {
      this.rawSet.rbSetAngvel(this.handle, t, e);
    }
    setNextKinematicTranslation(t) {
      this.rawSet.rbSetNextKinematicTranslation(this.handle, t.x, t.y);
    }
    setNextKinematicRotation(t) {
      this.rawSet.rbSetNextKinematicRotation(this.handle, t);
    }
    linvel() {
      return U.fromRaw(this.rawSet.rbLinvel(this.handle));
    }
    angvel() {
      return this.rawSet.rbAngvel(this.handle);
    }
    mass() {
      return this.rawSet.rbMass(this.handle);
    }
    effectiveInvMass() {
      return U.fromRaw(this.rawSet.rbEffectiveInvMass(this.handle));
    }
    invMass() {
      return this.rawSet.rbInvMass(this.handle);
    }
    localCom() {
      return U.fromRaw(this.rawSet.rbLocalCom(this.handle));
    }
    worldCom() {
      return U.fromRaw(this.rawSet.rbWorldCom(this.handle));
    }
    invPrincipalInertiaSqrt() {
      return this.rawSet.rbInvPrincipalInertiaSqrt(this.handle);
    }
    principalInertia() {
      return this.rawSet.rbPrincipalInertia(this.handle);
    }
    effectiveWorldInvInertiaSqrt() {
      return this.rawSet.rbEffectiveWorldInvInertiaSqrt(this.handle);
    }
    effectiveAngularInertia() {
      return this.rawSet.rbEffectiveAngularInertia(this.handle);
    }
    sleep() {
      this.rawSet.rbSleep(this.handle);
    }
    wakeUp() {
      this.rawSet.rbWakeUp(this.handle);
    }
    isCcdEnabled() {
      return this.rawSet.rbIsCcdEnabled(this.handle);
    }
    numColliders() {
      return this.rawSet.rbNumColliders(this.handle);
    }
    collider(t) {
      return this.colliderSet.get(this.rawSet.rbCollider(this.handle, t));
    }
    setEnabled(t) {
      this.rawSet.rbSetEnabled(this.handle, t);
    }
    isEnabled() {
      return this.rawSet.rbIsEnabled(this.handle);
    }
    bodyType() {
      return this.rawSet.rbBodyType(this.handle);
    }
    setBodyType(t, e) {
      return this.rawSet.rbSetBodyType(this.handle, t, e);
    }
    isSleeping() {
      return this.rawSet.rbIsSleeping(this.handle);
    }
    isMoving() {
      return this.rawSet.rbIsMoving(this.handle);
    }
    isFixed() {
      return this.rawSet.rbIsFixed(this.handle);
    }
    isKinematic() {
      return this.rawSet.rbIsKinematic(this.handle);
    }
    isDynamic() {
      return this.rawSet.rbIsDynamic(this.handle);
    }
    linearDamping() {
      return this.rawSet.rbLinearDamping(this.handle);
    }
    angularDamping() {
      return this.rawSet.rbAngularDamping(this.handle);
    }
    setLinearDamping(t) {
      this.rawSet.rbSetLinearDamping(this.handle, t);
    }
    recomputeMassPropertiesFromColliders() {
      this.rawSet.rbRecomputeMassPropertiesFromColliders(this.handle, this.colliderSet.raw);
    }
    setAdditionalMass(t, e) {
      this.rawSet.rbSetAdditionalMass(this.handle, t, e);
    }
    setAdditionalMassProperties(t, e, r, n) {
      let s = U.intoRaw(e);
      this.rawSet.rbSetAdditionalMassProperties(this.handle, t, s, r, n), s.free();
    }
    setAngularDamping(t) {
      this.rawSet.rbSetAngularDamping(this.handle, t);
    }
    resetForces(t) {
      this.rawSet.rbResetForces(this.handle, t);
    }
    resetTorques(t) {
      this.rawSet.rbResetTorques(this.handle, t);
    }
    addForce(t, e) {
      const r = U.intoRaw(t);
      this.rawSet.rbAddForce(this.handle, r, e), r.free();
    }
    applyImpulse(t, e) {
      const r = U.intoRaw(t);
      this.rawSet.rbApplyImpulse(this.handle, r, e), r.free();
    }
    addTorque(t, e) {
      this.rawSet.rbAddTorque(this.handle, t, e);
    }
    applyTorqueImpulse(t, e) {
      this.rawSet.rbApplyTorqueImpulse(this.handle, t, e);
    }
    addForceAtPoint(t, e, r) {
      const n = U.intoRaw(t), s = U.intoRaw(e);
      this.rawSet.rbAddForceAtPoint(this.handle, n, s, r), n.free(), s.free();
    }
    applyImpulseAtPoint(t, e, r) {
      const n = U.intoRaw(t), s = U.intoRaw(e);
      this.rawSet.rbApplyImpulseAtPoint(this.handle, n, s, r), n.free(), s.free();
    }
    userForce() {
      return U.fromRaw(this.rawSet.rbUserForce(this.handle));
    }
    userTorque() {
      return this.rawSet.rbUserTorque(this.handle);
    }
  }
  class fe {
    constructor(t) {
      this.enabled = true, this.status = t, this.translation = U.zeros(), this.rotation = Ft.identity(), this.gravityScale = 1, this.linvel = U.zeros(), this.mass = 0, this.massOnly = false, this.centerOfMass = U.zeros(), this.translationsEnabledX = true, this.translationsEnabledY = true, this.angvel = 0, this.principalAngularInertia = 0, this.rotationsEnabled = true, this.linearDamping = 0, this.angularDamping = 0, this.canSleep = true, this.sleeping = false, this.ccdEnabled = false, this.softCcdPrediction = 0, this.dominanceGroup = 0, this.additionalSolverIterations = 0;
    }
    static dynamic() {
      return new fe(ke.Dynamic);
    }
    static kinematicPositionBased() {
      return new fe(ke.KinematicPositionBased);
    }
    static kinematicVelocityBased() {
      return new fe(ke.KinematicVelocityBased);
    }
    static fixed() {
      return new fe(ke.Fixed);
    }
    static newDynamic() {
      return new fe(ke.Dynamic);
    }
    static newKinematicPositionBased() {
      return new fe(ke.KinematicPositionBased);
    }
    static newKinematicVelocityBased() {
      return new fe(ke.KinematicVelocityBased);
    }
    static newStatic() {
      return new fe(ke.Fixed);
    }
    setDominanceGroup(t) {
      return this.dominanceGroup = t, this;
    }
    setAdditionalSolverIterations(t) {
      return this.additionalSolverIterations = t, this;
    }
    setEnabled(t) {
      return this.enabled = t, this;
    }
    setTranslation(t, e) {
      if (typeof t != "number" || typeof e != "number") throw TypeError("The translation components must be numbers.");
      return this.translation = {
        x: t,
        y: e
      }, this;
    }
    setRotation(t) {
      return this.rotation = t, this;
    }
    setGravityScale(t) {
      return this.gravityScale = t, this;
    }
    setAdditionalMass(t) {
      return this.mass = t, this.massOnly = true, this;
    }
    setLinvel(t, e) {
      if (typeof t != "number" || typeof e != "number") throw TypeError("The linvel components must be numbers.");
      return this.linvel = {
        x: t,
        y: e
      }, this;
    }
    setAngvel(t) {
      return this.angvel = t, this;
    }
    setAdditionalMassProperties(t, e, r) {
      return this.mass = t, U.copy(this.centerOfMass, e), this.principalAngularInertia = r, this.massOnly = false, this;
    }
    enabledTranslations(t, e) {
      return this.translationsEnabledX = t, this.translationsEnabledY = e, this;
    }
    restrictTranslations(t, e) {
      return this.enabledTranslations(t, e);
    }
    lockTranslations() {
      return this.restrictTranslations(false, false);
    }
    lockRotations() {
      return this.rotationsEnabled = false, this;
    }
    setLinearDamping(t) {
      return this.linearDamping = t, this;
    }
    setAngularDamping(t) {
      return this.angularDamping = t, this;
    }
    setCanSleep(t) {
      return this.canSleep = t, this;
    }
    setSleeping(t) {
      return this.sleeping = t, this;
    }
    setCcdEnabled(t) {
      return this.ccdEnabled = t, this;
    }
    setSoftCcdPrediction(t) {
      return this.softCcdPrediction = t, this;
    }
    setUserData(t) {
      return this.userData = t, this;
    }
  }
  class hs {
    constructor() {
      this.fconv = new Float64Array(1), this.uconv = new Uint32Array(this.fconv.buffer), this.data = new Array(), this.size = 0;
    }
    set(t, e) {
      let r = this.index(t);
      for (; this.data.length <= r; ) this.data.push(null);
      this.data[r] == null && (this.size += 1), this.data[r] = e;
    }
    len() {
      return this.size;
    }
    delete(t) {
      let e = this.index(t);
      e < this.data.length && (this.data[e] != null && (this.size -= 1), this.data[e] = null);
    }
    clear() {
      this.data = new Array();
    }
    get(t) {
      let e = this.index(t);
      return e < this.data.length ? this.data[e] : null;
    }
    forEach(t) {
      for (const e of this.data) e != null && t(e);
    }
    getAll() {
      return this.data.filter((t) => t != null);
    }
    index(t) {
      return this.fconv[0] = t, this.uconv[0];
    }
  }
  class _3 {
    constructor(t) {
      this.raw = t || new Wt(), this.map = new hs(), t && t.forEachRigidBodyHandle((e) => {
        this.map.set(e, new bl(t, null, e));
      });
    }
    free() {
      this.raw && this.raw.free(), this.raw = void 0, this.map && this.map.clear(), this.map = void 0;
    }
    finalizeDeserialization(t) {
      this.map.forEach((e) => e.finalizeDeserialization(t));
    }
    createRigidBody(t, e) {
      let r = U.intoRaw(e.translation), n = Ft.intoRaw(e.rotation), s = U.intoRaw(e.linvel), o = U.intoRaw(e.centerOfMass), a = this.raw.createRigidBody(e.enabled, r, n, e.gravityScale, e.mass, e.massOnly, o, s, e.angvel, e.principalAngularInertia, e.translationsEnabledX, e.translationsEnabledY, e.rotationsEnabled, e.linearDamping, e.angularDamping, e.status, e.canSleep, e.sleeping, e.softCcdPrediction, e.ccdEnabled, e.dominanceGroup, e.additionalSolverIterations);
      r.free(), n.free(), s.free(), o.free();
      const c = new bl(this.raw, t, a);
      return c.userData = e.userData, this.map.set(a, c), c;
    }
    remove(t, e, r, n, s) {
      for (let o = 0; o < this.raw.rbNumColliders(t); o += 1) r.unmap(this.raw.rbCollider(t, o));
      n.forEachJointHandleAttachedToRigidBody(t, (o) => n.unmap(o)), s.forEachJointHandleAttachedToRigidBody(t, (o) => s.unmap(o)), this.raw.remove(t, e.raw, r.raw, n.raw, s.raw), this.map.delete(t);
    }
    len() {
      return this.map.len();
    }
    contains(t) {
      return this.get(t) != null;
    }
    get(t) {
      return this.map.get(t);
    }
    forEach(t) {
      this.map.forEach(t);
    }
    forEachActiveRigidBody(t, e) {
      t.forEachActiveRigidBodyHandle((r) => {
        e(this.get(r));
      });
    }
    getAll() {
      return this.map.getAll();
    }
  }
  class g3 {
    constructor(t) {
      this.raw = t || new Mr();
    }
    free() {
      this.raw && this.raw.free(), this.raw = void 0;
    }
    get dt() {
      return this.raw.dt;
    }
    get contact_erp() {
      return this.raw.contact_erp;
    }
    get lengthUnit() {
      return this.raw.lengthUnit;
    }
    get normalizedAllowedLinearError() {
      return this.raw.normalizedAllowedLinearError;
    }
    get normalizedPredictionDistance() {
      return this.raw.normalizedPredictionDistance;
    }
    get numSolverIterations() {
      return this.raw.numSolverIterations;
    }
    get numAdditionalFrictionIterations() {
      return this.raw.numAdditionalFrictionIterations;
    }
    get numInternalPgsIterations() {
      return this.raw.numInternalPgsIterations;
    }
    get minIslandSize() {
      return this.raw.minIslandSize;
    }
    get maxCcdSubsteps() {
      return this.raw.maxCcdSubsteps;
    }
    set dt(t) {
      this.raw.dt = t;
    }
    set contact_natural_frequency(t) {
      this.raw.contact_natural_frequency = t;
    }
    set lengthUnit(t) {
      this.raw.lengthUnit = t;
    }
    set normalizedAllowedLinearError(t) {
      this.raw.normalizedAllowedLinearError = t;
    }
    set normalizedPredictionDistance(t) {
      this.raw.normalizedPredictionDistance = t;
    }
    set numSolverIterations(t) {
      this.raw.numSolverIterations = t;
    }
    set numAdditionalFrictionIterations(t) {
      this.raw.numAdditionalFrictionIterations = t;
    }
    set numInternalPgsIterations(t) {
      this.raw.numInternalPgsIterations = t;
    }
    set minIslandSize(t) {
      this.raw.minIslandSize = t;
    }
    set maxCcdSubsteps(t) {
      this.raw.maxCcdSubsteps = t;
    }
    switchToStandardPgsSolver() {
      this.raw.switchToStandardPgsSolver();
    }
    switchToSmallStepsPgsSolver() {
      this.raw.switchToSmallStepsPgsSolver();
    }
    switchToSmallStepsPgsSolverWithoutWarmstart() {
      this.raw.switchToSmallStepsPgsSolverWithoutWarmstart();
    }
  }
  var wl;
  (function(i) {
    i[i.Revolute = 0] = "Revolute", i[i.Fixed = 1] = "Fixed", i[i.Prismatic = 2] = "Prismatic", i[i.Rope = 3] = "Rope", i[i.Spring = 4] = "Spring";
  })(wl || (wl = {}));
  var yl;
  (function(i) {
    i[i.AccelerationBased = 0] = "AccelerationBased", i[i.ForceBased = 1] = "ForceBased";
  })(yl || (yl = {}));
  var xl;
  (function(i) {
    i[i.LinX = 1] = "LinX", i[i.LinY = 2] = "LinY", i[i.LinZ = 4] = "LinZ", i[i.AngX = 8] = "AngX", i[i.AngY = 16] = "AngY", i[i.AngZ = 32] = "AngZ";
  })(xl || (xl = {}));
  class fr {
    constructor(t, e, r) {
      this.rawSet = t, this.bodySet = e, this.handle = r;
    }
    static newTyped(t, e, r) {
      switch (t.jointType(r)) {
        case ar.Revolute:
          return new x3(t, e, r);
        case ar.Prismatic:
          return new y3(t, e, r);
        case ar.Fixed:
          return new m3(t, e, r);
        case ar.Spring:
          return new w3(t, e, r);
        case ar.Rope:
          return new b3(t, e, r);
        default:
          return new fr(t, e, r);
      }
    }
    finalizeDeserialization(t) {
      this.bodySet = t;
    }
    isValid() {
      return this.rawSet.contains(this.handle);
    }
    body1() {
      return this.bodySet.get(this.rawSet.jointBodyHandle1(this.handle));
    }
    body2() {
      return this.bodySet.get(this.rawSet.jointBodyHandle2(this.handle));
    }
    type() {
      return this.rawSet.jointType(this.handle);
    }
    anchor1() {
      return U.fromRaw(this.rawSet.jointAnchor1(this.handle));
    }
    anchor2() {
      return U.fromRaw(this.rawSet.jointAnchor2(this.handle));
    }
    setAnchor1(t) {
      const e = U.intoRaw(t);
      this.rawSet.jointSetAnchor1(this.handle, e), e.free();
    }
    setAnchor2(t) {
      const e = U.intoRaw(t);
      this.rawSet.jointSetAnchor2(this.handle, e), e.free();
    }
    setContactsEnabled(t) {
      this.rawSet.jointSetContactsEnabled(this.handle, t);
    }
    contactsEnabled() {
      return this.rawSet.jointContactsEnabled(this.handle);
    }
  }
  class tp extends fr {
    limitsEnabled() {
      return this.rawSet.jointLimitsEnabled(this.handle, this.rawAxis());
    }
    limitsMin() {
      return this.rawSet.jointLimitsMin(this.handle, this.rawAxis());
    }
    limitsMax() {
      return this.rawSet.jointLimitsMax(this.handle, this.rawAxis());
    }
    setLimits(t, e) {
      this.rawSet.jointSetLimits(this.handle, this.rawAxis(), t, e);
    }
    configureMotorModel(t) {
      this.rawSet.jointConfigureMotorModel(this.handle, this.rawAxis(), t);
    }
    configureMotorVelocity(t, e) {
      this.rawSet.jointConfigureMotorVelocity(this.handle, this.rawAxis(), t, e);
    }
    configureMotorPosition(t, e, r) {
      this.rawSet.jointConfigureMotorPosition(this.handle, this.rawAxis(), t, e, r);
    }
    configureMotor(t, e, r, n) {
      this.rawSet.jointConfigureMotor(this.handle, this.rawAxis(), t, e, r, n);
    }
  }
  class m3 extends fr {
  }
  class b3 extends fr {
  }
  class w3 extends fr {
  }
  class y3 extends tp {
    rawAxis() {
      return ss.LinX;
    }
  }
  class x3 extends tp {
    rawAxis() {
      return ss.AngX;
    }
  }
  class v3 {
    constructor(t) {
      this.raw = t || new Qe(), this.map = new hs(), t && t.forEachJointHandle((e) => {
        this.map.set(e, fr.newTyped(t, null, e));
      });
    }
    free() {
      this.raw && this.raw.free(), this.raw = void 0, this.map && this.map.clear(), this.map = void 0;
    }
    finalizeDeserialization(t) {
      this.map.forEach((e) => e.finalizeDeserialization(t));
    }
    createJoint(t, e, r, n, s) {
      const o = e.intoRaw(), a = this.raw.createJoint(o, r, n, s);
      o.free();
      let c = fr.newTyped(this.raw, t, a);
      return this.map.set(a, c), c;
    }
    remove(t, e) {
      this.raw.remove(t, e), this.unmap(t);
    }
    forEachJointHandleAttachedToRigidBody(t, e) {
      this.raw.forEachJointAttachedToRigidBody(t, e);
    }
    unmap(t) {
      this.map.delete(t);
    }
    len() {
      return this.map.len();
    }
    contains(t) {
      return this.get(t) != null;
    }
    get(t) {
      return this.map.get(t);
    }
    forEach(t) {
      this.map.forEach(t);
    }
    getAll() {
      return this.map.getAll();
    }
  }
  class Qr {
    constructor(t, e) {
      this.rawSet = t, this.handle = e;
    }
    static newTyped(t, e) {
      switch (t.jointType(e)) {
        case ar.Revolute:
          return new A3(t, e);
        case ar.Prismatic:
          return new E3(t, e);
        case ar.Fixed:
          return new S3(t, e);
        default:
          return new Qr(t, e);
      }
    }
    isValid() {
      return this.rawSet.contains(this.handle);
    }
    setContactsEnabled(t) {
      this.rawSet.jointSetContactsEnabled(this.handle, t);
    }
    contactsEnabled() {
      return this.rawSet.jointContactsEnabled(this.handle);
    }
  }
  class ep extends Qr {
  }
  class S3 extends Qr {
  }
  class E3 extends ep {
    rawAxis() {
      return ss.LinX;
    }
  }
  class A3 extends ep {
    rawAxis() {
      return ss.AngX;
    }
  }
  class T3 {
    constructor(t) {
      this.raw = t || new er(), this.map = new hs(), t && t.forEachJointHandle((e) => {
        this.map.set(e, Qr.newTyped(this.raw, e));
      });
    }
    free() {
      this.raw && this.raw.free(), this.raw = void 0, this.map && this.map.clear(), this.map = void 0;
    }
    createJoint(t, e, r, n) {
      const s = t.intoRaw(), o = this.raw.createJoint(s, e, r, n);
      s.free();
      let a = Qr.newTyped(this.raw, o);
      return this.map.set(o, a), a;
    }
    remove(t, e) {
      this.raw.remove(t, e), this.map.delete(t);
    }
    unmap(t) {
      this.map.delete(t);
    }
    len() {
      return this.map.len();
    }
    contains(t) {
      return this.get(t) != null;
    }
    get(t) {
      return this.map.get(t);
    }
    forEach(t) {
      this.map.forEach(t);
    }
    forEachJointHandleAttachedToRigidBody(t, e) {
      this.raw.forEachJointAttachedToRigidBody(t, e);
    }
    getAll() {
      return this.map.getAll();
    }
  }
  var zn;
  (function(i) {
    i[i.Average = 0] = "Average", i[i.Min = 1] = "Min", i[i.Multiply = 2] = "Multiply", i[i.Max = 3] = "Max";
  })(zn || (zn = {}));
  class C3 {
    constructor(t) {
      this.raw = t || new jo();
    }
    free() {
      this.raw && this.raw.free(), this.raw = void 0;
    }
  }
  class R3 {
    constructor(t) {
      this.raw = t || new tr();
    }
    free() {
      this.raw && this.raw.free(), this.raw = void 0;
    }
    forEachActiveRigidBodyHandle(t) {
      this.raw.forEachActiveRigidBodyHandle(t);
    }
  }
  class P3 {
    constructor(t) {
      this.raw = t || new Br();
    }
    free() {
      this.raw && this.raw.free(), this.raw = void 0;
    }
  }
  class B3 {
    constructor(t) {
      this.raw = t || new dr(), this.tempManifold = new M3(null);
    }
    free() {
      this.raw && this.raw.free(), this.raw = void 0;
    }
    contactPairsWith(t, e) {
      this.raw.contact_pairs_with(t, e);
    }
    intersectionPairsWith(t, e) {
      this.raw.intersection_pairs_with(t, e);
    }
    contactPair(t, e, r) {
      const n = this.raw.contact_pair(t, e);
      if (n) {
        const s = n.collider1() != t;
        let o;
        for (o = 0; o < n.numContactManifolds(); ++o) this.tempManifold.raw = n.contactManifold(o), this.tempManifold.raw && r(this.tempManifold, s), this.tempManifold.free();
        n.free();
      }
    }
    intersectionPair(t, e) {
      return this.raw.intersection_pair(t, e);
    }
  }
  class M3 {
    constructor(t) {
      this.raw = t;
    }
    free() {
      this.raw && this.raw.free(), this.raw = void 0;
    }
    normal() {
      return U.fromRaw(this.raw.normal());
    }
    localNormal1() {
      return U.fromRaw(this.raw.local_n1());
    }
    localNormal2() {
      return U.fromRaw(this.raw.local_n2());
    }
    subshape1() {
      return this.raw.subshape1();
    }
    subshape2() {
      return this.raw.subshape2();
    }
    numContacts() {
      return this.raw.num_contacts();
    }
    localContactPoint1(t) {
      return U.fromRaw(this.raw.contact_local_p1(t));
    }
    localContactPoint2(t) {
      return U.fromRaw(this.raw.contact_local_p2(t));
    }
    contactDist(t) {
      return this.raw.contact_dist(t);
    }
    contactFid1(t) {
      return this.raw.contact_fid1(t);
    }
    contactFid2(t) {
      return this.raw.contact_fid2(t);
    }
    contactImpulse(t) {
      return this.raw.contact_impulse(t);
    }
    contactTangentImpulse(t) {
      return this.raw.contact_tangent_impulse(t);
    }
    numSolverContacts() {
      return this.raw.num_solver_contacts();
    }
    solverContactPoint(t) {
      return U.fromRaw(this.raw.solver_contact_point(t));
    }
    solverContactDist(t) {
      return this.raw.solver_contact_dist(t);
    }
    solverContactFriction(t) {
      return this.raw.solver_contact_friction(t);
    }
    solverContactRestitution(t) {
      return this.raw.solver_contact_restitution(t);
    }
    solverContactTangentVelocity(t) {
      return U.fromRaw(this.raw.solver_contact_tangent_velocity(t));
    }
  }
  class Bi {
    constructor(t, e, r, n, s) {
      this.distance = t, this.point1 = e, this.point2 = r, this.normal1 = n, this.normal2 = s;
    }
    static fromRaw(t) {
      if (!t) return null;
      const e = new Bi(t.distance(), U.fromRaw(t.point1()), U.fromRaw(t.point2()), U.fromRaw(t.normal1()), U.fromRaw(t.normal2()));
      return t.free(), e;
    }
  }
  var Mi;
  (function(i) {
    i[i.Vertex = 0] = "Vertex", i[i.Face = 1] = "Face", i[i.Unknown = 2] = "Unknown";
  })(Mi || (Mi = {}));
  class ds {
    constructor(t, e) {
      this.point = t, this.isInside = e;
    }
    static fromRaw(t) {
      if (!t) return null;
      const e = new ds(U.fromRaw(t.point()), t.isInside());
      return t.free(), e;
    }
  }
  class jn {
    constructor(t, e, r, n, s) {
      this.featureType = Mi.Unknown, this.featureId = void 0, this.collider = t, this.point = e, this.isInside = r, s !== void 0 && (this.featureId = s), n !== void 0 && (this.featureType = n);
    }
    static fromRaw(t, e) {
      if (!e) return null;
      const r = new jn(t.get(e.colliderHandle()), U.fromRaw(e.point()), e.isInside(), e.featureType(), e.featureId());
      return e.free(), r;
    }
  }
  class fs {
    constructor(t, e, r, n) {
      this.featureType = Mi.Unknown, this.featureId = void 0, this.timeOfImpact = t, this.normal = e, n !== void 0 && (this.featureId = n), r !== void 0 && (this.featureType = r);
    }
    static fromRaw(t) {
      if (!t) return null;
      const e = new fs(t.time_of_impact(), U.fromRaw(t.normal()), t.featureType(), t.featureId());
      return t.free(), e;
    }
  }
  class Wn {
    constructor(t, e, r, n, s) {
      this.featureType = Mi.Unknown, this.featureId = void 0, this.collider = t, this.timeOfImpact = e, this.normal = r, s !== void 0 && (this.featureId = s), n !== void 0 && (this.featureType = n);
    }
    static fromRaw(t, e) {
      if (!e) return null;
      const r = new Wn(t.get(e.colliderHandle()), e.time_of_impact(), U.fromRaw(e.normal()), e.featureType(), e.featureId());
      return e.free(), r;
    }
  }
  class La {
    constructor(t, e) {
      this.collider = t, this.timeOfImpact = e;
    }
    static fromRaw(t, e) {
      if (!e) return null;
      const r = new La(t.get(e.colliderHandle()), e.timeOfImpact());
      return e.free(), r;
    }
  }
  class Ni {
    constructor(t, e, r, n, s) {
      this.time_of_impact = t, this.witness1 = e, this.witness2 = r, this.normal1 = n, this.normal2 = s;
    }
    static fromRaw(t, e) {
      if (!e) return null;
      const r = new Ni(e.time_of_impact(), U.fromRaw(e.witness1()), U.fromRaw(e.witness2()), U.fromRaw(e.normal1()), U.fromRaw(e.normal2()));
      return e.free(), r;
    }
  }
  class ps extends Ni {
    constructor(t, e, r, n, s, o) {
      super(e, r, n, s, o), this.collider = t;
    }
    static fromRaw(t, e) {
      if (!e) return null;
      const r = new ps(t.get(e.colliderHandle()), e.time_of_impact(), U.fromRaw(e.witness1()), U.fromRaw(e.witness2()), U.fromRaw(e.normal1()), U.fromRaw(e.normal2()));
      return e.free(), r;
    }
  }
  class ce {
    static fromRaw(t, e) {
      const r = t.coShapeType(e);
      let n, s, o, a, c, u, l;
      switch (r) {
        case ue.Ball:
          return new rp(t.coRadius(e));
        case ue.Cuboid:
          return n = t.coHalfExtents(e), new np(n.x, n.y);
        case ue.RoundCuboid:
          return n = t.coHalfExtents(e), s = t.coRoundRadius(e), new sp(n.x, n.y, s);
        case ue.Capsule:
          return c = t.coHalfHeight(e), u = t.coRadius(e), new op(c, u);
        case ue.Segment:
          return o = t.coVertices(e), new ap(U.new(o[0], o[1]), U.new(o[2], o[3]));
        case ue.Polyline:
          return o = t.coVertices(e), a = t.coIndices(e), new lp(o, a);
        case ue.Triangle:
          return o = t.coVertices(e), new cp(U.new(o[0], o[1]), U.new(o[2], o[3]), U.new(o[4], o[5]));
        case ue.RoundTriangle:
          return o = t.coVertices(e), s = t.coRoundRadius(e), new up(U.new(o[0], o[1]), U.new(o[2], o[3]), U.new(o[4], o[5]), s);
        case ue.HalfSpace:
          return l = U.fromRaw(t.coHalfspaceNormal(e)), new ip(l);
        case ue.TriMesh:
          o = t.coVertices(e), a = t.coIndices(e);
          const h = t.coTriMeshFlags(e);
          return new hp(o, a, h);
        case ue.HeightField:
          const f = t.coHeightfieldScale(e), p = t.coHeightfieldHeights(e);
          return new dp(p, f);
        case ue.ConvexPolygon:
          return o = t.coVertices(e), new Wo(o, false);
        case ue.RoundConvexPolygon:
          return o = t.coVertices(e), s = t.coRoundRadius(e), new Vo(o, s, false);
        default:
          throw new Error("unknown shape type: " + r);
      }
    }
    castShape(t, e, r, n, s, o, a, c, u, l) {
      let h = U.intoRaw(t), f = Ft.intoRaw(e), p = U.intoRaw(r), m = U.intoRaw(s), y = Ft.intoRaw(o), b = U.intoRaw(a), v = this.intoRaw(), A = n.intoRaw(), T = Ni.fromRaw(null, v.castShape(h, f, p, A, m, y, b, c, u, l));
      return h.free(), f.free(), p.free(), m.free(), y.free(), b.free(), v.free(), A.free(), T;
    }
    intersectsShape(t, e, r, n, s) {
      let o = U.intoRaw(t), a = Ft.intoRaw(e), c = U.intoRaw(n), u = Ft.intoRaw(s), l = this.intoRaw(), h = r.intoRaw(), f = l.intersectsShape(o, a, h, c, u);
      return o.free(), a.free(), c.free(), u.free(), l.free(), h.free(), f;
    }
    contactShape(t, e, r, n, s, o) {
      let a = U.intoRaw(t), c = Ft.intoRaw(e), u = U.intoRaw(n), l = Ft.intoRaw(s), h = this.intoRaw(), f = r.intoRaw(), p = Bi.fromRaw(h.contactShape(a, c, f, u, l, o));
      return a.free(), c.free(), u.free(), l.free(), h.free(), f.free(), p;
    }
    containsPoint(t, e, r) {
      let n = U.intoRaw(t), s = Ft.intoRaw(e), o = U.intoRaw(r), a = this.intoRaw(), c = a.containsPoint(n, s, o);
      return n.free(), s.free(), o.free(), a.free(), c;
    }
    projectPoint(t, e, r, n) {
      let s = U.intoRaw(t), o = Ft.intoRaw(e), a = U.intoRaw(r), c = this.intoRaw(), u = ds.fromRaw(c.projectPoint(s, o, a, n));
      return s.free(), o.free(), a.free(), c.free(), u;
    }
    intersectsRay(t, e, r, n) {
      let s = U.intoRaw(e), o = Ft.intoRaw(r), a = U.intoRaw(t.origin), c = U.intoRaw(t.dir), u = this.intoRaw(), l = u.intersectsRay(s, o, a, c, n);
      return s.free(), o.free(), a.free(), c.free(), u.free(), l;
    }
    castRay(t, e, r, n, s) {
      let o = U.intoRaw(e), a = Ft.intoRaw(r), c = U.intoRaw(t.origin), u = U.intoRaw(t.dir), l = this.intoRaw(), h = l.castRay(o, a, c, u, n, s);
      return o.free(), a.free(), c.free(), u.free(), l.free(), h;
    }
    castRayAndGetNormal(t, e, r, n, s) {
      let o = U.intoRaw(e), a = Ft.intoRaw(r), c = U.intoRaw(t.origin), u = U.intoRaw(t.dir), l = this.intoRaw(), h = fs.fromRaw(l.castRayAndGetNormal(o, a, c, u, n, s));
      return o.free(), a.free(), c.free(), u.free(), l.free(), h;
    }
  }
  var ie;
  (function(i) {
    i[i.Ball = 0] = "Ball", i[i.Cuboid = 1] = "Cuboid", i[i.Capsule = 2] = "Capsule", i[i.Segment = 3] = "Segment", i[i.Polyline = 4] = "Polyline", i[i.Triangle = 5] = "Triangle", i[i.TriMesh = 6] = "TriMesh", i[i.HeightField = 7] = "HeightField", i[i.ConvexPolygon = 9] = "ConvexPolygon", i[i.RoundCuboid = 10] = "RoundCuboid", i[i.RoundTriangle = 11] = "RoundTriangle", i[i.RoundConvexPolygon = 12] = "RoundConvexPolygon", i[i.HalfSpace = 13] = "HalfSpace";
  })(ie || (ie = {}));
  var vl;
  (function(i) {
    i[i.DELETE_BAD_TOPOLOGY_TRIANGLES = 4] = "DELETE_BAD_TOPOLOGY_TRIANGLES", i[i.ORIENTED = 8] = "ORIENTED", i[i.MERGE_DUPLICATE_VERTICES = 16] = "MERGE_DUPLICATE_VERTICES", i[i.DELETE_DEGENERATE_TRIANGLES = 32] = "DELETE_DEGENERATE_TRIANGLES", i[i.DELETE_DUPLICATE_TRIANGLES = 64] = "DELETE_DUPLICATE_TRIANGLES", i[i.FIX_INTERNAL_EDGES = 152] = "FIX_INTERNAL_EDGES";
  })(vl || (vl = {}));
  class rp extends ce {
    constructor(t) {
      super(), this.type = ie.Ball, this.radius = t;
    }
    intoRaw() {
      return ct.ball(this.radius);
    }
  }
  class ip extends ce {
    constructor(t) {
      super(), this.type = ie.HalfSpace, this.normal = t;
    }
    intoRaw() {
      let t = U.intoRaw(this.normal), e = ct.halfspace(t);
      return t.free(), e;
    }
  }
  class np extends ce {
    constructor(t, e) {
      super(), this.type = ie.Cuboid, this.halfExtents = U.new(t, e);
    }
    intoRaw() {
      return ct.cuboid(this.halfExtents.x, this.halfExtents.y);
    }
  }
  class sp extends ce {
    constructor(t, e, r) {
      super(), this.type = ie.RoundCuboid, this.halfExtents = U.new(t, e), this.borderRadius = r;
    }
    intoRaw() {
      return ct.roundCuboid(this.halfExtents.x, this.halfExtents.y, this.borderRadius);
    }
  }
  class op extends ce {
    constructor(t, e) {
      super(), this.type = ie.Capsule, this.halfHeight = t, this.radius = e;
    }
    intoRaw() {
      return ct.capsule(this.halfHeight, this.radius);
    }
  }
  class ap extends ce {
    constructor(t, e) {
      super(), this.type = ie.Segment, this.a = t, this.b = e;
    }
    intoRaw() {
      let t = U.intoRaw(this.a), e = U.intoRaw(this.b), r = ct.segment(t, e);
      return t.free(), e.free(), r;
    }
  }
  class cp extends ce {
    constructor(t, e, r) {
      super(), this.type = ie.Triangle, this.a = t, this.b = e, this.c = r;
    }
    intoRaw() {
      let t = U.intoRaw(this.a), e = U.intoRaw(this.b), r = U.intoRaw(this.c), n = ct.triangle(t, e, r);
      return t.free(), e.free(), r.free(), n;
    }
  }
  class up extends ce {
    constructor(t, e, r, n) {
      super(), this.type = ie.RoundTriangle, this.a = t, this.b = e, this.c = r, this.borderRadius = n;
    }
    intoRaw() {
      let t = U.intoRaw(this.a), e = U.intoRaw(this.b), r = U.intoRaw(this.c), n = ct.roundTriangle(t, e, r, this.borderRadius);
      return t.free(), e.free(), r.free(), n;
    }
  }
  class lp extends ce {
    constructor(t, e) {
      super(), this.type = ie.Polyline, this.vertices = t, this.indices = e ?? new Uint32Array(0);
    }
    intoRaw() {
      return ct.polyline(this.vertices, this.indices);
    }
  }
  class hp extends ce {
    constructor(t, e, r) {
      super(), this.type = ie.TriMesh, this.vertices = t, this.indices = e, this.flags = r;
    }
    intoRaw() {
      return ct.trimesh(this.vertices, this.indices, this.flags);
    }
  }
  class Wo extends ce {
    constructor(t, e) {
      super(), this.type = ie.ConvexPolygon, this.vertices = t, this.skipConvexHullComputation = !!e;
    }
    intoRaw() {
      return this.skipConvexHullComputation ? ct.convexPolyline(this.vertices) : ct.convexHull(this.vertices);
    }
  }
  class Vo extends ce {
    constructor(t, e, r) {
      super(), this.type = ie.RoundConvexPolygon, this.vertices = t, this.borderRadius = e, this.skipConvexHullComputation = !!r;
    }
    intoRaw() {
      return this.skipConvexHullComputation ? ct.roundConvexPolyline(this.vertices, this.borderRadius) : ct.roundConvexHull(this.vertices, this.borderRadius);
    }
  }
  class dp extends ce {
    constructor(t, e) {
      super(), this.type = ie.HeightField, this.heights = t, this.scale = e;
    }
    intoRaw() {
      let t = U.intoRaw(this.scale), e = ct.heightfield(this.heights, t);
      return t.free(), e;
    }
  }
  class D3 {
    constructor(t) {
      this.raw = t || new Nx();
    }
    free() {
      this.raw && this.raw.free(), this.raw = void 0;
    }
    step(t, e, r, n, s, o, a, c, u, l, h, f) {
      let p = U.intoRaw(t);
      h ? this.raw.stepWithEvents(p, e.raw, r.raw, n.raw, s.raw, o.raw, a.raw, c.raw, u.raw, l.raw, h.raw, f, f ? f.filterContactPair : null, f ? f.filterIntersectionPair : null) : this.raw.step(p, e.raw, r.raw, n.raw, s.raw, o.raw, a.raw, c.raw, u.raw, l.raw), p.free();
    }
  }
  var Sl;
  (function(i) {
    i[i.EXCLUDE_FIXED = 1] = "EXCLUDE_FIXED", i[i.EXCLUDE_KINEMATIC = 2] = "EXCLUDE_KINEMATIC", i[i.EXCLUDE_DYNAMIC = 4] = "EXCLUDE_DYNAMIC", i[i.EXCLUDE_SENSORS = 8] = "EXCLUDE_SENSORS", i[i.EXCLUDE_SOLIDS = 16] = "EXCLUDE_SOLIDS", i[i.ONLY_DYNAMIC = 3] = "ONLY_DYNAMIC", i[i.ONLY_KINEMATIC = 5] = "ONLY_KINEMATIC", i[i.ONLY_FIXED = 6] = "ONLY_FIXED";
  })(Sl || (Sl = {}));
  class I3 {
    constructor(t) {
      this.raw = t || new Qf();
    }
    free() {
      this.raw && this.raw.free(), this.raw = void 0;
    }
    update(t) {
      this.raw.update(t.raw);
    }
    castRay(t, e, r, n, s, o, a, c, u, l) {
      let h = U.intoRaw(r.origin), f = U.intoRaw(r.dir), p = La.fromRaw(e, this.raw.castRay(t.raw, e.raw, h, f, n, s, o, a, c, u, l));
      return h.free(), f.free(), p;
    }
    castRayAndGetNormal(t, e, r, n, s, o, a, c, u, l) {
      let h = U.intoRaw(r.origin), f = U.intoRaw(r.dir), p = Wn.fromRaw(e, this.raw.castRayAndGetNormal(t.raw, e.raw, h, f, n, s, o, a, c, u, l));
      return h.free(), f.free(), p;
    }
    intersectionsWithRay(t, e, r, n, s, o, a, c, u, l, h) {
      let f = U.intoRaw(r.origin), p = U.intoRaw(r.dir), m = (y) => o(Wn.fromRaw(e, y));
      this.raw.intersectionsWithRay(t.raw, e.raw, f, p, n, s, m, a, c, u, l, h), f.free(), p.free();
    }
    intersectionWithShape(t, e, r, n, s, o, a, c, u, l) {
      let h = U.intoRaw(r), f = Ft.intoRaw(n), p = s.intoRaw(), m = this.raw.intersectionWithShape(t.raw, e.raw, h, f, p, o, a, c, u, l);
      return h.free(), f.free(), p.free(), m;
    }
    projectPoint(t, e, r, n, s, o, a, c, u) {
      let l = U.intoRaw(r), h = jn.fromRaw(e, this.raw.projectPoint(t.raw, e.raw, l, n, s, o, a, c, u));
      return l.free(), h;
    }
    projectPointAndGetFeature(t, e, r, n, s, o, a, c) {
      let u = U.intoRaw(r), l = jn.fromRaw(e, this.raw.projectPointAndGetFeature(t.raw, e.raw, u, n, s, o, a, c));
      return u.free(), l;
    }
    intersectionsWithPoint(t, e, r, n, s, o, a, c, u) {
      let l = U.intoRaw(r);
      this.raw.intersectionsWithPoint(t.raw, e.raw, l, n, s, o, a, c, u), l.free();
    }
    castShape(t, e, r, n, s, o, a, c, u, l, h, f, p, m) {
      let y = U.intoRaw(r), b = Ft.intoRaw(n), v = U.intoRaw(s), A = o.intoRaw(), T = ps.fromRaw(e, this.raw.castShape(t.raw, e.raw, y, b, v, A, a, c, u, l, h, f, p, m));
      return y.free(), b.free(), v.free(), A.free(), T;
    }
    intersectionsWithShape(t, e, r, n, s, o, a, c, u, l, h) {
      let f = U.intoRaw(r), p = Ft.intoRaw(n), m = s.intoRaw();
      this.raw.intersectionsWithShape(t.raw, e.raw, f, p, m, o, a, c, u, l, h), f.free(), p.free(), m.free();
    }
    collidersWithAabbIntersectingAabb(t, e, r) {
      let n = U.intoRaw(t), s = U.intoRaw(e);
      this.raw.collidersWithAabbIntersectingAabb(n, s, r), n.free(), s.free();
    }
  }
  class El {
    constructor(t) {
      this.raw = t || new zx();
    }
    free() {
      this.raw && this.raw.free(), this.raw = void 0;
    }
    serializeAll(t, e, r, n, s, o, a, c, u) {
      let l = U.intoRaw(t);
      const h = this.raw.serializeAll(l, e.raw, r.raw, n.raw, s.raw, o.raw, a.raw, c.raw, u.raw);
      return l.free(), h;
    }
    deserializeAll(t) {
      return fp.fromRaw(this.raw.deserializeAll(t));
    }
  }
  class F3 {
    constructor(t, e) {
      this.vertices = t, this.colors = e;
    }
  }
  class U3 {
    constructor(t) {
      this.raw = t || new Ix();
    }
    free() {
      this.raw && this.raw.free(), this.raw = void 0, this.vertices = void 0, this.colors = void 0;
    }
    render(t, e, r, n, s) {
      this.raw.render(t.raw, e.raw, r.raw, n.raw, s.raw), this.vertices = this.raw.vertices(), this.colors = this.raw.colors();
    }
  }
  class k3 {
  }
  class G3 {
    constructor(t, e, r, n, s) {
      this.params = e, this.bodies = r, this.colliders = n, this.queries = s, this.raw = new Gx(t), this.rawCharacterCollision = new Jf(), this._applyImpulsesToDynamicBodies = false, this._characterMass = null;
    }
    free() {
      this.raw && (this.raw.free(), this.rawCharacterCollision.free()), this.raw = void 0, this.rawCharacterCollision = void 0;
    }
    up() {
      return this.raw.up();
    }
    setUp(t) {
      let e = U.intoRaw(t);
      return this.raw.setUp(e);
    }
    applyImpulsesToDynamicBodies() {
      return this._applyImpulsesToDynamicBodies;
    }
    setApplyImpulsesToDynamicBodies(t) {
      this._applyImpulsesToDynamicBodies = t;
    }
    characterMass() {
      return this._characterMass;
    }
    setCharacterMass(t) {
      this._characterMass = t;
    }
    offset() {
      return this.raw.offset();
    }
    setOffset(t) {
      this.raw.setOffset(t);
    }
    normalNudgeFactor() {
      return this.raw.normalNudgeFactor();
    }
    setNormalNudgeFactor(t) {
      this.raw.setNormalNudgeFactor(t);
    }
    slideEnabled() {
      return this.raw.slideEnabled();
    }
    setSlideEnabled(t) {
      this.raw.setSlideEnabled(t);
    }
    autostepMaxHeight() {
      return this.raw.autostepMaxHeight();
    }
    autostepMinWidth() {
      return this.raw.autostepMinWidth();
    }
    autostepIncludesDynamicBodies() {
      return this.raw.autostepIncludesDynamicBodies();
    }
    autostepEnabled() {
      return this.raw.autostepEnabled();
    }
    enableAutostep(t, e, r) {
      this.raw.enableAutostep(t, e, r);
    }
    disableAutostep() {
      return this.raw.disableAutostep();
    }
    maxSlopeClimbAngle() {
      return this.raw.maxSlopeClimbAngle();
    }
    setMaxSlopeClimbAngle(t) {
      this.raw.setMaxSlopeClimbAngle(t);
    }
    minSlopeSlideAngle() {
      return this.raw.minSlopeSlideAngle();
    }
    setMinSlopeSlideAngle(t) {
      this.raw.setMinSlopeSlideAngle(t);
    }
    snapToGroundDistance() {
      return this.raw.snapToGroundDistance();
    }
    enableSnapToGround(t) {
      this.raw.enableSnapToGround(t);
    }
    disableSnapToGround() {
      this.raw.disableSnapToGround();
    }
    snapToGroundEnabled() {
      return this.raw.snapToGroundEnabled();
    }
    computeColliderMovement(t, e, r, n, s) {
      let o = U.intoRaw(e);
      this.raw.computeColliderMovement(this.params.dt, this.bodies.raw, this.colliders.raw, this.queries.raw, t.handle, o, this._applyImpulsesToDynamicBodies, this._characterMass, r, n, this.colliders.castClosure(s)), o.free();
    }
    computedMovement() {
      return U.fromRaw(this.raw.computedMovement());
    }
    computedGrounded() {
      return this.raw.computedGrounded();
    }
    numComputedCollisions() {
      return this.raw.numComputedCollisions();
    }
    computedCollision(t, e) {
      if (this.raw.computedCollision(t, this.rawCharacterCollision)) {
        let r = this.rawCharacterCollision;
        return e = e ?? new k3(), e.translationDeltaApplied = U.fromRaw(r.translationDeltaApplied()), e.translationDeltaRemaining = U.fromRaw(r.translationDeltaRemaining()), e.toi = r.toi(), e.witness1 = U.fromRaw(r.worldWitness1()), e.witness2 = U.fromRaw(r.worldWitness2()), e.normal1 = U.fromRaw(r.worldNormal1()), e.normal2 = U.fromRaw(r.worldNormal2()), e.collider = this.colliders.get(r.handle()), e;
      } else return null;
    }
  }
  let fp = class pp {
    constructor(t, e, r, n, s, o, a, c, u, l, h, f, p, m) {
      this.gravity = t, this.integrationParameters = new g3(e), this.islands = new R3(r), this.broadPhase = new P3(n), this.narrowPhase = new B3(s), this.bodies = new _3(o), this.colliders = new O3(a), this.impulseJoints = new v3(c), this.multibodyJoints = new T3(u), this.ccdSolver = new C3(l), this.queryPipeline = new I3(h), this.physicsPipeline = new D3(f), this.serializationPipeline = new El(p), this.debugRenderPipeline = new U3(m), this.characterControllers = /* @__PURE__ */ new Set(), this.impulseJoints.finalizeDeserialization(this.bodies), this.bodies.finalizeDeserialization(this.colliders), this.colliders.finalizeDeserialization(this.bodies);
    }
    free() {
      this.integrationParameters.free(), this.islands.free(), this.broadPhase.free(), this.narrowPhase.free(), this.bodies.free(), this.colliders.free(), this.impulseJoints.free(), this.multibodyJoints.free(), this.ccdSolver.free(), this.queryPipeline.free(), this.physicsPipeline.free(), this.serializationPipeline.free(), this.debugRenderPipeline.free(), this.characterControllers.forEach((t) => t.free()), this.integrationParameters = void 0, this.islands = void 0, this.broadPhase = void 0, this.narrowPhase = void 0, this.bodies = void 0, this.colliders = void 0, this.ccdSolver = void 0, this.impulseJoints = void 0, this.multibodyJoints = void 0, this.queryPipeline = void 0, this.physicsPipeline = void 0, this.serializationPipeline = void 0, this.debugRenderPipeline = void 0, this.characterControllers = void 0;
    }
    static fromRaw(t) {
      return t ? new pp(U.fromRaw(t.takeGravity()), t.takeIntegrationParameters(), t.takeIslandManager(), t.takeBroadPhase(), t.takeNarrowPhase(), t.takeBodies(), t.takeColliders(), t.takeImpulseJoints(), t.takeMultibodyJoints()) : null;
    }
    takeSnapshot() {
      return this.serializationPipeline.serializeAll(this.gravity, this.integrationParameters, this.islands, this.broadPhase, this.narrowPhase, this.bodies, this.colliders, this.impulseJoints, this.multibodyJoints);
    }
    static restoreSnapshot(t) {
      return new El().deserializeAll(t);
    }
    debugRender() {
      return this.debugRenderPipeline.render(this.bodies, this.colliders, this.impulseJoints, this.multibodyJoints, this.narrowPhase), new F3(this.debugRenderPipeline.vertices, this.debugRenderPipeline.colors);
    }
    step(t, e) {
      this.physicsPipeline.step(this.gravity, this.integrationParameters, this.islands, this.broadPhase, this.narrowPhase, this.bodies, this.colliders, this.impulseJoints, this.multibodyJoints, this.ccdSolver, t, e), this.queryPipeline.update(this.colliders);
    }
    propagateModifiedBodyPositionsToColliders() {
      this.bodies.raw.propagateModifiedBodyPositionsToColliders(this.colliders.raw);
    }
    updateSceneQueries() {
      this.propagateModifiedBodyPositionsToColliders(), this.queryPipeline.update(this.colliders);
    }
    get timestep() {
      return this.integrationParameters.dt;
    }
    set timestep(t) {
      this.integrationParameters.dt = t;
    }
    get lengthUnit() {
      return this.integrationParameters.lengthUnit;
    }
    set lengthUnit(t) {
      this.integrationParameters.lengthUnit = t;
    }
    get numSolverIterations() {
      return this.integrationParameters.numSolverIterations;
    }
    set numSolverIterations(t) {
      this.integrationParameters.numSolverIterations = t;
    }
    get numAdditionalFrictionIterations() {
      return this.integrationParameters.numAdditionalFrictionIterations;
    }
    set numAdditionalFrictionIterations(t) {
      this.integrationParameters.numAdditionalFrictionIterations = t;
    }
    get numInternalPgsIterations() {
      return this.integrationParameters.numInternalPgsIterations;
    }
    set numInternalPgsIterations(t) {
      this.integrationParameters.numInternalPgsIterations = t;
    }
    switchToStandardPgsSolver() {
      this.integrationParameters.switchToStandardPgsSolver();
    }
    switchToSmallStepsPgsSolver() {
      this.integrationParameters.switchToSmallStepsPgsSolver();
    }
    switchToSmallStepsPgsSolverWithoutWarmstart() {
      this.integrationParameters.switchToSmallStepsPgsSolverWithoutWarmstart();
    }
    createRigidBody(t) {
      return this.bodies.createRigidBody(this.colliders, t);
    }
    createCharacterController(t) {
      let e = new G3(t, this.integrationParameters, this.bodies, this.colliders, this.queryPipeline);
      return this.characterControllers.add(e), e;
    }
    removeCharacterController(t) {
      this.characterControllers.delete(t), t.free();
    }
    createCollider(t, e) {
      let r = e ? e.handle : void 0;
      return this.colliders.createCollider(this.bodies, t, r);
    }
    createImpulseJoint(t, e, r, n) {
      return this.impulseJoints.createJoint(this.bodies, t, e.handle, r.handle, n);
    }
    createMultibodyJoint(t, e, r, n) {
      return this.multibodyJoints.createJoint(t, e.handle, r.handle, n);
    }
    getRigidBody(t) {
      return this.bodies.get(t);
    }
    getCollider(t) {
      return this.colliders.get(t);
    }
    getImpulseJoint(t) {
      return this.impulseJoints.get(t);
    }
    getMultibodyJoint(t) {
      return this.multibodyJoints.get(t);
    }
    removeRigidBody(t) {
      this.bodies && this.bodies.remove(t.handle, this.islands, this.colliders, this.impulseJoints, this.multibodyJoints);
    }
    removeCollider(t, e) {
      this.colliders && this.colliders.remove(t.handle, this.islands, this.bodies, e);
    }
    removeImpulseJoint(t, e) {
      this.impulseJoints && this.impulseJoints.remove(t.handle, e);
    }
    removeMultibodyJoint(t, e) {
      this.impulseJoints && this.multibodyJoints.remove(t.handle, e);
    }
    forEachCollider(t) {
      this.colliders.forEach(t);
    }
    forEachRigidBody(t) {
      this.bodies.forEach(t);
    }
    forEachActiveRigidBody(t) {
      this.bodies.forEachActiveRigidBody(this.islands, t);
    }
    castRay(t, e, r, n, s, o, a, c) {
      return this.queryPipeline.castRay(this.bodies, this.colliders, t, e, r, n, s, o ? o.handle : null, a ? a.handle : null, this.colliders.castClosure(c));
    }
    castRayAndGetNormal(t, e, r, n, s, o, a, c) {
      return this.queryPipeline.castRayAndGetNormal(this.bodies, this.colliders, t, e, r, n, s, o ? o.handle : null, a ? a.handle : null, this.colliders.castClosure(c));
    }
    intersectionsWithRay(t, e, r, n, s, o, a, c, u) {
      this.queryPipeline.intersectionsWithRay(this.bodies, this.colliders, t, e, r, n, s, o, a ? a.handle : null, c ? c.handle : null, this.colliders.castClosure(u));
    }
    intersectionWithShape(t, e, r, n, s, o, a, c) {
      let u = this.queryPipeline.intersectionWithShape(this.bodies, this.colliders, t, e, r, n, s, o ? o.handle : null, a ? a.handle : null, this.colliders.castClosure(c));
      return u != null ? this.colliders.get(u) : null;
    }
    projectPoint(t, e, r, n, s, o, a) {
      return this.queryPipeline.projectPoint(this.bodies, this.colliders, t, e, r, n, s ? s.handle : null, o ? o.handle : null, this.colliders.castClosure(a));
    }
    projectPointAndGetFeature(t, e, r, n, s, o) {
      return this.queryPipeline.projectPointAndGetFeature(this.bodies, this.colliders, t, e, r, n ? n.handle : null, s ? s.handle : null, this.colliders.castClosure(o));
    }
    intersectionsWithPoint(t, e, r, n, s, o, a) {
      this.queryPipeline.intersectionsWithPoint(this.bodies, this.colliders, t, this.colliders.castClosure(e), r, n, s ? s.handle : null, o ? o.handle : null, this.colliders.castClosure(a));
    }
    castShape(t, e, r, n, s, o, a, c, u, l, h, f) {
      return this.queryPipeline.castShape(this.bodies, this.colliders, t, e, r, n, s, o, a, c, u, l ? l.handle : null, h ? h.handle : null, this.colliders.castClosure(f));
    }
    intersectionsWithShape(t, e, r, n, s, o, a, c, u) {
      this.queryPipeline.intersectionsWithShape(this.bodies, this.colliders, t, e, r, this.colliders.castClosure(n), s, o, a ? a.handle : null, c ? c.handle : null, this.colliders.castClosure(u));
    }
    collidersWithAabbIntersectingAabb(t, e, r) {
      this.queryPipeline.collidersWithAabbIntersectingAabb(t, e, this.colliders.castClosure(r));
    }
    contactPairsWith(t, e) {
      this.narrowPhase.contactPairsWith(t.handle, this.colliders.castClosure(e));
    }
    intersectionPairsWith(t, e) {
      this.narrowPhase.intersectionPairsWith(t.handle, this.colliders.castClosure(e));
    }
    contactPair(t, e, r) {
      this.narrowPhase.contactPair(t.handle, e.handle, r);
    }
    intersectionPair(t, e) {
      return this.narrowPhase.intersectionPair(t.handle, e.handle);
    }
  };
  var Xo;
  (function(i) {
    i[i.NONE = 0] = "NONE", i[i.COLLISION_EVENTS = 1] = "COLLISION_EVENTS", i[i.CONTACT_FORCE_EVENTS = 2] = "CONTACT_FORCE_EVENTS";
  })(Xo || (Xo = {}));
  var qo;
  (function(i) {
    i[i.NONE = 0] = "NONE", i[i.FILTER_CONTACT_PAIRS = 1] = "FILTER_CONTACT_PAIRS", i[i.FILTER_INTERSECTION_PAIRS = 2] = "FILTER_INTERSECTION_PAIRS";
  })(qo || (qo = {}));
  var Al;
  (function(i) {
    i[i.EMPTY = 0] = "EMPTY", i[i.COMPUTE_IMPULSE = 1] = "COMPUTE_IMPULSE";
  })(Al || (Al = {}));
  var $o;
  (function(i) {
    i[i.DYNAMIC_DYNAMIC = 1] = "DYNAMIC_DYNAMIC", i[i.DYNAMIC_KINEMATIC = 12] = "DYNAMIC_KINEMATIC", i[i.DYNAMIC_FIXED = 2] = "DYNAMIC_FIXED", i[i.KINEMATIC_KINEMATIC = 52224] = "KINEMATIC_KINEMATIC", i[i.KINEMATIC_FIXED = 8704] = "KINEMATIC_FIXED", i[i.FIXED_FIXED = 32] = "FIXED_FIXED", i[i.DEFAULT = 15] = "DEFAULT", i[i.ALL = 60943] = "ALL";
  })($o || ($o = {}));
  class Tl {
    constructor(t, e, r, n) {
      this.colliderSet = t, this.handle = e, this._parent = r, this._shape = n;
    }
    finalizeDeserialization(t) {
      this.handle != null && (this._parent = t.get(this.colliderSet.raw.coParent(this.handle)));
    }
    ensureShapeIsCached() {
      this._shape || (this._shape = ce.fromRaw(this.colliderSet.raw, this.handle));
    }
    get shape() {
      return this.ensureShapeIsCached(), this._shape;
    }
    isValid() {
      return this.colliderSet.raw.contains(this.handle);
    }
    translation() {
      return U.fromRaw(this.colliderSet.raw.coTranslation(this.handle));
    }
    rotation() {
      return Ft.fromRaw(this.colliderSet.raw.coRotation(this.handle));
    }
    isSensor() {
      return this.colliderSet.raw.coIsSensor(this.handle);
    }
    setSensor(t) {
      this.colliderSet.raw.coSetSensor(this.handle, t);
    }
    setShape(t) {
      let e = t.intoRaw();
      this.colliderSet.raw.coSetShape(this.handle, e), e.free(), this._shape = t;
    }
    setEnabled(t) {
      this.colliderSet.raw.coSetEnabled(this.handle, t);
    }
    isEnabled() {
      return this.colliderSet.raw.coIsEnabled(this.handle);
    }
    setRestitution(t) {
      this.colliderSet.raw.coSetRestitution(this.handle, t);
    }
    setFriction(t) {
      this.colliderSet.raw.coSetFriction(this.handle, t);
    }
    frictionCombineRule() {
      return this.colliderSet.raw.coFrictionCombineRule(this.handle);
    }
    setFrictionCombineRule(t) {
      this.colliderSet.raw.coSetFrictionCombineRule(this.handle, t);
    }
    restitutionCombineRule() {
      return this.colliderSet.raw.coRestitutionCombineRule(this.handle);
    }
    setRestitutionCombineRule(t) {
      this.colliderSet.raw.coSetRestitutionCombineRule(this.handle, t);
    }
    setCollisionGroups(t) {
      this.colliderSet.raw.coSetCollisionGroups(this.handle, t);
    }
    setSolverGroups(t) {
      this.colliderSet.raw.coSetSolverGroups(this.handle, t);
    }
    contactSkin() {
      return this.colliderSet.raw.coContactSkin(this.handle);
    }
    setContactSkin(t) {
      return this.colliderSet.raw.coSetContactSkin(this.handle, t);
    }
    activeHooks() {
      return this.colliderSet.raw.coActiveHooks(this.handle);
    }
    setActiveHooks(t) {
      this.colliderSet.raw.coSetActiveHooks(this.handle, t);
    }
    activeEvents() {
      return this.colliderSet.raw.coActiveEvents(this.handle);
    }
    setActiveEvents(t) {
      this.colliderSet.raw.coSetActiveEvents(this.handle, t);
    }
    activeCollisionTypes() {
      return this.colliderSet.raw.coActiveCollisionTypes(this.handle);
    }
    setContactForceEventThreshold(t) {
      return this.colliderSet.raw.coSetContactForceEventThreshold(this.handle, t);
    }
    contactForceEventThreshold() {
      return this.colliderSet.raw.coContactForceEventThreshold(this.handle);
    }
    setActiveCollisionTypes(t) {
      this.colliderSet.raw.coSetActiveCollisionTypes(this.handle, t);
    }
    setDensity(t) {
      this.colliderSet.raw.coSetDensity(this.handle, t);
    }
    setMass(t) {
      this.colliderSet.raw.coSetMass(this.handle, t);
    }
    setMassProperties(t, e, r) {
      let n = U.intoRaw(e);
      this.colliderSet.raw.coSetMassProperties(this.handle, t, n, r), n.free();
    }
    setTranslation(t) {
      this.colliderSet.raw.coSetTranslation(this.handle, t.x, t.y);
    }
    setTranslationWrtParent(t) {
      this.colliderSet.raw.coSetTranslationWrtParent(this.handle, t.x, t.y);
    }
    setRotation(t) {
      this.colliderSet.raw.coSetRotation(this.handle, t);
    }
    setRotationWrtParent(t) {
      this.colliderSet.raw.coSetRotationWrtParent(this.handle, t);
    }
    shapeType() {
      return this.colliderSet.raw.coShapeType(this.handle);
    }
    halfExtents() {
      return U.fromRaw(this.colliderSet.raw.coHalfExtents(this.handle));
    }
    setHalfExtents(t) {
      const e = U.intoRaw(t);
      this.colliderSet.raw.coSetHalfExtents(this.handle, e);
    }
    radius() {
      return this.colliderSet.raw.coRadius(this.handle);
    }
    setRadius(t) {
      this.colliderSet.raw.coSetRadius(this.handle, t);
    }
    roundRadius() {
      return this.colliderSet.raw.coRoundRadius(this.handle);
    }
    setRoundRadius(t) {
      this.colliderSet.raw.coSetRoundRadius(this.handle, t);
    }
    halfHeight() {
      return this.colliderSet.raw.coHalfHeight(this.handle);
    }
    setHalfHeight(t) {
      this.colliderSet.raw.coSetHalfHeight(this.handle, t);
    }
    vertices() {
      return this.colliderSet.raw.coVertices(this.handle);
    }
    indices() {
      return this.colliderSet.raw.coIndices(this.handle);
    }
    heightfieldHeights() {
      return this.colliderSet.raw.coHeightfieldHeights(this.handle);
    }
    heightfieldScale() {
      let t = this.colliderSet.raw.coHeightfieldScale(this.handle);
      return U.fromRaw(t);
    }
    parent() {
      return this._parent;
    }
    friction() {
      return this.colliderSet.raw.coFriction(this.handle);
    }
    restitution() {
      return this.colliderSet.raw.coRestitution(this.handle);
    }
    density() {
      return this.colliderSet.raw.coDensity(this.handle);
    }
    mass() {
      return this.colliderSet.raw.coMass(this.handle);
    }
    volume() {
      return this.colliderSet.raw.coVolume(this.handle);
    }
    collisionGroups() {
      return this.colliderSet.raw.coCollisionGroups(this.handle);
    }
    solverGroups() {
      return this.colliderSet.raw.coSolverGroups(this.handle);
    }
    containsPoint(t) {
      let e = U.intoRaw(t), r = this.colliderSet.raw.coContainsPoint(this.handle, e);
      return e.free(), r;
    }
    projectPoint(t, e) {
      let r = U.intoRaw(t), n = ds.fromRaw(this.colliderSet.raw.coProjectPoint(this.handle, r, e));
      return r.free(), n;
    }
    intersectsRay(t, e) {
      let r = U.intoRaw(t.origin), n = U.intoRaw(t.dir), s = this.colliderSet.raw.coIntersectsRay(this.handle, r, n, e);
      return r.free(), n.free(), s;
    }
    castShape(t, e, r, n, s, o, a, c) {
      let u = U.intoRaw(t), l = U.intoRaw(r), h = Ft.intoRaw(n), f = U.intoRaw(s), p = e.intoRaw(), m = Ni.fromRaw(this.colliderSet, this.colliderSet.raw.coCastShape(this.handle, u, p, l, h, f, o, a, c));
      return u.free(), l.free(), h.free(), f.free(), p.free(), m;
    }
    castCollider(t, e, r, n, s, o) {
      let a = U.intoRaw(t), c = U.intoRaw(r), u = ps.fromRaw(this.colliderSet, this.colliderSet.raw.coCastCollider(this.handle, a, e.handle, c, n, s, o));
      return a.free(), c.free(), u;
    }
    intersectsShape(t, e, r) {
      let n = U.intoRaw(e), s = Ft.intoRaw(r), o = t.intoRaw(), a = this.colliderSet.raw.coIntersectsShape(this.handle, o, n, s);
      return n.free(), s.free(), o.free(), a;
    }
    contactShape(t, e, r, n) {
      let s = U.intoRaw(e), o = Ft.intoRaw(r), a = t.intoRaw(), c = Bi.fromRaw(this.colliderSet.raw.coContactShape(this.handle, a, s, o, n));
      return s.free(), o.free(), a.free(), c;
    }
    contactCollider(t, e) {
      return Bi.fromRaw(this.colliderSet.raw.coContactCollider(this.handle, t.handle, e));
    }
    castRay(t, e, r) {
      let n = U.intoRaw(t.origin), s = U.intoRaw(t.dir), o = this.colliderSet.raw.coCastRay(this.handle, n, s, e, r);
      return n.free(), s.free(), o;
    }
    castRayAndGetNormal(t, e, r) {
      let n = U.intoRaw(t.origin), s = U.intoRaw(t.dir), o = fs.fromRaw(this.colliderSet.raw.coCastRayAndGetNormal(this.handle, n, s, e, r));
      return n.free(), s.free(), o;
    }
  }
  var jr;
  (function(i) {
    i[i.Density = 0] = "Density", i[i.Mass = 1] = "Mass", i[i.MassProps = 2] = "MassProps";
  })(jr || (jr = {}));
  class jt {
    constructor(t) {
      this.enabled = true, this.shape = t, this.massPropsMode = jr.Density, this.density = 1, this.friction = 0.5, this.restitution = 0, this.rotation = Ft.identity(), this.translation = U.zeros(), this.isSensor = false, this.collisionGroups = 4294967295, this.solverGroups = 4294967295, this.frictionCombineRule = zn.Average, this.restitutionCombineRule = zn.Average, this.activeCollisionTypes = $o.DEFAULT, this.activeEvents = Xo.NONE, this.activeHooks = qo.NONE, this.mass = 0, this.centerOfMass = U.zeros(), this.contactForceEventThreshold = 0, this.contactSkin = 0, this.principalAngularInertia = 0, this.rotationsEnabled = true;
    }
    static ball(t) {
      const e = new rp(t);
      return new jt(e);
    }
    static capsule(t, e) {
      const r = new op(t, e);
      return new jt(r);
    }
    static segment(t, e) {
      const r = new ap(t, e);
      return new jt(r);
    }
    static triangle(t, e, r) {
      const n = new cp(t, e, r);
      return new jt(n);
    }
    static roundTriangle(t, e, r, n) {
      const s = new up(t, e, r, n);
      return new jt(s);
    }
    static polyline(t, e) {
      const r = new lp(t, e);
      return new jt(r);
    }
    static trimesh(t, e, r) {
      const n = new hp(t, e, r);
      return new jt(n);
    }
    static cuboid(t, e) {
      const r = new np(t, e);
      return new jt(r);
    }
    static roundCuboid(t, e, r) {
      const n = new sp(t, e, r);
      return new jt(n);
    }
    static halfspace(t) {
      const e = new ip(t);
      return new jt(e);
    }
    static heightfield(t, e) {
      const r = new dp(t, e);
      return new jt(r);
    }
    static convexHull(t) {
      const e = new Wo(t, false);
      return new jt(e);
    }
    static convexPolyline(t) {
      const e = new Wo(t, true);
      return new jt(e);
    }
    static roundConvexHull(t, e) {
      const r = new Vo(t, e, false);
      return new jt(r);
    }
    static roundConvexPolyline(t, e) {
      const r = new Vo(t, e, true);
      return new jt(r);
    }
    setTranslation(t, e) {
      if (typeof t != "number" || typeof e != "number") throw TypeError("The translation components must be numbers.");
      return this.translation = {
        x: t,
        y: e
      }, this;
    }
    setRotation(t) {
      return this.rotation = t, this;
    }
    setSensor(t) {
      return this.isSensor = t, this;
    }
    setEnabled(t) {
      return this.enabled = t, this;
    }
    setContactSkin(t) {
      return this.contactSkin = t, this;
    }
    setDensity(t) {
      return this.massPropsMode = jr.Density, this.density = t, this;
    }
    setMass(t) {
      return this.massPropsMode = jr.Mass, this.mass = t, this;
    }
    setMassProperties(t, e, r) {
      return this.massPropsMode = jr.MassProps, this.mass = t, U.copy(this.centerOfMass, e), this.principalAngularInertia = r, this;
    }
    setRestitution(t) {
      return this.restitution = t, this;
    }
    setFriction(t) {
      return this.friction = t, this;
    }
    setFrictionCombineRule(t) {
      return this.frictionCombineRule = t, this;
    }
    setRestitutionCombineRule(t) {
      return this.restitutionCombineRule = t, this;
    }
    setCollisionGroups(t) {
      return this.collisionGroups = t, this;
    }
    setSolverGroups(t) {
      return this.solverGroups = t, this;
    }
    setActiveHooks(t) {
      return this.activeHooks = t, this;
    }
    setActiveEvents(t) {
      return this.activeEvents = t, this;
    }
    setActiveCollisionTypes(t) {
      return this.activeCollisionTypes = t, this;
    }
    setContactForceEventThreshold(t) {
      return this.contactForceEventThreshold = t, this;
    }
  }
  class O3 {
    constructor(t) {
      this.raw = t || new Nt(), this.map = new hs(), t && t.forEachColliderHandle((e) => {
        this.map.set(e, new Tl(this, e, null));
      });
    }
    free() {
      this.raw && this.raw.free(), this.raw = void 0, this.map && this.map.clear(), this.map = void 0;
    }
    castClosure(t) {
      return (e) => {
        if (t) return t(this.get(e));
      };
    }
    finalizeDeserialization(t) {
      this.map.forEach((e) => e.finalizeDeserialization(t));
    }
    createCollider(t, e, r) {
      let n = r != null && r != null;
      if (n && isNaN(r)) throw Error("Cannot create a collider with a parent rigid-body handle that is not a number.");
      let s = e.shape.intoRaw(), o = U.intoRaw(e.translation), a = Ft.intoRaw(e.rotation), c = U.intoRaw(e.centerOfMass), u = this.raw.createCollider(e.enabled, s, o, a, e.massPropsMode, e.mass, c, e.principalAngularInertia, e.density, e.friction, e.restitution, e.frictionCombineRule, e.restitutionCombineRule, e.isSensor, e.collisionGroups, e.solverGroups, e.activeCollisionTypes, e.activeHooks, e.activeEvents, e.contactForceEventThreshold, e.contactSkin, n, n ? r : 0, t.raw);
      s.free(), o.free(), a.free(), c.free();
      let l = n ? t.get(r) : null, h = new Tl(this, u, l, e.shape);
      return this.map.set(u, h), h;
    }
    remove(t, e, r, n) {
      this.raw.remove(t, e.raw, r.raw, n), this.unmap(t);
    }
    unmap(t) {
      this.map.delete(t);
    }
    get(t) {
      return this.map.get(t);
    }
    len() {
      return this.map.len();
    }
    contains(t) {
      return this.get(t) != null;
    }
    forEach(t) {
      this.map.forEach(t);
    }
    getAll() {
      return this.map.getAll();
    }
  }
  class N3 {
    constructor() {
    }
    createKinematicRectangle(t, e, r, n, s = true) {
      const o = {
        x: t.x,
        y: t.y,
        width: e,
        height: r,
        velocity: {
          x: 0,
          y: 0
        }
      }, a = fe.kinematicPositionBased().setTranslation(t.x, t.y);
      s && a.setCcdEnabled(s).setSoftCcdPrediction(0.5);
      const c = app.world.rapierWorld.createRigidBody(a), u = jt.cuboid(e / 2, r / 2).setFriction(0), l = app.world.rapierWorld.createCollider(u, c), h = new $e();
      return h.rect(0, 0, e * app.settings.ptom, r * app.settings.ptom).fill(n), h.x = app.settings.ptom * (t.x - e / 2), h.y = app.Papp.screen.height - app.settings.ptom * (t.y + r / 2), h.updatePosition = function() {
        h.x = app.settings.ptom * (c.translation().x - e / 2), h.y = app.Papp.screen.height - app.settings.ptom * (c.translation().y + r / 2);
      }, app.Papp.stage.addChild(h), {
        body: o,
        rigidBodyDesc: a,
        rigidBody: c,
        colliderDesc: u,
        collider: l,
        rendered: h
      };
    }
    createFixedRectangle(t, e, r, n) {
      const s = {
        x: t.x,
        y: t.y,
        width: e,
        height: r,
        velocity: {
          x: 0,
          y: 0
        }
      }, o = fe.fixed().setTranslation(t.x, t.y), a = app.world.rapierWorld.createRigidBody(o), c = jt.cuboid(e / 2, r / 2).setFriction(0), u = app.world.rapierWorld.createCollider(c, a), l = new $e();
      return l.rect(0, 0, e * app.settings.ptom, r * app.settings.ptom).fill(n), l.x = app.settings.ptom * (t.x - e / 2), l.y = app.Papp.screen.height - app.settings.ptom * (t.y + r / 2), l.updatePosition = function() {
        l.x = app.settings.ptom * (a.translation().x - e / 2), l.y = app.Papp.screen.height - app.settings.ptom * (a.translation().y + r / 2);
      }, app.Papp.stage.addChild(l), {
        body: s,
        rigidBodyDesc: o,
        rigidBody: a,
        colliderDesc: c,
        collider: u,
        rendered: l
      };
    }
    createDynamicRectangle(t, e, r, n, s = true, o = true) {
      let a = fe.dynamic().setTranslation(t.x, t.y);
      o && a.setCcdEnabled(o).setSoftCcdPrediction(1), s && a.lockRotations();
      let c = app.world.rapierWorld.createRigidBody(a), u = jt.cuboid(e / 2, r / 2).setFriction(0), l = app.world.rapierWorld.createCollider(u, c), h = new $e();
      return h.rect(0, 0, e * app.settings.ptom, r * app.settings.ptom).fill(n), h.x = app.settings.ptom * (t.x - e / 2), h.y = app.Papp.screen.height - app.settings.ptom * (t.y + r / 2), h.updatePosition = function() {
        h.x = app.settings.ptom * (c.translation().x - e / 2), h.y = app.Papp.screen.height - app.settings.ptom * (c.translation().y + r / 2);
      }, app.Papp.stage.addChild(h), {
        rigidBodyDesc: a,
        rigidBody: c,
        colliderDesc: u,
        collider: l,
        rendered: h
      };
    }
    createDynamicCircle(t, e, r, n = true) {
      let s = fe.dynamic().setTranslation(t.x, t.y);
      n && s.setCcdEnabled(n).setSoftCcdPrediction(0.5);
      let o = app.world.rapierWorld.createRigidBody(s), a = jt.ball(e).setFriction(0), c = app.world.rapierWorld.createCollider(a, o), u = new $e();
      return u.circle(0, 0, e * app.settings.ptom).fill(r), u.updatePosition = function() {
        u.x = app.settings.ptom * o.translation().x, u.y = app.Papp.screen.height - app.settings.ptom * o.translation().y;
      }, app.Papp.stage.addChild(u), {
        rigidBodyDesc: s,
        rigidBody: o,
        colliderDesc: a,
        collider: c,
        rendered: u
      };
    }
  }
  class L3 {
    constructor(t, e) {
      this.cellWidth = t, this.cellHeight = e, this.gridQuadrantI = [], this.gridQuadrantII = [], this.gridQuadrantIII = [], this.gridQuadrantIV = [];
    }
    getQuadrant(t, e) {
      if (t >= 0 && e >= 0) return 1;
      if (t < 0 && e >= 0) return 2;
      if (t < 0 && e < 0) return 3;
      if (t >= 0 && e < 0) return 4;
    }
    getGrid(t) {
      let e;
      switch (t) {
        case 1:
          e = this.gridQuadrantI;
          break;
        case 2:
          e = this.gridQuadrantII;
          break;
        case 3:
          e = this.gridQuadrantIII;
          break;
        case 4:
          e = this.gridQuadrantIV;
          break;
      }
      return e;
    }
    getCellCoordinates(t, e, r) {
      let n = t, s = e;
      r === 2 ? n = -t : r === 3 ? (n = -t, s = -e) : r === 4 && (s = -e);
      const o = Math.floor(n / this.cellWidth), a = Math.floor(s / this.cellHeight);
      return [
        o,
        a
      ];
    }
    getObjectBounds(t) {
      const e = t.x - t.width / 2, r = t.y - t.height / 2, n = t.x + t.width / 2, s = t.y + t.height / 2;
      return {
        x1: e,
        y1: r,
        x2: n,
        y2: s
      };
    }
    addObject(t) {
      this.getOccupiedCells(t).forEach((r) => {
        const n = r.quadrant;
        this.getGrid(n)[r.i][r.j].push(t);
      });
    }
    getObjectsInCell(t, e) {
      const r = this.getQuadrant(t, e), [n, s] = this.getCellCoordinates(t, e, r), o = this.getGrid(r);
      return o[n] && o[n][s] ? o[n][s] : [];
    }
    calculateCells(t) {
      let e = [];
      if (t.x1 < 0 && t.x2 > 0) e.push(...this.calculateCells({
        x1: t.x1,
        x2: 0,
        y1: t.y1,
        y2: t.y2
      })), e.push(...this.calculateCells({
        x1: 0,
        x2: t.x2,
        y1: t.y1,
        y2: t.y2
      }));
      else if (t.y1 < 0 && t.y2 > 0) e.push(...this.calculateCells({
        x1: t.x1,
        x2: t.x2,
        y1: t.y1,
        y2: 0
      })), e.push(...this.calculateCells({
        x1: t.x1,
        x2: t.x2,
        y1: 0,
        y2: t.y2
      }));
      else {
        const r = this.getQuadrant(t.x1, t.y1), n = this.getCellCoordinates(t.x1, t.y1, r), s = this.getCellCoordinates(t.x2, t.y2, r), o = Math.min(n[0], s[0]), a = Math.max(n[0], s[0]), c = Math.min(n[1], s[1]), u = Math.max(n[1], s[1]), l = this.getGrid(r);
        for (; l.length <= a; ) l.push([]);
        for (let h = o; h <= a; h++) {
          for (; l[h].length <= u; ) l[h].push([]);
          for (let f = c; f <= u; f++) e.push({
            quadrant: r,
            i: h,
            j: f
          });
        }
      }
      return e;
    }
    getOccupiedCells(t) {
      const e = this.getObjectBounds(t), r = [];
      return r.push(...this.calculateCells(e)), r;
    }
    checkIntersect(t, e) {
      return Math.abs(t.x - e.x) < 0.5 * (t.width + e.width) && Math.abs(t.y - e.y) < 0.5 * (t.height + e.height);
    }
    checkTouch(t, e) {
      return Math.abs(t.x - e.x) === 0.5 * (t.width + e.width) && Math.abs(t.y - e.y) === 0.5 * (t.height + e.height);
    }
    checkIntersectOrTouch(t, e) {
      return Math.abs(t.x - e.x) <= 0.5 * (t.width + e.width) && Math.abs(t.y - e.y) <= 0.5 * (t.height + e.height);
    }
    getIntersectingObjects(t) {
      const e = /* @__PURE__ */ new Set(), r = {
        x: t.x,
        y: t.y,
        width: t.width + 0.1,
        height: t.height + 0.1
      };
      return this.getOccupiedCells(r).forEach((n) => {
        this.getGrid(n.quadrant)[n.i][n.j].forEach((s) => {
          s in e || this.checkIntersect(t, s) && e.add(s);
        });
      }), Array.from(e);
    }
  }
  class H3 {
    constructor(t) {
      __publicField(this, "objects", []);
      __publicField(this, "partitioning");
      __publicField(this, "player");
      __publicField(this, "direction", 1);
      this.partitioning = new L3(app.settings.partitionCellWidth, app.settings.partitionCellHeight);
    }
    setPlayer(t) {
      this.player = t;
    }
    addObject(t) {
      this.objects.push(t), this.partitioning.addObject(t);
    }
    step() {
      app.player.controls.canJump = false, this.player.velocity.y += app.settings.gravity;
      const t = this.player.x, e = this.player.y;
      this.player.x += this.player.velocity.x, this.player.y += this.player.velocity.y;
      const r = Math.sign(this.player.velocity.y), n = Math.sign(this.player.velocity.x);
      let s = this.partitioning.getIntersectingObjects(this.player), o = this.player.velocity.x, a = this.player.velocity.y;
      for (; s.length > 0; ) {
        let c = false;
        for (; s.length > 0; ) {
          let l = function(m) {
            const y = u.y - 0.5 * r * (u.height + m.player.height);
            r * m.player.y > r * y && r * e <= r * y && (m.player.y = y, r === -1 && (app.player.controls.canJump = true), c = true, a = 0);
          }, h = function(m) {
            const y = u.x - 0.5 * n * (u.width + m.player.width);
            n * m.player.x > n * y && n * t <= n * y && (m.player.x = y, c = true, o = 0);
          };
          const u = s.pop();
          let f = h, p = l;
          Math.abs(this.player.velocity.y) <= Math.abs(this.player.velocity.x) && (f = l, p = h), f(this), this.partitioning.checkIntersect(u, this.player) && p(this);
        }
        c && (s = this.partitioning.getIntersectingObjects(this.player));
      }
      this.player.velocity = {
        x: o,
        y: a
      };
    }
  }
  class z3 {
    constructor(t, e) {
      __publicField(this, "customWorld");
      __publicField(this, "rapierWorld");
      __publicField(this, "pixiWorld");
      __publicField(this, "dynamicObjects", []);
      __publicField(this, "staticObjects", []);
      __publicField(this, "player");
      this.customWorld = new H3(), this.rapierWorld = t, this.pixiWorld = e;
    }
    setPlayer(t) {
      this.customWorld.setPlayer(t.body), this.player = t, this.dynamicObjects.push(t);
    }
    addObject(t) {
      return this.dynamicObjects.push(t), t;
    }
    addStaticObject(t) {
      return this.staticObjects.push(t), this.customWorld.addObject(t.body), t;
    }
    updatePosition() {
      this.dynamicObjects.forEach((t) => {
        t.rendered.updatePosition();
      });
    }
    updateAll() {
      this.updatePosition(), this.staticObjects.forEach((t) => {
        t.rendered.updatePosition();
      });
    }
    step() {
      this.player.updateControls(), this.customWorld.step(), this.player.rigidBody.setNextKinematicTranslation(this.player.body), this.rapierWorld.step(), this.updatePosition();
    }
    getWorld() {
      return [
        ...this.world
      ];
    }
  }
  class j3 {
    constructor(t) {
      __publicField(this, "body");
      __publicField(this, "rigidBodyDesc");
      __publicField(this, "rigidBody");
      __publicField(this, "colliderDesc");
      __publicField(this, "collider");
      __publicField(this, "rendered");
      __publicField(this, "keydown");
      __publicField(this, "keyup");
      __publicField(this, "controls");
      __publicField(this, "constants");
      let e = app.entityFactory.createKinematicRectangle(t, app.settings.playerWidth, app.settings.playerHeight, app.settings.playerColour);
      this.body = e.body, this.rigidBodyDesc = e.rigidBodyDesc, this.rigidBody = e.rigidBody, this.colliderDesc = e.colliderDesc, this.collider = e.collider, this.rendered = e.rendered, this.constants = app.settings.playerControls, this.controls = {
        left: 0,
        right: 0,
        jump: false,
        canJump: false
      }, this.keydown = (r) => {
        let n = r.key.toLowerCase();
        n == "a" || n == "arrowleft" ? this.controls.left = -1 : n == "d" || n == "arrowright" ? this.controls.right = 1 : (n == "w" || n == "arrowup" || n == " ") && (this.controls.jump = true);
      }, this.keyup = (r) => {
        let n = r.key.toLowerCase();
        n == "a" || n == "arrowleft" ? this.controls.left = 0 : (n == "d" || n == "arrowright") && (this.controls.right = 0);
      }, window.addEventListener("keydown", this.keydown), window.addEventListener("keyup", this.keyup);
    }
    updatePosition() {
      this.rendered.updatePosition();
    }
    updateControls() {
      let t = this.controls.left + this.controls.right, e = t, r = this.body.velocity, n = r.x;
      t == 0 && (t = 1, n < 0 ? e = app.settings.playerConstants.slowDown : n > 0 && (e = -app.settings.playerConstants.slowDown), Math.abs(n) <= app.settings.playerConstants.speed * app.settings.playerConstants.slowDown && (n = 0, e = 0)), n += app.settings.playerConstants.speed * e, e != 0 && (n = t * Math.min(t * n, app.settings.playerConstants.maxSpeed));
      let s = r.y;
      this.controls.jump && this.controls.canJump && (s = Math.max(s, 0) + app.settings.playerConstants.jumpStrength), this.controls.jump = false, this.controls.canJump = false, this.body.velocity = {
        x: n,
        y: s
      };
    }
  }
  const Yo = {
    playerWidth: 1,
    playerHeight: 1.5,
    playerColour: 16776960,
    playerConstants: {
      speed: 0.2,
      maxSpeed: 0.3,
      slowDown: 0.5,
      jumpStrength: 0.7
    },
    gravity: -0.07,
    rapierGravity: -50,
    partitionCellWidth: 30,
    partitionCellHeight: 20,
    ptom: 40
  };
  Yo.ptom = window.innerWidth / Yo.partitionCellWidth;
  async function W3() {
    const i = {};
    window.app = i, i.settings = Yo;
    const t = new _h();
    i.Papp = t, await t.init({
      width: window.innerWidth,
      height: window.innerHeight,
      backgroundColor: 1087931,
      resolution: window.devicePixelRatio || 1
    }), t.canvas.style.width = "100%", t.canvas.style.height = "100%";
    const e = new fp({
      x: 0,
      y: i.settings.rapierGravity
    }), r = new N3();
    i.entityFactory = r;
    const n = new z3(e, t);
    i.world = n, window.physicsTop = i.settings.partitionCellHeight, window.physicsRight = i.settings.partitionCellWidth;
    const s = new j3({
      x: 3 * physicsRight / 4 + 2,
      y: i.settings.playerHeight / 2 + 0.5
    });
    i.player = s, n.setPlayer(s);
    for (let p = 1; p <= 6; p++) for (let m = 1 + p % 2 / 2; m <= 3 * physicsRight / 4 - 2; m++) n.addObject(r.createDynamicCircle({
      x: m,
      y: p
    }, 0.5, Math.round(Math.random() * 16777215))).collider.setDensity(0.05);
    const o = n.addStaticObject(r.createFixedRectangle({
      x: physicsRight / 2,
      y: 0
    }, physicsRight, 1, 0)), a = n.addStaticObject(r.createFixedRectangle({
      x: 0,
      y: physicsTop / 2
    }, 1, physicsTop, 0)), c = n.addStaticObject(r.createFixedRectangle({
      x: physicsRight,
      y: physicsTop / 2
    }, 1, physicsTop, 0)), u = n.addStaticObject(r.createFixedRectangle({
      x: 3 * physicsRight / 4,
      y: 1.5
    }, 1, 2.5, 0)), l = n.addStaticObject(r.createFixedRectangle({
      x: physicsRight / 2,
      y: physicsTop
    }, physicsRight, 1, 0)), h = n.addStaticObject(r.createFixedRectangle({
      x: 7 * physicsRight / 8,
      y: 4
    }, 2, 2, 0));
    document.body.appendChild(t.canvas), setInterval(() => {
      n.step();
    }, 1e3 / 60);
    function f() {
      t.renderer.resize(window.innerWidth, window.innerHeight), i.settings.ptom = window.innerWidth / i.settings.partitionCellWidth, n.updateAll();
    }
    window.addEventListener("resize", f);
  }
  W3();
})();
export {
  v_ as A,
  ux as B,
  Dt as C,
  uw as E,
  aR as F,
  j0 as G,
  Yf as H,
  q0 as M,
  Y0 as N,
  _g as R,
  gg as T,
  __tla,
  X3 as a,
  Ch as b,
  xx as c,
  wx as d,
  Mt as e,
  lx as f,
  ix as g,
  Pw as h,
  Ew as i
};
